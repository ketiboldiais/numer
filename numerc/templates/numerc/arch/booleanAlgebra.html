{% extends "numerc/layout.html" %}
{% block content %}
<h4>Boolean Expressions</h4>
<p>
	With the ability to use the three basic operators &mdash;
	<span class="monoText">AND</span>, <span class="monoText">OR</span>, and <span class="monoText">NOT</span>&mdash;we can combine them to form <span class="boldItalics">Boolean expressions</span>, which are expressions similar to those we see in mathematics. Boolean expressions are what allow us to create more complex operators and to perform increasingly elaborate operations.
</p>
<p>
	For example, consider the Boolean expression:
	<span class="monoText">NOT(0 OR (1 AND 1))</span>. What might this expression evaluate to? To evaluate the expression, we work from the innermost expression towards the outermost expression. The innermost expression is <span class="monoText">1 AND 1</span>. This evaluates to <span class="monoText">1</span>, since both input signals are <span class="monoText">1</span>. These leads to the next expression, <span class="monoText">0 or 1</span>, which evaluates to <span class="monoText">1</span>, since at least one input signal is <span class="monoText">1</span>. Finally, the <span class="monoText">NOT</span> operator kicks in, and reverses our result (<span class="monoText">1</span>), returning the output signal <span class="monoText">0</span>. Thus, the Boolean expression <span class="monoText">NOT(0 OR (1 AND 1))</span> returns the output signal <span class="monoText">0</span>.
</p>

<h4>Boolean Functions</h4>
<p>
	With the ability to write Boolean expressions, we can then write
	<span class="boldItalics">Boolean functions</span>&mdash;general Boolean "rules" that we construct ourselves that will output results based on inputs.
</p>
<p>
	For example, a Boolean function might look like:
	<span class="monoText">f(x, y, z) = (x AND y) OR (NOT(x) AND z)</span>. We can list all of the possible values for this function:
</p>
<figure>
	<table class="truth_table">
		<thead>
			<th>x</th>
			<th>y</th>
			<th>z</th>
			<th>(x AND y)</th>
			<th>(NOT(x))</th>
			<th>(NOT(x) AND z)</th>
			<th>(x AND y) OR (NOT(x) AND z)</th>
		</thead>
		<tbody>
			<tr>
				<td>0</td>
				<td>0</td>
				<td>0</td>
				<td>0</td>
				<td>1</td>
				<td>0</td>
				<td>0</td>
			</tr>
			<tr>
				<td>1</td>
				<td>0</td>
				<td>0</td>
				<td>0</td>
				<td>0</td>
				<td>0</td>
				<td>0</td>
			</tr>
			<tr>
				<td>0</td>
				<td>1</td>
				<td>0</td>
				<td>0</td>
				<td>1</td>
				<td>0</td>
				<td>0</td>
			</tr>
			<tr>
				<td>0</td>
				<td>0</td>
				<td>1</td>
				<td>0</td>
				<td>1</td>
				<td>1</td>
				<td>1</td>
			</tr>
			<tr>
				<td>1</td>
				<td>1</td>
				<td>0</td>
				<td>1</td>
				<td>0</td>
				<td>0</td>
				<td>1</td>
			</tr>
			<tr>
				<td>1</td>
				<td>0</td>
				<td>1</td>
				<td>0</td>
				<td>0</td>
				<td>0</td>
				<td>0</td>
			</tr>
			<tr>
				<td>0</td>
				<td>1</td>
				<td>1</td>
				<td>0</td>
				<td>1</td>
				<td>1</td>
				<td>1</td>
			</tr>
			<tr>
				<td>1</td>
				<td>1</td>
				<td>1</td>
				<td>1</td>
				<td>0</td>
				<td>0</td>
				<td>1</td>
			</tr>
		</tbody>
	</table>
</figure>

<h4>Boolean Identities</h4>
<p>
	If we can write Boolean functions, then we can draw what are called
	<span class="boldItalics">Boolean identities</span>&mdash;laws that will always hold true, regardless of what inputs a function takes. These identities include
</p>
<p>the <span class="boldItalics">commutative laws</span>:</p>
<ol>
	<li><span class="monoText">(x AND y) = (y AND x)</span></li>
	<li><span class="monoText">(x OR y) = (y OR x)</span></li>
</ol>
<p>the <span class="boldItalics">associative laws</span>:</p>
<ol>
	<li>
		<span class="monoText">(x AND (y AND z)) = ((x AND y) AND z)</span>
	</li>
	<li>
		<span class="monoText">(x OR (y OR z)) = ((x OR y) OR z)</span>
	</li>
</ol>
<p>the <span class="boldItalics">distributive laws:</span></p>
<ol>
	<li>
		<span class="monoText">(x AND (y OR z)) = ((x AND y) OR (x AND z))</span>
	</li>
	<li>
		<span class="monoText">(x OR (y AND Z)) = ((x OR y) AND (x OR z))</span>
	</li>
</ol>
<p><span class="boldItalics">deMorgan's laws</span>:</p>
<ol>
	<li>
		<span class="monoText">NOT(x AND y) = NOT(x) OR NOT(y)</span>
	</li>
	<li>
		<span class="monoText">NOT(x OR y) = NOT(x) AND NOT(y)</span>
	</li>
</ol>
<p>the <span class="boldItalics">indempotence law</span>:</p>
<ol>
	<li><span class="monoText">x AND x = x</span></li>
	<li>
		<span class="monoText">(NOT(x)) AND (NOT(x)) = NOT(x)</span>
	</li>
</ol>
<p>and the <span class="boldItalics">double negation law</span>:</p>
<ol>
	<li><span class="monoText">NOT(NOT(x)) = x</span></li>
</ol>
<p>
	The Boolean identities allow us to simply complex Boolean expressions into simpler forms. For example, suppose the Boolean expression
	<span class="monoText">NOT(NOT(x) AND NOT(x OR y))</span>. The term <span class="monoText">NOT(x OR y)</span> can be reduced to <span class="monoText">(NOT(x) AND NOT(y))</span> by deMorgan's law. Thus, the expression now looks like: <span class="monoText">NOT(NOT(x) AND (NOT(x) AND NOT(y)))</span>. Then, we can use the associative law to change the order of evaluating the <span class="monoText">AND</span> operations: <span class="monoText">NOT((NOT(x) AND NOT(x)) AND NOT(y))</span>. Next, with the idempotence law, we can remove one of the <span class="monoText">NOT(x)</span>s: <span class="monoText">NOT(NOT(x) AND NOT(y))</span>. Then we can use deMorgan's law again: <span class="monoText">NOT(NOT(x)) OR NOT(NOT(y))</span>. Finally, using the double negation law: <span class="monoText">x OR y</span>.
</p>

<h3>Arithmetic with Logic</h3>
<p>
	Bits are not a very useful unit of measurement, since they can very rapidly grow into large numbers (the characters H, i, and ! took up 24 bits alone&mdash;imagine how many bits a paragraph or a Wikipedia article takes). Because of this problem, we measure bits in
	<span class="boldItalics">bytes</span>. A <span class="italicsText">byte</span> is simply 8 bits.
</p>

{% endblock %}