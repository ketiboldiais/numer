{% extends "numerc/layout.html" %} 

{% block title %}
<title>Computer Architecture: Logic</title>
{% endblock %}

{% block content %}
<section>
	<h3>Boolean Expressions</h3>
	<p>
		With the ability to use the three basic operators &mdash;
		<span class="monoText">AND</span>, <span class="monoText">OR</span>, and
		<span class="monoText">NOT</span>&mdash;we can combine them to form
		<span class="boldItalics">Boolean expressions</span>, which are expressions
		similar to those we see in mathematics. Boolean expressions are what allow
		us to create more complex operators and to perform increasingly elaborate
		operations.
	</p>
	<p>
		For example, consider the Boolean expression:
		<span class="monoText">NOT(0 OR (1 AND 1))</span>. What might this
		expression evaluate to? To evaluate the expression, we work from the
		innermost expression towards the outermost expression. The innermost
		expression is <span class="monoText">1 AND 1</span>. This evaluates to
		<span class="monoText">1</span>, since both input signals are
		<span class="monoText">1</span>. These leads to the next expression,
		<span class="monoText">0 or 1</span>, which evaluates to
		<span class="monoText">1</span>, since at least one input signal is
		<span class="monoText">1</span>. Finally, the
		<span class="monoText">NOT</span> operator kicks in, and reverses our result
		(<span class="monoText">1</span>), returning the output signal
		<span class="monoText">0</span>. Thus, the Boolean expression
		<span class="monoText">NOT(0 OR (1 AND 1))</span> returns the output signal
		<span class="monoText">0</span>.
	</p>

	<p>
		<span class="topic">Boolean Functions.</span>
		With the ability to write Boolean expressions, we can then write
		<span class="boldItalics">Boolean functions</span>&mdash;general Boolean
		"rules" that we construct ourselves that will output results based on
		inputs.
	</p>
	<p>
		For example, a Boolean function might look like:
		<span class="monoText">f(x, y, z) = (x AND y) OR (NOT(x) AND z)</span>. We
		can list all of the possible values for this function:
	</p>
	<figure>
		<table class="truth_table headers-mono all-td-centered">
			<thead>
				<th>x</th>
				<th>y</th>
				<th>z</th>
				<th>(x AND y)</th>
				<th>(NOT(x))</th>
				<th>(NOT(x) AND z)</th>
				<th>(x AND y) OR (NOT(x) AND z)</th>
			</thead>
			<tbody>
				<tr>
					<td>0</td>
					<td>0</td>
					<td>0</td>
					<td>0</td>
					<td>1</td>
					<td>0</td>
					<td>0</td>
				</tr>
				<tr>
					<td>1</td>
					<td>0</td>
					<td>0</td>
					<td>0</td>
					<td>0</td>
					<td>0</td>
					<td>0</td>
				</tr>
				<tr>
					<td>0</td>
					<td>1</td>
					<td>0</td>
					<td>0</td>
					<td>1</td>
					<td>0</td>
					<td>0</td>
				</tr>
				<tr>
					<td>0</td>
					<td>0</td>
					<td>1</td>
					<td>0</td>
					<td>1</td>
					<td>1</td>
					<td>1</td>
				</tr>
				<tr>
					<td>1</td>
					<td>1</td>
					<td>0</td>
					<td>1</td>
					<td>0</td>
					<td>0</td>
					<td>1</td>
				</tr>
				<tr>
					<td>1</td>
					<td>0</td>
					<td>1</td>
					<td>0</td>
					<td>0</td>
					<td>0</td>
					<td>0</td>
				</tr>
				<tr>
					<td>0</td>
					<td>1</td>
					<td>1</td>
					<td>0</td>
					<td>1</td>
					<td>1</td>
					<td>1</td>
				</tr>
				<tr>
					<td>1</td>
					<td>1</td>
					<td>1</td>
					<td>1</td>
					<td>0</td>
					<td>0</td>
					<td>1</td>
				</tr>
			</tbody>
		</table>
	</figure>

	<p>
		<span class="topic">Boolean Identities.</span>
		If we can write Boolean functions, then we can draw what are called
		<span class="boldItalics">Boolean identities</span>&mdash;laws that will
		always hold true, regardless of what inputs a function takes. These
		identities include
	</p>
	<p>the <span class="boldItalics">commutative laws</span>:</p>
	<ol>
		<li><span class="monoText">(x AND y) = (y AND x)</span></li>
		<li><span class="monoText">(x OR y) = (y OR x)</span></li>
	</ol>
	<p>the <span class="boldItalics">associative laws</span>:</p>
	<ol>
		<li>
			<span class="monoText">(x AND (y AND z)) = ((x AND y) AND z)</span>
		</li>
		<li>
			<span class="monoText">(x OR (y OR z)) = ((x OR y) OR z)</span>
		</li>
	</ol>
	<p>the <span class="boldItalics">distributive laws:</span></p>
	<ol>
		<li>
			<span class="monoText">(x AND (y OR z)) = ((x AND y) OR (x AND z))</span>
		</li>
		<li>
			<span class="monoText">(x OR (y AND Z)) = ((x OR y) AND (x OR z))</span>
		</li>
	</ol>
	<p><span class="boldItalics">deMorgan's laws</span>:</p>
	<ol>
		<li>
			<span class="monoText">NOT(x AND y) = NOT(x) OR NOT(y)</span>
		</li>
		<li>
			<span class="monoText">NOT(x OR y) = NOT(x) AND NOT(y)</span>
		</li>
	</ol>
	<p>the <span class="boldItalics">indempotence law</span>:</p>
	<ol>
		<li><span class="monoText">x AND x = x</span></li>
		<li>
			<span class="monoText">(NOT(x)) AND (NOT(x)) = NOT(x)</span>
		</li>
	</ol>
	<p>and the <span class="boldItalics">double negation law</span>:</p>
	<ol>
		<li><span class="monoText">NOT(NOT(x)) = x</span></li>
	</ol>
	<p>
		The Boolean identities allow us to simply complex Boolean expressions into
		simpler forms. For example, suppose the Boolean expression
		<span class="monoText">NOT(NOT(x) AND NOT(x OR y))</span>. The term
		<span class="monoText">NOT(x OR y)</span> can be reduced to
		<span class="monoText">(NOT(x) AND NOT(y))</span> by deMorgan's law. Thus,
		the expression now looks like:
		<span class="monoText">NOT(NOT(x) AND (NOT(x) AND NOT(y)))</span>. Then, we
		can use the associative law to change the order of evaluating the
		<span class="monoText">AND</span> operations:
		<span class="monoText">NOT((NOT(x) AND NOT(x)) AND NOT(y))</span>. Next,
		with the idempotence law, we can remove one of the
		<span class="monoText">NOT(x)</span>s:
		<span class="monoText">NOT(NOT(x) AND NOT(y))</span>. Then we can use
		deMorgan's law again:
		<span class="monoText">NOT(NOT(x)) OR NOT(NOT(y))</span>. Finally, using the
		double negation law: <span class="monoText">x OR y</span>.
	</p>

	<h5>Arithmetic with Logic.</h5>
	<p>
		Bits are not a very useful unit of measurement, since they can very rapidly
		grow into large numbers (the characters H, i, and ! took up 24 bits
		alone&mdash;imagine how many bits a paragraph or a Wikipedia article takes).
		Because of this problem, we measure bits in
		<span class="boldItalics">bytes</span>. A
		<span class="italicsText">byte</span> is simply 8 bits.
	</p>
</section>

<section>
	<h3>Elementary Logic Gates</h3>
	<p>
		We begin with an introduction to Boolean logic. Computers can only handle
		two values: 0s and 1s (setting aside developments in quantum computing).
		This is because having only two values is the simplest way to perform
		computations&mdash;yes or no, open or close, true or false, etc. With just
		0s and 1s, we can use basic logical operators.
	</p>

	<p>
		<span class="topic">The <span class="monoText">AND</span> Operator.</span>
		One such operator is the
		<span class="monoText boldText">AND</span> operation in logic:
	</p>
	<figure>
		<table class="truth_table headers-mono all-td-centered">
			<thead>
				<th>x</th>
				<th>y</th>
				<th>AND</th>
			</thead>
			<tbody>
				<tr>
					<td>0</td>
					<td>0</td>
					<td>0</td>
				</tr>
				<tr>
					<td>0</td>
					<td>1</td>
					<td>0</td>
				</tr>
				<tr>
					<td>1</td>
					<td>0</td>
					<td>0</td>
				</tr>
				<tr>
					<td>1</td>
					<td>1</td>
					<td>1</td>
				</tr>
			</tbody>
		</table>
	</figure>
	<p>
		The <span class="monoText">AND</span> operator takes two input signals, and
		outputs one input signal. It returns an input signal of
		<span class="monoText">1</span> if, and only if, both input signals are
		<span class="monoText">1</span>. Otherwise, it outputs the input signal
		<span class="monoText">0</span>.
	</p>

	<p>
		<span class="topic">The <span class="monoText">OR</span> Operator.</span>
		Another basic operator is the
		<span class="monoText boldText">OR</span> operator:
	</p>
	<figure>
		<table class="truth_table headers-mono all-td-centered">
			<thead>
				<th>x</th>
				<th>y</th>
				<th>OR</th>
			</thead>
			<tbody>
				<tr>
					<td>0</td>
					<td>0</td>
					<td>0</td>
				</tr>
				<tr>
					<td>0</td>
					<td>1</td>
					<td>1</td>
				</tr>
				<tr>
					<td>1</td>
					<td>0</td>
					<td>1</td>
				</tr>
				<tr>
					<td>1</td>
					<td>1</td>
					<td>1</td>
				</tr>
			</tbody>
		</table>
	</figure>
	<p>
		Like the <span class="monoText">AND</span> operator, the
		<span class="monoText">OR</span> operator takes two inputs signals, and
		outputs one input signal. Unlike the
		<span class="monoText">AND</span> operator, however, it returns an output
		signal of <span class="monoText">1</span> if just one of the input signals
		is <span class="monoText">1</span>. In other words, the only time the
		<span class="monoText">OR</span> operator returns an output signal of
		<span class="monoText">0</span> is when both input signals are
		<span class="monoText">0</span>.
	</p>

	<p>
		<span class="topic">The <span class="monoText">NOT</span> Operator.</span>
		The third basic operator is the
		<span class="monoText boldText">NOT</span> operator. The
		<span class="monoText">NOT</span> operator is a
		<span class="italicsText">unary operator</span> (it takes only one input
		signal), as opposed to the <span class="monoText">AND</span> and
		<span class="monoText">OR</span> operators, which are
		<span class="italicsText">binary operators</span> (they take two input
		signals).
	</p>
	<figure>
		<table class="truth_table headers-mono all-td-centered">
			<thead>
				<th>x</th>
				<th>NOT</th>
			</thead>
			<tbody>
				<tr>
					<td>0</td>
					<td>1</td>
				</tr>
				<tr>
					<td>1</td>
					<td>0</td>
				</tr>
			</tbody>
		</table>
	</figure>
	<p>
		The <span class="monoText">NOT</span> operator takes one input signal, and
		returns its opposite. Thus, if the input signal is
		<span class="monoText">1</span>, the
		<span class="monoText">NOT</span> operator will return
		<span class="monoText">0</span>, and if the input signal is
		<span class="monoText">0</span>, the
		<span class="monoText">NOT</span> operator returns
		<span class="monoText">1</span>.
	</p>
</section>
{% endblock %}
