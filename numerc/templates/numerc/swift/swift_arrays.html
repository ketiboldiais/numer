{% extends '../layout.html' %} {% load static %} {% block content %}
<section id="collections">
	<h2>Collections</h2>
	<p>
		In Swift, compound data is referred to as a
		<span class="term">collection</span>. We can think of them as big containers
		(at least as compared to variables) for storing however many values we would
		like. There are a variety of collections in Swift, and we can even make our
		own custom collections. More generally, a collection is a
		<span class="term">data structure</span>.
	</p>

	<p>
		What collection we should use depends on the problem we're trying to solve.
		In Swift, the decision usually hinges on four criteria: (1)
		<span class="term">maintainability</span> (how easy is it to maintain the
		collection over time); (2) <span class="term">efficiency</span> (how fast
		can operations on the collection be completed); (3)
		<span class="term">cost</span> (how expensive &mdash; whether it's in terms
		of time, memory, or CPU usage &mdash; is the collection); and (4)
		<span class="term">security</span> (how well does the collection hold up
		against breaches).
	</p>

	<p>
		<span class="topic">Mutability v. Immutability.</span> One factor that
		directly implicates all the critera above is
		<span class="term">mutability</span> &mdash; the ability to modify data (in
		this case, a collection) after it is created. To ensure a collection is
		immutable (i.e., it cannot be changed), we declare the collection with
		<span class="monoText">let</span>. To ensure mutability,
		<span class="monoText">var</span>.
	</p>

	<p>
		Mutable data structures are tricky. On the one hand, they provide great
		flexibility and freedom in writing algorithms, or operations, for that data
		structure. On the other hand, they can also lead to incorrect algorithms or
		security breaches. There is no bright-line rule for which to use, but erring
		on the side of immutability reduces program complexity &mdash; we reduce the
		number of changes we have to keep track of.
	</p>
</section>

<section id="arrays">
	<h3>Arrays</h3>
	<p>
		An <span class="term">array</span> is an ordered collection of the
		<span class="underlineText">same type</span> values. Every element in the
		array has an <span class="term">index</span> starting from
		<span class="monoText">0</span>. Moreover, every array has a type,
		<span class="monoText">[${t}$]</span>, where ${t}$ is the type for all the
		array's elements. Arrays in Swift are similar to most languages in that they
		are created with square brackets:
	</p>

	<pre class="language-swift"><code>
		let shoppingList = ["mangoes", "milk", "orange juice", "eggs"]
		print(shoppingList)
	</code></pre>
	<pre class="language-bash"><code>
		["mangoes", "milk", "orange juice", "eggs"]
	</code></pre>

	<p>We can access individual elements in the array using angle brackets.</p>

	<pre class="language-swift"><code>
		let shoppingList = ["mangoes", "milk", "orange juice", "eggs"]
		print(shoppingList[0])
	</code></pre>
	<pre class="language-bash"><code>
		mangoes
	</code></pre>

	<p>
		Like most other languages, Swift indices start at 0. If we initialize a list
		with the keyword <span class="monoText">var</span>, we can mutate the list:
	</p>

	<pre class="language-swift"><code>
		var shoppingList = ["mangoes", "milk", "orange juice", "eggs"]
		shoppingList[0] = "papayas"
		print(shoppingList)
	</code></pre>
	<pre class="language-bash"><code>
		["papayas", "milk", "orange juice", "eggs"]
	</code></pre>

	<p>
		<span class="topic">Empty Array.</span> To create an empty array, we use the
		following initializer syntax:
	</p>
	<pre class="language-swift"><code>
		var studentList: [String] = []
	</code></pre>
	<p>Notice the general form:</p>

	<figure class="math-display">
		<ul class="syntax">
			<li>var ${n}$: [${t}$] = []</li>
		</ul>
		<ul class="def">
			<li class="where">${n}$ is the array's name; and</li>
			<li>${t}$ is the type for each value in the array</li>
		</ul>
	</figure>

	<p>
		If type can be inferred, we can create the empty array with just square
		brackets:
	</p>
	<pre class="language-swift"><code>
		var myArray = []
	</code></pre>

	<p>
		<span class="topic">Array Methods.</span> Swift provides numerous build-in
		methods for operating on arrays. Here are a few:
	</p>

	<figure class="table">
		<table class="truth_table">
			<thead>
				<th>methods/operations</th>
				<th>operation</th>
				<th>comment</th>
			</thead>
			<tbody>
				<tr>
					<td><span class="monoText redText">${arr}$.append(${v}$)</span></td>
					<td>Inserts at the array ${arr}$'s end the value ${v}$</td>
					<td>Return is a mutated array; ${arr}$ must be a var.</td>
				</tr>
				<tr>
					<td>
						<span class="monoText redText"
							>${arr}$.insert(${v}$, at: ${n}$)</span
						>
					</td>
					<td>Insert the value ${v}$ at the index ${n}$</td>
					<td>Return is a mutated array; ${arr}$ must be a var.</td>
				</tr>
				<tr>
					<td>
						<span class="monoText redText">${arr}$.remove(at: ${n}$)</span>
					</td>
					<td>Removes the element at index ${n}$</td>
					<td>Return is the removed element; ${arr}$ must be a var.</td>
				</tr>
				<tr>
					<td><span class="monoText redText">${arr}$.removeLast()</span></td>
					<td>Removes the last element of ${arr}$</td>
					<td>Return is the removed element; ${arr}$ must be a var.</td>
				</tr>
				<tr>
					<td><span class="monoText redText">${arr}$.removeAll()</span></td>
					<td>Removes all elements inside the array</td>
					<td>${arr}$ must be a var.</td>
				</tr>
				<tr>
					<td><span class="monoText redText">${arr}$.isEmpty</span></td>
					<td>Is this array empty?</td>
					<td>Returns Boolean type value: true or false.</td>
				</tr>
				<tr>
					<td><span class="monoText redText">${arr}$.count</span></td>
					<td>How many elements are in this array?</td>
					<td>
						Returns an Int type value: The length/size of the array; how many
						elements are in the array.
					</td>
				</tr>
				<tr>
					<td><span class="monoText redText">${arr}$.first</span></td>
					<td>What is the first element in this array?</td>
					<td>
						Returns the element at the head of the array (equivalent to hd in
						Scheme and ML). The return type is an Optional, so it must be safely
						unwrapped before use.
					</td>
				</tr>
				<tr>
					<td><span class="monoText redText">${arr}$.contains(${v}$)</span></td>
					<td>Is the value ${v}$ inside this array?</td>
					<td>
						Returns a Boolean type value: true if ${v}$ is inside the array,
						else false.
					</td>
				</tr>
				<tr>
					<td><span class="monoText redText">${arr_0}$ += ${arr_1}$</span></td>
					<td>merges ${arr_0}$ and ${arr_1}$ into a single array</td>
					<td>
						Mutates ${arr_0}$ into a new array where the elements of ${arr_1}$
						are inserted to the tail of ${arr_0.}$ ${arr_1}$ is not mutated.
						Cannot merge arrays of different types.
					</td>
				</tr>
				<tr>
					<td><span class="monoText redText">${arr}$[${n}$]</span></td>
					<td>Returns the element of ${arr}$ at index ${n.}$</td>
					<td>
						Referencing an index greater than the length of the array will
						return an index-out-of-range error. (In Swift, the range of an array
						refers to the range of the indices).
					</td>
				</tr>
				<tr>
					<td><span class="monoText redText">${arr}$[${i_0...i_n}$]</span></td>
					<td>
						Returns an <span class="term">array slice</span> consisting of the
						elements of ${arr}$ with indices from ${i_0}$ to ${i_n}$
					</td>
					<td>
						Return is an array slice, which is a stored reference to a part of
						${arr.}$ This means the indices of the elements in the array slice
						are their indices in ${arr.}$
					</td>
				</tr>
				<tr>
					<td>
						<span class="monoText redText">Array(${arr}$[${i_0...i_n}$])</span>
					</td>
					<td>
						Returns a new array consisting of the elements of ${arr}$ with
						indices from ${i_0}$ to ${i_n}$
					</td>
					<td>
						Unlike the array slice, this returns a new array, with elements
						having indices starting from 0.
					</td>
				</tr>
				<tr>
					<td><span class="monoText redText">${arr.}$max()</span></td>
					<td>Returns the largest/maximum element in the array</td>
					<td>Return type is an Optional, must safely unwrap before use.</td>
				</tr>
				<tr>
					<td><span class="monoText redText">${arr.}$min()</span></td>
					<td>Returns the smallest/minimum element in the array</td>
					<td>Return type is an Optional, must safely unwrap before use.</td>
				</tr>
				<tr>
					<td><span class="monoText redText">${arr.}$sort()</span></td>
					<td>Returns elements of array sorted in place</td>
					<td>Mutates the array</td>
				</tr>
				<tr>
					<td><span class="monoText redText">${arr.}$sorted()</span></td>
					<td>Returns elements of array sorted</td>
					<td>Does not mutate the array</td>
				</tr>
				<tr>
					<td><span class="monoText redText">${arr.}$reverse()</span></td>
					<td>Reverses the elements of the array in place</td>
					<td>Mutates the array.</td>
				</tr>
				<tr>
					<td><span class="monoText redText">${arr.}$reversed()</span></td>
					<td>Returns elements of array reversed</td>
					<td>Does not mutate the array</td>
				</tr>
				<tr>
					<td>
						<span class="monoText redText"
							>${arr.}$swapAt(${n_0}$, ${n_1}$)</span
						>
					</td>
					<td>Swaps the elements at ${n_0}$ and ${n_1}$</td>
					<td>Mutates the array</td>
				</tr>
			</tbody>
		</table>
	</figure>
</section>

<section id="array_runningTime">
	<h4>Runtime: Arrays</h4>
	<p>
		Arrays are the simplest data structure. A single array is stored as a
		contiguous block in memory, and this has a large impact on the runtime for
		certain operations.
	</p>
	<p>
		<span class="topic">Accessing a Particular Element.</span> Accessing
		elements in an array is very low cost. Given some array ${A,}$ accessing
		<span class="monoText">${A}$[${n}$]</span> has a complexity of ${O(1).}$
		This is because Swift just takes one step &mdash; go to the element ${n.}$
	</p>
	<p>
		<span class="topic">Inserting Elements.</span> Inserting elements has
		varying complexities, largely dependant on where in the array we want to
		insert the new element. If we add to the array's head, then Swift must shift
		all of the array's elements over by one to make room. And since Swift can
		only shift one element at a time, the number of steps it takes is ${n,}$
		where ${n}$ is the number of existing elements in the array. Thus, inserting
		an element to the head has a complexity of ${O(n).}$
	</p>
	<p>
		Similarly, if we want to insert an element to the middle of the array, Swift
		must shift ${n/2}$ elements. In terms of complex, the ${\frac{1}{2}}$ is
		just a constant (${n/2 = \frac{1}{2}(n)}$), so we can factor it out, leaving
		us with a complexity of ${O(n.)}$
	</p>
	<p>
		In contrast, if we want to insert an element to the tail of the array, then
		Swift doesn't have to shift any elements. Assuming the array has enough room
		&mdash; which is usually the case &mdash; then Swift only takes on step: add
		it to the end. This is a complexity of ${O(1).}$
		<span class="marginnote"
			>In the case where there isn't enough room in the existing array, then
			Swift must make a copy of the array before inserting the new element.
			Copying the array requires individually copying each of the elements,
			leaving a complexity of ${O(n).}$</span
		>
	</p>
	<p>
		<span class="topic">Removing Elements.</span> Like insertion, removing an
		element in the array depends on which element we are removing. When we
		remove an element, Swift must shift all the remaining elements to fill in
		the empty position. Thus, if we remove an element from anywhere but the
		tail, we have a complexity of ${O(n).}$ If we remove an element from the
		tail, then no shifting is needed, and the complexity is constant time,
		${O(1).}$
	</p>
</section>

<section id="dictionaries">
	<h3>Dictionaries</h3>
	<p>
		In Swift and most other languages, a <span class="term">dictionary</span> is
		an unordered collection of key-value pairs. Dictionaries useful when we want
		to access a value by means of an <span class="term">identifier</span>. For
		example, we might have the following key-value pairs:
	</p>

	<figure class="math-display">
		<ul class="syntax">
			<li>[</li>
			<ul>
				<li>"gold" : "Au"</li>
				<li>"sodium" : "Na"</li>
				<li>"copper" : "Cu"</li>
				<li>"hydrogen" : "H"</li>
			</ul>
			<li>]</li>
		</ul>
	</figure>

	<p>
		In Swift, dictionary keys must be unique. For example, in the dictionary
		above, we would not be able to have two keys named
		<span class="monoText">"Copper"</span> (Swift wouldn't be able to tell which
		one we're referring to). However, different keys can point to the same value
		(in other words, the same value can appear in multiple keys). For example:
	</p>

	<figure class="math-display">
		<ul class="syntax">
			<li>[</li>
			<ul>
				<li>"rice" : "available"</li>
				<li>"corn" : "unavailable"</li>
				<li>"wheat" : "available"</li>
				<li>"lentils" : "unavailable"</li>
			</ul>
			<li>]</li>
		</ul>
	</figure>

	<p>
		Unlike some languages, all the keys in a dictionary
		<span class="underlineText">must</span> be the same type. We cannot have
		some keys with a <span class="monoText">String</span> type and others an
		<span class="monoText">Int</span> type. The same goes for the values. We
		cannot have some values of type <span class="monoText">Int</span> and other
		values of type <span class="monoText">Bool</span>. You can, however, have
		keys of one type, and values of another type. For example, keys of type
		<span class="monoText">String</span>, paired to values of type
		<span class="monoText">Double</span>.
	</p>

	<p>
		These rules demonstrate several crucial differences between dictionaries and
		arrays. With dictionaries, we access values by referencing their paired key.
		Those keys can be of any type, and they inherently have no order. With
		arrays, we access values by index, and all indices are of type
		<span class="monoText">Int</span>. Furthermore, the indices start from 0 and
		are sequential &mdash; there is an inherent order. The general syntax for a
		dictionary:
	</p>

	<figure class="math-display">
		<ul class="syntax">
			<li>[</li>
			<ul>
				<li>${key_0}$ : ${val_0}$,</li>
				<li>${\vdots}$,</li>
				<li>${key_n}$ : ${val_n}$</li>
			</ul>
			<li>]</li>
		</ul>
	</figure>

	<p>Let's see what the data type is for a dictionary:</p>

	<pre class="language-swift"><code>
		var alphabet = [
			0: "a",
			1: "b",
			2: "c",
			3: "d"
		]
		print(type(of: alphabet))
	</code></pre>
	<pre class="language-bash"><code>
		Dictionary&lt;Int, String&gt;
	</code></pre>

	<p>
		A dictionary has the type
		<span class="monoText">Dictionary&lt;Int, String&gt;</span>. We can add to
		the dictionary with the following:
	</p>

	<pre class="language-swift"><code>
		var studentMajors = [
			"Immanuel Kant": "philosophy",
			"Maurits Cornelis Escher": "art",
			"Evariste Galois": "mathematics"
		]

		studentMajors["Roger Ebert"] = "film"
	</code></pre>
	<pre class="language-bash"><code>
		["Evariste Galois": "mathematics", "Immanuel Kant": "philosophy", "Maurits Cornelis Escher": "art", "Roger Ebert": "film"]
	</code></pre>

	<p>
		Swift provides numerous methods and operations we can use on dictionaries:
	</p>

	<figure class="table">
		<table class="truth_table">
			<thead>
				<th>operator</th>
				<th>operation</th>
				<th>comment</th>
			</thead>
			<tbody>
				<tr>
					<td>
						<span class="monoText"
							>${d}$.updateValue(${n}$, forKey: ${k}$)</span
						>
					</td>
					<td>Updates the value paired to key ${k}$ with the value ${n}$</td>
					<td></td>
				</tr>
				<tr>
					<td><span class="monoText">${d}$[${k}$] = ${n}$</span></td>
					<td>
						The same operation as the previous; updates/replaces the value
						paired with ${k}$ with the value ${n}$
					</td>
					<td></td>
				</tr>
				<tr>
					<td><span class="monoText">${d}$[${k}$]</span></td>
					<td>Evaluates to the value paired with the key ${k}$</td>
					<td>
						Return type is an <span class="underlineText">optional</span>; must
						unwrap for use
					</td>
				</tr>
				<tr>
					<td><span class="monoText">${d}$.isEmpty</span></td>
					<td>Does the dictionary contain any key-value pairs?</td>
					<td>Return type is a Bool</td>
				</tr>
				<tr>
					<td><span class="monoText">${d}$.count</span></td>
					<td>How many key-value pairs are in the dictionary?</td>
					<td>Return type is an Int</td>
				</tr>
				<tr>
					<td>
						<span class="monoText">${d}$.removeValue(forKey: ${k}$)</span>
					</td>
					<td>Removes the value ${v}$ paired with the key ${k}$</td>
					<td>
						Return type is an Optional<${t_v}$>, where ${t_v}$ is the type of
						the value removed; this mutates the dictionary
					</td>
				</tr>
				<tr>
					<td><span class="monoText">${d}$[${k}$] = nil</span></td>
					<td>
						Removes the key-value pair with the key ${k}$ in the dictionary
					</td>
					<td>
						No return type; mutates the dictionary by removing the key-value
						pair with the key ${k}$
					</td>
				</tr>
				<tr>
					<td colspan="3"><sup>*</sup>where ${d}$ is the dictionary's name</td>
				</tr>
			</tbody>
		</table>
	</figure>

	<p>
		<span class="topic">Looping through a Dictionary.</span> Another critical
		difference between arrays and dictionaries is that we do not get an
		out-of-bounds error when we ask for the value associated with a key that
		does not exist. Importantly, you
		<span class="underlineText">cannot</span> have a key in a dictionary that is
		not paired with a value. In other words, every key we write in the
		dictionary <span class="underlineText">must</span> have a value paired with
		it. If the key doesn't exist, the dictionary simply returns
		<span class="monoText">nil</span>. This is a helpful feature in Swift to
		keep in mind when we attempt to loop through a dictionary.
	</p>

	<p>
		Just like arrays, we can in fact loop through a dictionary. But instead of
		just returning the value, the loop will return the key-value pair. This
		key-value pair is actually a <span class="italicsText">tuple</span>. So, for
		example:
	</p>

	<pre class="language-swift"><code>
		var chemicalSymbols = [
			"gold" : "Au",
			"sodium": "Na",
			"copper": "Cu"
		]
		print(chemicalSymbols["gold"])
		print(chemicalSymbols["Oxygen"])
	</code></pre>
	<pre class="language-bash"><code>
		Optional("Au")
		nil
	</code></pre>

	<p>Looping through dictionaries is straightforward and clear:</p>

	<pre class="language-swift"><code>
		var chemicalSymbols = [
			"gold" : "Au",
			"sodium": "Na",
			"copper": "Cu"
		]

		for (chemical, chemSymbol) in chemicalSymbols {
			print("\(chemical) has the symbol \(chemSymbol).")
		}
	</code></pre>
	<pre class="language-bash"><code>
		gold has the symbol Au.
		copper has the symbol Cu.
		sodium has the symbol Na.
	</code></pre>

	<p>
		The keys and the values of a dictionary are called the dictionaries
		<span class="term">properties</span>. Swift allows us to iterate through
		either of these properties. As in most other languages, we reference these
		properties with <span class="italicsText">dot notation</span>. For example,
		suppose we want to iterate through the keys in our example dictionary:
	</p>

	<pre class="language-swift"><code>
		var chemicalSymbols = [
			"gold" : "Au",
			"sodium": "Na",
			"copper": "Cu"
		]
		for chemical in chemicalSymbols.keys {
			print(chemical)
		}
	</code></pre>
	<pre class="language-bash"><code>
		gold
		sodium
		copper
	</code></pre>

	<p>And if we want to iterate through the values:</p>

	<pre class="language-swift"><code>
		var chemicalSymbols = [
			"gold" : "Au",
			"sodium": "Na",
			"copper": "Cu"
		]
		for chemicalSymbol in chemicalSymbols.values {
			print(chemicalSymbol)
		}
	</code></pre>
	<pre class="language-bash"><code>
		Cu
		Au
		Na
	</code></pre>

	<p>
		<span class="topic">Empty Dictionary.</span> To create an empty dictionary,
		we use the same initializer syntax:
	</p>

	<pre class="language-swift"><code>
		var studentMajors: [String: String] = [:]
	</code></pre>

	<p>The general syntax:</p>

	<figure class="math-display">
		<ul class="syntax">
			<li>var ${n}$: [${k_{t}}$ : ${v_{t}}$] = [:]</li>
		</ul>
		<ul class="def">
			<li class="where">${n}$ is the dictionary's name,</li>
			<li>${k_t}$ is the key's type, and</li>
			<li>${v_t}$ is the value's type</li>
		</ul>
	</figure>

	<p>
		Like arrays, if type can be inferred, we can create the empty dictionary
		with just square brackets and a colon:
	</p>

	<pre class="language-swift"><code>
		var myDictionary = [:]
	</code></pre>
</section>

<section id="dictionary_runtime">
	<h4>Runtime: Dictionaries</h4>
	<p>
		To understand the complexities for operations on dictionaries, we must
		briefly discuss how dictionaries actually work. Unlike arrays, dictionaries
		are not created by simply storing values in a contiguous region of memory.
		Instead, dictionaries require <span class="term">hashing</span>.
	</p>

	<p>
		<span class="topic">Hashing.</span> Hashing is the process of turning a
		value of a particular type &mdash; whether it's a
		<span class="monoText">String</span>, <span class="monoText">Int</span>,
		etc. &mdash; into a numeric value. The resulting numeric value is called a
		<span class="term">hash value</span>. These hash values are then used to
		lookup values in a <span class="term">hash table</span>. To better
		understand how this works, we briefly consider some searching algorithms.
		<span class="marginnote"
			>This discussion on hashing is not unique to Swift; it is a broad overview
			applicable across other languages. For a more rigorous discussion on
			hashing, see
			<span class="italicsText">Data Structures and Algorithms: C++</span
			>.</span
		>
	</p>

	<p>Say we had some array ${A}$ containing ${n}$ elements, and we want to check if the array contains some value ${v}$ (let's say it does). To do so, we need a searching algorithm. If we use linear search, then we have a complexity of ${O(n).}$ This is because Swift has to look at each element, one by one from left to right, checking if the given element is equal to ${v.}$</p>
	
	<p>Alternatively, we could use binary search. With binary search, however, the array's elements must be first be sorted from least to greatest. Assuming the elements are sorted correctly, then we have a complexity of ${O(\text{lg } n).}$ Swift just has to split the array in half, check which head of each half is closer to ${v,}$ toss the half further, and continue searching in the other half. Dividing over and over again, Swift eventually finds ${v.}$ Mathematically, this takes ${\text{lg } n}$ steps. <span class="marginnote">For those unfamiliar, the symbol ${\text{lg}}$ is equivalent to ${\log_{2}.}$ We use ${\text{lg}}$ rather than ${\log}$ because ${\log}$ is usually reserved for ${\log_{10},}$ the common logarithm. ${\text{lg}}$ is the binary logarithm.</span></p>

	<p>Comparing the two, binary search is much faster &mdash; linear time is generally slower than logarithmic time. The catch, of course, is that the elements in the array must first be sorted. Now, even though logarithmic time is pretty good, constant time, ${O(1),}$ is even better. It is this goal, achieving ${O(1),}$ that sparks the need for hashing.</p>

	<p>With hashing, we want to transform values into some number corresponding to an index in the array. For example, if we had the elements 8, 4, 9, 11, and 3. We call these elements <span class="term">keys</span>. The first idea: store each key at a particular index, rather than just blindly storing them as presented. 8 goes to index 8, 4 goes to index 4, 9 goes to index 9, 11 to 11, 3 to 3, and so on. If the value we're looking for is 8, we tell Swift to look at index 8. If it's 4, look at 4. Notice what this leads to in terms of complexity. Swift just needs to take one step, like accessing an element in the array. This is a complexity of order ${O(1)}$ &mdash; constant time.</p>

	<p>The problem, however, is when we have a key like 8435. This is very far down the array. Worse, there are a lot of spaces wasted in the array. With our original keys, 11 was the greatest, so there are 8422 positions left empty (or more accurately, 8429, since there are 7 empty positions before 11). This is a lot of wasted space. It seems that by achieving ${O(1),}$ we did so at a gigantic cost in memory. So now we have another goal &mdash; reducing memory costs while maintaing ${O(1).}$</p>

	<p>The solution is to use a mathematical model. To do so, we need a function, more specifically called a <span class="term">hash function</span>. Before we consider the hash function, we should lay out the problem thus far, and use more specific terminology. First, the keys, all together, form a <span class="term">key space</span>. Second, we'll refer to the array we mentioned previously as a <span class="term">hash table</span>. Third, there is some hash function ${h(x) = x}$ that maps elements of the key space to elements of the hash table. E.g., ${h(8) = 8,}$ ${h(11) = 11,}$ and so on.</p>

	<figure><img src="{% static 'images/keyspace.svg' %}" alt="keyspace and hashtable" loading="lazy" class="forty-p"></figure>

	<p>Applying the hash function to all the elements in the key space, the final result looks like:</p>

	<figure><img src="{% static 'images/keyspace2.svg' %}" alt="keyspace" loading="lazy" class="forty-p"></figure>

	<p>Again, notice the empty spaces in the hash table. Let's think more about that hash function. Mathematically, functions consist of two types: (1) <span class="italicsText">one-to-one functions</span>, and (2) <span class="italicsText">many-to-one functions</span>. Our function above, ${h(x) = x,}$ is a one-to-one type function. Keeping this detail in mind, we want to rewrite our hash function such that we use the empty positions in the hash table.</p>

	<p>How might we do so? Well, looking at the hash table above, it has a size of 12. One possible definition for ${h(x):}$</p>

	<figure class="math-display">
		<div>
			<p>${h(x) = x \bmod s}$</p>
			<ul class="def">
				<li class="where"> ${s}$ is the size of the hash table.</li>
				<li></li>
			</ul>
		</div>
	</figure>

	<p>With this definition, let's say our key space now includes 13:</p>

	<figure><img src="{% static 'images/keyspace3.svg' %}" alt="keyspace" loading="lazy" class="sixty-p"></figure>

	<p>Great, it works. We are now actually using the empty spaces. But there's a problem lingering &mdash; what happens when we the keyspace includes 1? ${h(1) = 1 \bmod 12 = 1.}$ But 1 is already occupied by 13. We can have 1 map to 1, but that would result in a <span class="term">collision</span>. We do not want collisions. So now we have another problem to solve: How do we avoid collisions?</p>

	<p>It turns out there are a lot of different methods to for avoiding or removing collisions. Generally, they fall into two categories: (1) <span class="term">open hashing</span>, and (2) <span class="term">closed hashing</span>. Within open hashing, we have the method of <span class="term">chaining</span>. Within closed hashing, we have a category of methods called <span class="term">open addressing</span>, which itself consists of <span class="term">linear probing</span> and <span class="term">quadratic probing</span>. These are just a few methods.</p>

	<p>Let's first consider chaining. With chaining, we use our usual hash function. But instead of simply inserting the key into an empty position in the hash table, we insert the key <span class="italicsText">and</span> include a pointer. In other words, we start a chain. If we encounter a key that maps to an occupied position in the hash table, the key is chained to the occupying key by having the occupying key's pointer point to the subsequent key. For example, let's say our key space now includes 1:</p>

	<figure><img src="{% static 'images/keyspace4.svg' %}" alt="keyspace" loading="lazy" class="seventy-p"></figure>

	<p>The chain above is really just a <span class="italicsText">linked list</span>. With linked lists, we solve the collision proble. But, in doing so, we've increased complexity. On average, this is still faster than ${O(\text{lg } n),}$ but if we have to search for 1, we'll have to search through the linked list as well. If the chain grows too long, then we potentially hit ${O(n).}$ Moreover, there are open positions in the hash table, but instead of using them, we're adding to chains.</p>

	<p>Let's consider another method, <span class="term">linear probing</span>. </p>

	<p>
		In dictionaries, the value to be hashed is the key. And to be hashed, the
		key must be <span class="term">hashable</span>.
	</p>
</section>
{% endblock %}
