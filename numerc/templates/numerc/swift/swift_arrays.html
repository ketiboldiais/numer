{% extends '../layout.html' %} {% load static %} {% block content %}
<section id="collections">
	<h2>Collections</h2>
	<p>
		In Swift, compound data is referred to as a
		<span class="term">collection</span>. We can think of them as big containers
		(at least as compared to variables) for storing however many values we would
		like. There are a variety of collections in Swift, and we can even make our
		own custom collections. More generally, a collection is a
		<span class="term">data structure</span>.
	</p>

	<p>
		What collection we should use depends on the problem we're trying to solve.
		In Swift, the decision usually hinges on four criteria: (1)
		<span class="term">maintainability</span> (how easy is it to maintain the
		collection over time); (2) <span class="term">efficiency</span> (how fast
		can operations on the collection be completed); (3)
		<span class="term">cost</span> (how expensive &mdash; whether it's in terms
		of time, memory, or CPU usage &mdash; is the collection); and (4)
		<span class="term">security</span> (how well does the collection hold up
		against breaches).
	</p>

	<p>
		<span class="topic">Mutability v. Immutability.</span> One factor that
		directly implicates all the critera above is
		<span class="term">mutability</span> &mdash; the ability to modify data (in
		this case, a collection) after it is created. To ensure a collection is
		immutable (i.e., it cannot be changed), we declare the collection with
		<span class="monoText">let</span>. To ensure mutability,
		<span class="monoText">var</span>.
	</p>

	<p>
		Mutable data structures are tricky. On the one hand, they provide great
		flexibility and freedom in writing algorithms, or operations, for that data
		structure. On the other hand, they can also lead to incorrect algorithms or
		security breaches. There is no bright-line rule for which to use, but erring
		on the side of immutability reduces program complexity &mdash; we reduce the
		number of changes we have to keep track of.
	</p>
</section>

<section id="arrays">
	<h3>Arrays</h3>
	<p>
		An <span class="term">array</span> is an ordered collection of the
		<span class="underlineText">same type</span> values. Every element in the
		array has an <span class="term">index</span> starting from
		<span class="monoText">0</span>. Moreover, every array has a type,
		<span class="monoText">[${t}$]</span>, where ${t}$ is the type for all the
		array's elements. Arrays in Swift are similar to most languages in that they
		are created with square brackets:
	</p>

	<pre class="language-swift"><code>
		let shoppingList = ["mangoes", "milk", "orange juice", "eggs"]
		print(shoppingList)
	</code></pre>
	<pre class="language-bash"><code>
		["mangoes", "milk", "orange juice", "eggs"]
	</code></pre>

	<p>We can access individual elements in the array using angle brackets.</p>

	<pre class="language-swift"><code>
		let shoppingList = ["mangoes", "milk", "orange juice", "eggs"]
		print(shoppingList[0])
	</code></pre>
	<pre class="language-bash"><code>
		mangoes
	</code></pre>

	<p>
		Like most other languages, Swift indices start at 0. If we initialize a list
		with the keyword <span class="monoText">var</span>, we can mutate the list:
	</p>

	<pre class="language-swift"><code>
		var shoppingList = ["mangoes", "milk", "orange juice", "eggs"]
		shoppingList[0] = "papayas"
		print(shoppingList)
	</code></pre>
	<pre class="language-bash"><code>
		["papayas", "milk", "orange juice", "eggs"]
	</code></pre>

	<p>
		<span class="topic">Empty Array.</span> To create an empty array, we use the
		following initializer syntax:
	</p>
	<pre class="language-swift"><code>
		var studentList: [String] = []
	</code></pre>
	<p>Notice the general form:</p>

	<figure class="math-display">
		<ul class="syntax">
			<li>var ${n}$: [${t}$] = []</li>
		</ul>
		<ul class="def">
			<li class="where">${n}$ is the array's name; and</li>
			<li>${t}$ is the type for each value in the array</li>
		</ul>
	</figure>

	<p>
		If type can be inferred, we can create the empty array with just square
		brackets:
	</p>
	<pre class="language-swift"><code>
		var myArray = []
	</code></pre>

	<p>
		<span class="topic">Array Methods.</span> Swift provides numerous build-in
		methods for operating on arrays. Here are a few:
	</p>

	<figure class="table">
		<table class="truth_table">
			<thead>
				<th>methods/operations</th>
				<th>operation</th>
				<th>comment</th>
			</thead>
			<tbody>
				<tr>
					<td><span class="monoText redText">${arr}$.append(${v}$)</span></td>
					<td>Inserts at the array ${arr}$'s end the value ${v}$</td>
					<td>Return is a mutated array; ${arr}$ must be a var.</td>
				</tr>
				<tr>
					<td>
						<span class="monoText redText"
							>${arr}$.insert(${v}$, at: ${n}$)</span
						>
					</td>
					<td>Insert the value ${v}$ at the index ${n}$</td>
					<td>Return is a mutated array; ${arr}$ must be a var.</td>
				</tr>
				<tr>
					<td>
						<span class="monoText redText">${arr}$.remove(at: ${n}$)</span>
					</td>
					<td>Removes the element at index ${n}$</td>
					<td>Return is the removed element; ${arr}$ must be a var.</td>
				</tr>
				<tr>
					<td><span class="monoText redText">${arr}$.removeLast()</span></td>
					<td>Removes the last element of ${arr}$</td>
					<td>Return is the removed element; ${arr}$ must be a var.</td>
				</tr>
				<tr>
					<td><span class="monoText redText">${arr}$.removeAll()</span></td>
					<td>Removes all elements inside the array</td>
					<td>${arr}$ must be a var.</td>
				</tr>
				<tr>
					<td><span class="monoText redText">${arr}$.isEmpty</span></td>
					<td>Is this array empty?</td>
					<td>Returns Boolean type value: true or false.</td>
				</tr>
				<tr>
					<td><span class="monoText redText">${arr}$.count</span></td>
					<td>How many elements are in this array?</td>
					<td>
						Returns an Int type value: The length/size of the array; how many
						elements are in the array.
					</td>
				</tr>
				<tr>
					<td><span class="monoText redText">${arr}$.first</span></td>
					<td>What is the first element in this array?</td>
					<td>
						Returns the element at the head of the array (equivalent to hd in
						Scheme and ML). The return type is an Optional, so it must be safely
						unwrapped before use.
					</td>
				</tr>
				<tr>
					<td><span class="monoText redText">${arr}$.contains(${v}$)</span></td>
					<td>Is the value ${v}$ inside this array?</td>
					<td>
						Returns a Boolean type value: true if ${v}$ is inside the array,
						else false.
					</td>
				</tr>
				<tr>
					<td><span class="monoText redText">${arr_0}$ += ${arr_1}$</span></td>
					<td>merges ${arr_0}$ and ${arr_1}$ into a single array</td>
					<td>
						Mutates ${arr_0}$ into a new array where the elements of ${arr_1}$
						are inserted to the tail of ${arr_0.}$ ${arr_1}$ is not mutated.
						Cannot merge arrays of different types.
					</td>
				</tr>
				<tr>
					<td><span class="monoText redText">${arr}$[${n}$]</span></td>
					<td>Returns the element of ${arr}$ at index ${n.}$</td>
					<td>
						Referencing an index greater than the length of the array will
						return an index-out-of-range error. (In Swift, the range of an array
						refers to the range of the indices).
					</td>
				</tr>
				<tr>
					<td><span class="monoText redText">${arr}$[${i_0...i_n}$]</span></td>
					<td>
						Returns an <span class="term">array slice</span> consisting of the
						elements of ${arr}$ with indices from ${i_0}$ to ${i_n}$
					</td>
					<td>
						Return is an array slice, which is a stored reference to a part of
						${arr.}$ This means the indices of the elements in the array slice
						are their indices in ${arr.}$
					</td>
				</tr>
				<tr>
					<td>
						<span class="monoText redText">Array(${arr}$[${i_0...i_n}$])</span>
					</td>
					<td>
						Returns a new array consisting of the elements of ${arr}$ with
						indices from ${i_0}$ to ${i_n}$
					</td>
					<td>
						Unlike the array slice, this returns a new array, with elements
						having indices starting from 0.
					</td>
				</tr>
				<tr>
					<td><span class="monoText redText">${arr.}$max()</span></td>
					<td>Returns the largest/maximum element in the array</td>
					<td>Return type is an Optional, must safely unwrap before use.</td>
				</tr>
				<tr>
					<td><span class="monoText redText">${arr.}$min()</span></td>
					<td>Returns the smallest/minimum element in the array</td>
					<td>Return type is an Optional, must safely unwrap before use.</td>
				</tr>
				<tr>
					<td><span class="monoText redText">${arr.}$sort()</span></td>
					<td>Returns elements of array sorted in place</td>
					<td>Mutates the array</td>
				</tr>
				<tr>
					<td><span class="monoText redText">${arr.}$sorted()</span></td>
					<td>Returns elements of array sorted</td>
					<td>Does not mutate the array</td>
				</tr>
				<tr>
					<td><span class="monoText redText">${arr.}$reverse()</span></td>
					<td>Reverses the elements of the array in place</td>
					<td>Mutates the array.</td>
				</tr>
				<tr>
					<td><span class="monoText redText">${arr.}$reversed()</span></td>
					<td>Returns elements of array reversed</td>
					<td>Does not mutate the array</td>
				</tr>
				<tr>
					<td>
						<span class="monoText redText"
							>${arr.}$swapAt(${n_0}$, ${n_1}$)</span
						>
					</td>
					<td>Swaps the elements at ${n_0}$ and ${n_1}$</td>
					<td>Mutates the array</td>
				</tr>
			</tbody>
		</table>
	</figure>
</section>

<section id="array_runningTime">
	<h4>Runtime: Arrays</h4>
	<p>
		Arrays are the simplest data structure. A single array is stored as a
		contiguous block in memory, and this has a large impact on the runtime for
		certain operations.
	</p>
	<p>
		<span class="topic">Accessing a Particular Element.</span> Accessing
		elements in an array is very low cost. Given some array ${A,}$ accessing
		<span class="monoText">${A}$[${n}$]</span> has a complexity of ${O(1).}$
		This is because Swift just takes one step &mdash; go to the element ${n.}$
	</p>
	<p>
		<span class="topic">Inserting Elements.</span> Inserting elements has
		varying complexities, largely dependant on where in the array we want to
		insert the new element. If we add to the array's head, then Swift must shift
		all of the array's elements over by one to make room. And since Swift can
		only shift one element at a time, the number of steps it takes is ${n,}$
		where ${n}$ is the number of existing elements in the array. Thus, inserting
		an element to the head has a complexity of ${O(n).}$
	</p>
	<p>
		Similarly, if we want to insert an element to the middle of the array, Swift
		must shift ${n/2}$ elements. In terms of complex, the ${\frac{1}{2}}$ is
		just a constant (${n/2 = \frac{1}{2}(n)}$), so we can factor it out, leaving
		us with a complexity of ${O(n.)}$
	</p>
	<p>
		In contrast, if we want to insert an element to the tail of the array, then
		Swift doesn't have to shift any elements. Assuming the array has enough room
		&mdash; which is usually the case &mdash; then Swift only takes on step: add
		it to the end. This is a complexity of ${O(1).}$
		<span class="marginnote"
			>In the case where there isn't enough room in the existing array, then
			Swift must make a copy of the array before inserting the new element.
			Copying the array requires individually copying each of the elements,
			leaving a complexity of ${O(n).}$</span
		>
	</p>
	<p>
		<span class="topic">Removing Elements.</span> Like insertion, removing an
		element in the array depends on which element we are removing. When we
		remove an element, Swift must shift all the remaining elements to fill in
		the empty position. Thus, if we remove an element from anywhere but the
		tail, we have a complexity of ${O(n).}$ If we remove an element from the
		tail, then no shifting is needed, and the complexity is constant time,
		${O(1).}$
	</p>
</section>

<section id="dictionaries">
	<h3>Dictionaries</h3>
	<p>
		In Swift and most other languages, a <span class="term">dictionary</span> is
		an unordered collection of key-value pairs. Dictionaries useful when we want
		to access a value by means of an <span class="term">identifier</span>. For
		example, we might have the following key-value pairs:
	</p>

	<figure class="math-display">
		<ul class="syntax">
			<li>[</li>
			<ul>
				<li>"gold" : "Au"</li>
				<li>"sodium" : "Na"</li>
				<li>"copper" : "Cu"</li>
				<li>"hydrogen" : "H"</li>
			</ul>
			<li>]</li>
		</ul>
	</figure>

	<p>
		In Swift, dictionary keys must be unique. For example, in the dictionary
		above, we would not be able to have two keys named
		<span class="monoText">"Copper"</span> (Swift wouldn't be able to tell which
		one we're referring to). However, different keys can point to the same value
		(in other words, the same value can appear in multiple keys). For example:
	</p>

	<figure class="math-display">
		<ul class="syntax">
			<li>[</li>
			<ul>
				<li>"rice" : "available"</li>
				<li>"corn" : "unavailable"</li>
				<li>"wheat" : "available"</li>
				<li>"lentils" : "unavailable"</li>
			</ul>
			<li>]</li>
		</ul>
	</figure>

	<p>
		Unlike some languages, all the keys in a dictionary
		<span class="underlineText">must</span> be the same type. We cannot have
		some keys with a <span class="monoText">String</span> type and others an
		<span class="monoText">Int</span> type. The same goes for the values. We
		cannot have some values of type <span class="monoText">Int</span> and other
		values of type <span class="monoText">Bool</span>. You can, however, have
		keys of one type, and values of another type. For example, keys of type
		<span class="monoText">String</span>, paired to values of type
		<span class="monoText">Double</span>.
	</p>

	<p>
		These rules demonstrate several crucial differences between dictionaries and
		arrays. With dictionaries, we access values by referencing their paired key.
		Those keys can be of any type, and they inherently have no order. With
		arrays, we access values by index, and all indices are of type
		<span class="monoText">Int</span>. Furthermore, the indices start from 0 and
		are sequential &mdash; there is an inherent order. The general syntax for a
		dictionary:
	</p>

	<figure class="math-display">
		<ul class="syntax">
			<li>[</li>
			<ul>
				<li>${key_0}$ : ${val_0}$,</li>
				<li>${\vdots}$,</li>
				<li>${key_n}$ : ${val_n}$</li>
			</ul>
			<li>]</li>
		</ul>
	</figure>

	<p>Let's see what the data type is for a dictionary:</p>

	<pre class="language-swift"><code>
		var alphabet = [
			0: "a",
			1: "b",
			2: "c",
			3: "d"
		]
		print(type(of: alphabet))
	</code></pre>
	<pre class="language-bash"><code>
		Dictionary&lt;Int, String&gt;
	</code></pre>

	<p>
		A dictionary has the type
		<span class="monoText">Dictionary&lt;Int, String&gt;</span>. We can add to
		the dictionary with the following:
	</p>

	<pre class="language-swift"><code>
		var studentMajors = [
			"Immanuel Kant": "philosophy",
			"Maurits Cornelis Escher": "art",
			"Evariste Galois": "mathematics"
		]

		studentMajors["Roger Ebert"] = "film"
	</code></pre>
	<pre class="language-bash"><code>
		["Evariste Galois": "mathematics", "Immanuel Kant": "philosophy", "Maurits Cornelis Escher": "art", "Roger Ebert": "film"]
	</code></pre>

	<p>
		Swift provides numerous methods and operations we can use on dictionaries:
	</p>

	<figure class="table">
		<table class="truth_table">
			<thead>
				<th>operator</th>
				<th>operation</th>
				<th>comment</th>
			</thead>
			<tbody>
				<tr>
					<td>
						<span class="monoText"
							>${d}$.updateValue(${n}$, forKey: ${k}$)</span
						>
					</td>
					<td>Updates the value paired to key ${k}$ with the value ${n}$</td>
					<td></td>
				</tr>
				<tr>
					<td><span class="monoText">${d}$[${k}$] = ${n}$</span></td>
					<td>
						The same operation as the previous; updates/replaces the value
						paired with ${k}$ with the value ${n}$
					</td>
					<td></td>
				</tr>
				<tr>
					<td><span class="monoText">${d}$[${k}$]</span></td>
					<td>Evaluates to the value paired with the key ${k}$</td>
					<td>
						Return type is an <span class="underlineText">optional</span>; must
						unwrap for use
					</td>
				</tr>
				<tr>
					<td><span class="monoText">${d}$.isEmpty</span></td>
					<td>Does the dictionary contain any key-value pairs?</td>
					<td>Return type is a Bool</td>
				</tr>
				<tr>
					<td><span class="monoText">${d}$.count</span></td>
					<td>How many key-value pairs are in the dictionary?</td>
					<td>Return type is an Int</td>
				</tr>
				<tr>
					<td>
						<span class="monoText">${d}$.removeValue(forKey: ${k}$)</span>
					</td>
					<td>Removes the value ${v}$ paired with the key ${k}$</td>
					<td>
						Return type is an Optional<${t_v}$>, where ${t_v}$ is the type of
						the value removed; this mutates the dictionary
					</td>
				</tr>
				<tr>
					<td><span class="monoText">${d}$[${k}$] = nil</span></td>
					<td>
						Removes the key-value pair with the key ${k}$ in the dictionary
					</td>
					<td>
						No return type; mutates the dictionary by removing the key-value
						pair with the key ${k}$
					</td>
				</tr>
				<tr>
					<td colspan="3"><sup>*</sup>where ${d}$ is the dictionary's name</td>
				</tr>
			</tbody>
		</table>
	</figure>

	<p>
		<span class="topic">Looping through a Dictionary.</span> Another critical
		difference between arrays and dictionaries is that we do not get an
		out-of-bounds error when we ask for the value associated with a key that
		does not exist. Importantly, you
		<span class="underlineText">cannot</span> have a key in a dictionary that is
		not paired with a value. In other words, every key we write in the
		dictionary <span class="underlineText">must</span> have a value paired with
		it. If the key doesn't exist, the dictionary simply returns
		<span class="monoText">nil</span>. This is a helpful feature in Swift to
		keep in mind when we attempt to loop through a dictionary.
	</p>

	<p>
		Just like arrays, we can in fact loop through a dictionary. But instead of
		just returning the value, the loop will return the key-value pair. This
		key-value pair is actually a <span class="italicsText">tuple</span>. So, for
		example:
	</p>

	<pre class="language-swift"><code>
		var chemicalSymbols = [
			"gold" : "Au",
			"sodium": "Na",
			"copper": "Cu"
		]
		print(chemicalSymbols["gold"])
		print(chemicalSymbols["Oxygen"])
	</code></pre>
	<pre class="language-bash"><code>
		Optional("Au")
		nil
	</code></pre>

	<p>Looping through dictionaries is straightforward and clear:</p>

	<pre class="language-swift"><code>
		var chemicalSymbols = [
			"gold" : "Au",
			"sodium": "Na",
			"copper": "Cu"
		]

		for (chemical, chemSymbol) in chemicalSymbols {
			print("\(chemical) has the symbol \(chemSymbol).")
		}
	</code></pre>
	<pre class="language-bash"><code>
		gold has the symbol Au.
		copper has the symbol Cu.
		sodium has the symbol Na.
	</code></pre>

	<p>
		The keys and the values of a dictionary are called the dictionaries
		<span class="term">properties</span>. Swift allows us to iterate through
		either of these properties. As in most other languages, we reference these
		properties with <span class="italicsText">dot notation</span>. For example,
		suppose we want to iterate through the keys in our example dictionary:
	</p>

	<pre class="language-swift"><code>
		var chemicalSymbols = [
			"gold" : "Au",
			"sodium": "Na",
			"copper": "Cu"
		]
		for chemical in chemicalSymbols.keys {
			print(chemical)
		}
	</code></pre>
	<pre class="language-bash"><code>
		gold
		sodium
		copper
	</code></pre>

	<p>And if we want to iterate through the values:</p>

	<pre class="language-swift"><code>
		var chemicalSymbols = [
			"gold" : "Au",
			"sodium": "Na",
			"copper": "Cu"
		]
		for chemicalSymbol in chemicalSymbols.values {
			print(chemicalSymbol)
		}
	</code></pre>
	<pre class="language-bash"><code>
		Cu
		Au
		Na
	</code></pre>

	<p>
		<span class="topic">Empty Dictionary.</span> To create an empty dictionary,
		we use the same initializer syntax:
	</p>

	<pre class="language-swift"><code>
		var studentMajors: [String: String] = [:]
	</code></pre>

	<p>The general syntax:</p>

	<figure class="math-display">
		<ul class="syntax">
			<li>var ${n}$: [${k_{t}}$ : ${v_{t}}$] = [:]</li>
		</ul>
		<ul class="def">
			<li class="where">${n}$ is the dictionary's name,</li>
			<li>${k_t}$ is the key's type, and</li>
			<li>${v_t}$ is the value's type</li>
		</ul>
	</figure>

	<p>
		Like arrays, if type can be inferred, we can create the empty dictionary
		with just square brackets and a colon:
	</p>

	<pre class="language-swift"><code>
		var myDictionary = [:]
	</code></pre>
</section>

<section id="dictionary_runtime">
	<h4>Runtime: Dictionaries</h4>
	<p>
		To understand the complexities for operations on dictionaries, we must
		briefly discuss how dictionaries actually work. Unlike arrays, dictionaries
		are not created by simply storing values in a contiguous region of memory.
		Instead, dictionaries require <span class="term">hashing</span>. <a href="{% url 'numerc:cpp_hashing' %}"><span class="italicsText">See</span> Part V: Hashing (explaining the details of Hashing in C++).</a>
	</p>

	<p>
		In dictionaries, the value to be hashed is the key. And to be hashed, the
		key must be <span class="term">hashable</span>.
	</p>
</section>
{% endblock %}
