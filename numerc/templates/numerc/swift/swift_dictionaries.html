{% extends '../layout.html' %} {% load static %} {% block content %}
<section id="dictionaries">
	<h4>Dictionaries</h4>
	<p>
		In Swift and most other languages, a <span class="term">dictionary</span> is
		an unordered collection of key-value pairs. Dictionaries useful when we want
		to access a value by means of an <span class="term">identifier</span>. For
		example, we might have the following key-value pairs:
	</p>

	<figure class="math-display">
		<ul class="syntax">
			<li>[</li>
			<ul>
				<li>"gold" : "Au"</li>
				<li>"sodium" : "Na"</li>
				<li>"copper" : "Cu"</li>
				<li>"hydrogen" : "H"</li>
			</ul>
			<li>]</li>
		</ul>
	</figure>

	<p>
		In Swift, dictionary keys must be unique. For example, in the dictionary
		above, we would not be able to have two keys named
		<span class="monoText">"Copper"</span> (Swift wouldn't be able to tell which
		one we're referring to). However, different keys can point to the same value
		(in other words, the same value can appear in multiple keys). For example:
	</p>

	<figure class="math-display">
		<ul class="syntax">
			<li>[</li>
			<ul>
				<li>"rice" : "available"</li>
				<li>"corn" : "unavailable"</li>
				<li>"wheat" : "available"</li>
				<li>"lentils" : "unavailable"</li>
			</ul>
			<li>]</li>
		</ul>
	</figure>

	<p>
		Unlike some languages, all the keys in a dictionary
		<span class="underlineText">must</span> be the same type. We cannot have
		some keys with a <span class="monoText">String</span> type and others an
		<span class="monoText">Int</span> type. The same goes for the values. We
		cannot have some values of type <span class="monoText">Int</span> and other
		values of type <span class="monoText">Bool</span>. You can, however, have
		keys of one type, and values of another type. For example, keys of type
		<span class="monoText">String</span>, paired to values of type
		<span class="monoText">Double</span>.
	</p>

	<p>
		These rules demonstrate several crucial differences between dictionaries and
		arrays. With dictionaries, we access values by referencing their paired key.
		Those keys can be of any type, and they inherently have no order. With
		arrays, we access values by index, and all indices are of type
		<span class="monoText">Int</span>. Furthermore, the indices start from 0 and
		are sequential &mdash; there is an inherent order. The general syntax for a
		dictionary:
	</p>

	<figure class="math-display">
		<ul class="syntax">
			<li>[</li>
			<ul>
				<li>${key_0}$ : ${val_0}$,</li>
				<li>${\vdots}$,</li>
				<li>${key_n}$ : ${val_n}$</li>
			</ul>
			<li>]</li>
		</ul>
	</figure>

	<p>Let's see what the data type is for a dictionary:</p>

	<pre class="language-swift"><code>
		var alphabet = [
			0: "a",
			1: "b",
			2: "c",
			3: "d"
		]
		print(type(of: alphabet))
	</code></pre>
	<pre class="language-bash"><code>
		Dictionary&lt;Int, String&gt;
	</code></pre>

	<p>
		A dictionary has the type
		<span class="monoText">Dictionary&lt;Int, String&gt;</span>. We can add to
		the dictionary with the following:
	</p>

	<pre class="language-swift"><code>
		var studentMajors = [
			"Immanuel Kant": "philosophy",
			"Maurits Cornelis Escher": "art",
			"Evariste Galois": "mathematics"
		]

		studentMajors["Roger Ebert"] = "film"
	</code></pre>
	<pre class="language-bash"><code>
		["Evariste Galois": "mathematics", "Immanuel Kant": "philosophy", "Maurits Cornelis Escher": "art", "Roger Ebert": "film"]
	</code></pre>

	<p>
		Swift provides numerous methods and operations we can use on dictionaries:
	</p>

	<figure class="table">
		<table class="truth_table">
			<thead>
				<th>operator</th>
				<th>operation</th>
				<th>comment</th>
			</thead>
			<tbody>
				<tr>
					<td>
						<span class="monoText redText"
							>${d}$.updateValue(${n}$, forKey: ${k}$)</span
						>
					</td>
					<td>Updates the value paired to key ${k}$ with the value ${n}$</td>
					<td></td>
				</tr>
				<tr>
					<td><span class="monoText redText">${d}$[${k}$] = ${n}$</span></td>
					<td>
						The same operation as the previous; updates/replaces the value
						paired with ${k}$ with the value ${n}$
					</td>
					<td></td>
				</tr>
				<tr>
					<td><span class="redText">${d}$[${k}$]</span></td>
					<td>Evaluates to the value paired with the key ${k}$</td>
					<td>
						Return type is an <span class="underlineText">optional</span>; must
						unwrap for use
					</td>
				</tr>
				<tr>
					<td><span class="redText">${d}$.isEmpty</span></td>
					<td>Does the dictionary contain any key-value pairs?</td>
					<td>Return type is a Bool</td>
				</tr>
				<tr>
					<td><span class="redText">${d}$.count</span></td>
					<td>How many key-value pairs are in the dictionary?</td>
					<td>Return type is an Int</td>
				</tr>
				<tr>
					<td><span class="redText">${d}$.removeValue(forKey: ${k}$)</span></td>
					<td>Removes the value ${v}$ paired with the key ${k}$</td>
					<td>
						Return type is an Optional<${t_v}$>, where ${t_v}$ is the type of
						the value removed; this mutates the dictionary
					</td>
				</tr>
				<tr>
					<td><span class="redText">${d}$[${k}$] = nil</span></td>
					<td>
						Removes the key-value pair with the key ${k}$ in the dictionary
					</td>
					<td>
						No return type; mutates the dictionary by removing the key-value
						pair with the key ${k}$
					</td>
				</tr>
				<tr>
					<td colspan="3"><sup>*</sup>where ${d}$ is the dictionary's name</td>
				</tr>
			</tbody>
		</table>
	</figure>

	<p>
		<span class="topic">Looping a Dictionary.</span> Another critical difference
		between arrays and dictionaries is that we do not get an out-of-bounds error
		when we ask for the value associated with a key that does not exist.
		Importantly, you <span class="underlineText">cannot</span> have a key in a
		dictionary that is not paired with a value. In other words, every key we
		write in the dictionary <span class="underlineText">must</span> have a value
		paired with it. If the key doesn't exist, the dictionary simply returns
		<span class="monoText">nil</span>. This is a helpful feature in Swift to
		keep in mind when we attempt to loop through a dictionary.
	</p>

	<p>
		Just like arrays, we can in fact loop through a dictionary. But instead of
		just returning the value, the loop will return the key-value pair. This
		key-value pair is actually a <span class="italicsText">tuple</span>. So, for
		example:
	</p>

	<pre class="language-swift"><code>
		var chemicalSymbols = [
			"gold" : "Au",
			"sodium": "Na",
			"copper": "Cu"
		]
		print(chemicalSymbols["gold"])
		print(chemicalSymbols["Oxygen"])
	</code></pre>
	<pre class="language-bash"><code>
		Optional("Au")
		nil
	</code></pre>

	<p>Looping through dictionaries is straightforward and clear:</p>

	<pre class="language-swift"><code>
		var chemicalSymbols = [
			"gold" : "Au",
			"sodium": "Na",
			"copper": "Cu"
		]

		for (chemical, chemSymbol) in chemicalSymbols {
			print("\(chemical) has the symbol \(chemSymbol).")
		}
	</code></pre>
	<pre class="language-bash"><code>
		gold has the symbol Au.
		copper has the symbol Cu.
		sodium has the symbol Na.
	</code></pre>

	<p>
		The keys and the values of a dictionary are called the dictionaries
		<span class="term">properties</span>. Swift allows us to iterate through
		either of these properties. As in most other languages, we reference these
		properties with <span class="italicsText">dot notation</span>. For example,
		suppose we want to iterate through the keys in our example dictionary:
	</p>

	<pre class="language-swift"><code>
		var chemicalSymbols = [
			"gold" : "Au",
			"sodium": "Na",
			"copper": "Cu"
		]
		for chemical in chemicalSymbols.keys {
			print(chemical)
		}
	</code></pre>
	<pre class="language-bash"><code>
		gold
		sodium
		copper
	</code></pre>

	<p>And if we want to iterate through the values:</p>

	<pre class="language-bash"><code>
		var chemicalSymbols = [
			"gold" : "Au",
			"sodium": "Na",
			"copper": "Cu"
		]
		for chemicalSymbol in chemicalSymbols.values {
			print(chemicalSymbol)
		}
	</code></pre>
	<pre class="language-bash"><code>
		Cu
		Au
		Na
	</code></pre>

	<p>
		<span class="topic">Empty Dictionary.</span> To create an empty dictionary,
		we use the same initializer syntax:
	</p>

	<pre class="language-swift"><code>
		var studentMajors: [String: String] = [:]
	</code></pre>

	<p>The general syntax:</p>

	<figure class="math-display">
		<ul class="syntax">
			<li>var ${n}$: [${k_{t}}$ : ${v_{t}}$] = [:]</li>
		</ul>
		<ul class="def">
			<li class="where">${n}$ is the dictionary's name,</li>
			<li>${k_t}$ is the key's type, and</li>
			<li>${v_t}$ is the value's type</li>
		</ul>
	</figure>

	<p>
		Like arrays, if type can be inferred, we can create the empty dictionary
		with just square brackets and a colon:
	</p>

	<pre class="language-swift"><code>
		var myDictionary = [:]
	</code></pre>
</section>
{% endblock %}
