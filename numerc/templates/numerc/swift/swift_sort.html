{% extends '../layout.html' %} {% load static %} {% block content %}
<section id="sort">
	<h4>Sort</h4>
	<p>
		Sorting algorithms can be cumbersome to implement, and for most
		applications, Swift's built-in sort method can handle our needs easily. As
		such, for most tasks, we won't need to write our own sorting algorithms
		(most &mdash; there are situations where Swift's algorithms may not be the
		best). To use Swift's <span class="monoText">.sort</span> method, we must
		include a closure. That closure tells Swift how the elements in the
		collection should be compared.
	</p>

	<p>
		Swift provides several sorting methods. The
		<span class="monoText">.sort()</span> method will sort elements
		<span class="underlineText">in place</span>. This means
		<span class="monoText">.sort()</span> will mutate the existing collection.
	</p>

	<pre class="language-swift"><code>
		var names = ["Dan", "Alice", "Jane", "Fen"]
		names.sort()
		print(names)
	</code></pre>
	<pre class="language-bash"><code>
		["Alice", "Dan", "Fen", "Jane"]
	</code></pre>

	<p>
		If we want to sort the elements in a particular way, we pass into the
		parameter list a closure:
	</p>

	<pre class="language-swift"><code>
		var names = ["Dan", "Alice", "Jane", "Fen"]
		names.sort {(a, b) -> Bool in a > b}
		print(names)
	</code></pre>
	<pre class="language-bash"><code>
		["Jane", "Fen", "Dan", "Alice"]
	</code></pre>

	<p>
		If we want to create a new sorted array (i.e., not mutating the existing
		array), we used the <span class="monoText">.sorted()</span> method. Suppose
		we wanted to sort the names from longest to shortest:
	</p>

	<pre class="language-swift"><code>
		var names = ["Dan", "Alice", "Jane", "Fen"]
		var newArr = names.sorted { $0.count > $1.count }
		print(newArr)
	</code></pre>
	<pre class="language-bash"><code>
		["Alice", "Jane", "Dan", "Fen"]
	</code></pre>
</section>
{% endblock %}
