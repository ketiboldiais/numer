{% extends '../layout.html' %} {% load static %} {% block content %}
<section id="closures">
	<h4>Closures</h4>
	<p>
		Functions are a subset of <span class="term">closures</span>. Recall our two
		functions, <span class="monoText">add()</span> and
		<span class="monoText">minus()</span>. These functions can be assigned to a
		variable and passed arguments:
	</p>

	<pre class="language-swift"><code>
		func add(n: Int, m: Int) -> Int {
			n + m
		}
		func minus(n: Int, m: Int) -> Int {
			n - m
		}
		var sum = add
		var diff = minus

		// returns 3
		add(n:1, m:2) 
		sum(1, 2)

		// returns 1
		minus(n:3, m:2) 
		diff(3, 2)
	</code></pre>

	<p>
		Calling the function directly or by way of a variable returns the same
		result. However, notice that when we use variables, we do not need to
		include the argument labels. This is because the variable is actually a
		<span class="term">closure</span>. Let's rewrite the
		<span class="monoText">add()</span> function in closure form:
	</p>

	<pre class="language-swift"><code>
		var plus:(Int,Int) -> Int = { (a:Int,b:Int) -> Int in a+b }
		plus(3,2) // returns 5
	</code></pre>

	<p>
		With closures, we cannot include argument labels, nor we can use default
		values. For those abilities, we must use a function. Question: When should
		we use closures? Closures are best used when we want to execute some custom
		operation exactly once. In other words, situations where we want to write
		some code that appears like a function (i.e., takes inputs and returns an
		output) but does not need to be reused (recall that functions should be used
		as much as possible because of reusability).
	</p>

	<p>There are multiple ways to write closures in Swift:</p>

	<pre class="language-swift"><code>
		typealias IntOp = (Int,Int) -> Int

		// long form
		let foo:IntOp = { (a:Int, b:Int) -> Int in a*b }

		// no parameter types
		let baz:IntOp = {(a,b) -> Int in a*b}

		// no return type
		let bop:IntOp = {(a,b) in a*b}

		// short form
		let lar:IntOp = { $0 * $1 }
	</code></pre>

	<p>
		We can also write closures (and functions) that take no arguments and return
		nothing. With functions, these are called
		<span class="term">void functions</span>, and with closures, they are called
		<span class="term">void closures</span>:
	</p>

	<pre class="language-swift"><code>
		let greetWorld: ()->Void = { ()->Void in print("Hello, world!") }
		greetWorld()
	</code></pre>

	<p>
		The type <span class="monoText">Void</span> is actually a type alias for
		<span class="monoText">()</span>. Thus, the same function above can be
		written as:
	</p>

	<pre class="language-swift"><code>
		let greetWorld: ()->() = { ()->() in print("Hello, world!") }
		greetWorld()
	</code></pre>

	<p>But, we cannot write this:</p>

	<pre class="language-swift"><code>
		let greetWorld: Void->Void = { Void->Void in print("Hello, world!") }
		greetWorld()
	</code></pre>

	<p>Why? Because parameters must always be placed in parentheses.</p>

	<p>
		<span class="topic">Trailing Closures.</span> One coding style we'll often
		see in Swift development is the trailing closure. Consider this code:
	</p>
	<pre class="language-swift"><code>
		typealias IntOp = (Int,Int) -> Int
		func printr(_ a:Int, _ b:Int, _ operate: IntOp) {
			print(operate(a, b))
		}

		// inline closure
		printr(1, 2, {$0 * $1 + 3}) // returns (1*2+3) -> 5

		// trailing closure
		printr(2, 3) {$0 * $1 + 3} // returns (2*3+3) -> 9
	</code></pre>

	<p>
		The trailing closure syntax can only be used if the the closure is the last
		argument to be passed. Otherwise, we must use the typical inline closure
		syntax.
	</p>
</section>
{% endblock %}
