{% extends '../layout.html' %} {% load static %} {% block description %}
<meta
	name="description"
	content="Getting started with Haskell; Haskell basics"
/>
{% endblock %} {% block title %}
<title>Haskell: Getting Started</title>
{% endblock %} {% block content %}
<h1>Basic Data</h1>
<section id="start">
	<p>
		In this article, we'll learn the basic constructs for writing Haskell
		programs. This article assumes familiarity with at least 2 languages, so we
		will go through the constructs and common programming idioms fairly quickly.
		This is done for the sake of expediency; the interesting parts of Haskell
		aren't so much its syntax or lexicon, but what it can do and the ideas it
		represents.
	</p>
</section>

<section id="getting_started">
	<h2>Getting Started</h2>
	<p>
		The first step to using Haskell is to
		<a href="https://www.haskell.org/downloads/" target="_blank"
			>install the Haskell compiler</a
		>. Compiler installed, we'll create a new file called
		<span class="monoText">lab.hs</span>. As we can probably tell, Haskell files
		use the extension <span class="monoText">.hs</span>. To compile and execute
		<span class="monoText">main.hs</span>, we write in our terminal:
	</p>
	<pre class="language-bash"><code>
		ghc lab.hs
		./main
	</code></pre>
	<p>
		Haskell also has a REPL called <span class="monoText">GHCi</span>. To use
		the REPL, we write:
	</p>
	<pre class="language-bash"><code>
		ghci
		Prelude> :l lab.hs
		*Main>
	</code></pre>
	<p>
		This will load <span class="monoText">lab.hs</span> into the REPL, allowing
		us to use everything inside <span class="monoText">lab.hs</span>. To run
		<span class="monoText">lab.hs</span>, we will simply write:
	</p>
	<pre class="language-bash"><code>
		ghci
		Prelude> :l lab.hs
		*Main> :r
	</code></pre>
	<p>
		As we can tell from these commands, <span class="monoText">:l</span> is an
		instruction to <span class="italicsText">load</span>
		<span class="monoText">lab.hs</span>, and
		<span class="monoText">:r</span> is an instruction to
		<span class="italicsText">run</span> <span class="monoText">lab.hs</span>.
	</p>
	<section id="comments">
		<p>
			<span class="topic">Comments.</span> As with any other language, the first
			construct we should learn is how to comment. Haskell supports both single
			and multiline comments:
		</p>
		<pre class="language-haskell"><code>
			-- Single line comments are indicated with two dashes
			
			{-
				Multiline comments start with an 
				open curly-brace followed by a dash
				And end with a 
				dash followed by a closed curly-brace
			-}
		</code></pre>
	</section>
	<p>
		All that said, here's a simple Haskell program. First, we'll create a file
		called <var>hello.hs</var>. The extension <var>.hs</var> indicates a Haskell
		source code file. Inside <var>hello.hs</var>, we write:
	</p>
	<pre class="language-haskell"><code>
		greet :: String -> IO ()
		greet x =
			putStrLn("Hello," ++ x ++ "!")
	</code></pre>
	<p>
		Similar to ML, the syntax <var>::</var> indicates a type signature. In this
		case, <var>greet</var> has the type <var>String -> IO ()</var>. If we load
		the file in the REPL:
	</p>
	<pre class="language-bash" data-output="3"><code>
		> load hello.hs
		> greet "world"
		Hello, world!
	</code></pre>
</section>

<section id="expressions">
	<h2>Expressions</h2>
	<p>Everything we write in Haskell is one of two entities:</p>
	<figure>
		<ol>
			<li>An expression, or</li>
			<li>A declaration</li>
		</ol>
	</figure>
	<p>
		An <b>expressiong</b> is a sequence is a sequence of symbols that evaluates
		to a result. A <b>declaration</b> is a top-level binding that allows us to
		<i>name</i> expressions. Names, or <i>identifiers</i>, can then be used
		later in our programs to refer to their associated expressions.
	</p>
	<p>
		Expressions are in <b>normal form</b> when no further evaluation steps can
		be taken. For example, the expression <var>1</var> is in normal form. The
		expression <var>2 + 2</var> is not &mdash; its normal form is <var>4</var>.
		An expression like <var>2 + 2</var> is one where further evaluation steps
		can made. Such expressions are said to <b>redexes</b> (<q
			>reducible expressions</q
		>).<sup></sup>
	</p>
	<div class="note">
		<p>
			The process of evaluating an expression to normal form has many names
			&mdash; <q>normalizing,</q> <q>executing,</q> <q>reducing</q>,
			<q>evaluating,</q> &mdash; they all refer to the process of taking a redex
			and boiling it down to a normal expression.
		</p>
	</div>
</section>

<section id="functions">
	<h2>Functions</h2>
	<p>
		The most basic unit in a Haskell program is the <b>function</b> &mdash; an
		expression which, when applied to an argument, returns a result. Unlike
		other languages, functions in Haskell <em>always</em> return the same values
		for a given input. No side effects here. Moreover, Haskell functions only
		take <em>one</em> argument, and only return <em>one</em> result.
	</p>
	<p>
		Here's a simple function in a Haskell source file, call it
		<var>foo.hs</var>:
	</p>
	<pre class="language-haskell"><code>
		double x = x * 2;
	</code></pre>
	<p>Let's dissect the line above. First:</p>
	<pre class="language-pseudo"><code>
		<span class="redText">double</span> x = x * 2
	</code></pre>
	<p>
		The symbol <var>double</var> is the function's name. We call this a
		<b>function declaration</b>. Importantly, function declarations and variable
		names in Haskell must begin with a lowercase letter.<sup></sup>
	</p>
	<div class="note">
		<p>In Haskell, the naming convention is <i>camelCasing</i>.</p>
	</div>
	<p>Next:</p>
	<pre class="language-pseudo"><code>
		double <span class="redText">x</span> = x * 2
	</code></pre>
	<p>
		This is the function's <b>parameter</b>. In terms of lambda calculus, the
		function's parameter corresponds to a lambda's head. It binds the variables
		that appear in the body expression.
	</p>
	<p>Then we have the equal sign:</p>
	<pre class="language-pseudo"><code>
		double x <span class="redText">=</span> x * 2
	</code></pre>
	<p>
		The equal sign has a special meaning in Haskell. It is dedicated to
		defining, or declaring, values and functions. It does <em>not</em> denote
		equality.
	</p>
	<p>Finally, we have the function's <b>body</b>:</p>
	<pre class="language-javascript"><code>
		double x = <span class="redText">x * 2</span>
	</code></pre>
	<p>
		When <var>double</var> applies to argument, the argument is bound to
		<var>x.</var> Once bound, the function's body is normalized with that
		binding.
	</p>
	<p>That said, let's use our function:</p>
	<pre class="language-bash"><code>
		$ ghci
		GHCi, version 8.10.6: https://www.haskell.org/ghc/  :? for help
		$ :l foo.hs
		[1 of 1] Compiling Main             ( foo.hs, interpreted )
		Ok, one module loaded.
		*Main> double 3
		6
		*Main> double 2
		4
		*Main> double (1+3)
		8
		*Main> double (double 3)
		12
	</code></pre>
	<p>
		Above, we used the <var><mark>:l</mark></var> command to load our
		<var>foo.hs</var> file into the REPL. Once loaded, we can call the function
		with the relevant arguments. Notice how we can pass expressions to the
		functions. We can also pass functions as arguments to the functions. Very
		cool.<sup></sup>
	</p>
	<div class="note">
		<p>
			After making changes to the source code file, we can relad the same file
			by running <var><mark>:r</mark></var
			>.
		</p>
	</div>
</section>

<section id="evaluation">
	<h2>Evaluation</h2>
	<p>
		In Haskell, values are expressions. But, they're expressions in irreducible
		form. For example, <var>179</var> is an expression, but it cannot be reduced
		any further. In contrast, a function call is an expression, but it is
		reducible.
	</p>
	<p>
		When an expression can no longer be reduced, we say that the expression is
		<b>irreducible</b>. In Haskell, expressions are reduced to irreducible form
		<em>only if</em> it's required. In other words, if Haskell can accomplish a
		task without having to reduce a particular expression, it will not perform
		the reduction. This is called <b>lazy evaluation</b>, or more formally,
		<b>nonstrict evaluation</b>. Instead of evaluating every expression,
		Haskell's defult is to only evaluate to <b>weak head normal form (WHNF)</b>.
	</p>
</section>

<section id="variables">
	<h2>The Variable: A Declaration of Value</h2>
	<p>
		To declare variables in Haskell, we use the keyword
		<var><mark>let</mark></var
		>. To illustrate, let's write some code in a source code file called
		<var>lab.hs</var>:
	</p>
	<pre class="language-haskell"><code>
		module Lab where
		x = 10 * 5 + y
		result = x * 5
		y = 5
	</code></pre>
	<pre class="language-bash"><code>
		$ ghci
		$ :l lab.hs
		*Lab> x
		55
	</code></pre>
	<p>A few things to note about the code we've written. First, the line:</p>
	<pre class="language-pseudo"><code>
		module Lab where
	</code></pre>
	<p>
		This is <b>module name declaration</b>. Writing this line allows us to the
		contents of <var>lab.hs</var> into other files. It's not of much use at the
		moment, but as we work on larger and more complex programs, modularization
		is everything.<sup></sup>
	</p>
	<div class="note">
		<p>In Haskell, module names are always capitalized.</p>
	</div>
</section>
<section id="arithmetic_operations">
	<h2>Arithmetic Operations</h2>
	<p>Below are Haskell's arithmetic operators:</p>
	<table class="api">
		<thead>
			<th>Operator</th>
			<th>Operation</th>
			<th>Example</th>
		</thead>
		<tbody>
			<tr>
				<td><var>${m}$ + ${n}$</var></td>
				<td>Add ${m}$ and ${n}$</td>
				<td>
					<pre class="language-bash"><code>
						Prelude> 1 + 1
						2
					</code></pre>
				</td>
			</tr>
			<tr>
				<td><var>${m}$ - ${n}$</var></td>
				<td>Subtract ${n}$ from ${m}$</td>
				<td>
					<pre class="language-bash"><code>
						Prelude> 1 - 1
						0
					</code></pre>
				</td>
			</tr>
			<tr>
				<td><var>${m}$ * ${n}$</var></td>
				<td>${m}$ times ${n}$</td>
				<td>
					<pre class="language-bash"><code>
						Prelude> 2 * 3
						6
					</code></pre>
				</td>
			</tr>
			<tr>
				<td><var>${m}$ / ${n}$</var></td>
				<td>Fractional division, ${\dfrac{m}{n}}$</td>
				<td>
					<pre class="language-bash"><code>
						Prelude> 5 / 2
						2.5
						Prelude> 4 / 2
						2.0
					</code></pre>
				</td>
			</tr>
			<tr>
				<td><var>mod ${m}$ ${n}$</var></td>
				<td>Remainder after modular division &mdash; ${m \bmod n.}$</td>
				<td>
					<pre class="language-bash"><code>
						Prelude> mod 6 3
						0
						Prelude> mod 6 4
						2
					</code></pre>
				</td>
			</tr>
			<tr>
				<td><var>div ${m}$ ${n}$</var></td>
				<td>Integral division, ${\dfrac{m}{n},}$ round down.</td>
				<td>
					<pre class="language-bash"><code>
						Prelude> div 9 3
						3
						Prelude> div 9 2
						4
					</code></pre>
				</td>
			</tr>
			<tr>
				<td><var>quot ${m}$ ${n}$</var></td>
				<td>Integral division, ${\dfrac{m}{n},}$ rounds towards zero.</td>
				<td>
					<pre class="language-pseudo"><code>
						Prelude> quot 21 2
						10
						Prelude> quot 21 3
						7
					</code></pre>
				</td>
			</tr>
			<tr>
				<td><var>rem ${m}$ ${n}$</var></td>
				<td>Remainder after division ${m \text{ rem } n.}$</td>
				<td>
					<pre class="language-pseudo"><code>
						Prelude> rem 10 2
						0
						Prelude> rem 10 3
						1
						Prelude> rem 10 4
						2
					</code></pre>
				</td>
			</tr>
		</tbody>
	</table>
	<section id="negative_numbers">
		<h3>Negative Numbers</h3>
		<p>
			Haskell has a particular rule with respect to negative numbers &mdash; if
			the negative rule is next to an arithmetic operator, we should surround
			the negative operand with parentheses. For example:
		</p>
		<pre class="language-haskell"><code>
			2 + -1   -- This returns an error
			2 + (-1) -- This is ok
		</code></pre>
		<p>
			We're seeing the strange behavior with the lack of parentheses because the
			negative sign is actually just <i>actually syntactic sugar</i> for the
			<var>negate</var> function (or alternatively, subtraction):
		</p>
		<pre class="language-pseudo"><code>
			2 + (-1) 
			2 + (negate 1)
			2 + (0 - 1)
		</code></pre>
	</section>

	<section id="parenthization">
		<h3>The Dollar Operator</h3>
		<p>
			The <var><mark>$</mark></var> operator can be used to clean up
			parentheses. For example, consider the following:
		</p>
		<pre class="language-bash"><code>
			Prelude> 2^(2+2)
			16
		</code></pre>
		<p>The dollar operator allows us to write:</p>
		<pre class="language-bash"><code>
			Prelude> (2^) $ 2 + 2
			16
		</code></pre>
		<p>
			The dollar operator tells Haskell to evaluate everything to the right of
			<var>$</var> to be evaluated first. In essence, it's used to delay
			function application.
		</p>
	</section>

	<section id="let_and_where">
		<h3>Let & Where</h3>
		<p>
			In Haskell code, we often see two keywords,
			<var><mark>let</mark></var> and <var><mark>where</mark></var
			>. The keyword <var>let</var> introduces an <i>expression</i>, and the
			keyword <var>where</var> introduces a <i>declaration</i>. More
			specifically, the keyword <var>let</var> is what we use to create
			<i>local bindings</i>. For example:
		</p>
		<pre class="language-bash"><code>
			Prelude> let x = 5 in x * x
			25
			Prelude> let x = 5; y = 6 in x * y
			30
		</code></pre>
	</section>
</section>

<section id="strings_in_haskell">
	<h2>Strings</h2>
	<p></p>
</section>
{% endblock %}
