{% extends '../layout.html' %} {% load static %} {% block content %}
<section id="haskell_intro">
	<h2>Functional Programming with Haskell</h2>
	<p>
		Haskell has a reputation for being a difficult programming language. That
		difficulty is not so much in the language itself, but rather how its taught.
		Compared to other programming languages, Haskell is a
		<span class="italicsText">functional programming language</span>. We will
		see what this means as we proceed through the next section, but the gist of
		it is: Haskell is often perceived as difficult because introductory
		programming courses, by and large, emphasize imperative or object-oriented
		programming. Functional programming is effectively an about-face.
	</p>

	<p>
		There is nothing wrong with object-oriented or imperative programming, but
		there are numerous problems that are best handled by functional programming
		approaches. We study those approaches in these next sections.
	</p>

	<pre class="language-haskell"><code>
		main :: IO ()
		main = putStrLn "Hello, world!"
	</code></pre>

	<p>
		<span class="monoText">Haskell</span> is what we might call the purest of
		all functional programming languages. We use Haskell because everything we
		learn in these materials is directly applicable to all other functional
		programming languages &mdash; Scala, Swift, Rust, Go, and many more.
	</p>
</section>

<section id="principles_of_functional_programming">
	<p>
		<span class="topic">Programming Language Families.</span> Programming
		languages generally fall into two broad categories: (1)
		<span class="italicsText">imperative languages</span>; and (2)
		<span class="italicsText">declarative languages</span>. Imperative languages
		include languages like Java, C, and Pascal. Some of these languages are
		object-oriented langauges, like Java, Python, and JavaScript. Others are
		procedural, like C, Pascal, and Fortran. The common trait across these
		languages: Programs instruct the computer
		<span class="italicsText">how</span> to perform a computation.
	</p>

	<p>
		In contrast are the
		<span class="italicsText">declarative languages</span> &mdash; languages
		like Haskell, Lisp, ML, and Prolog. Some declarative languages are
		<span class="italicsText">functional programming languages</span>, like
		Haskell, Swift, and Scheme. Other declarative languages are
		<span class="italicsText">logic programming languages</span>, the most
		famous of which is Prolog.
	</p>

	<p>
		These distinctions, however, are not always clear cut. For example, the
		latest updates to Java have brought the language closer to functional
		programming. Similarly, Swift is a functional programming language, but
		allows object-oriented programming. Where imperative languages instruct the
		computer <span class="italicsText">how</span> to perform a computation,
		declarative languages merely state, or describe the problem, and leave the
		computation to the computer.
	</p>

	<p>
		Which language, or paradigm, is better depends on the task at hand. For
		example, if we are writing a program for a life-support machine or jet
		fighter, we might prefer a procedural language like Pascal or C, since human
		lives are at risk. On other hand, if we are writing a fluid simulation
		program &mdash; a highly resource intensive process &mdash; then a
		functional programming approach would be ideal (as we will soon see).
	</p>

	<p>
		<span class="topic">Focus of Functional Programming.</span> What makes
		functional programming so different from other programming paradigms? In
		functional programming, the focus is on
		<span class="italicsText">functions</span> and
		<span class="italicsText">values</span>, rather than
		<span class="italicsText">assignments</span> and
		<span class="italicsText">pointers</span>. In imperative programming
		languages like C, the most important statement is assignment &mdash; binding
		values to variables &mdash; storing values at a memory address &mdash; and
		changing the contents of those memory addresses. These values are then
		organized to form large data structures by way of pointers.
	</p>

	<p>
		In pure functional programming languages like Haskell, there is no
		assigment, and there are no pointers. We think
		<span class="underlineText">entirely</span> in functions. Changing our
		thinking to the functional approach can vastly improve our programming
		skills &mdash; we stop focusing on what the computer
		<span class="italicsText">should</span> do, and focus instead on what the
		computer <span class="italicsText">will</span> do. This is accomplished by
		the defining characteristic of functional programming: the absence of
		<span class="italicsText">side effects</span>. Good functional code does not
		rely on any data outside the current function, and it will not change data
		that exists outside the current function. Here is a Python example:
	</p>

	<p>Here is a function that is not functional:</p>

	<pre class="language-python"><code>
		a = 0
		def increment():
			a
			a += 1
	</code></pre>

	<p>
		And here is a function that
		<span class="underlineText">is</span> functional:
	</p>

	<pre class="language-python"><code>
		def increment(a):
			return a + 1
	</code></pre>

	<p>
		In functional programming, we write
		<span class="italicsText">declarative statements</span> &mdash; statements
		only stating a fact, what we want, but not necessarily
		<span class="italicsText">how</span> to obtain what we want &mdash; rather
		than imperative statements &mdash; statements expressing
		<span class="italicsText">how</span> to obtain what we want, step-by-step.
	</p>

	<div class="compare">
		<div>
			<p class="subheading">Declarative Programming</p>
			<p>Give me everything in this list that is even.</p>
		</div>

		<div>
			<p class="subheading">Imperative Programming</p>
			<p>
				Step through this list. Look at the element. If
				<span class="monoText">element % 2 == 0</span>, include it in the
				results list. Give me the results list when you are done.
			</p>
		</div>
	</div>
</section>
{% endblock %}
