{% extends '../layout.html' %} {% load static %} {% block description %}
<meta
	name="description"
	content="Shells: Working with bash and the terminal."
/>
{% endblock %} {% block title %}
<title>Shells</title>
{% endblock %} {% block content %}
<h1>Shells & Shell Scripting</h1>

<section id="introduction">
	<p>
		A typical computer science usually focuses on
		<span class="italicsText">theory</span>, rather than the tools that
		<span class="italicsText">apply</span> such theory. This is
		understandable, given that theory seldom changes, but applications
		change by the second. Great computer science courses will strive to
		balance both by providing a "lab" module or project assignments to
		accompany the course, but even there, the assumption is that students
		learn the tools on their own. The material that follows provides an
		overview of the most common tools used in the field, but beware: there
		is a strong possibility that what appears here may be outdated.
	</p>
</section>

<section id="operating_systems">
	<h2>Basic Terminology</h2>

	<p>
		Before we proceed to the substantive material, we need to have basic
		terms down. This will allow us to quickly understand the material, as
		well as provide the ability to research for further material.
	</p>
	<p>
		An <span class="boldItalics">operating system</span> is a bundle of
		software that manages computer hardware, software resources, and common
		services for programs. Generally, most modern operating systems fall
		into two <span class="italicsText">families</span> of operating
		systems:
	</p>

	<ul>
		<li>Microsoft Windows</li>
		<ul>
			<li>Windows, Xbox OS, Windows Mobile</li>
		</ul>
		<li>Unix</li>
		<ul>
			<li>macOS, Linux, iOS, Android, Chrome OS, Blackberry OS</li>
		</ul>
	</ul>

	<p>
		Of course, there are other families of operating systems (and as such,
		operating systems in those families), but these systems have generally
		fallen out of use, limited to specialist fields, or limited to certain
		devices. E.g., Wii system (the operating system for Nintendo Wiis),
		XTS-400 (an operating system by BAE systems, aimed at securing and
		classifying information for entities like the NSA and DoD), classic Mac
		OS (the non-Unix ancestor of Apple's macOS), MINIX (an operating system
		made purely for research). But, for the most part, we are only
		concerned with the two families above, particularly the Unix system.
	</p>
	<p>
		This is why we might hear words like "true Unix" and "Unix-like."
		Either or, many of the Unix descendants will share the same features,
		and the distinction is generally unimportant. We mention it here to
		prevent any further confusion.
	</p>
</section>

<section id="unix_system">
	<p>
		<span class="topic">The Unix System.</span> Originally, Unix was an
		operating system that was developed at Bell labs (now AT&T) in the
		mid-1960s. Many of the shell command names we have today are directly
		from Unix.
	</p>
	<p>
		Today, the term Unix is a trademark owned by the global consortium The
		Open Group. This consortium decides whether an operating system can use
		the trademark Unix by setting the guidelines for eligibility&mdash;what
		core commands the operating system provide, what features it must have,
		what interfaces it must display, what utilities must be enabled, etc.
	</p>
	<p>
		Companies pay to have their operating systems tested and continue to
		pay for their continued licenses. Because of the costs and difficulty
		of obtaining a trademark license, many operating systems never get the
		license, but are very much <span class="italicsText">Unix-like</span>.
		These operating systems act like Unix, but are not considered
		<span class="italicsText">true Unix</span> because they have not been
		licensed by The Open Group. Nevertheless, because many operating
		systems are descended from Unix, many of the commands below will work
		across the Unix descended operating systems.
	</p>
</section>

<section id="linux">
	<p>
		<span class="topic">The Linux Distributions.</span> A
		<span class="italicsText">Linux distribution</span> is an operating
		system based on the <span class="italicsText">Linux kernel</span>. A
		<span class="boldItalics">kernel</span> is the computer program that
		connects a computer's operating system to the computer's hardware
		(e.g., the computer's CPU, memory, and devices).
	</p>
	<p>
		The Linux kernel was born in the 1980s, conceived by concerns that
		computers and their respective operating systems were too restrictive
		(at the time, computers and their accompanying software were entirely
		proprietary). The moment of conception was in 1984, when the computer
		scientist Richard Stallman began the GNU Project, an enterprise aimed
		at creating an operating system identical to a Unix system, but free.
		Linus Torvalds, another computer scientist, took the programs developed
		by the GNU Project, and wrote a kernel. The result was the Linux
		kernel, which gave way to a Linux operating system. Note: This is a
		very controversial topic, as the term "Linux" has led many to forget
		about the contributions by the GNU Project.
	</p>
	<p>
		There are many Linux distributions: Linux Mint, Ubuntu, MX Linux, Arch
		Linux, Debian, Fedora, Red Hat Enterprise, Gentoo, Slackware Linux,
		openSUSE, CentOS, FreeBSD, the list goes on.
	</p>
</section>

<section id="introduction_shell_tools_intro">
	<h3>The Shell</h3>
	<p>
		Most people use and interact with computers through a
		<span class="boldItalics">GUI ("Graphical User Interface")</span>.
		While most computer tasks can be completed through a GUI alone, GUIs
		are restrictive&mdash;we can only perform tasks based on what the GUI
		provides: buttons, a window, options to choose from, etc. There are
		often situations where we run into a problem and the GUI simply does
		not provide us with a way to solve issues.
	</p>
	<p>
		A <span class="boldItalics">shell</span> provides an alternative method
		of interacting with a computer. Unlike a GUI where we interact with a
		computer by using the mouse and a cursor in response to graphical cues,
		with a shell, we interact with the computer through text. This gives us
		much more control over a computer, as there are many things we do not
		have control over with GUI. Even better, it is much much faster than
		using a GUI&mdash;typing is faster than moving a mouse, and we can
		easily automate many tasks that we usually do.
	</p>
	<p>
		To interact with a computer with a shell, we use the relevant operating
		system's provided shell. On Windows, its the
		<span class="boldItalics">power shell</span> (but there are other
		shells). On Linux and Mac, its the
		<span class="boldItalics">bash shell</span> ("Bourne-Again SHell", a
		punny name referencing Stephen Bourne, the creator of bash's ancestor,
		sh). Note: For Mac users with an operating system after OS X Jaguar
		(released in 2007), OS X includes the bash shell, but has not updated
		it since 2007; Apple has instead come to use a shell called
		<span class="boldItalics">Zsh</span>.
	</p>
	<p>
		To see and interact with the shell, we use an application called the
		<span class="boldItalics">terminal</span>. The name "terminal" comes
		from the fact that the shells for early computers were handled with a
		separate physical device called a terminal. The terminal application is
		software specifically made to execute shell commands.
	</p>
	<p>
		A computer, as a whole, is a system of various parts. The rules and
		methods that dictate how those parts function together, are organized,
		and implemented, is called the computer's
		<span class="boldItalics">architecture</span>.
	</p>
	<p>
		Most modern computer architectures organize the system into layers. The
		outer most layer consists of all the programs and files we use
		daily&mdash;Finder, Microsoft Word, Chrome, etc. Under that layer,
		supporting it all, is the operating system. The operating system itself
		is then composed of layers: an outer most layer, the
		<span class="italicsText">shell</span>, and its core, the
		<span class="italicsText">kernel</span>.
	</p>
	<p>
		The shell is the operating system's computer interface. It allows us to
		visually see and interact with the operating system's services. The
		name "shell" comes from the fact that it is the outer most layer of the
		operating system. The shell basically takes our commands, translates
		them into code that the operating system understands, and sends it to
		the operating system to execute.
	</p>
</section>

<section id="the_terminal">
	<h2>The Terminal</h2>
	<p>
		<span class="topic">Arrow Keys in Terminal.</span> The arrow keys have
		specific functions in terminal.
	</p>
	<ul>
		<li>
			The left and right arrows allow us to move the cursor left or right
			on a line.
		</li>
		<li>
			The up arrow will cycle to the most recent command we ran, over and
			over.
		</li>
		<li>
			If we go too far up the previous commands, we can go back down with
			the down arrow.
		</li>
	</ul>
	<p>
		The arrow keys are particularly useful when we need to write very long
		commands. When you open the terminal, you might be greeted by something
		that looks like this:
	</p>

	<pre class="language-bash" data-user="root" data-host="localhost"><code>
		lorem ipsum
	</code></pre>

	<p>
		The line to the left, before the dollar sign,
		<span class="monoText">[root@localhost] | $</span> is called the
		<span class="boldItalics">shell prompt</span> (the "lorem ipsum" is
		placed in the example above just to render the code). The
		<span class="italicsText">shell prompt</span> is where you tell the
		shell what you want to do (i.e., executing a command). For example, if
		we execute the <span class="monoText">date</span> command:
	</p>

	<pre class="language-bash"><code>
		date
		Mon May 17 14:02:36 CDT 2021
	</code></pre>

	<p>
		Or, if we enter the <span class="monoText">ncal</span> command ("new
		calendar"), we get a calendar output. If we run the
		<span class="monoText">cal</span> command, we get another calendar
		output, but with a different formatting. Another command is the
		<span class="monoText">echo</span> command, which prints out the
		arguments we pass after it:
	</p>

	<pre class="language-bash"><code>
		echo hello!
		hello!
	</code></pre>

	<p>
		To provide an argument in the terminal, we enter a command, followed by
		a space, then an argument. What if the argument itself contains spaces?
		For our example, we can use quotes to indicate a string.
	</p>

	<pre class="language-bash"><code>
		echo "hello, world"
		hello, world
	</code></pre>

	<p>
		Alternatively, we can use the escape key
		<span class="monoText">\</span> to tell the computer that we're using a
		white space not as part of the command, but as part of the argument:
	</p>

	<pre class="language-bash"><code>
		echo hello,\ world
		hello, world
	</code></pre>

	<p>
		The terminal is able execute shell commands because the commands
		trigger programs built in to the computer. These programs are stored in
		the computer's file system, and come with the computer (just as Safari
		comes with Mac OS or Notepad comes with Windows). The shell
		(particularly the bash shell), is in actuality a programming language,
		and it has the ability to find where a particular program is located,
		through an
		<span class="boldItalics">environment variable</span>. With the prompt
		that appears in the terminal, we can do things like while loops, for
		loops, conditional expressions, function declaration, etc. When we use
		the prompt this way, we are
		<span class="boldItalics">shell scripting</span>.
	</p>

	<p>
		As we work in the shell, the terminal can quickly become cluttered. To
		clear the terminal, type <span class="monoText">clear</span> and press
		enter.
	</p>
</section>

<section id="the_syntax_of_a_command">
	<p>Commands follow a general structure:</p>
	<figure class="math-display">
		<pre class="language-pseudo"><code>
			⟨command⟩ -⟨options⟩ ⟨arguments⟩
		</code></pre>
	</figure>
	<p>
		The <span class="term">command</span> is the name of the program we
		run. <span class="term">Options</span> are characters or words we
		include that modify how the shell executes the command. We can include
		multiple options by simply writing them one after another:
	</p>

	<figure class="math-display">
		<pre class="language-pseudo"><code>
			⟨command⟩ -⟨option⟩ -⟨option⟩ ⟨arguments⟩
		</code></pre>
	</figure>

	<p>Alternatively, we can write multiple options into a single dash:</p>

	<figure class="math-display">
		<pre class="language-pseudo"><code>
			⟨command⟩ -⟨optionOptionOption⟩ 
		</code></pre>
	</figure>

	<p>
		Some options have <span class="boldItalics">long form names</span>.
		Only some options support this, and they must be indicated with two
		dashes <span class="monoText">--</span>. For example, the option
		<span class="monoText">-u</span> has the long form name
		<span class="monoText">--universal</span>.
	</p>

	<p>
		Some options require us to include values. For example, the
		<span class="monoText">-A</span> option for the command
		<span class="monoText">ncal</span> prints the calendar for a month $n$
		months <span class="italicsText">after</span> a specific date. Thus,
		for the <span class="monoText">-A</span> option to work, we need to
		include that date.
	</p>

	<p>
		The command above prints the calendar for the month 1 month after the
		current month. The <span class="monoText">1</span> is an argument
		passed to the <span class="monoText">-A</span> option. Note that, if we
		have multiple options and some of the options have parameters, we need
		to list the options separately rater than using the single dash syntax.
	</p>

	<p>
		The <span class="term">arguments</span> are the values that we pass
		through to the program behind the command. These are also called
		<span class="term">parameters</span>.
	</p>
	<p>
		For example, if we run the <span class="monoText">cal</span> command
		followed by a particular year (e.g.,
		<span class="monoText">cal 1961</span>), we get the entire calendar for
		that year. Or, if we include a month (e.g.,
		<span class="monoText">cal june 1943</span>), we get the calendar for
		June of 1943. The year and the month we passed are the arguments. If we
		have more than 1 argument, we separate the arguments with spaces. Note,
		however, that the above is a
		<span class="italicsText">general</span> structure. The commands we
		write can take on a different ordering of the above components.
	</p>

	<p>
		An <span class="boldItalics">environment variable</span> is a variable
		initialized whenever we start the shell. These are basically "built-in"
		variables&mdash;variables that we do not have to set ourselves. An
		environment variable might store, for example, the path to your home
		directory, your username, or, as seen above, the current date.
	</p>

	<p>
		For example, the <span class="monoText">$PATH</span> variable will
		display all of the paths on the computer that the shell will use to
		search for programs. A <span class="boldItalics">path</span> is where
		bash will look for the file or program with the name that matches the
		command that we entered. For example, when we enter the command
		<span class="monoText">date</span>, bash goes through all of the paths
		above, and looks for a program with the name DATE, and once it finds
		that program, it runs it.
	</p>

	<p>
		If we want to know the actual name of the program that's actually run,
		we can use the <span class="monoText">which</span> command:
	</p>

	<pre class="language-bash"><code>
		which date
		/bin/date
	</code></pre>

	<p>
		The above tells us that the program executed is called "date" (the last
		name in the list). By default, programs run in the
		<span class="term">current working directory</span> &mdash; the
		directory we are currently in. In turn, every directory has a
		<span class="boldItalics">path</span> &mdash; the full name of a file
		in a computer. Thus, the actual output from running the command above,
		<span class="monoText">/bin/date</span>, means the program "date" is
		found in a directory called "bin". On Linux and Mac OS, there is only
		one path, and it is indicated by forward slashes. For example,
		<span class="monoText">usr/bin</span>. On Windows, each
		<span class="boldItalics">partition</span>, or
		<span class="boldItalics">drive</span>, has its own path, and they are
		indicated by the partition's name, followed by backslashes. For
		example: <span class="monoText">C:usr\bin\date</span>.
	</p>

	<p>
		There are different types of paths. The paths above are called
		<span class="boldItalics">absolute paths</span>. When we run
		<span class="monoText">which echo</span>, we get
		<span class="monoText">bin/echo</span>. That path is the full path to
		that file. But, there are also
		<span class="boldItalics">relative paths</span>. A
		<span class="boldItalics">relative path</span> is a path that is
		relative to where we currently are. All relative paths are relative to
		the <span class="boldItalics">current working directory</span>, which
		is the directory displayed from running the
		<span class="monoText">pwd</span> command. To change the current
		working directory, we use the <span class="monoText">cd</span> command.
	</p>

	<p>
		Bearing this in mind, we can find out where we currently are in the
		computer with the <span class="monoText">pwd</span> command ("print
		working directory").
	</p>

	<pre class="language-bash"><code>
		pwd
		/Users/mathlab
	</code></pre>

	<pre class="language-bash"><code>
		cd /content
		/Users/mathlab/content
	</code></pre>

	<p>
		In the file system, there is a directory named
		<span class="monoText">content</span>, in the directory named
		<span class="monoText">mathlab</span>. We changed our current working
		directory from <span class="monoText">mathlab</span>, to a directory
		inside it, <span class="monoText">content</span>.
	</p>

	<p>
		<span class="topic">Special Directories</span>
		There are special directories: <span class="monoText">.</span> (dot),
		<span class="monoText">..</span> (dot dot), and
		<span class="monoText">~</span> (tilde). The directory
		<span class="monoText">.</span> means
		<span class="italicsText">the current directory</span>. The directory
		<span class="monoText">..</span> means
		<span class="italicsText">the parent directory</span>. And the
		directory <span class="monoText">~</span> means
		<span class="italicsText">the home directory</span>
		These special directories allow us to easily navigate around the
		system. For example:
	</p>

	<pre class="language-bash"><code>
		pwd
		/Users/mathlab/content
		cd ..
		pwd
		/Users/mathlab
	</code></pre>

	<p>
		In the example above, we started by determining our current working
		directory. There, it was
		<span class="monoText">/Users/mathlab/content</span>. Then we changed
		the directory to the parent directory with
		<span class="monoText">cd ..</span>; we moved up one directory, to
		<span class="monoText">/Users/mathlab</span>. When we execute the
		<span class="monoText">pwd</span> command, we see our current working
		directory: <span class="monoText">/Users/mathlab</span>. We can also
		use relative paths to go <span class="italicsText">down</span> a
		directory:
	</p>

	<pre class="language-bash"><code>
		pwd
		/Users/mathlab
		cd ./content
		pwd
		/Users/mathlab/content
	</code></pre>

	<p>
		We can also <span class="monoText">cd</span> all the way back to where
		we were. So, we're in the directory
		<span class="monoText">mathlab</span>. In the directory
		<span class="monoText">mathlab</span>, there's a directory
		<span class="monoText">content</span>, and inside that directory,
		there's a directory <span class="monoText">cs_tools</span>. We can go
		into <span class="monoText">cs_tools</span> with:
	</p>

	<pre class="language-bash"><code>
		cd content/cs_tools
	</code></pre>

	<p>To go back to the <span class="monoText">mathlab</span> directory:</p>

	<pre class="language-bash"><code>
		cd ../..
	</code></pre>

	<p>Finally, to go very quickly to the home directory:</p>

	<pre class="language-bash"><code>
		cd ~
	</code></pre>

	<p>
		The <span class="monoText">~</span> directory is very useful for
		quickly navigating to other folders. Say we're in a directory called in
		<span class="monoText">calculus</span> inside the directory
		<span class="monoText">content</span>. We want to go into a directory
		called <span class="monoText">archived_calculus</span>, inside the
		directory archives, which is inside the home directory,
		<span class="monoText">mathlab</span>:
	</p>

	<pre class="language-bash"><code>
		pwd
		/Users/mathlab/content/calculus
		cd ~/mathlab/archives/archived_calculus
		pwd
		Users/mathlab/archives/archived_calculus
	</code></pre>

	<p>
		Another extremely useful bash command is
		<span class="monoText">cd -</span> ("cd dash"). This will change your
		current working directory to the directory you were previously in.
	</p>

	<p>
		<span class="topic">Prompt Disappears.</span> Lack of a prompt
		indicates we likely ommitted part of a command (the most common
		culprint being double or single quotes). This is happening because we
		failed to close the string, which the shell interprets as an incomplete
		command. Thus, to solve the problem, we need to complete the command.
		In this case, closing the quotation:
	</p>
	<p>
		Doing so will allow the shell to execute (in the example above, we get
		the output "command not found"). Furthermore, a prompt might not be
		displayed because the previous command is still running. In those
		situations, wait for the command to finish (or simply close the
		terminal window if the command is stuck in a loop).
	</p>
</section>

<section id="finding_whats_in_the_cwd">
	<p>
		<span class="topic">Content Viewing.</span> If we want to see a list of
		the files in the
		<span class="italicsText">current working directory</span>, we use the
		<span class="monoText">ls</span> (short for "list") command. So,
		suppose we're in the <span class="monoText">mathlab</span> directory:
	</p>

	<pre class="language-bash"><code>
		pwd
		/Users/mathlab
		ls
		content  notes  todos  archives
	</code></pre>

	<p>
		It looks like there are four directories inside the
		<span class="monoText">mathlab</span> directory:
		<span class="monoText">content</span>,
		<span class="monoText">notes</span>,
		<span class="monoText">todos</span>, and
		<span class="monoText">archives</span>.
	</p>
	<p>
		We can also use the
		<span class="italicsText">special directory</span> notation to list the
		files in a parent directory. Suppose we're inside the
		<span class="monoText">content</span> directory:
	</p>

	<pre class="language-bash"><code>
		cd content
		pwd
		/Users/mathlab/content
	</code></pre>

	<p>
		Then we want to list the files in the parent directory,
		<span class="monoText">mathlab</span>:
	</p>

	<pre class="language-bash"><code>
		ls ..
		content  notes  todos  archives readme.md
	</code></pre>

	<p>
		<span class="topic">Content Detailed Viewing.</span> When we run the
		<span class="monoText">ls</span> command, we only get the names of the
		files or directories in the current working directory.
	</p>
	<p>
		If we want more detailed information about the files or directories, we
		need to use the <span class="monoText">ls -l</span> command:
	</p>
	<p>Suppose we're in the mathlab directory:</p>

	<pre class="language-bash"><code>
		cd ls -l
		total 350
		drwxr-xr-x  25 mathlab staff    399  Feb. 19 09:25 content
		drwx------  10 mathlab staff     25  Jan. 14 18:29 notes
		drwx------@ 11 mathlab staff     24  Feb. 15 19:32 todos
		drwx------+ 12 mathlab staff     44  Feb.  9 20:01 backups
		drwxr-xr-x+ 12 mathlab staff     44  Feb.  9 20:01 archives
		-rw-r--r--   1 mathlab staff     22  Feb.  3 13:03 readme.md
	</code></pre>

	<p>What does the data mean? Looking at the left most column:</p>
	<ul>
		<li>
			If the first character is a <span class="monoText">-</span>, that
			indicates a <span class="italicsText">file</span>.
		</li>
		<li>
			If the first character is a <span class="monoText">d</span>, that
			indicates a <span class="italicsText">directory</span>.
		</li>
		<li>
			If the first character is an <span class="monoText">l</span>, that
			indicates a <span class="italicsText">link</span>.
		</li>
		<li>
			The next characters indicate the permissions the
			<span class="italicsText">root user</span> has for a file or
			directory:
		</li>
		<ul>
			<li>
				<span class="monoText">rw-</span> means the owner has read and
				write permissions over the file.
			</li>
			<li>
				<span class="monoText">rwx-</span> means the owner has read, write,
				and execute permissions over the file.
			</li>
		</ul>
		<li>
			After those characters, you have the permissions (if any) that a
			<span class="italicsText">group</span> has over the file:
		</li>
		<ul>
			<li>
				<span class="monoText">r--</span> means the group only has the
				permission to read.
			</li>
			<li>
				<span class="monoText">rw-</span> means the group has the
				permissions to read and write.
			</li>
			<li>
				<span class="monoText">rx-</span> means the group has the
				permissions to read and execute.
			</li>
		</ul>
		<li>
			After those characters, you have the permissions (if any) that
			everyone other than a group or the root user has over the file. The
			same rules above apply.
		</li>
		<li>
			Note: Permissions work differently for files and directories. If you
			have a read permission for a file, then you can open the file (i.e.,
			"read its contents"). If you have a write permission for a file, then
			you can open the file, read, write (i.e., make changes), save the
			file, or replace it entirely. If you have an execute permission, you
			can execute the file (i.e., run the program contained in the file).
		</li>
		<li>
			For directories, however, the permissions are different. A read
			permission for a directory means you are allowed to see the files
			inside that directory (i.e., you can
			<span class="monoText">ls</span> the directory). A write permission
			for a directory means you can create, rename, and remove files within
			that directory. This means that while you may have write permissions
			for a file, if that file is inside a directory that you do not have
			write permissions to, then you can make changes to the file, but you
			cannot delete or rename that file. An execute permission for a
			directory means that you are allowed to enter the directory (i.e.,
			you can <span class="monoText">cd</span> into the directory).
		</li>
		<li>
			The second column (a number) indicates the number of links or
			directories inside a directory (if a single file, 1).
		</li>
		<li>
			The third column (a word) indicates the user that owns the file or
			directory.
		</li>
		<li>
			The fourth column (another word) indicates the group that the file or
			directory belongs to (any user in that group will have the group
			permissions indicated above).
		</li>
		<li>
			The fifth column (a number) indicates the size of the file or
			directory in bytes.
		</li>
		<li>
			The sixth column (a date and a time) indicates the date the file or
			directory was last modified.
		</li>
		<li>
			The final column (a word or a number) indicates the name of the file
			or directory.
		</li>
	</ul>
</section>

<section id="help_tool">
	<p>
		<span class="topic">What does this command do?</span> If we do not know
		what a particular command does, we can use the
		<span class="monoText">man</span> command, followed by the command:
	</p>

	<pre class="language-bash"><code>
		man ls
	</code></pre>

	<p>
		Running the above code will display in the terminal the
		<span class="italicsText">manual</span> for that command. To end the
		program, enter <span class="monoText">q</span> to quit. When you run
		the <span class="monoText">man</span> command, there's a part of the
		outputted manual labeled synopsis. It generally looks like:
	</p>

	<pre class="language-bash"><code>
		SYNOPSIS
		command [-options parameters] [file ...]
	</code></pre>

	<p>
		The synopsis shows us the general syntax for the command. Everything
		inside the square brackets, <span class="monoText">[]</span> is
		optional (we are free to decide whether to include it). Everything not
		in square brackets is required; the command will not execute unless the
		described statements are written.
	</p>
	<p>
		The ellipses, <span class="monoText">...</span> indicate that multiple
		arguments can be passed. And, if the option's parameter requires a
		particular argument, it will be indicated by the value's type (e.g.,
		<span class="monoText">number</span> or
		<span class="monoText">string</span>).
	</p>
	<p>The manual itself has 8 sections:</p>
	<ul>
		<li>User Commands</li>
		<li>System Calls</li>
		<li>C Library Functions</li>
		<li>Special Files</li>
		<li>File Forms</li>
		<li>Games</li>
		<li>Miscellaneous</li>
		<li>System Admin Commands</li>
	</ul>
</section>

<section id="type_and_which_command">
	<p>
		<span class="topic"
			>The <span class="monoText">type</span> Command.</span
		>
		In bash, there are four types of commands:
	</p>
	<ol>
		<li>An executable program;</li>
		<li>A built-in shell command;</li>
		<li>A shell function</li>
		<li>An alias</li>
	</ol>
	<p>
		<span class="term">Executable program commands</span> are programs that
		can be executed. These are usually stored in the
		<span class="term">bin</span> directory. These programs are compiled
		binary files (hence the directory name
		<span class="monoText">bin</span>).
		<span class="monoText">Built-in shell commands</span> are commands that
		are part of the shell, rather than separate programs.
	</p>

	<p>
		To determine what <span class="italicsText">type</span> a command is,
		we use the <span class="monoText">type</span> command. The syntax is
		the following:
	</p>

	<figure class="math-display">
		<pre class="language-pseudo"><code>
			type ⟨command⟩
		</code></pre>
	</figure>

	<p>For example:</p>

	<pre class="language-bash"><code>
		type ls
		ls is hashed (/bin/ls)
	</code></pre>

	<p>
		Using the <span class="monoText">type</span> command on
		<span class="monoText">ls</span> shows us that
		<span class="monoText">ls</span> is an
		<span class="italicsText">executable program</span> type command,
		located in the <span class="monoText">/bin</span> directory.
	</p>
</section>

<section id="which_command">
	<p>
		<span class="topic"
			>The <span class="monoText">which</span> Command.</span
		>
		If we need to know the exact location of an executable program, we use
		the
		<span class="monoText">which</span> command. This only works for
		executable programs; it will not work for built-in shell commands or
		aliases. The syntax:
	</p>
	<figure class="math-display">
		<pre class="language-pseudo"><code>
			which ⟨command⟩
		</code></pre>
	</figure>
</section>

<section id="opening_a_file">
	<h3>Opening a File</h3>
	<p>
		To open a file, we simply use the
		<span class="monoText">open</span> command:
	</p>

	<figure class="math-display">
		<pre class="language-pseudo"><code>
			open ⟨file_name.extension⟩
		</code></pre>
	</figure>
</section>

<section id="unix_file_system">
	<p>
		<span class="topic">The Unix File System</span> The Unix file system is
		generally (there are variations across the Unix and Unix-like operating
		systems) organized as a tree.
	</p>

	<p>
		<span class="topic"
			>The <span class="monoText">root</span> Directory.</span
		>
		Every single directory and file in the computer is located in the
		folder
		<span class="monoText">/</span>. This is often referred to as the
		<span class="boldItalics">root directory</span>, but in some operating
		systems there is a separate directory called
		<span class="monoText">root</span>, located inside the
		<span class="monoText">/</span> directory. These are not the same
		directories. Most of the time, however, when we say "root directory" we
		refer to the <span class="monoText">/</span> directory.
	</p>

	<p>
		The <span class="monoText">root</span> directory has a shorthand, the
		forward slash (<span class="monoText">/</span>). We can quickly go to
		the <span class="monoText">root</span> directory by entering:
	</p>

	<pre class="language-bash"><code>
		cd /
	</code></pre>

	<h4></h4>
	<p>
		<span class="topic"
			>The Home Directory <span class="monoText">~</span></span
		>
		The <span class="monoText">home</span> directory contains the
		directories for each of the users in the system. So, if a system has
		the users Tarski, Peirce, and Russell, the
		<span class="monoText">home</span> directory will contain the
		directories <span class="monoText">/tarski</span>,
		<span class="monoText">/peirce</span>, and
		<span class="monoText">/russell</span>. Inside these directories are
		all of those users' files, data, user-created directories, directories
		like <span class="monoText">/Downloads</span>,
		<span class="monoText">/Desktop</span>, etc.
	</p>

	<p>
		Like the <span class="monoText">root</span> directory, the
		<span class="monoText">home</span> directory has its own shorthand, the
		tilde (<span class="monoText">~</span>). To quickly move to the home
		directory, you can enter just <span class="monoText">cd</span> or
		<span class="monoText">cd ~</span>.
	</p>

	<pre class="language-bash"><code>
		cd
	</code></pre>
</section>

<section id="renaming_files">
	<p>
		<span class="topic">Renaming and Moving Files</span> We can rename a
		file with the <span class="monoText">mv</span> command. The
		<span class="monoText">mv</span> command takes two arguments:
	</p>

	<figure class="math-display">
		<pre class="language-pseudo"><code>
			mv ⟨original_file_path⟩ ⟨new_file_path⟩
		</code></pre>
	</figure>

	<p>Or, if we're just renaming a file in the same directory:</p>

	<figure class="math-display">
		<pre class="language-pseudo"><code>
			mv ⟨file_name.extension⟩ ⟨new_file_name.extension⟩
		</code></pre>
	</figure>

	<p>
		The argument <span class="italicsText">original-file-path</span> is the
		path of the file we want to move (or, if the file is in our current
		working directory, just the file name). The argument
		<span class="italicsText">new-file-path</span> is the path to the
		directory we want to move the file to (or, if we just want to rename
		the file, the new file name).
	</p>

	<p>
		For example, suppose we're inside the
		<span class="monoText">mathlab</span> directory, and there is a file
		<span class="monoText">readme.md</span>. Let's change that file's name
		to <span class="monoText">read.md</span>:
	</p>

	<pre class="language-bash"><code>
		mv readme.md read.md
	</code></pre>

	<p>
		The above file's name has now been changed to
		<span class="monoText">read.md</span>.
	</p>
</section>

<section id="copying_files">
	<p>
		<span class="topic">Copying a File.</span> We can copy a file with the
		<span class="monoText">cp</span> command. The
		<span class="monoText">cp</span> command works much like the
		<span class="monoText">mv</span> command, and takes two arguments:
	</p>

	<figure class="math-display">
		<pre class="language-pseudo"><code>
			cp ⟨original_file_path⟩ ⟨new_file_path⟩
		</code></pre>
	</figure>

	<p>Of, if we're just making a copy of the file in the same directory:</p>

	<figure class="math-display">
		<pre class="language-pseudo"><code>
			cp ⟨file_name.extension⟩ ⟨new_file_name.extension⟩ 
			
		</code></pre>
	</figure>

	<p>
		For example, let's copy the file
		<span class="monoText">read.md</span> into the directory
		<span class="monoText">notes</span>:
	</p>

	<pre class="language-bash"><code>
		cp read.md notes
	</code></pre>

	<p>
		The file <span class="monoText">read.md</span> is now in the directory
		<span class="monoText">notes</span>. While we're inside the directory
		<span class="monoText">notes</span>, suppose there's a file named
		<span class="monoText">writeme.txt</span>. I want to make a copy of
		that file in the directory <span class="monoText">archives</span>,
		which is inside the <span class="monoText">mathlab</span> directory:
	</p>

	<pre class="language-bash"><code>
		cp writeme.txt ../archives
	</code></pre>
</section>

<section id="deleting_files">
	<p>
		<span class="topic">Deleting a File.</span> We can delete a file with
		the <span class="monoText">rm</span> command. Suppose that inside the
		<span class="monoText">mathlab</span> directory, there's a directory
		named <span class="monoText">todelete</span>. Inside that directory,
		there's a file named <span class="monoText">removeme.txt</span>. While
		we are inside the directory <span class="monoText">todelete</span>, we
		can <span class="italicsText">remove</span>, or
		<span class="italicsText">delete</span>, the file
		<span class="monoText">removeme.txt</span> with the
		<span class="monoText">rm</span> command:
	</p>

	<figure class="math-display">
		<pre class="language-pseudo"><code>
			rm ⟨file_name.extension⟩
		</code></pre>
	</figure>

	<p>
		<span class="topic">Deleting a Directory.</span> Doing the above will
		delete the removeme.txt file
		<span class="underlineText">permanently</span>. Note: the
		<span class="monoText">rm</span> command is not recursive; as such, it
		cannot delete directories. We can remove a directory with the
		<span class="monoText">rmdir</span> command, but only if the directory
		is empty:
	</p>

	<figure class="math-display">
		<pre class="language-pseudo"><code>
			rmdir ⟨directory_name⟩
		</code></pre>
	</figure>
</section>

<section id="creating_directory">
	<p>
		We can create a directory with the
		<span class="monoText">mkdir</span> command:
	</p>

	<figure class="math-display">
		<pre class="language-pseudo"><code>
			mkdir ⟨new_directory_name⟩
		</code></pre>
	</figure>

	<p>
		For example, while we're inside the
		<span class="monoText">mathlab</span> directory:
	</p>

	<pre class="language-bash"><code>
		mkdir experiments	
	</code></pre>

	<p>
		The above created a new directory named
		<span class="monoText">experiments</span> in the directory
		<span class="monoText">mathlab</span>. Remember that a white space
		separates arguments. If we ran the command:
	</p>

	<pre class="language-bash"><code>
		mkdir new experiments
	</code></pre>

	<p>
		We would create two directories, <span class="monoText">new</span> and
		<span class="monoText">experiments</span>. If we wanted to create a
		directory with a space in its name, we must use quotes (to indicate a
		string) or enter an escape key.
	</p>

	<pre class="language-bash"><code>
		mkdir "new experiments"
	</code></pre>
</section>

<section id="naming_directories">
	<h2>Naming Files and Directories.</h2>
	<p>
		Naming directories is a matter of personal preference and whatever
		style guidelines we're required to follow. Here are some practices that
		might make our lives easier.
	</p>
	<p>
		<span class="topic">Characters to Avoid.</span> There are characters
		that should never be used when naming files because they almost always
		have a special meanings for the operating system:
	</p>
	<figure class="table">
		<table class="api">
			<thead>
				<th colspan="7" class="center">Special Characters</th>
			</thead>
			<tr>
				<td><span class="monoText">/</span></td>
				<td><span class="monoText">\</span></td>
				<td><span class="monoText">"</span></td>
				<td><span class="monoText">'</span></td>
				<td><span class="monoText">[]</span></td>
				<td><span class="monoText">{}</span></td>
				<td><span class="monoText">-</span></td>
			</tr>
			<tr>
				<td><span class="monoText">*</span></td>
				<td><span class="monoText">;</span></td>
				<td><span class="monoText">?</span></td>
				<td><span class="monoText">()</span></td>
				<td><span class="monoText">~</span></td>
				<td><span class="monoText">!</span></td>
				<td><span class="monoText">$</span></td>
			</tr>
		</table>
	</figure>

	<p>
		<span class="topic">Indicating Spaces.</span> To indicate spaces in a
		file name, use either: <span class="monoText">camelCasing</span>,
		<span class="monoText">PascalCasing</span>, or
		<span class="monoText">pothole_casing</span>. Avoiding the use of
		whitespace can save a lot of headache later down the line with file
		paths and projects involving file I/O.
	</p>

	<p>
		<span class="topic">Dates.</span> If the name includes dates, many
		style guides recommend the ISO format:
		<span class="monoText">YYYYMMDD</span>. Whatever format is chosen, the
		more important point is to be consistent.
	</p>

	<p>
		<span class="topic">Numbers.</span> If the name includes numbers, use
		two digits: 1 is <span class="monoText">01</span>, 9 is
		<span class="monoText">09</span>, etc. Again, whatever format is
		chosen, it is much more important to be consistent.
	</p>

	<p>Other guidelines include:</p>
	<ul>
		<li>Names should be descriptive and concise.</li>
		<li>
			If the file name includes a personal name, use the family name first,
			followed by initials.
		</li>
		<li>
			Order the elements in a name in the way that would be most efficient
			to retrieving the named entity.
		</li>
	</ul>
</section>

<section id="the_root_user">
	<h2>The Root User</h2>
	<p>
		On Linux and Mac OS, the <span class="italicsText">root user</span> is
		equivalent to the <span class="italicsText">administrator</span> on
		Windows. It has a <span class="boldItalics">user id</span> of 0. The
		<span class="italicsText">root user</span> can be described as the
		head, or superuser, of a system. It can do whatever it wants or needs
		in the system. Even if a file or directory cannot be accessed, written,
		or executed by anyone, the root user can access it.
	</p>

	<p>
		Most of the time, even if you own a computer, you will not be acting in
		a root user capacity. You will almost always be acting as a
		<span class="italicsText">normal user</span>. This stems from the
		<span class="boldItalics">principle of least privilege</span>, which
		states that, while in a computing environment, the user should only use
		the privileges necessary to accomplish legitimate purposes, since
		interacting with a computing environment with unlimited privileges can
		lead to damaging, potentially permanently, the environment.
	</p>
</section>

<section id="sudo_user">
	<p>
		<span class="topic">The <span class="monoText">sudo</span> User.</span>
		But, if we want to use the terminal as the
		<span class="italicsText">root user</span>, we can preface our commands
		with the word <span class="monoText">sudo</span> ("do as superuser").
		By prefacing our commands with <span class="monoText">sudo</span>, we
		are indicating to the computer that we are running the following
		commands as the root user rather than as the users we actually are.
	</p>

	<p>
		<span class="topic">When to use <span class="topic">sudo</span>?</span>
		If we enter the command <span class="monoText">cd //</span> (on Mac OS)
		or <span class="monoText">cd /sys</span> (on Linux), we can access the
		<span class="italicsText">kernel parameters</span>, which constitute
		the core of the computer. But, if we try to use the angle bracket
		syntax or the pipe syntax to change these files, we get a
		<span class="monoText">permission denied</span>.
	</p>

	<p>
		This is because these are kernel files, and we have to be very careful
		about changing them. If we are sure want to change these files, we need
		to preface our commands with the
		<span class="monoText">#</span> symbol. This tells the computer, "run
		this as root."
	</p>

	<p>
		To get around having to write the <span class="monoText">#</span> each
		time for commands, we can open a
		<span class="boldItalics">root terminal</span> with the
		<span class="monoText">sudo su</span> command. To exit the root
		terminal, we enter the <span class="monoText">exit</span> command.
		While opening a root terminal is relatively easy, we almost always
		never want to be in a root terminal. It's too dangerous. So, another
		way to ensure that our commands are executed as a root user is to use
		the pipe character:
	</p>

	<figure class="math-display">
		<pre class="language-pseudo"><code>
			command_1 | command_2
		</code></pre>
	</figure>

	<p>
		The above code says, take the output of
		<span class="italicsText">command_1</span>, and pipe it to
		<span class="italicsText">sudo command_2</span>.
	</p>
</section>

<section id="ports">
	<h2>Ports</h2>
	<p>
		To determine which TCP ports are being used, we can run (on Unix
		systems):
	</p>
	<pre class="language-bash command-line"><code>
		lsof -i tcp:&lt;port-number&gt;
		kill -9 &lt;PID&gt;
	</code></pre>
	<p>Alternatively, we can simply run:</p>
	<pre class="language-bash command-line"><code>
		npx kill-port &lt;port-number&gt;
	</code></pre>
	<p>and to kill multiple ports:</p>
	<pre class="language-bash command-line"><code>
		npx kill-port &lt;port-1&gt; &lt;port-2&gt; ... &lt;port-n&gt;
	</code></pre>
	<p>If none of the above work, we can use:</p>
	<pre class="language-bash"><code>
		sudo lsof -i:&lt;port-number&gt;
		sudo kill &lt;PID&gt;
	</code></pre>
	<p>On Windows:</p>
	<pre class="language-bash command-line"><code>
		netstat -ano | findstr :&lt;port-number&gt;
		tskill &lt;PID&gt;
	</code></pre>
</section>
{% endblock %}
