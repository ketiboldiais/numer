{% extends '../layout.html' %} {% load static %} {% block description %}
<meta name="description" content="Notes on software licensing" />
{% endblock %} {% block title %}
<title>Software Licensing</title>
{% endblock %} {% block content %}
<h1>Software Licensing</h1>

<section id="intro">
	<p>
		<q>Don't repeat yourself.</q> This is arguably the most oft-repeated
		phrase in software engineering. The idea behind the phrase is simple:
		If it's been written, don't write it again. This concept is so deeply
		rooted in software engineering that its acronym might as well be
		written across stone tables &mdash; DRY. Professors recite DRY as a
		foundational principle in programming, senior engineers as a sound
		piece of wisdom, and colleagues as a witticism.
	</p>
	<p>
		And rightly so. The modern software developer's most valuable resource
		isn't broadband internet, ${64}$-bit registers, or quad-core
		processors. Those are all luxuries. The developer can get by with
		dial-up, ${16}$-bit registers, and floppy disks, however bleak it may
		be. The developer's most valuable resource is, and always has been,
		<i>human time.</i>
	</p>
	<p>
		The fact is, when we allocate the seconds spent sleeping, eating,
		drinking, fulfilling social obligations, and dealing with &mdash; to
		quote Justice Stevens &mdash; <q>life's vagaries,</q> only a small
		fraction of the developer's lifespan is left for actual
		development.<sup></sup> The software developer's existence is a never
		ending battle on two fronts &mdash; allocating time to keep their
		software functioning, and allocating time to keep themselves
		functioning. Recognizing this challenge, DRY serves as a time saving
		measure. To understand how, we must briefly define software.
	</p>
	<div class="note">
		<p>
			<i>Crawford v. Marion County Election Board</i>, 553 U.S. 181 (2008).
		</p>
	</div>
	<p>
		From a high-level view, software isn't that different from any other
		product. For example, consider a Boeing 747. The 747 is a remarkably
		complex machine. It has numerous components &mdash; a flightdeck,
		cabin, fuselage, powerplant, landing gear, aerodynamics system,
		communications system, and so on. These are all major components,
		comprised of smaller components. The aerodynamics system consists of
		two wings, a vertical tail, and two stabilizers. Within each of these
		components are smaller components. A wing consists of ailerons,
		spoilers, and flaps. Each of these components consists of components,
		each of those components consist of components, and so on.
	</p>
	<p>
		Software is no different. Take Microsoft Word for example. Clicking on
		the Word icon, a window opens, and we see an instance of software with
		a dizzying array of components. There's a toolbar, a menu bar, and a
		document window. Within each of these components are more components.
		The toolbar consists of many tabs: <i>Home</i>, <i>Insert</i>,
		<i>Page Layout</i>, <i>View</i>, and more. Within <i>Home</i>, we see
		components for changing the font family, font size, text color, and so
		on.
	</p>
	<p>
		Looking closely at some of <i>Word</i>'s components, we might notice
		that some are text fields (the user can pass any input they'd like),
		some are dropdown menus (the user can only specify one among multiple),
		and others are buttons (the user can only specify on or off). This is
		where we see DRY in action: To manufacture the buttons, we don't make
		hundreds of different button designs. We make a single, general button
		design, and <i>reuse</i> that design to manufacture all of the buttons.
		Some buttons are longer than others, so we make variant of the general
		design for long buttons, and use this generalized variant for the
		longer buttons. Some are shorter, so we make a variant of the general
		design for short buttons, and use this variant for the shorter buttons.
		This saves a considerable amount of time. It is faster to write one
		design and share it across a thousand components than it is to write a
		thousand designs for a thousand components.
	</p>
	<p>
		Because of DRY, software developers have a gut instinct when they
		encounter difficult problems in the production process: Go to Google
		and search for existing solutions. For example, rendering a 3D sphere
		on a website is a fairly challenging problem. The software developer
		could write their own code in WebGL, but unless they know what they're
		doing, that could easily take months. A faster solution would be to use
		an existing solution like ThreeJS, a piece of software that outputs
		WebGL code in just a few lines. If the software developer opts to use
		ThreeJS &mdash; a software product made by another software developer
		&mdash; ThreeJS is called a <b>dependency</b>.
	</p>
	<p>
		This application of DRY &mdash; using dependancies &mdash; is not
		without its risks. The risk most software developers are aware of is
		<i>dependency support</i>. By using a dependency, the developer's
		personal product is tied to a product she has no control over. If the
		dependency malfunctions or its manufacturer ceases to support it, the
		software developer's personal product suffers the consequences.
	</p>
	<p>
		That risk, however, only occurs if the software developer can use the
		dependency in the first place. Whether a dependency can be used turns
		on a variety of factors: How stable is the dependency? I.e., how much
		will the software developer have to change her product in response to
		the dependency's changes? How large is the dependency? How fast is the
		dependency? These are all production and shipping factors. Not included
		in this list, and unfortunately often ignored, is
		<i>licensing</i>: Can the software developer comply with the
		dependecy's license?
	</p>
	<p>
		Failing to comply with a dependency's license is a compliance risk that
		can lead to significant legal costs. This article attempts to aid
		developers avoid this risk in four parts. Part I presents an overview
		of foundational law behind software licenses. Part II provides an
		overview of the most common licenses and their risks. Part III presents
		various ways to mitigate those risks. The article then concludes with
		some remarks on deciding which software licenses to use when releasing
		software products.
	</p>
</section>

<section id="software_licenses">
	<h2>Software Licensing Law</h2>
	<p>
		In the United States, software is considered a literary work.<sup
		></sup> And because software is a literary work, it is protected under
		U.S. copyright law. This protection gives the software creator the
		right to copy: the exclusive right to reproduce, publish, sell, and
		distribute the software. Because this right is exclusive, software
		creators can prevent others from reproducing, publishing, selling, or
		distributing their software by exercising their right to copy &mdash;
		filing, or threatening to file, a copyright infringement claim in
		court.
	</p>
	<div class="note">
		<p>17 U.S.C. ยง 117 (1998).</p>
	</div>
	<p>
		A software license is ultimately a contract of the right to copy,
		between two parties: A
		<i>licensor</i> (the software's creator), and a <i>licensee</i> (the
		software's user). In exchange for a specified set of promises by the
		licensee, the licensor promises not to exercise her right to copy,
		either partially or entirely.
	</p>
	<p>
		That said, not all software is licensed. Some software is released to
		the public without any licensing. Such software is considered
		<b>public domain software</b>, and is not copyright protected. Public
		domain software is fairly rare today, but there are a few examples:
		SQLite, youtube-dl, CERN's httpd, and SHA-3.
	</p>
	<p>
		Other software is not released to the public at all, held exclusively
		by its creators. This software is considered
		<b>private unlicensed software</b>, and <i>is</i> copyright protected.
		Examples include Sony's secret in-house game engines, or Electronic
		Art's Frostbite game engine.
	</p>
	<p>
		This article will not address unlicensed software beyond these two
		meager paragraphs. For our purposes, it's sufficient to say that using
		public domain software carries low legal risk, if any, and using
		private unlicensed software is extremely risky and should not be done.
	</p>
	<p>
		Returning to licenses: What a licensee's promises are, and how the
		licensor limits her right to copy, varies by license. Some licenses
		require many promises from the licensee, others one or two. Some
		licenses require the licensor to forgo exercising her right to copy at
		all times, others under specified conditions. Fortunately, because
		software licenses share the common thread of contracting the right to
		copy, we can classify them by type.
	</p>
</section>

<section id="license_categories">
	<h2>Software License Types</h2>
	<p>
		There are two main types of software licenses under copyright law: (1)
		<b>proprietary licenses</b> (also called <i>closed source licenses</i>)
		and (2) <b>free licenses</b> (also called <i>open source licenses</i>).
	</p>
	<p>
		Complying with open source and closed source licenses require entirely
		different processes. To begin, because software licenses are contracts
		between private parties, enforcement mechanisms differ. We begin by
		examining closed licenses, then move on to consider open licenses.
	</p>
</section>

<section id="proprietary_licenses">
	<h2>Proprietary Licenses</h2>
	<p>
		A properietary license is any license that is not considered a free
		license. The most common characteristic among properietary licenses is
		some restriction on use, modification, distribution, or all three.
		Proprietary licenses are most commonly found with commercial software
		&mdash; Mac OS X, Windows, the Microsoft Office Suite, Adobe Photoshop,
		and so on.
	</p>
</section>

<section id="open_source_licenses">
	<h2>Open Source Licenses</h2>
	<p>
		In industry, the term <q>open source</q> has a very specific meaning.
		For software to be considered open source, it must have an open source
		license. To have an open source license, authors have two choices: (A)
		Choose from a list of approved licenses, or (B) create their own.
	</p>
	<p>If the author decides (A), the list of approved licenses includes:</p>
	<ol>
		<li>Apache License 2.0</li>
		<li>GNU General Public License</li>
		<li>GNU Lesser General Public License (LGPL)</li>
		<li>MIT License</li>
		<li>BSD 3-Clause "New" or "Revised" License</li>
		<li>BSD 2-Clause "Simplified" or "FreeBSD" License</li>
		<li>Mozilla Public License</li>
		<li>Comment Development and Distribution License</li>
		<li>Eclipse Public License</li>
	</ol>
	<p>
		Each of these license templates are considered open source licenses, as
		defined by the <i>Open Source Initiative</i> (OSI). For a license to be
		considered open source, it must comply with OSI's ten-commandment
		definition:
	</p>
	<ol>
		<li>
			The license cannot restrict others from distributing or selling the
			software as a component of a larger software containing programs from
			different sources.
		</li>
		<li>
			The license must allow the distribution of source code and compiled
			source code.
		</li>
		<li>The license must allow modifications and derived works.</li>
		<li>
			If the license restricts source-code from being distributed in
			modified form, then it must allow distribution of
			<q>patch files</q> for modifying the program at build time.
		</li>
		<li>
			The license cannot discriminate against any person or group of
			persons.
		</li>
		<li>
			The license cannot restrict anyone from making use of the program in
			a specific field of endeavor.
		</li>
		<li>
			The rights attached to the program must apply to all distributees,
			without the need for an additional license.
		</li>
		<li>The license must not be specific to a product.</li>
		<li>The license must not place restrictions on other software.</li>
		<li>
			The license cannot be predicated on an individual technology or style
			of interface.
		</li>
	</ol>
	<p>
		These ten criteria raise challenges on two fronts: (1) Complying with
		an open source license, and (2) advertising software as open source. We
		examine each of these types of challenges in turn.
	</p>

	<section id="compliance_challenges">
		<h3>Open Source Compliance Challenges</h3>
		<p>
			On its face, open source licenses may not seem that difficult to
			comply with, but this misconception can lead to significant problems.
			This is apparent when we consider the data on open source license
			usage.
		</p>
		<p>
			The line plot below presents license usage from 2010 to April 2022.
			The data was gathered through a customized Python web scraper, which
			crawled WhiteSource.com and BlackDuck.com for publicly available
			data. Both WhiteSource.com and BlackDuck.com are software license
			compliance firms, providing a variety of services. One of those
			services is collecting metrics on license usage.
		</p>
		<figure class="block">
			<div id="license_trends"></div>
			<figcaption>
				Key: Red maps to the Apache License, blue for the GPL license, and
				green for the MIT license.
			</figcaption>
		</figure>
		<p>
			Importantly, some of the data gathered above had to be estimated at
			the processing stage. This is because much of the data is
			proprietary, and exact data values could not be found from 2017 to
			2020.
		</p>
		<p>
			Because of this shortcoming, an alternative webscrape was done. The
			largest source code repository system, Github, provides a search tool
			for filtering repositories by license and year. Writing another web
			scraper to gather the results of the search queries, we have another
			view of quantifying license popularity:
		</p>
		<figure class="block">
			<div id="github_license_trends"></div>
			<figcaption>
				Key: Orange maps to the MIT license, blue to the GPL license, red
				to the Apache License, purple for the BSD 3-clause license, and
				green for the LGPL license.
			</figcaption>
		</figure>
		<p>
			Interestingly, the data gathered from the web scrape of
			WhiteSource.com and BlackDuck.com indicate some discrepancy in the
			popularity of licenses in the industry as a whole, compared to the
			popularity of licenses on Github. For example, the industry web
			scrape indicate that the Apache license was the most popular license
			in 2010, while the MIT license was the most popular license on
			Github.
		</p>
		<p>
			One possible explanation for this discrepancy is Github's user base.
			As a public repository, Github is much more likely to host users
			creating personal projects rather than industrial software products.
		</p>
		<p>
			Despite the discrepancy, both data sets indicate that the two most
			popular licenses &mdash; as of the past decade &mdash; are the MIT
			license and GPL license. These are two very different licenses,
			despite compliance with the OSI definition of open source. The MIT
			license is considered a <i>free license</i>, while the GPL license is
			considered a <i>copyleft license</i>.
		</p>
		<p>
			The key difference between copyleft licenses and free licenses is
			that copyleft licenses are far more restrictive. Most notably,
			copyleft licenses require the licensee to use the same license as the
			software library used. This results in a recursive licensing scheme.
			If developer ${A}$ creates a software library ${L_1}$ with a copyleft
			license ${x,}$ developer ${B}$ uses ${L_1}$ to create a software
			library ${L_2,}$ then developer ${B}$ must license ${L_2}$ with the
			license ${x.}$ If another developer ${C}$ uses ${L_2}$ to create
			another library ${L_3,}$ then ${C}$ is bound to use license ${x.}$
			This restriction does not exist for free licenses.
		</p>
		<p>
			Based on the data, the open source compliance challenges software
			developers face will more than likely be either a broader copyleft or
			free license related issue. We examine each issue in the following
			sections.
		</p>

		<section id="apis">
			<h4>API Copyrights</h4>
		</section>

		<section id="modified_open_source_licenses">
			<h4>Modified Open Source Licenses</h4>
		</section>

		<section id="attribution">
			<h4>Attribution</h4>
			<p>
				Each of the common open source licenses require some form of
				attribution to the original author. Failure to provide attribution
				can lead to both legal and reputational risks.
			</p>
		</section>

		<section id="advertisting_as_open_source">
			<h4>Advertising as Open Source</h4>
			<p>
				One compliance risk developers should be aware of is advertising
				their products as open source when they are not. This is
				essentially false advertising, and it can generate significant
				costs.
			</p>
			<p>
				An illustrative case is Facebook's release of React, an open source
				software library for creating user interfaces.
			</p>
		</section>

		<section id="recursive_licenses">
			<h4>Copyleft Licenses</h4>
		</section>

		<section id="dead_projects">
			<h4>Dead Projects</h4>
			<p>
				Another difficulty with open source licensing compliance is when
				the licensed software is <i>dead</i>, in the sense that the
				community backing the project is no longer active. For example,
				consider the library dagrejs, which provides that the project is no
				longer maintained and without active project members.<sup
				></sup> The project is still licensed, but it's unclear who, or
				what, the developer should reach out to for license queries.
			</p>
			<div class="note">
				<p>https://github.com/dagrejs/dagre</p>
			</div>
		</section>
	</section>
</section>

<section id="closed_licenses">
	<h2>Closed Licenses</h2>
	<p>
		There are three methods of closed license enforcement: (1) Licensors
		pursuing civil claims in court, (2) federal criminal law, and (3)
		standards-setting organizations.
	</p>

	<section id="federal_enforcement">
		<h3>Federal Enforcement</h3>
		<p>
			A common example of violating a closed source license is
			<i>pirating</i> software. Because pirating involves modification and
			distribution of proprietary software, licensors can enforce their
			licenses through the Digital Millenium Copyright Act (DMCA). Perhaps
			more importantly, the DMCA criminalizes the unauthorized reproduction
			and distribution of copyrighted software, and grants the Federal
			Bureau of Investigation authority to investigate violations.
		</p>
	</section>
</section>

<!-- <h1>Developing and Enforcing Standards in the Software Industry</h1>
<section id="standards_compliance">
	<p>
		This article presents a broad overview of how standards are developed
		and implemented in the software industry. Examining the history of how
		these standards are developed and enforced, we can find parallels to
		similar developments in the law. Working within these parallels, we can
		identify which development and enforcement approaches worked and
		failed. This article argues that these failures can help identify
		compliance approaches today with greater likelihoods of failure.
	</p>
</section>

<section id="standards_v_rules">
	<h2>Standards or Rules?</h2>
	<p>
		At the highest level, all software products comply with some standard.
		For example, Mac OS X, Apple's proprietary operating system, complies
		with the UNIX standard. Google Chrome complies with WHATWG's web
		standards. The text we type into a Word Document complies with the
		UNICODE standard.
	</p>
	<p>
		At the lower levels, software products comply with rules. For example,
		if a user enters an incorrect password to a particular account, there's
		a rule &mdash; implemented by the software product's developers &mdash;
		providing that the user is prohibited from entering the account. If the
		user enters the password incorrectly three times, there might be
		another rule requiring that the account be locked, and no further
		attempts are permitted. But why three? Why not four? Or five?
	</p>
	<p>
		The answer is because the product's architects &mdash; engineers
		overseeing teams of engineers &mdash; exercised their discretion in
		determining that three was the optimal amount to comply with some
		standard. That standard is set by some private organization: Perhaps
		WHATWG for web development, PCI DSS for credit card transactions,
	</p>
</section>

<section id="successful_standards">
	<h2>Successful Standards</h2>
	<p>
		In this section, we present some case studies of successful standards,
		and the compliance approaches they've taken to maintain that success.
	</p>
</section>

<section id="failed_standards">
	<h2>Failed Standards</h2>
	<p>
		In this section, we present some case studies of failed standards. The
		cases presented examine several common instances of failure:
	</p>
	<ol>
		<li>
			The standards-setting entity fails to reach a consensus and
			deadlocks.
		</li>
		<li>
			The standards-setting entity releases a standard, but the standard is
			ignored.
		</li>
		<li>
			The standards-setting entity releases a standard, but the standard
			cannot be enforced.
		</li>
		<li>
			The standards-setting entity is released and enforced, but fails to
			achieve its purposes.
		</li>
	</ol>
	<section id="deadlocks">
		<h3>Deadlocks</h3>
		<p>
			Before a standard ever applies, the standards entity must reach a
			consensus on what the standard should be. This is a difficult task.
			As Cass Sunstein wrote,
			<q
				>a standard &hellip; needs a good deal of specification to be used
				to resolve individual cases.</q
			><sup></sup> Given that standards entities in the software industry
			commonly consist of different firms, individual interests can prevent
			the standards entity from progressing in specification.
		</p>
		<div class="note">
			<p>Problems with Rules, Sunstein, 967.</p>
		</div>
		<p>
			An illustrative case of the deadlock is Sun Microsystem's attempt to
			standardize the Java language. In 1999, Sun submitted their proposed
			standard to the ECMA standards consortium for standardization.<sup
			></sup> After the first meeting, Sun withdrew their proposal because
			ECMA's intellectual property interests were incompatible with Sun's.
			Sun then approached another standards organization, ISO, for
			standardization. Once again, Sun withdrew its standards proposal.
			This time, because ISO had misunderstood parts of Sun's
			specifications. In the end, Java was never standardized.
		</p>
		<div class="note">
			<p>Tineke M. Egyedi, Why Java Was not Standardized Twice, 253</p>
		</div>
		<p>
			The deadlock mode of failure is not unique to the software industry.
			As Gary C. Bryner wrote, implementations can fail to gain traction
			<q>because of a lack of political will or agreement.</q
			><sup></sup> Deadlocks are not uncommon in the legal world &mdash;
			bills failing to pass in Congress, judges failing to reach a
			majority, or a team of administrators failing to agree on a
			particular solution.
		</p>
		<div class="note">
			<p>Bryner, Public Organizations & Public Policies, 302.</p>
		</div>
		<p>
			The solution to deadlocks is obvious: The members of a
			standards-setting organization should be clear on what their
			interests are, and to settle any differences <i>before</i> the
			specification process.
		</p>
		<p>
			The illustrative case in the software industry is the standardization
			of PDF.
		</p>
	</section>
</section> -->

<script src="https://d3js.org/d3.v7.min.js"></script>
<script type="module" src="../../../static/numerc/csmd/csmd.mjs"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mermaid/9.0.0/mermaid.min.js"></script>
<script
	type="module"
	src="../../../static/numerc/scripts/des_licensing.js"
></script>
{% endblock %}
