{% extends '../layout.html' %} {% load static %} {% block description %}
<meta name="description" content="Notes on the tree data structure" />
{% endblock %} {% block title %}
<title>Trees</title>
{% endblock %} {% block content %}
<h1>Binary Trees</h1>

<section id="binary_tree_implementation">
	<p>There are two ways to implement binary trees:</p>
	<ol>
		<li>array implementation</li>
		<li>linked list implementation</li>
	</ol>
	<p>We begin first with the array implementation.</p>
	<section id="array_implemented_binary_tree">
		<h3>Array-implemented Binary Trees</h3>
		<p>
			As its name implies, an <b>array-implemented binary tree (ABT)</b> is
			a binary tree implemented, and represented, with an array. First, we
			have the following binary tree, with an accompanying array:
		</p>
		<div id="abt1"></div>
		<div id="abt1_array"></div>
		<p>
			The challenge: How do we store each node in this binary tree in the
			array such that the relationships between the nodes are preserved?
			For example, <var>B</var> is the left child of <var>A</var>, and
			<var>C</var> is the right child of <var>A</var>. How is that
			information preserved in an array implementation?
		</p>
		<p>
			Here's an idea: Use the array's indices. Let's start by storing the
			elements from the top generation to the bottom generation, left to
			right. At ${L = 1,}$ we have a single node, <var>A</var>. So we store
			in the array:
		</p>
		<div id="abt1_array_level1"></div>
		<p>
			At ${L = 2,}$ we have two nodes, <var>B</var> and <var>C</var>, so we
			store, from left to right, <var>B</var> then <var>C</var>:
		</p>
		<div id="abt1_array_level2"></div>
		<p>
			Then, we go on to ${L = 3,}$ and see that there are ${4}$ nodes
			&mdash; <var>D</var>, <var>E</var>, <var>F</var>, and <var>G</var>.
			Again we store the nodes from left to right:
		</p>
		<div id="abt1_array_level3"></div>
		<p>
			Let's construct a table to see if we can find a pattern. Suppose
			${i}$ is an index in the array, ${i_L}$ is the index of the left
			child, and ${i_R}$ is the index of the right child.
		</p>
		<table class="alg">
			<thead>
				<th>Element</th>
				<th>${i}$</th>
				<th>${i_L}$</th>
				<th>${i_R}$</th>
			</thead>
			<tbody>
				<tr>
					<td><var>A</var></td>
					<td>${0}$</td>
					<td>${1}$</td>
					<td>${2}$</td>
				</tr>
				<tr>
					<td><var>B</var></td>
					<td>${1}$</td>
					<td>${3}$</td>
					<td>${4}$</td>
				</tr>
				<tr>
					<td><var>C</var></td>
					<td>${2}$</td>
					<td>${5}$</td>
					<td>${6}$</td>
				</tr>
				<tr>
					<td><var>D</var></td>
					<td>${3}$</td>
					<td>${\varnothing}$</td>
					<td>${\varnothing}$</td>
				</tr>
				<tr>
					<td><var>E</var></td>
					<td>${4}$</td>
					<td>${\varnothing}$</td>
					<td>${\varnothing}$</td>
				</tr>
				<tr>
					<td><var>F</var></td>
					<td>${5}$</td>
					<td>${\varnothing}$</td>
					<td>${\varnothing}$</td>
				</tr>
				<tr>
					<td><var>G</var></td>
					<td>${6}$</td>
					<td>${\varnothing}$</td>
					<td>${\varnothing}$</td>
				</tr>
			</tbody>
		</table>
		<p>
			Examining the table, we see that at the first generation, the
			element's left child is offset by ${1,}$ and its right child is
			offset by ${2.}$ For the left node on the second generation, the
			element's left child is offset by ${2}$ and its right child is offset
			by ${3.}$ For the right node on the second generation, the element's
			left child is offset by ${3}$ and its right child is offset by ${4.}$
			Examining these mappings we that, to get the left child, we use:
		</p>
		<figure>$$ i_L = 2i + 1 $$</figure>
		<p>and to get the right child, we use:</p>
		<figure>$$ i_R = 2i + 2 $$</figure>
		<p>
			These two formulas allow us to access the left and right children.
			But what about the parents? Well, let's construct another table,
			where ${i_P}$ is the index of the given element's parent.
		</p>
		<table class="alg">
			<thead>
				<th>Element</th>
				<th>${i}$</th>
				<th>${i_P}$</th>
			</thead>
			<tbody>
				<tr>
					<td><var>A</var></td>
					<td>${0}$</td>
					<td>${\varnothing}$</td>
				</tr>
				<tr>
					<td><var>B</var></td>
					<td>${1}$</td>
					<td>${0}$</td>
				</tr>
				<tr>
					<td><var>C</var></td>
					<td>${2}$</td>
					<td>${0}$</td>
				</tr>
				<tr>
					<td><var>D</var></td>
					<td>${3}$</td>
					<td>${1}$</td>
				</tr>
				<tr>
					<td><var>E</var></td>
					<td>${4}$</td>
					<td>${1}$</td>
				</tr>
				<tr>
					<td><var>F</var></td>
					<td>${5}$</td>
					<td>${2}$</td>
				</tr>
				<tr>
					<td><var>G</var></td>
					<td>${6}$</td>
					<td>${2}$</td>
				</tr>
			</tbody>
		</table>
		<p>
			Examining this table, we see that given an element with the index
			${i,}$ the index of its parent is:
		</p>
		<figure>$$ i_P = \left\lfloor \dfrac{i}{2} \right\rfloor $$</figure>
		<p>
			This is a fairly useful piece of information, so we state it as a
			lemma:
		</p>
		<dfn>
			<small>Lemma</small>
			<p>
				Let ${A}$ be an array representing an array-implemented binary
				tree, and ${i}$ an index in the array. Given a branch node
				${A[i],}$ the left child of ${A[i]}$ has the index ${i_L,}$ where
			</p>
			<figure>$$ i_L = 2i + 1 $$</figure>
			<p>and the right child of ${A[i]}$ has the index ${i_R,}$ where</p>
			<figure>$$ i_R = 2i + 2 $$</figure>
		</dfn>
		<section id="variant_complete_binary_trees">
			<h3>Complete ABTs</h3>
			<p>
				Recall that a <i>perfect binary tree</i> is a binary tree where
				every branch node has exactly ${2}$ children, and a
				<i>complete binary tree</i> is a binary tree where (a) every node
				with a height greater than ${0}$ has ${2}$ children, and (b) the
				last generation is filled from left to right.
			</p>
			<p>
				We might have wondered why the prong (b) is a condition for the
				complete binary tree. Now that we're discussing implementations, we
				can see a helpful rationale. Consider the following perfect binary
				tree:
			</p>
			<div id="perfect_abt1"></div>
			<p>
				To implement this tree with an array, we go generation by
				generation, assigning nodes into the array from left to right:
			</p>
			<div id="perfect_abt1_array"></div>
			<p>Next, consider the following complete binary tree.</p>
			<div id="complete_abt1"></div>
			<p>
				Using the same storage order &mdash; generation by generation, left
				to right &mdash; we get:
			</p>
			<div id="complete_abt1_array"></div>
			<p>
				Here we see the first difference. With a perfect binary tree, we
				used all of the array's allocated spaces. With a complete binary
				tree, however, some of the spaces are unused. Now let's consider an
				<i>incomplete binary tree</i>:
			</p>
			<div id="incomplete_abt1"></div>
			<p>Implementing this tree as an array, we see:</p>
			<div id="incomplete_abt1_array"></div>
			<p>
				Examinining the array, we observe that with an incomplete binary
				tree, some of the allocated spaces are unused, and there are gaps.
				This presents an additional problem. As we saw with the array data
				structure, when there are gaps in the array, we must perform
				shifting to fill the gaps. That shifting is costly, and negates the
				benefits we gain from using a binary tree in the first place. For
				this reason, if our solution allows or requires the use of
				incomplete binary trees, ABTs are more than likely an unsuitable
				implementation.
			</p>
		</section>
	</section>

	<section id="tree_traversals">
		<h3>Tree Traversal</h3>
		<p>
			To <i>traverse</i> a data structure is to visit, or read, all of the
			structure's elements. In a linear data structure like an array, there
			are two traversal approaches:
		</p>
		<ol>
			<li>first to last (called <b>forward-linear traversal</b>), or</li>
			<li>last to first (<b>backward-linear traversal</b>).</li>
		</ol>
		<p>
			Data structures like binary trees, however, are non-linear. And
			because they're non-linear, they have several traversal approaches:
		</p>
		<ol>
			<li><i>preorder traversal</i></li>
			<li><i>inorder traversal</i></li>
			<li><i>postorder traversal</i></li>
			<li><i>generational traversal</i></li>
		</ol>
		<p>
			We examine each of these traversal approaches in turn. As we'll see,
			each traversal approach is best defined recursively.
		</p>

		<section id="pre_order_traversal">
			<h4>Preorder Traversal</h4>
			<p>Preorder traveral is defined as follows:</p>
			<dfn>
				<small>Procedure: Preorder Traversal</small>
				<p>Let ${B}$ be a binary tree. To traverse ${B}$ in preorder:</p>
				<ol>
					<li>Visit some node ${n}$ in ${B.}$</li>
					<li>Traverse the left subtree of ${n}$ in preorder.</li>
					<li>Traverse the right subtree of ${n}$ in preorder.</li>
				</ol>
			</dfn>
			<p>In pseudocode, the procedure looks like:</p>
			<ol class="alg">
				<li>fn preorder_traverse(tree):</li>
				<ol>
					<li>visit(node);</li>
					<li>preorder_traverse(left_subtree);</li>
					<li>preorder_traverse(right_subtree);</li>
				</ol>
			</ol>
			<p>
				Let's illustrate with a few examples. Consider the following tree:
			</p>
			<div id="_3node_preorder"></div>
			<p>
				We start by executing <var>visit(node)</var>. This means visiting
				the root, ${n_a:}$
			</p>
			<div id="_3node_preorder_visit"></div>
			<p>
				Then we execute <var>preorder_traverse(left_subtree)</var>. This is
				simply a recursive call of <var>preorder_traverse()</var>, with the
				left subtree of ${n_a}$ passed as an argument. Passing the left
				subtree of ${n_a}$ as an argument, we again call
				<var>visit(node)</var>. This means visiting the root of the tree,
				${n_b:}$
			</p>
			<div id="_3node_preorder_left_subtree"></div>
			<p>
				Because ${n_b}$ has no subrees, we finish the call
				<var>preorder_traverse(left_subtree)</var> and go to the next call,
				<var>preorder_traverse(right_subtree)</var>. This is the right
				subtree of ${n_a:}$
			</p>
			<div id="_3node_preorder_right_subtree"></div>
			<p>
				Putting these calls all together, for binary tree of order ${3,}$
				the traversal sequence is:
			</p>
			<figure>$$ (n_a, n_b, n_c) $$</figure>
			<p>
				If we had a left-skewed binary tree, the sequence would be ${(n_a,
				n_b).}$
			</p>
			<div id="_2nodeleft_preorder"></div>
			<p>
				The same goes for a right-skewed binary tree. Since there is no
				left-subtree, the next call is
				<var>preorder_traverse(right_subtree)</var>:
			</p>
			<div id="_2noderight_preorder"></div>
		</section>

		<section id="pre_order_traversal">
			<h4>Inorder Traversal</h4>
			<p>Inorder traveral is defined:</p>
			<dfn>
				<small>Procedure: Inorder Traversal</small>
				<p>Let ${B}$ be a binary tree. To traverse ${B}$ in inorder:</p>
				<ol>
					<li>Traverse the left subtree inorder.</li>
					<li>Visit a node.</li>
					<li>Traverse the right subtree inorder.</li>
				</ol>
			</dfn>
			<p>In pseudocode, the procedure looks like:</p>
			<ol class="alg">
				<li>fn inorder_traverse(tree):</li>
				<ol>
					<li>inorder_traverse(left_subtree);</li>
					<li>visit(node);</li>
					<li>inorder_traverse(right_subtree);</li>
				</ol>
			</ol>
			<p>To illustrate, let's use the following tree:</p>
			<div id="_3node_inorder"></div>
			<p>
				We start by executing <var>inorder_traverse(left_subtree)</var>.
				This means we start by traversing the left subtree. Here, the left
				subtree starts at ${n_b.}$ ${n_b}$ has no left subtree, so we call
				<var>visit()</var>.
			</p>
			<div id="_3node_inorder_visit"></div>
			<p>
				After <var>visit()</var> finishes executing, we call
				<var>inorder_traverse(right_subtree)</var>. But, since ${n_b}$ has
				no right subtree, the call does not execute, and the function call
				<var>inorder_traverse(left_subtree: ${n_a}$)</var> finishes. This
				leads us to <var>visit(node: ${n_a}$)</var>.
			</p>
			<div id="_3node_inorder_visit_root"></div>
			<p>
				Once we've visited ${n_a,}$ we then call
				<var>inorder_traverse(right_subtree: n_a)</var>. This subtree
				starts with the node ${n_c.}$ Because ${n_c}$ has no left subtree,
				we call <var>visit(node: ${n_c}$)</var>.
			</p>
			<div id="_3node_inorder_visit_right"></div>
			<p>
				Putting these calls all together, for a binary tree of order ${3,}$
				the inorder traversal sequence is:
			</p>
			<figure>$$ (n_b, n_a, n_c) $$</figure>
			<p>
				If we had a left-skewed binary tree, the sequence would be ${(n_b,
				n_a).}$
			</p>
			<div id="_2nodeleft_inorder"></div>
			<p>
				For a right-skewed binary tree, the sequence would be ${(n_a,
				n_c).}$ Since the root ${n_a}$ has no left subtree, we immediately
				visit ${n_c,}$ then traverse its right subtree. This results in
				visiting ${n_c.}$
			</p>
			<div id="_2noderight_inorder"></div>
		</section>

		<section id="postorder_traversal">
			<h4>Postorder Traversal</h4>
			<p>Postorder traversal is defined as follows:</p>
			<dfn>
				<small>Procedure: Postorder Traversal</small>
				<p>Let ${B}$ be a binary tree. To traverse ${B}$ in postorder:</p>
				<ol>
					<li>Traverse the left subtree postorder.</li>
					<li>Traverse the right subtree postorder.</li>
					<li>Visit the node.</li>
				</ol>
			</dfn>
			<p>In pseudocode:</p>
			<ol class="alg">
				<li>fn postorder_traverse(tree):</li>
				<ol>
					<li>postorder_traverse(left_subtree);</li>
					<li>postorder_traverse(right_subtree);</li>
					<li>visit(node);</li>
				</ol>
			</ol>
			<p>We illustrate with a binary tree of order ${3:}$</p>
			<div id="_3node_post_order_tree"></div>
			<p>
				We start by calling <var>postorder_traverse()</var> with ${n_a,}$
				the root, as an argument. I.e., we call
				<var>postorder_traverse(tree: ${n_a}$)</var>. Calling this
				function, results in the recursive call
				<var>postorder_traverse(left_subtree: ${n_a}$).</var> Because the
				left subtree of ${n_a}$ has as its root ${n_b,}$ the call
				<var>postorder_traverse(left_subtree: ${n_a}$)</var> is actually
				the call <var>postorder_traverse(tree: ${n_b}$)</var>. That call
				then results in calling
				<var>postorder_traverse(left_subtree: ${n_b}$).</var> But because
				${n_b}$ has no left subtree, we go to the next call,
				<var>postorder_traverse(right_subtree: ${n_b}$)</var>. But there is
				no right subtree of ${n_b,}$ so we call
				<var>visit(node: ${n_b}$).</var>
			</p>
			<div id="_3node_post_order_tree_visit_left"></div>
			<p>
				This finishes the call
				<var>postorder_traverse(left_subtree: ${n_a}$)</var>, so we call
				<var>postorder_traverse(right_subtree: ${n_a}$)</var>. Because the
				right subtree of ${n_a}$ has the root ${n_c,}$ the call is actually
				<var>postorder_traverse(tree: ${n_c}$)</var>. Thus, we call
				<var>postorder_traverse(left_subtree: ${n_c}$)</var> and
				<var>postorder_traverse(right_subtree: ${n_c}$)</var>, but because
				${n_c}$ has neither left nor right subtrees, we call
				<var>visit(${n_c}$).</var>
			</p>
			<div id="_3node_post_order_tree_visit_right"></div>
			<p>
				This finishes the call
				<var>postorder_traverse(right_subtree: ${n_a}$)</var>. All that's
				left to do is call <var>visit(node: ${n_a}$)</var>.
			</p>
			<div id="_3node_post_order_tree_visit_root"></div>
			<p>
				Summarizing, the traversal sequence for a binary tree of order
				${3}$ is:
			</p>
			<figure>$$ (n_b, n_a, n_c) $$</figure>
			<p>
				If the binary tree was left-skewed, the traversal sequence would be
				${(n_b, n_a).}$
			</p>
			<div id="left_skew_post_order"></div>
			<p>
				If the binary tree was right-skewed, the traversal sequence would
				be ${(n_c, n_a).}$
			</p>
			<div id="right_skew_post_order"></div>
		</section>

		<section id="generational_traversal">
			<h4>Generational Traversal</h4>
			<p>
				In <b>generational traversal</b>, also called
				<b>level-order traversal</b>, we traverse the tree generation by
				generation, from left to right.
			</p>
			<p>
				For example, for the binary tree below, we start at the first
				generation, which has only one node, the root ${n_a.}$
			</p>
			<div id="genverse_gen1"></div>
			<p>Then we start at the next generation, visiting from the left:</p>
			<div id="genverse_gen2_left"></div>
			<p>to the right:</p>
			<div id="genverse_gen2_right"></div>
			<p>
				Hence, for generational traversal, we have the traversal sequence
				${(n_a, n_b, n_c).}$ For a left-skewed tree, we have the traversal
				sequence ${(n_a, n_b).}$
			</p>
			<div id="genverse_gen2_skew_left"></div>
			<p>
				And for a right-skewed tree, we have the traversal sequence ${(n_a,
				n_c).}$
			</p>
			<div id="genverse_gen2_skew_right"></div>
		</section>

		<section id="comparing_traversals">
			<h4>Comparing Traversals</h4>
			<p>
				When working with binary tree data structures, we often want to
				quickly sketch in our minds what a particular approach's traversal
				sequence looks like. Having this sketch can be a powerful tool for
				gainign some traction on solving a problem. Accordingly, let's
				investigate some techniques for quickly determining a particular
				sequence.
			</p>
			<p>
				First, it's helpful to associate the traversal approaches with a
				few visit sequences. For the visit sequences in the table below,
				<var>L</var> stands for <q>visit the <i>left</i> subtree,</q>
				<var>root</var> stands for <q>visit the <i>root</i>,</q> and
				<var>R</var> stands for <q>visit the <i>right</i> subtree.</q>
			</p>
			<table class="alg">
				<thead>
					<th>Traversal</th>
					<th>Visit Sequence</th>
				</thead>
				<tbody>
					<tr>
						<td>Preorder</td>
						<td><var>root L R</var></td>
					</tr>
					<tr>
						<td>Inorder</td>
						<td><var>L root R</var></td>
					</tr>
					<tr>
						<td>Postorder</td>
						<td><var>L R root</var></td>
					</tr>
					<tr>
						<td>Generational</td>
						<td>Generation by generation, left to right</td>
					</tr>
				</tbody>
			</table>
			<p>
				Knowing this sequences can make traversal sequences for more
				complicated trees clearer. For example, consider the following
				tree:
			</p>
			<div id="big_traverse"></div>
			<p>
				Trying to determine the traversal sequence for any given traversal
				approach can appear daunting. The trick, however, is
				<i>divide and conquer</i>: Break the tree down into subtrees. In
				this case, let's break it down into a left-subtree (the nodes in
				blue) and a right-subtree (the nodes in purple):
			</p>
			<div id="big_traverse_subtree"></div>
			<p>
				Let's first consider preorder traversal. For preorder traversal, we
				have <var>root L R</var>. So, we write:
			</p>
			<figure>$$ a, (~~~~~)_{\texttt{L}}, (~~~~~)_{\texttt{R}} $$</figure>
			<p>
				Now we fill in the parentheses. First, the left subtree, following
				the same sequence, <var>root L R</var>:
			</p>
			<figure>
				$$ a, (b, d, e)_{\texttt{L}}, (~~~~~)_{\texttt{R}} $$
			</figure>
			<p>
				Then the right subtree, following the same sequence,
				<var>root L R</var>.
			</p>
			<figure>
				$$ a, (b, d, e)_{\texttt{L}}, (c, f, g)_{\texttt{R}} $$
			</figure>
			<p>Thus, the inorder traversal sequence for the tree is:</p>
			<div class="split">
				<figure>$$ (a, b, d, e, c, f, g) $$</figure>
				<div id="big_traverse_subtree_preorder"></div>
			</div>
			<p>
				Using the same method, let's try inorder traversal. For inorder
				traversal, the visit sequence is <var>L root R</var>. So we write:
			</p>
			<figure>$$ (~~~~~)_{\texttt{L}}, a, (~~~~~)_{\texttt{R}} $$</figure>
			<p>
				Now we fill in the subtree parentheses. Starting with the left
				subtree, we use the same sequence, <var>L root R</var>:
			</p>
			<figure>
				$$ (d, b, e)_{\texttt{L}}, a, (~~~~~)_{\texttt{R}} $$
			</figure>
			<p>
				Then we fill in the right subtree's parentheses, again using
				<var>L root R</var>:
			</p>
			<figure>
				$$ (d, b, e)_{\texttt{L}}, a, (f, c, g)_{\texttt{R}} $$
			</figure>
			<p>Hence, the inorder traversal sequence is:</p>
			<div class="split">
				<figure>$$ (d, b, e, a, f, c, g) $$</figure>
				<div id="big_traverse_subtree_inorder"></div>
			</div>
			<p>
				Now let's try postorder traversal. The visit sequence is
				<var>L R root</var>, so we have:
			</p>
			<figure>$$ (~~~~~)_{\texttt{L}}, (~~~~~)_{\texttt{R}}, a $$</figure>
			<p>
				Now we fill in the subtrees, again using <var>L R root</var>. For
				the left subtree:
			</p>
			<figure>
				$$ (d, e, b)_{\texttt{L}}, (~~~~~)_{\texttt{R}}, a $$
			</figure>
			<p>And for the right subtree:</p>
			<figure>
				$$ (d, e, b)_{\texttt{L}}, (f, g, c)_{\texttt{R}}, a $$
			</figure>
			<p>This yields the postorder traversal sequence:</p>
			<div class="split">
				<figure>$$ (d, e, b, f, g, c, a) $$</figure>
				<div id="big_traverse_subtree_postorder"></div>
			</div>
			<p>
				Finally, generational traversal is simple enough that we don't need
				to apply some visit sequence. We merely traverse the tree from the
				first generation to the last generation, visiting each node from
				left to right:
			</p>
			<div class="split">
				<figure>$$ (a, b, c, d, e, f, g) $$</figure>
				<div id="big_traverse_subtree_generational"></div>
			</div>

			<section id="traversal_sketching">
				<h5>Traversal Sketching</h5>
				<p>
					We can also determine traversal sequences through a technique
					called <b>traversal sketching</b>. To sketch a traversal, we
					first draw a horizontal line at the bottom of the tree. Then, we
					draw lines linking each node to this horizontal line.
				</p>
				<p>
					For preorder traversal, the links are drawn from left to right,
					starting at the root:
				</p>
				<figure>
					<img
						src="{% static 'images/preorder_sketch.svg' %}"
						alt="preorder sketch"
						loading="lazy"
						style="width: 250px"
					/>
					<figcaption>Preorder: ${(a, b, d, e, c, f, g)}$</figcaption>
				</figure>
				<p>
					For inorder traversal, the links are drawn from left to right:
				</p>
				<figure>
					<img
						src="{% static 'images/inorder_sketch.svg' %}"
						alt="inorder sketch"
						loading="lazy"
						style="width: 250px"
					/>
					<figcaption>Inorder: ${(d, b, e, a, f, c, g)}$</figcaption>
				</figure>
				<p>
					And for postorder traversal, the links are drawn from right to
					left, starting at the root:
				</p>
				<figure>
					<img
						src="{% static 'images/postorder_sketch.svg' %}"
						alt="postorder sketch"
						loading="lazy"
						style="width: 250px"
					/>
				</figure>
				<figcaption>Postorder: ${(d, e, b, f, g, c, a)}$</figcaption>
				<p>
					Another way to sketch a traveral sequence is
					<b>tree contouring</b>. The idea is that we draw a path along the
					tree's outline. For each of the traversal approaches, we place a
					tick on either the left, bottom, or right. Each time the countour
					crosses a tick, we record the ticked node.
				</p>
				<p>
					With preorder traversal, the tick is placed on the lefthand side
					of the node:
				</p>
				<figure>
					<img
						src="{% static 'images/preorder_contour.svg' %}"
						alt="preorder contour"
						loading="lazy"
						style="width: 180px"
					/>
				</figure>
				<p>
					With inorder traversal, the tick is drawn on the bottom of the
					node:
				</p>
				<figure>
					<img
						src="{% static 'images/inorder_contour.svg' %}"
						alt="inorder contour"
						loading="lazy"
						style="width: 180px"
					/>
				</figure>
				<p>
					And with postorder traversal, the tick is drawn to the right of
					the node:
				</p>
				<figure>
					<img
						src="{% static 'images/postorder_contour.svg' %}"
						alt="postorder contour"
						loading="lazy"
						style="width: 180px"
					/>
				</figure>
			</section>
		</section>
	</section>
</section>

<section id="linked_list_implemented_binary_tree">
	<h2>Linked-list-implemented Binary Trees</h2>

	<section id="background">
		<p>
			The <b>linked-list-implemented binary tree (LBT)</b> looks similar to
			a general linked list in implementation. Usually, there's a
			<i>root pointer</i>, a pointer in the stack whose pointee is the
			<i>root</i> of the binary tree. For the binary tree, each node has
			${2}$ <i>next fields</i> &mdash; one for a
			<var>leftChild</var> pointer and one for the
			<var>rightChild</var> pointer, and ${1}$ <i>data field</i>.
			Furthermore, each node in the tree, other than the root node, is the
			lone pointee of another node.
		</p>
		<figure>
			<img
				src="{% static 'images/binary_tree_implementation.svg' %}"
				alt="Binary tree implementation"
				loading="lazy"
				style="width: 370px"
			/>
		</figure>
		<p>For example, suppose we had the following binary tree:</p>
		<div id="lbt1"></div>
		<p>This tree would be implemented as:</p>
		<figure>
			<img
				src="{% static 'images/lbt1_implementation.svg' %}"
				alt="Binary tree implementation"
				loading="lazy"
				style="width: 250px"
			/>
		</figure>
		<p>
			If we look at the representation, we see that there are ${7}$ nodes,
			corresponding to the ${7}$ elements we seek to store. Notice that
			with ${7}$ nodes, there are ${8}$ null pointers. If there are ${N}$
			nodes, then are ${N + 1}$ null pointers.
		</p>
		<p>
			To begin, we need to implement the basic <var>Node</var> data
			structure, as we saw with linked lists, along with its constructor:
		</p>
		<ol class="alg">
			<li>struct Node:</li>
			<ol>
				<li>int data;</li>
				<li>struct Node* left_child;</li>
				<li>struct Node* right_child;</li>
				<li></li>
				<li>fn newNode(int data):</li>
				<ol>
					<li>Node node = malloc(sizeof(node));</li>
					<li>(*node).data = data;</li>
					<li>(*node).left_child = null;</li>
					<li>(*node).right_child = null;</li>
				</ol>
			</ol>
		</ol>
	</section>

	<section id="dynamic_tree_constructor">
		<h3>Dynamic Tree Constructor</h3>
		<p>
			Once we have the node record, we want to think about how to
			<i>generate</i>, or create, the binary tree. In this section, we
			focus on a <b>dynamic tree constructor</b> &mdash; a tree constructor
			that generates a tree at runtime. The ideal starting point is the
			tree's root. Once we have a root, we create the root's left-child and
			right-child. That said, we have to keep in mind that there are four
			possiblities for a given node ${n}$'s lineage:
		</p>
		<ol>
			<li>${n}$ is leaf &mdash; it has ${0}$ children.</li>
			<li>
				${n}$ is left-uniparous &mdash; it has exactly ${1}$ left-child.
			</li>
			<li>
				${n}$ is right-uniparous &mdash; it has exactly ${1}$ right-child.
			</li>
			<li>${n}$ is full &mdash; it has exactly ${2}$ children.</li>
		</ol>
		<p>
			These conditions boil down to two questions: (1) Does a left-child
			exist? (2) Does a right-child exist?
		</p>
		<figure>
			<table class="alg">
				<thead>
					<th>${\exists (\texttt{left-child})}$</th>
					<th>${\exists (\texttt{right-child})}$</th>
					<th><var>node is</var></th>
				</thead>
				<tbody>
					<tr>
						<td><var>true</var></td>
						<td><var>true</var></td>
						<td><var>full</var></td>
					</tr>
					<tr>
						<td><var>true</var></td>
						<td><var>false</var></td>
						<td><var>left-uniparous</var></td>
					</tr>
					<tr>
						<td><var>false</var></td>
						<td><var>true</var></td>
						<td><var>right-uniparous</var></td>
					</tr>
					<tr>
						<td><var>false</var></td>
						<td><var>false</var></td>
						<td><var>leaf</var></td>
					</tr>
				</tbody>
			</table>
		</figure>
		<p>
			To illustrate, we'll use the following binary tree, called
			<var>B1</var>:
		</p>
		<div id="tree_b1"></div>
		<p>
			To implement the tree above, we will generate the binary tree
			generation by generation, from left to right. More specifically, we
			generate the tree using a <i>queue</i>.
		</p>
		<ol class="alg">
			<li>Queue queue = newQueue();</li>
		</ol>
		<div id="tree_b1_queue"></div>
		<p>With the queue, we use the following procedure:</p>
		<ol class="proc">
			<li>Create a root node.</li>
			<li>Enqueue the address of the root node into <var>queue</var>.</li>
			<li>
				Dequeue the address of the new node, name that address the pointer
				<var>p</var>.<sup></sup>
			</li>
			<li>
				Using <var>p</var>, ask: Does <var>p</var> have a left child?
			</li>
			<ol>
				<li>Yes ${\implies}$ go to step 4.</li>
				<li>No ${\implies}$ go to step 5.</li>
			</ol>
			<li>Create a pointer <var>t</var>.</li>
			<li>Create a new node and assign it to <var>t</var>.</li>
			<li>
				Initialize <var>p</var>'s <var>left_child</var> pointer as
				<var>t</var>.
			</li>
			<li>
				Initialize <var>p</var>'s <var>right_child</var> pointer as
				<var>t</var>.
			</li>
			<li>
				Using <var>p</var>, ask: Does <var>p</var> have a right child?
			</li>
			<ol>
				<li>Yes ${\implies}$ go to step 4.</li>
				<li>No ${\implies}$ go to step 5.</li>
			</ol>
			<li>Enqueue the address of <var>t</var> into <var>queue.</var></li>
			<li>Return to step 3.</li>
		</ol>
		<div class="note">
			<p>
				The operation <var>dequeue()</var> returns the address of the
				dequeued queuer.
			</p>
		</div>
		<p>
			Applying this procedure, the first step is to create the root node.
			For our tree <var>B1</var>, this is the node ${n_5.}$
		</p>
		<ol class="alg">
			<li>Node root = newNode(5); <var>address: F0</var></li>
			<li>Queue queue = newQueue();</li>
		</ol>
		<p>
			Let's say the address of <var>root</var> is some address
			<var>F0</var>. We take that address, and insert it into the queue:
		</p>
		<ol class="alg">
			<li>Node root = newNode(5);</li>
			<li>Queue queue = newQueue();</li>
			<li>queue.enqueue(root);</li>
		</ol>
		<p>
			With these steps performed, we now have the first node in our tree:
		</p>
		<div class="split">
			<div id="tree_b1_queue_with_root"></div>
			<div id="tree_b1_1"></div>
		</div>
		<p>
			We then dequeue the address <var>F0</var>, and have a pointer
			<var>p</var> point to the address <var>F0</var>.
		</p>
		<ol class="alg">
			<li>Node root = newNode(5);</li>
			<li>Queue queue = newQueue();</li>
			<li>queue.enqueue(root);</li>
			<li>Node* p = queue.dequeue();</li>
		</ol>
		<div class="split">
			<div id="tree_b1_queue_with_root_dequeue"></div>
			<div id="tree_b1_1_p"></div>
		</div>
		<p>
			With <var>p</var> pointed to <var>F0</var>, we ask:
			<q>Does the node <var>p</var> have a left-child?</q> Examining the
			tree <var>B1</var>, the answer is yes, the node <var>p</var> has a
			left child. So, we use a temporary pointer <var>t</var> to create a
			new node, and have <var>p</var>'s pointee's
			<var>left_child</var> pointer point to the new node:
		</p>
		<ol class="alg">
			<li>Node root = newNode(5);</li>
			<li>Queue queue = newQueue();</li>
			<li>queue.enqueue(root);</li>
			<li>Node* p = queue.dequeue();</li>
			<li>Node* t = newNode(8); <var>address: F1</var></li>
			<li>(*p).left_child = t;</li>
		</ol>
		<p>
			Suppose the address of the new node is <var>F1</var>. We enqueue this
			address to our queue:
		</p>
		<div class="split">
			<div id="tree_b1_2_p"></div>
			<div id="tree_b1_queue_with_2"></div>
		</div>
		<p>
			With the left-child linked, we then ask the second question:
			<q>Does the node <var>p</var> have a right-child?</q> Again, the
			answer is yes. We use the temporary pointer <var>t</var> to create a
			new node, and have <var>p</var>'s pointee's
			<var>right_child</var> pointer point to the new node:
		</p>
		<ol class="alg">
			<li>Node root = newNode(5);</li>
			<li>Queue queue = newQueue();</li>
			<li>queue.enqueue(root);</li>
			<li>Node* p = queue.dequeue();</li>
			<li>Node* t = newNode(8);</li>
			<li>(*p).left_child = t;</li>
			<li>t = newNode(6); <var>address: F2</var></li>
			<li>(*p).right_child = t;</li>
		</ol>
		<p>
			Let's say the address of the new node <var>F2</var>. We enqueue this
			address to our queue:
		</p>
		<div class="split">
			<div id="tree_b1_3_p"></div>
			<div id="tree_b1_queue_with_3"></div>
		</div>
		<p>
			We now have the first generation taken care of. So we go to the next
			generation, working from left to right.
		</p>
		<div id="tree_b1_1_gen2"></div>
		<p>
			We dequeue the address <var>F1</var>, and have the pointer
			<var>p</var> point to this address.
		</p>
		<ol class="alg">
			<li>Node root = newNode(5);</li>
			<li>Queue queue = newQueue();</li>
			<li>queue.enqueue(root);</li>
			<li>Node* p = queue.dequeue();</li>
			<li>Node* t = newNode(8);</li>
			<li>(*p).left_child = t;</li>
			<li>t = newNode(6);</li>
			<li>(*p).right_child = t;</li>
			<li>Node* p = queue.dequeue();</li>
		</ol>
		<div class="split">
			<div id="tree_b1_queue_with_4"></div>
			<div id="tree_b1_4_p"></div>
		</div>
		<p>
			Using <var>p</var> set, we ask,
			<q>Does the node <var>p</var> have a left-child?</q> In this case, it
			does not. So we immediately ask the next question:
			<q>Does the node <var>p</var> have a right child?</q> Yes. So we use
			the temporary pointer <var>t</var> to create a new node, enqueue
			<var>t</var>, and have <var>p</var>'s right-child pointer point to
			<var>t</var>:
		</p>
		<ol class="alg">
			<li>Node root = newNode(5);</li>
			<li>Queue queue = newQueue();</li>
			<li>queue.enqueue(root);</li>
			<li>Node* p = queue.dequeue();</li>
			<li>Node* t = newNode(8);</li>
			<li>(*p).left_child = t;</li>
			<li>t = newNode(6);</li>
			<li>queue.enqueue(t);</li>
			<li>(*p).right_child = t;</li>
			<li>p = queue.dequeue();</li>
			<li>t = newNode(9);</li>
			<li>queue.enqueue(t);</li>
			<li>(*p).right_child = t;</li>
		</ol>
		<p>Now we have:</p>
		<div class="split">
			<div id="tree_b1_4"></div>
			<div id="tree_b1_queue_4"></div>
		</div>
		<p>
			This takes care of the left node in the second generation, so now we
			consider the right node. We dequeue our <var>queue</var>, assigning
			the dequeued address to <var>p</var>:
		</p>
		<ol class="alg">
			<li>Node root = newNode(5);</li>
			<li>Queue queue = newQueue();</li>
			<li>queue.enqueue(root);</li>
			<li>Node* p = queue.dequeue();</li>
			<li>Node* t = newNode(8);</li>
			<li>(*p).left_child = t;</li>
			<li>t = newNode(6);</li>
			<li>queue.enqueue(t);</li>
			<li>(*p).right_child = t;</li>
			<li>p = queue.dequeue();</li>
			<li>t = newNode(9);</li>
			<li>(*p).right_child = t;</li>
			<li>p = queue.dequeue();</li>
		</ol>
		<p>
			Using <var>p</var>, again we ask, does <var>p</var> have a left
			child? Yes, it does. We create a new node using <var>t</var>, enqueue
			<var>t</var>, and have <var>p</var>'s left-child pointer point to
			<var>t</var>:
		</p>
		<ol class="alg">
			<li>Node root = newNode(5);</li>
			<li>Queue queue = newQueue();</li>
			<li>queue.enqueue(root);</li>
			<li>Node* p = queue.dequeue();</li>
			<li>Node* t = newNode(8);</li>
			<li>(*p).left_child = t;</li>
			<li>t = newNode(6);</li>
			<li>queue.enqueue(t);</li>
			<li>(*p).right_child = t;</li>
			<li>p = queue.dequeue();</li>
			<li>t = newNode(9);</li>
			<li>(*p).right_child = t;</li>
			<li>p = queue.dequeue();</li>
			<li>t = newNode(3);</li>
			<li>queue.enqueue(t);</li>
			<li>(*p).left_child = t;</li>
		</ol>
		<div class="split">
			<div id="tree_b1_5"></div>
			<div id="tree_b1_queue_5"></div>
		</div>
		<p>
			We then ask, does <var>p</var> have a right-child? No, it does not.
			So we go to the next generation:
		</p>
		<div id="tree_b1_1_gen3"></div>
		<p>
			We <var>dequeue</var> our <var>queue</var>, and assign the returned
			address to <var>p</var>.
		</p>
		<ol class="alg">
			<li>Node root = newNode(5);</li>
			<li>Queue queue = newQueue();</li>
			<li>queue.enqueue(root);</li>
			<li>Node* p = queue.dequeue();</li>
			<li>Node* t = newNode(8);</li>
			<li>(*p).left_child = t;</li>
			<li>t = newNode(6);</li>
			<li>queue.enqueue(t);</li>
			<li>(*p).right_child = t;</li>
			<li>p = queue.dequeue();</li>
			<li>t = newNode(9);</li>
			<li>(*p).right_child = t;</li>
			<li>p = queue.dequeue();</li>
			<li>t = newNode(3);</li>
			<li>queue.enqueue(t);</li>
			<li>(*p).left_child = t;</li>
			<li>p = queue.dequeue(); <var>address in p: F3</var></li>
		</ol>
		<div class="split">
			<div id="tree_b1_6"></div>
			<div id="tree_b1_queue_6"></div>
		</div>
		<p>
			We ask: Does the node <var>p</var> have a left child? Yes, it does.
			We create a new node using <var>t</var>, queue <var>t</var>, and
			assign <var>t</var> to the <var>left_child</var> pointer of
			<var>p</var>:
		</p>
		<ol class="alg">
			<li>Node root = newNode(5);</li>
			<li>Queue queue = newQueue();</li>
			<li>queue.enqueue(root);</li>
			<li>Node* p = queue.dequeue();</li>
			<li>Node* t = newNode(8);</li>
			<li>(*p).left_child = t;</li>
			<li>t = newNode(6);</li>
			<li>queue.enqueue(t);</li>
			<li>(*p).right_child = t;</li>
			<li>p = queue.dequeue();</li>
			<li>t = newNode(9);</li>
			<li>(*p).right_child = t;</li>
			<li>p = queue.dequeue();</li>
			<li>t = newNode(3);</li>
			<li>queue.enqueue(t);</li>
			<li>(*p).left_child = t;</li>
			<li>p = queue.dequeue(); <var>address in p: F3</var></li>
			<li>t = newNode(4); <var>address: F5</var></li>
			<li>queue.enqueue(t);</li>
			<li>(*p).left_child = t;</li>
		</ol>
		<div class="split">
			<div id="tree_b1_7"></div>
			<div id="tree_b1_queue_7"></div>
		</div>
		<p>
			Then we ask: Does the node <var>p</var> have a right child? Yes.
			Again we create a new node using <var>t</var>, queue <var>t</var>,
			and assign <var>t</var> to the <var>right_child</var> pointer of
			<var>p</var>:
		</p>
		<ol class="alg">
			<li>Node root = newNode(5);</li>
			<li>Queue queue = newQueue();</li>
			<li>queue.enqueue(root);</li>
			<li>Node* p = queue.dequeue();</li>
			<li>Node* t = newNode(8);</li>
			<li>(*p).left_child = t;</li>
			<li>t = newNode(6);</li>
			<li>queue.enqueue(t);</li>
			<li>(*p).right_child = t;</li>
			<li>p = queue.dequeue();</li>
			<li>t = newNode(9);</li>
			<li>(*p).right_child = t;</li>
			<li>p = queue.dequeue();</li>
			<li>t = newNode(3);</li>
			<li>queue.enqueue(t);</li>
			<li>(*p).left_child = t;</li>
			<li>p = queue.dequeue(); <var>address in p: F3</var></li>
			<li>t = newNode(4); <var>address: F5</var></li>
			<li>queue.enqueue(t);</li>
			<li>(*p).left_child = t;</li>
			<li>t = newNode(2); <var>address: F6</var></li>
			<li>(*p).right_child = t;</li>
		</ol>
		<div class="split">
			<div id="tree_b1_8"></div>
			<div id="tree_b1_queue_8"></div>
		</div>
		<p>
			At this point, we see that we've generated our tree. The algorithm
			continues by dequeuing the remaining queuers, testing for the two
			conditions of left- and right-child existence. Once the last queuer
			is dequeued, the algorithm terminates.
		</p>
		<div class="demo">
			<button>C</button>
			<div class="implementation">
				<h4>C Implementation</h4>
				<p>
					Below is an implementation in C. This is somewhat of a lengthy
					implementation because we need an auxiliary data structure, the
					circular queue.
				</p>
				<p>
					First, we start with a diagram of the tree we want to construct.
					In this case, we'll use the following tree for illustration:
				</p>
				<div id="create_tree_sample"></div>
				<p>
					Next, the program we'll run is written in a file called
					<var>Main.c</var>. Its source code and output appear as such:
				</p>
				<pre class="language-c"><code>
					#include "Tree.h"
					
					int main() {
						struct Tree* tree = newTree();
						printTree(tree);
						return 0;
					}
				</code></pre>
				<pre class="language-bash"><code>
					$ make Main
					cc     Main.c   -o Main
					$ ./Main
					Enter root value: 3
					Enter left child of 3: 1
					Enter right child of 3: 2
					Enter left child of 1: 8
					Enter right child of 1: 7
					Enter left child of 2: -1
					Enter right child of 2: 4
					Enter left child of 8: -1
					Enter right child of 8: -1
					Enter left child of 3: -1
					Enter right child of 3: -1
					3
					|---2
					|   |---4
					|---1
					|   |---8
					|   |---7
				</code></pre>
				<p>
					In the code above, we use a function called
					<var>newTree()</var>, which takes no parameters. When
					<var>Main.c</var> is run, the user is prompted to enter the
					different values to be placed in each node. To keep the code
					simple, we'll use the value <var>-1</var> to indicate that a
					particular node does not exist. Entering <var>-1</var> for all
					leaves in the tree terminates the tree construction, which brings
					us to the next line, <var>printTree(tree)</var>. This function
					prints the newly constructed tree.
				</p>
				<p>
					Now that we know how the overall program works, let's examine the
					implementation details. First, we have an include:
					<var>#include "Tree.h"</var>. Let's look inside this header file.
				</p>
				<h4>Tree.h</h4>
				<p>
					Inside the <var>Tree.h</var> header file, we have the following
					code:
				</p>
				<pre class="language-c"><code>
					#include "Queue.h"
				
					struct Node {
						int data;
						struct Node* left_child;
						struct Node* right_child;
					};

					struct Node* newNode(int datum) {
						struct Node* node = (struct Node*) malloc(sizeof(struct Node));
						(*node).data = datum;
						(*node).left_child = NULL;
						(*node).right_child = NULL;
						return node;
					}

					struct Tree {
						struct Node* root;
					};

					struct Tree* newTree() {
						struct Tree* tree = (struct Tree*) malloc(sizeof(struct Tree));
						(*tree).root = NULL;
						struct Node *p, *t;
						int user_input_data;
						struct Queue* pointerQueue = newQueue(10);
						printf("Enter root value: ");
						scanf("%d", &user_input_data);
						(*tree).root = newNode(user_input_data);
						enqueue(pointerQueue, (*tree).root);

						while(!isEmpty(pointerQueue)) {
							p = dequeue(pointerQueue);
							printf("Enter left child of %d: ", (*p).data);
							scanf("%d", &user_input_data);
							if (user_input_data != -1) {
								t = newNode(user_input_data);
								(*p).left_child = t;
								enqueue(pointerQueue, t);
							}
							printf("Enter right child of %d: ", (*p).data);
							scanf("%d", &user_input_data);
							if (user_input_data != -1) {
								t = newNode(user_input_data);
								(*p).right_child = t;
								enqueue(pointerQueue, t);
							}
						}
						return tree;
					}

					void print(struct Node* tree, int level) {
						if (tree != NULL) {
							for (int i = 0; i < level; i++) {
								printf(i == level - 1 ? "|---" : "|   ");
							}
							printf("%d\n", (*tree).data);
							print((*tree).right_child, level + 1);
							print((*tree).left_child, level + 1);
						}
					}

					void printTree(struct Tree* tree) {
						print((*tree).root, 0);
					}
				</code></pre>
				<p>The <var>queue.h</var> file contains the following code:</p>
				<pre class="language-c"><code>
					#pragma once
					#include &lt;stdbool.h&gt;
					#include &lt;stdio.h&gt;
					#include &lt;stdlib.h&gt;

					struct Queue {
						int capacity;
						int length;
						int front;
						int rear;
						struct Node** Q; 
					};

					struct Queue* newQueue(int maxSize) {
						struct Queue* queue = (struct Queue*) malloc(sizeof(struct Queue));
						(*queue).capacity = maxSize;
						(*queue).length = 0;
						(*queue).front = -1;
						(*queue).rear = -1;
						(*queue).Q = (struct Node**) malloc(sizeof(int) * maxSize);
						return queue;
					}

					bool isFull(struct Queue* queue) {
						int rear = (*queue).rear + 1;
						int front = (*queue).front;
						int max = (*queue).capacity;
						return rear % max == front;
					}

					bool isEmpty(struct Queue* queue) {
						return (*queue).front == (*queue).rear;
					}

					void enqueue(struct Queue* queue, struct Node* data) {
						if (isFull(queue)) {
							printf("Queue is full; enqueue prohibited.\n");
						} else {
							(*queue).rear = ((*queue).rear + 1) % (*queue).capacity;
							(*queue).Q[(*queue).rear] = data;
						}
					}

					struct Node* dequeue(struct Queue* queue) {
						struct Node* t = NULL;
						if (isEmpty(queue)) {
							printf("Queue is empty, dequeue prohibited. Returning null pointer.\n");
						} else {
							(*queue).front = ((*queue).front + 1) % ((*queue).capacity);
							t = (*queue).Q[(*queue).front];
						}
						return t;
					}

					void printQueue(struct Queue* queue) {
						for (int i = 0; i < (*queue).capacity; i++) {
							printf("%p ", (*queue).Q[i]);
							printf("\n");
						}
					}
				</code></pre>
				<p>
					Let's go over this code carefully, focusing on
					<var>Tree.h</var>. First, we have the definition for a
					<var>Node</var> struct:
				</p>
				<pre class="language-c"><code>
					struct Node {
						int data;
						struct Node* left_child;
						struct Node* right_child;
					};
				</code></pre>
				<p>
					This is a tree node. It has a data field, <var>data</var>, which
					is bound to the value the node stores. The node also has a
					<var>left_child</var> pointer, which points to the node's left
					child, itself a node, and a <var>right_child</var> pointer, which
					points to the node's right child.
				</p>
				<p>
					Next, we have a <i>node constructor</i>. This is similar to the
					singly-linked list's node constructor &mdash; a function that
					creates a new instance of a node.
				</p>
				<pre class="language-c"><code>
					struct Node* newNode(int datum) {
						struct Node* node = (struct Node*) malloc(sizeof(struct Node));
						(*node).data = datum;
						(*node).left_child = NULL;
						(*node).right_child = NULL;
						return node;
					}
				</code></pre>
				<p>
					The node constructor <var>newNode()</var> has the parameter
					<var>int datum</var>. We pass the data we want stored in the
					resulting tree node into <var>newNode()</var> as an argument,
					which is bound to <var>int datum</var>. Inside
					<var>newNode()</var>, we allocate enough space for a
					<var>Node</var> struct, followed by an instantiation of the new
					node's fields. In this case, <var>datum</var> is bound to the new
					node's <var>data</var> field, and the <var>left_child</var> and
					<var>right_child</var> pointers are initialized to
					<var>NULL</var>. Once initialized, we return the newly
					instantiated node.
				</p>
				<p>Next, we have the definition for a <var>Tree</var> struct.</p>
				<pre class="language-c"><code>
					struct Tree {
						struct Node* root;
					};
				</code></pre>
				<p>
					For now, this structure only has a single field, the
					<var>root</var>. This is a <var>Node</var> pointer, which serves
					as our access point for the rest of the tree. In later sections,
					we will add further properties to the <var>Tree</var> structure
					(e.g., depth, height, levels, etc.), as well as more elaborate
					methods that utilize these additional properties.
				</p>
				<p>
					Following the tree structure, we have the
					<i>tree constructor</i>:
				</p>
				<pre class="language-c"><code>
					struct Tree* newTree() {
						struct Tree* tree = (struct Tree*) malloc(sizeof(struct Tree));
						(*tree).root = NULL;
						struct Node *p, *t;
						int user_input_data;
						struct Queue* pointerQueue = newQueue(10);
						printf("Enter root value: ");
						scanf("%d", &user_input_data);
						(*tree).root = newNode(user_input_data);
						enqueue(pointerQueue, (*tree).root);
					
						while(!isEmpty(pointerQueue)) {
							p = dequeue(pointerQueue);

							printf("Enter left child of %d: ", (*p).data);
							scanf("%d", &user_input_data);
							if (user_input_data != -1) {
								t = newNode(user_input_data);
								(*p).left_child = t;
								enqueue(pointerQueue, t);
							}

							printf("Enter right child of %d: ", (*p).data);
							scanf("%d", &user_input_data);
							if (user_input_data != -1) {
								t = newNode(user_input_data);
								(*p).right_child = t;
								enqueue(pointerQueue, t);
							}
						}
						return tree;
					}
				</code></pre>
				<p>
					This is a fairly large function, so we'll take it a piece at a
					time. First, we create a new instace of a tree, with its
					<var>root</var> pointer initially <var>NULL</var>:
				</p>
				<pre class="language-c"><code>
					struct Tree* tree = (struct Tree*) malloc(sizeof(struct Tree));
					(*tree).root = NULL;
				</code></pre>
				<p>
					Next, we create two <var>Node</var> pointers, <var>p</var> and
					<var>t</var>.
				</p>
				<pre class="language-c"><code>
					struct Node *p, *t;
				</code></pre>
				<p>
					The pointer <var>p</var> is used to point to the current node we
					want to test for child existence. The pointer <var>t</var> is
					then used to create new node instances.
				</p>
				<p>After these two pointers, we have the <i>pointer queue</i>:</p>
				<pre class="language-c"><code>
					struct Queue* pointerQueue = newQueue(10);
				</code></pre>
				<p>This is a circular queue with a circumference of ${10:}$</p>
				<div id="circular_queue_tree"></div>
				<p>
					We use this queue to keep track of the values of
					<var>p</var> and <var>t</var>. The auxiliary circular queue's
					implementation will be discussed shortly in the
					<cite>Queue.h</cite> section.
				</p>
				<p>
					Following these pointers, we have a variable
					<var>user_input_data</var>, followed by a prompt for user input:
				</p>
				<pre class="language-c"><code>
					int user_input_data;
					printf("Enter root value: ");
				</code></pre>
				<p>
					The variable <var>user_input_data</var> stores the user's input
					passed to the <var>scanf</var> call:
				</p>
				<pre class="language-c"><code>
					scanf("%d", &user_input_data);
				</code></pre>
				<p>
					When the user inputs a value, that value is bound to
					<var>user_input_data</var>. With
					<var>user_input_data</var> initialized, it is then passed as an
					argument to <var>newNode()</var>:
				</p>
				<pre class="language-c"><code>
					(*tree).root = <mark>newNode(user_input_data)</mark>;
				</code></pre>
				<p>
					This results in a new tree node, following the
					<var>newNode()</var> constructor's implementation.
				</p>
				<pre class="language-pseudo"><code>
					*node = {
						data = user_input_data;
						left_child = NULL;
						right_child = NULL;
					}
				</code></pre>
				<p>
					The <var>tree</var> we initialized earlier, whose pointer
					<var>root</var> was initially <var>NULL</var>, now points to the
					address of this new node:
				</p>
				<pre class="language-pseudo"><code>
					(*tree).root = {
						data = user_input_data;
						left_child = NULL;
						right_child = NULL;
					}
				</code></pre>
				<p>
					Suppose the address of <var>root</var> is <var>0x1</var>. We
					enqueue this address into our circular queue,
					<var>pointerQueue</var>:
				</p>
				<div class="split">
					<pre class="language-c"><code>
						enqueue(pointerQueue, (*tree).root);
					</code></pre>
					<div id="root_queued"></div>
				</div>
				<p>
					All of this code establishes the tree's <var>root</var>. Once the
					root's established, we can begin inserting the root's
					descendants. To do so, we use a while-loop. The guard clause for
					the while loop: As long as the the pointer queue isn't empty.
				</p>
				<pre class="language-c"><code>
					<mark>while(!isEmpty(pointerQueue))</mark> {
						p = dequeue(pointerQueue);

						printf("Enter left child of %d: ", (*p).data);
						scanf("%d", &user_input_data);
						if (user_input_data != -1) {
							t = newNode(user_input_data);
							(*p).left_child = t;
							enqueue(pointerQueue, t);
						}

						printf("Enter right child of %d: ", (*p).data);
						scanf("%d", &user_input_data);
						if (user_input_data != -1) {
							t = newNode(user_input_data);
							(*p).right_child = t;
							enqueue(pointerQueue, t);
						}
					}
				</code></pre>
				<p>
					If the pointer queue is not empty, we enter the while-loop.
					Inside, we first assign to <var>p</var> the return value of
					dequeuing <var>pointerQueue</var>.
				</p>
				<pre class="language-c"><code>
					p = dequeue(pointerQueue);
				</code></pre>
				<p>
					The <var>dequeue()</var> function, found in <var>queue.h</var>,
					accesses the current front queuer of a queue, dequeues and
					returns that queuer as an output value. That output value, a node
					pointer, is then bound to <var>p</var>.
				</p>
				<p>Once dequeued, we proceed to the while-loop's two prongs:</p>
				<div class="split">
					<pre class="language-c"><code>
						printf("Enter left child of %d: ", (*p).data);
						scanf("%d", &user_input_data);
						if (user_input_data != -1) {
							t = newNode(user_input_data);
							(*p).left_child = t;
							enqueue(pointerQueue, t);
						}
					</code></pre>
					<pre class="language-c"><code>
						printf("Enter right child of %d: ", (*p).data);
						scanf("%d", &user_input_data);
						if (user_input_data != -1) {
							t = newNode(user_input_data);
							(*p).right_child = t;
							enqueue(pointerQueue, t);
						}
					</code></pre>
				</div>
				<p>
					For both of these prongs, we prompt the user to enter the left-
					and right-child values for <var>p</var> respectively. The
					<var>(*p).data</var> is used to inform the user which node the
					user is entering data for. When the user enters the data, she has
					the choice to enter either <var>-1</var> or any other
					<var>int</var> value. If the user enters <var>-1</var>, we enter
					the relevant if-block and create a new node. For example, suppose
					the user enters <var>2</var> for the <var>root</var>'s
					left-child. The code block to execute:
				</p>
				<pre class="language-c"><code>
					t = newNode(user_input_data);
					(*p).left_child = t;
					enqueue(pointerQueue, t);
				</code></pre>
				<p>In the first line, we create a new node:</p>
				<div class="split">
					<pre class="language-c"><code>
						t = newNode(user_input_data);
					</code></pre>
					<pre class="language-pseudo"><code>
						*t = {
							data = 2;
							left_child = NULL;
							right_child = NULL;
						}
					</code></pre>
				</div>

				<p>
					Let's say the address of this new node is <var>0x2</var>. Once
					the new node is created, we make the left-child of <var>p</var>,
					currently the <var>root</var>, point to this new node:
				</p>
				<pre class="language-pseudo"><code>
					*p = {
						data = 3;
						left_child = t;
						right_child = NULL;
					}
				</code></pre>
				<p>Then we enqueue this address to the <var>pointerQueue</var>:</p>
				<div class="split">
					<pre class="language-c"><code>
						enqueue(pointerQueue, t);
					</code></pre>
					<div id="root_left_child_queued"></div>
				</div>
				<p>
					Next, we prompt the user to enter the right-child of
					<var>p</var> (still currently the root). The user enters
					<var>1</var>. Using <var>t</var>, we create a new node with, say,
					an address of <var>0x3</var>.
				</p>
				<pre class="language-pseudo"><code>
					0x2 = {
						data = 1;
						left_child = NULL;
						right_child = NULL;
					}
					*t = {
						data = 1;
						left_child = NULL;
						right_child = NULL;
					}
					*p = {
						data = 3;
						left_child = 0x2;
						right_child = t;
					}
				</code></pre>
				<p>
					We again enqueue the current address <var>t</var> points to into
					<var>pointerQueue</var>:
				</p>
				<div class="split">
					<pre class="language-c"><code>
						enqueue(pointerQueue, t);
					</code></pre>
					<div id="root_right_child_queued"></div>
				</div>
				<p>
					Once the left- and right-children of the current
					<var>p</var> are taken care of, we move back to the top of the
					while-loop:
				</p>
				<pre class="language-c"><code>
					p = dequeue(pointerQueue);
				</code></pre>
				<p>
					Dequeuing <var>pointerQueue</var>, <var>p</var> now becomes the
					new front queuer:
				</p>
				<div id="new_front1"></div>
				<p>This process continues until the queue is completely empty.</p>
			</div>
		</div>
	</section>

	<section id="traversal_implementations">
		<h3>Tree Traversals</h3>
		<p>
			Now that we have a tree constructor, we can examine the
			implementations for tree traversals. Suppose we have the following
			tree, implemented as a linked list (red text indicating the address
			of the pointee):
		</p>
		<div id="traversal_1"></div>
		<p>
			Using this tree to illustrate, we examine each of the traversal
			implementations.
		</p>
		<section id="preorder_traversal">
			<h4>Preorder Traversal</h4>
			<p>For preorder traversal, we have the following function:</p>
			<ol class="alg">
				<li>fn preorder(Node* root):</li>
				<ol>
					<li>if (root != NULL):</li>
					<ol>
						<li>print "{(*root).data}";</li>
						<li>preorder((*root).left_child);</li>
						<li>preorder((*root).right_child);</li>
					</ol>
				</ol>
			</ol>
			<p>
				This is a recursive function. If the <var>root</var> is not
				<var>NULL</var>, we print the data. Thereafter, we make a recursive
				call using the left-child of <var>root</var> as an argument. After
				that recursive call, we make another recursive call using the
				right-child of <var>root</var> as an argument.
			</p>
			<p>
				For example, suppose our example tree is called <var>oak</var>,
				whose <var>root</var> has the address <var>F0</var>. To preorder
				traverse <var>oak</var>, we make the call
				<var>preorder((*oak).root)</var>. This results in a function call
				in the stack, <var>preorder(F0)</var>. The first line in this call
				prints the value <var>8</var>:
			</p>
			<div class="split">
				<div class="ds-stack">
					<ol>
						<li>preorder(F0)</li>
					</ol>
				</div>
				<div id="preorder_trace1"></div>
			</div>
			<p>
				Inside <var>preorder(F0)</var>, we call
				<var>preorder((*root).left_child)</var>. Following our diagram,
				this means making the call <var>preorder(F1)</var>:
			</p>
			<div class="split">
				<div class="ds-stack">
					<ol>
						<li>preorder(F0)</li>
						<li>preorder(F1)</li>
					</ol>
				</div>
				<div id="preorder_trace2"></div>
			</div>
			<p>
				Given <var>preorder(F1)</var>, we print the value <var>3</var>,
				then make the call <var>preorder(F3)</var>:
			</p>
			<div class="split">
				<div class="ds-stack">
					<ol>
						<li>preorder(F0)</li>
						<li>preorder(F1)</li>
						<li>preorder(F3)</li>
					</ol>
				</div>
				<div id="preorder_trace3"></div>
			</div>
			<p>
				The call <var>preorder(F3)</var> then prints the value
				<var>4</var>, and calls <var>preorder((*root).left_child)</var>.
			</p>
			<div class="split">
				<div class="ds-stack">
					<ol>
						<li>preorder(F0)</li>
						<li>preorder(F1)</li>
						<li>preorder(F3)</li>
						<li>preorder(0)</li>
					</ol>
				</div>
				<div id="preorder_trace4"></div>
			</div>
			<p>
				Because <var>F3</var> has no left-child, the call is essentially
				<var>preorder(0)</var> (a null pointer). Nevertheless, the call is
				made and subsequently popped off the stack. This takes us to the
				next call, <var>preorder((*root).right_child)</var>. Because
				<var>F3</var> has no right-child, this call also results in
				<var>preorder(0)</var>:
			</p>
			<div class="split">
				<div class="ds-stack">
					<ol>
						<li>preorder(F0)</li>
						<li>preorder(F1)</li>
						<li>preorder(F3)</li>
						<li>preorder(0)</li>
					</ol>
				</div>
				<div id="preorder_trace5"></div>
			</div>
			<p>
				Having executed all of the instructions for
				<var>preorder(F3)</var>, the most recent being the call
				<var>preorder(F1.left_child)</var>, the call
				<var>preorder(F3)</var> is popped off the stack:
			</p>
			<div class="split">
				<div class="ds-stack">
					<ol>
						<li>preorder(F0)</li>
						<li>preorder(F1)</li>
					</ol>
				</div>
				<div id="preorder_trace5"></div>
			</div>
			<p>
				We're now back at <var>preorder(F1)</var> to execute
				<var>preorder(F1.right_child)</var>. This results in the call
				<var>preorder(F4)</var>. The value <var>9</var> is printed, and the
				call <var>preorder(F4.left_child)</var> is made.
			</p>
			<div class="stackTrace">
				<div class="ds-stack">
					<ol>
						<li>preorder(F0)</li>
						<li>preorder(F1)</li>
						<li>preorder(F4)</li>
					</ol>
				</div>
				<div id="preorder_trace6"></div>
			</div>
			<p>
				This recursive call evaluates to <var>preorder(NULL)</var>, so we
				make the next recursive call, <var>preorder(F4.right_child)</var>.
				This also results in <var>preorder(NULL)</var>, so
				<var>preorder(F4)</var> is popped off the stack.
			</p>
		</section>
		<p>
			With <var>preorder(F4.right_child)</var> finished, this completes the
			call for <var>preorder(F4)</var>, which completes the call for
			<var>preorder(F1)</var>. This then completes the call for
			<var>preorder(F1.left_child)</var>. The process continues for
			<var>preorder(F1.right_child)</var>. Putting it all together, we have
			a call trace that looks like:
		</p>
		<div id="preorder_trace_final"></div>
		<p>
			If we count the number <var>preorder()</var> calls, we'll find that
			there are ${15}$ calls total, given ${7}$ nodes. Recall from our
			earlier discussion that given ${N}$ nodes, there are ${N}$ non-null
			pointers and ${N+1}$ null pointers. Thus, the total number of calls
			we make is ${2N + 1.}$ This conforms with our data: Given a binary
			tree of ${7}$ nodes, we have ${2(7) + 1 = 15}$ calls for preorder
			traversal.
		</p>
		<p>
			Now, although there are ${15}$ calls, that does not mean the size of
			the call stack grows to ${15.}$ Indeed, the most the call stack grows
			up to is ${4.}$ When we called <var>preorder(F0)</var>, that resulted
			in a call to <var>preorder(F2)</var>, then a call to
			<var>preorder(F5)</var>, then a call to <var>preorder(0)</var>. Once
			<var>preorder(0)</var> finishes, it's popped off the stack, then we
			make another call to <var>preorder(0)</var>, then that's popped off
			the stack, then back to <var>preorder(F5)</var>, and so on. The call
			stack grows up to <var>preorder(0)</var>, then back down, and so on.
		</p>
		<p>
			Because of this up and down movement, the most the call stack grows
			to is ${H + 2,}$ where ${H}$ is the height of the binary tree. For
			our example tree, the height is ${H = 2,}$ which yields the call
			stack size of ${S_c = H + 2 = 4.}$
		</p>
		<section id="iterative_inorder">
			<h4>Iterative Preorder Traversal</h4>
			<p>
				Although recursion is the preferred and more common approach for
				implementing tree traversals, we can also traverse through
				iterative means. With an iterative approach, we may have to
				implement our own stack. To see why, let's reuse our
				<var>oak</var> tree to illustrate. We'll use a function that (for
				now) looks like the recursive implementation:
			</p>
			<div class="split">
				<ol class="alg">
					<li>fn preorderLoop(Node* root) -> void:</li>
					<li>while (root != NULL):</li>
					<ol>
						<li>if ((*root).left_child != NULL):</li>
						<ol>
							<li>print((*root).data);</li>
							<li>root = (*root).left_child;</li>
						</ol>
						<li>else if ((*root).right_child != NULL):</li>
						<ol>
							<li>print((*root).data);</li>
							<li>root = (*root).right_child;</li>
						</ol>
						<li>else:</li>
						<ol>
							<li>print("Finished")</li>
						</ol>
					</ol>
				</ol>
				<div id="preorder_loop"></div>
			</div>
			<p>
				Suppose <var>(*oak).root</var> has the address <var>F0</var>. First
				we make the call <var>preorderLoop((*oak).root)</var>, which
				evaluates to <var>preorderLoop(F0)</var>. The first instruction in
				this call is <var>print((*root).data)</var>, which evaluates to
				<var>print(F0.data)</var>. The value <var>8</var> is thus printed
				to the console.
			</p>
			<p>
				Next, we make a call to <var>preorderLoop(F0.left_child)</var>.
				This evaluates to <var>preorderLoop(F1)</var>. The first
				instruction for this call is <var>print(F1.data)</var>, so the
				value <var>3</var> is logged to the console. Following this call,
				we have <var>preorderLoop(F1.left_child)</var>. This evaluates to
				<var>preorderLoop(F3)</var>. Again the first instruction is
				<var>print(F3.data)</var>, so we output <var>4</var> to the
				console.
			</p>
			<p>
				Then we have <var>preorderLoop(F3.left_child)</var>. There is no
				left-child, so we call <var>preorderLoop(F3.right_child)</var>. Now
				we've got a problem. There is no right-child of
				<var>F3</var> &mdash; it's a null pointer. Given the program as is,
				we have no way of <q>going back</q> to the previous node,
				<var>F1</var>. Accordingly, what we need is an auxiliar data
				structure to keep track of the nodes we've previously visited
				&mdash; a <i>stack</i>.
			</p>
			<p>
				Suppose we've implemented a <var>Stack</var> data structure, with
				the functions <var>push()</var> and <var>pop()</var>. The function
				<var>push()</var> inserts a new node address onto the stack, and
				the function <var>pop()</var> removes the topmost address from the
				stack, returning that address as an output value. We also have a
				function <var>isEmpty()</var> which returns <var>true</var> if the
				stack is empty, and <var>false</var> otherwise. With this auxiliary
				data structure, we'll write the rewrite our
				<var>preorderLoop()</var> function as follows:
			</p>
			<ol class="alg">
				<li>fn preorderLoop(Node* root) -> void:</li>
				<ol>
					<li>struct Stack nodeStack;</li>
					<li>while (root != NULL || !isEmpty()):</li>
					<ol>
						<li>if (root != NULL):</li>
						<ol>
							<li>print((*root).data);</li>
							<li>push(nodeStack, root);</li>
							<li>root = (*root).left_child;</li>
						</ol>
						<li>else:</li>
						<ol>
							<li>root = pop(nodeStack);</li>
							<li>root = (*root).right_child;</li>
						</ol>
					</ol>
				</ol>
			</ol>
			<p>
				Let's trace the call. We bgin by calling
				<var>preorder((*oak).root)</var>. The variable <var>root</var> is
				not <var>NULL</var>, so we enter the while-loop.
			</p>
			<figure>
				<table class="alg">
					<thead>
						<th>Iteration Count</th>
						<th>Evaluation</th>
						<th>Stack</th>
					</thead>
					<tbody>
						<tr>
							<td>${1}$</td>
							<td>
								<pre class="language-pseudo"><code>
									.
									└── preorderLoop((*oak).root)
											└── preorderLoop(F0)
													├── print(F0.data)
													├── push(nodeStack, root);
													└── root = (F0).left_child = F1;
								</code></pre>
							</td>
							<td>
								<div class="ds-stack">
									<ol>
										<li>F0</li>
									</ol>
								</div>
							</td>
						</tr>
					</tbody>
				</table>
			</figure>
			<p>
				The variable <var>root</var> now points to the address
				<var>F1</var>. This is not a <var>NULL</var> value, so we again
				enter the loop and evaluate:
			</p>
			<figure>
				<table class="alg">
					<thead>
						<th>Iteration Count</th>
						<th>Evaluation</th>
						<th>Stack</th>
					</thead>
					<tbody>
						<tr>
							<td>${1}$</td>
							<td>
								<pre class="language-pseudo"><code>
									.
									└── preorderLoop(root)
											└── preorderLoop(F0)
													├── print(F0.data) >> "8"
													├── push(nodeStack, root);
													└── root = (F0).left_child = F1;
								</code></pre>
							</td>
							<td>
								<div class="ds-stack">
									<ol>
										<li>F0</li>
									</ol>
								</div>
							</td>
						</tr>
						<tr>
							<td>${2}$</td>
							<td>
								<pre class="language-pseudo"><code>
									.
									└── preorderLoop(root)
											└── preorderLoop(F1)
													├── print(F1.data) >> "3"
													├── push(nodeStack, root);
													└── root = (F1).left_child = F3;
								</code></pre>
							</td>
							<td>
								<div class="ds-stack">
									<ol>
										<li>F0</li>
										<li>F1</li>
									</ol>
								</div>
							</td>
						</tr>
					</tbody>
				</table>
			</figure>
			<p>
				The variable <var>root</var> is now <var>F3</var>. This is not
				<var>NULL</var>, so we again enter the loop and evaluate:
			</p>
			<figure>
				<table class="alg">
					<thead>
						<th>Iteration Count</th>
						<th>Evaluation</th>
						<th>Stack</th>
					</thead>
					<tbody>
						<tr>
							<td>${1}$</td>
							<td>
								<pre class="language-pseudo"><code>
									.
									└── preorderLoop(root)
											└── preorderLoop(F0)
													├── print(F0.data) >> "8"
													├── push(nodeStack, root);
													└── root = (F0).left_child = F1;
								</code></pre>
							</td>
							<td>
								<div class="ds-stack">
									<ol>
										<li>F0</li>
									</ol>
								</div>
							</td>
						</tr>
						<tr>
							<td>${2}$</td>
							<td>
								<pre class="language-pseudo"><code>
									.
									└── preorderLoop(root)
											└── preorderLoop(F1)
													├── print(F1.data) >> "3"
													├── push(nodeStack, F3);
													└── root = (F1).left_child = F3;
								</code></pre>
							</td>
							<td>
								<div class="ds-stack">
									<ol>
										<li>F0</li>
										<li>F1</li>
									</ol>
								</div>
							</td>
						</tr>
						<tr>
							<td>${2}$</td>
							<td>
								<pre class="language-pseudo"><code>
									.
									└── preorderLoop(root)
											└── preorderLoop(F3)
													├── print(F3.data) >> "4"
													├── push(nodeStack, F3);
													└── root = (F1).left_child = NULL;
								</code></pre>
							</td>
							<td>
								<div class="ds-stack">
									<ol>
										<li>F0</li>
										<li>F1</li>
										<li>F3</li>
									</ol>
								</div>
							</td>
						</tr>
					</tbody>
				</table>
			</figure>
			<p>
				Now <var>root == NULL</var>. Accordingly, we check the second prong
				of the while-loop's guard clause, <var>!isEmpty()</var>. This
				returns <var>true</var>, so we again enter the loop. However,
				because <var>root == NULL</var>, we enter the second prong:
			</p>
			<figure>
				<table class="alg">
					<thead>
						<th>Iteration Count</th>
						<th>Evaluation</th>
						<th>Stack</th>
					</thead>
					<tbody>
						<tr>
							<td>${1}$</td>
							<td>
								<pre class="language-pseudo"><code>
									.
									└── preorderLoop(root)
											└── preorderLoop(F0)
													├── print(F0.data) >> "8"
													├── push(nodeStack, root);
													└── root = (F0).left_child = F1;
								</code></pre>
							</td>
							<td>
								<div class="ds-stack">
									<ol>
										<li>F0</li>
									</ol>
								</div>
							</td>
						</tr>
						<tr>
							<td>${2}$</td>
							<td>
								<pre class="language-pseudo"><code>
									.
									└── preorderLoop(root)
											└── preorderLoop(F1)
													├── print(F1.data) >> "3"
													├── push(nodeStack, F3);
													└── root = (F1).left_child = F3;
								</code></pre>
							</td>
							<td>
								<div class="ds-stack">
									<ol>
										<li>F0</li>
										<li>F1</li>
										<li>F3</li>
									</ol>
								</div>
							</td>
						</tr>
						<tr>
							<td>${3}$</td>
							<td>
								<pre class="language-pseudo"><code>
									.
									└── preorderLoop(root)
											├── root = pop(nodeStack) = F3
											└── root = (*root).right_child = (F3).right_child = F4
								</code></pre>
							</td>
							<td>
								<div class="ds-stack">
									<ol>
										<li>F0</li>
										<li>F1</li>
									</ol>
								</div>
							</td>
						</tr>
					</tbody>
				</table>
			</figure>
			<p>
				At this point, it should be apparent how the auxiliary
				<var>nodeStack</var> is helping us <q>go back</q> to our previously
				visited nodes. Eventually, the stack is emptied, and the while-loop
				terminates. Comparing the stack's growth over time:
			</p>
			<div id="preorder_stack_growth"></div>
			<p>
				Examining this chart, we see that a total of ${15}$ iterations are
				done to traverse the entire tree. Indeed, there is no difference in
				terms of time complexity between recursive and iterative preorder
				traversals &mdash; it's still ${O(n),}$ where ${n}$ is the number
				of nodes in the tree.
			</p>
			<div class="demo">
				<button>C</button>
				<div class="implementation">
					<h3>C Implementation</h3>
					<p>Below is an implementation in C.</p>
				</div>
			</div>
		</section>
	</section>

	<section id="inorder_traversal">
		<h3>Inorder Traversal</h3>
		<p>
			The inorder traversal algorithm is implemented with the following
			function:
		</p>
		<ol class="alg">
			<li>fn inorder(Node* root) -> void:</li>
			<ol>
				<li>if (root != NULL):</li>
				<ol>
					<li>inorder((*root).left_child);</li>
					<li>print "{(*root).data}";</li>
					<li>inorder((*root).right_child);</li>
				</ol>
			</ol>
		</ol>
		<p>
			Suppose we want to inorder-traverse the following tree, named
			<var>sequoia</var>.
		</p>
		<div id="inorder_tree_demo"></div>
		<p>
			We begin by making the call <var>inorder((*sequoia).root)</var>.
			Suppose <var>root</var> points to the address <var>F0</var>. This
			results in the call <var>inorder(F0)</var>. Making this call, the
			first statement is <var>inorder((*root).left_child)</var>. This
			evaluates to <var>inorder(F0.left_child)</var>, which evaluates to
			<var>inorder(F1)</var>:
		</p>
		<div id="inorder_trace_f1"></div>
		<p>
			Calling <var>inorder(F1)</var>, we then call
			<var>inorder(F1.left_child)</var>, which evaluates to
			<var>inorder(F3)</var>.
		</p>
		<div id="inorder_trace_f3"></div>
		<p>
			The call <var>inorder(F3)</var> results in the call
			<var>inorder(F3.left_child)</var>. Because <var>F3</var> has no
			left-child, this evaluates to the call <var>inorder(0)</var>. This
			does not lead to any further calls, so it completes and we go to the
			next call, <var>print "{F3.data}"</var>:
		</p>
		<div id="inorder_trace_f3_1"></div>
		<p>
			Once the <var>print</var> line finishes executing, we go to the next
			call, <var>inorder(F3.right_child)</var>. Here, <var>F3</var> has no
			right-child, so the call evaluates to <var>inorder(0)</var>.
		</p>
		<div id="inorder_trace_f3_2"></div>
		<p>
			This completes the call to <var>inorder(F3)</var>, so we go back to
			the call <var>inorder(F1)</var>. The next line is
			<var>print "{F1.data}"</var>, so we print the value <var>8</var>:
		</p>
		<div id="inorder_trace_f1_1"></div>
		<p>
			We then proceed to the next line, <var>inorder(F1.right_child)</var>.
			Because <var>F1</var> has a right-child, this call evaluates to
			<var>inorder(F4)</var>. Inside this call, we make the recursive call
			<var>inorder(F4.left_child)</var>. But <var>F4</var> has no
			left-child, so the call evaluates to <var>inorder(0)</var>.
		</p>
		<div id="inorder_trace_f4"></div>
		<p>
			We go to the next line, <var>print "{F4.data}"</var>, which prints
			the value <var>6</var>. This line is followed by
			<var>inorder(F4.right_child)</var>. And once again, because
			<var>F4</var> has no right-child, the call evaluates to
			<var>inorder(0)</var>:
		</p>
		<div id="inorder_trace_f4_1"></div>
		<p>
			This completes the call to <var>inorder(F4)</var>, which in turn
			completes the call to <var>inorder(F1)</var>. This brings us back to
			<var>inorder(F0)</var>. We execute the line
			<var>print "{F0.data}"</var>, and proceed to
			<var>inorder(F0.right_child)</var>, repeating the process we've
			covered. All of the calls together yield the following call trace:
		</p>
		<div id="inorder_trace_final"></div>

		<section id="iterative_inorder">
			<h4>Iterative Inorder Traversal</h4>
			<p>
				Just as we saw with preorder traversal, we can also implement an
				iterative version of inorder traversal. Recall that with inorder
				traversal, we want to traverse all of the left-subtrees before
				visiting the node. Thus, the iterative procedure looks similar to
				the <var>preorderLoop()</var>, with a few modifications:
			</p>
			<ol class="alg">
				<li>fn inorderLoop(Node* root) -> void:</li>
				<ol>
					<li>Stack nodeStack;</li>
					<li>while (root != NULL || !isEmpty(nodeStack)):</li>
					<ol>
						<li>if (root != NULL):</li>
						<ol>
							<li>push(nodeStack, root);</li>
							<li>root = (*root).left_child;</li>
						</ol>
						<li>else:</li>
						<ol>
							<li>root = pop(nodeStack);</li>
							<li>print((*root).data);</li>
							<li>root = (*root).right_child;</li>
						</ol>
					</ol>
				</ol>
			</ol>
			<p>
				Notice that with <var>inorderLoop()</var>, the first arm of the
				while loop is to traverse the entire left-subtree. Only after we've
				traversed the entire left-subtree do we enter the second arm. Once
				we've arrived at the state where there are no left-children, we
				proceed to the second arm. Here, we pop node stack (binding the
				return value to <var>root</var>), then <var>print()</var> the
				relevant data. Thereafter, we change <var>root</var>'s assigned
				value to <var>(*root).right_child</var>.
			</p>
			<p>Our auxiliary <var>nodeStack</var>'s changes over time:</p>
			<div id="inorder_stack_growth"></div>
			<p>
				Notice that, broadly, the changes occur in the same way as
				<var>preorderLoop()</var>. This isn't all that odd, the only change
				we've made is moving the <var>print()</var> line elsewhere. With
				<var>preorderLoop()</var>, we printed the value before moving on to
				the <em>left-child</em>. With <var>inorderLoop()</var>, we print
				the value before moving on to the <em>right-child</em>. Moving this
				<var>print()</var> line does not impact the time complexity of
				traversing the entire tree &mdash; it's still ${O(n),}$ where ${n}$
				is the number of nodes in the tree.
			</p>
		</section>
	</section>

	<section id="postorder_traversal">
		<h3>Postorder Traversal</h3>
		<p>
			The postorder traversal algorithm is embodied in the following
			function:
		</p>
		<ol class="alg">
			<li>fn postorder(Node* root) -> void:</li>
			<ol>
				<li>postorder((*root).left_child)</li>
				<li>postorder((*root).right_child)</li>
				<li>print((*root).data)</li>
			</ol>
		</ol>
		<p>
			Notice that the algorithm looks similar to the other traversal
			methods, the only difference being: The <var>print()</var> call
			occurs only after the left- and right-subtrees of a given node have
			been traversed. Suppose we called <var>postorder()</var> on a tree
			called <var>cedar</var>, represented as follows:
		</p>
		<div id="postorder_sample"></div>
		<p>
			We won't go over the call execution for postorder traversal in
			detail, as it is similar to the other traversals we've seen. The call
			trace is as follows:
		</p>
		<div id="postorder_trace_final"></div>
		<p>
			As we saw with preorder and inorder traversal, postorder traversal
			results in ${2N + 1}$ function calls, where ${N}$ is the binary
			tree's order &mdash; i.e., the number of its nodes. Along the same
			lines, the resulting call stack size for a given invokation of
			<var>postorder()</var> is ${S_c = H + 2,}$ where ${H}$ is the tree's
			height.
		</p>
	</section>

	<section id="traversal_time_complexities">
		<h3>Traversal Complexities</h3>
		<p>
			Let's lay out our numeric conclusions for the traversal approaches:
		</p>
		<table class="alg">
			<thead>
				<th>Traversal Method</th>
				<th>Number of Calls</th>
				<th>Stack Size</th>
			</thead>
			<tbody>
				<tr>
					<td><var>preorder()</var></td>
					<td>${2N + 1}$</td>
					<td>${H + 2}$</td>
				</tr>
				<tr>
					<td><var>inorder()</var></td>
					<td>${2N + 1}$</td>
					<td>${H + 2}$</td>
				</tr>
				<tr>
					<td><var>postorder()</var></td>
					<td>${2N + 1}$</td>
					<td>${H + 2}$</td>
				</tr>
				<tr>
					<td colspan="3">
						Where ${N}$ is the tree's order, and ${H}$ is the tree's
						height.
					</td>
				</tr>
			</tbody>
		</table>
		<p>
			The number of calls and stack sizes are all the same. Now, recall the
			<cite
				><a href="#proper_binary_tree_bounds_lemma" target="_blank"
					>Proper Binary Tree Bounds Lemma</a
				></cite
			>: The height of a tree, denoted ${H,}$ has the bounds:
		</p>
		<figure>$$ O(\log n) ≤ H ≤ O(n) $$</figure>
		<p>
			where ${n}$ is the number of nodes. This yields the following
			complexities:
		</p>
		<table class="alg">
			<thead>
				<th>Traversal Method</th>
				<th>Time Complexity</th>
				<th>Space Complexity</th>
			</thead>
			<tbody>
				<tr>
					<td><var>preorder()</var></td>
					<td>${O(n)}$</td>
					<td>${O(\log n) \leq H \leq O(n)}$</td>
				</tr>
				<tr>
					<td><var>inorder()</var></td>
					<td>${O(n)}$</td>
					<td>${O(\log n) \leq H \leq O(n)}$</td>
				</tr>
				<tr>
					<td><var>postorder()</var></td>
					<td>${O(n)}$</td>
					<td>${O(\log n) \leq H \leq O(n)}$</td>
				</tr>
				<tr>
					<td colspan="3">
						Where ${n}$ is the tree's order, and ${H}$ is the tree's
						height.
					</td>
				</tr>
			</tbody>
		</table>
		<p>
			Thus, traversing an entire binary tree has a time complexity of
			${O(n).}$ And the space complexity for such a traversal is at least
			${O(\log n),}$ and at most ${O(n),}$ depending on the tree's height.
		</p>
	</section>

	<section id="level_order_traversal">
		<h3>Level-order Traversal</h3>
		<p>
			One traversal method we've left out is <b>level-order traversal</b>.
			Consider the following tree (edge labels are pointer values):
		</p>
		<div id="level_order_traversal_sample"></div>
		<p>
			In level-order traversal, we traverse the tree's nodes level by
			level. Thus, for the tree above, we have the traversal:
		</p>
		<figure>$$ \lang 8, 3, 9, 7, 6, 4, 5, 2 \rang $$</figure>
		<p>
			As with the other traversal methods, we can implement level-order
			traversal the tree by making use of queue.
		</p>
		<div class="pseudosource">
			<ol class="alg">
				<li>fn levelOrder(Node* root) -> void:</li>
				<ol>
					<li>Queue qeueue = newQueue();</li>
					<li>print((*root).data)</li>
					<li>enqueue(qeueue, root);</li>
					<li>while (!isEmpty(q)):</li>
					<ol>
						<li>root = dequeue(qeueue);</li>
						<li>if ((*root).leftChild):</li>
						<ol>
							<li>print((*(*root).leftChild).data);</li>
							<li>enqueue(queue, (*root).leftChild);</li>
						</ol>
						<li>if ((*root).rightChild):</li>
						<ol>
							<li>print((*(*root).rightChild).data);</li>
							<li>enqueue(queue, (*root).rightChild);</li>
						</ol>
					</ol>
				</ol>
			</ol>
			<ol class="algc">
				<li>Declare the function.</li>
				<li>Create a new empty queue.</li>
				<li>
					Print the <var>root</var>'s data. This is the first node in the
					tree, the root node.
				</li>
				<li>Enqueue <var>root</var> to the queue.</li>
				<li>
					As long as the queue is not empty, execute the following
					instructions. If the queue is empty, END.
				</li>
				<li>
					Dequeue the queue, and make <var>root</var> the dequeued value (a
					node).
				</li>
				<li>
					If the dequeued node has a left child, execute the instructions
					below. Otherwise, go to instruction 9.
				</li>
				<li>Print the dequeued node's data.</li>
				<li>Enqueue the left child of the dequeued node to the queue.</li>
				<li>
					If the dequeued node has a right child, execute the instructions
					below. Otherwise, go back to instruction 4.
				</li>
				<li>Print the dequeued node's data.</li>
				<li>Enqueue the right child of the dequeued node to the queue.</li>
			</ol>
		</div>
	</section>
</section>

<section id="tree_generation">
	<h2>Tree Generation</h2>
	<p>
		In this section, we examine different ways of generating trees. Since
		we've just gon over traversals, we begin by considering how we might
		generate a tree using the traversal methods.
	</p>
	<section id="traversal_generation">
		<h3>Traversal Generation</h3>
		<p>
			The idea behind traversal generation can be thought of as
			<q>working backwards:</q> If we're given traversal sequences, we can
			generate the tree that results in those sequences. Note the plural
			&mdash; traversal <i>sequences</i>. This is a key point, because with
			just a single traversal sequence, we do not have enough data to
			generate a tree. For example, suppose we're told that the following
			is a preorder traversal sequence of the tree's node values:
		</p>
		<div id="sample_data_traversal_generation"></div>
		<p>
			Without further information, we cannot construct a tree because the
			traversal sequence above could have come from five possible trees:
		</p>
		<div class="split">
			<div id="tg1"></div>
			<div id="tg2"></div>
			<div id="tg3"></div>
		</div>
		<div class="split">
			<div id="tg4"></div>
			<div id="tg5"></div>
		</div>
		<p>
			Accordingly, preorder, inorder, and postorder sequences alone are
			insufficient. We need additional sequences. Specifically, we need one
			of the following combinations of data:
		</p>
		<ol>
			<li>The preorder sequence and inorder sequence, or</li>
			<li>the postorder sequence and inorder sequence.</li>
		</ol>
		<p>
			Notice that in both cases, we need the inorder sequence. To see why
			we need the inorder sequence, let's just go straight to the algorithm
			with an example.
		</p>
		<p>First, we're given the sequences:</p>
		<table class="alg">
			<tbody>
				<tr>
					<td>Preorder</td>
					<td><div id="tg_pre_array"></div></td>
				</tr>
				<tr>
					<td>Inorder</td>
					<td><div id="tg_in_array"></div></td>
				</tr>
			</tbody>
		</table>
		<p>
			From the preorder sequence, we know that the node containing
			<var>4</var> is the root. Thus, the tree's root is a node containing
			<var>4</var>. Then, from the inorder sequence of the tree, we know
			that all the values to the left of <var>4</var> form the
			left-subtree, and all the values to the right of <var>4</var> form
			the right-subtree. Thus, we have:
		</p>
		<div id="tg_true_tree"></div>
		<p>
			The rest of the algorithm follows this basic step. We continue
			splitting until there's nothing left to split. So, we look at the
			next element in the preorder sequence and see that it's <var>7</var>.
			This tells us that the node containing <var>7</var> is the root of
			the left-subtree.
		</p>
		<p>
			We go to the inorder sequence and look for <var>7</var>, and find
			that it's the first element. Inorder sequence then tells us that
			everything to the left of <var>7</var> forms its left-subtree, and
			everything to the right forms the right-subtree. Thus, we have:
		</p>
		<div id="tg_true_tree2"></div>
		<p>
			The algorithm continues. We go to the next element, and see that it's
			<var>9</var>. We go to the inorder sequence, look for <var>9</var>,
			and divide accordingly:
		</p>
		<div id="tg_true_tree3"></div>
		<p>
			We then move to the next element in the preorder sequence,
			<var>6</var>. Here, we see that it's a single element &mdash; there's
			nothing to its left or right. The same goes for <var>3</var>. So we
			go the next element, <var>2</var>. Again we search for
			<var>2</var> in the inorder sequence, and find that it has
			<var>5</var> and <var>8</var> to its left, and <var>1</var> to its
			right:
		</p>
		<div id="tg_true_tree4"></div>
		<p>
			At this point, the algorithm should be clear. Executing the rest of
			the algorithm, we get:
		</p>
		<div id="tg_true_tree5"></div>
	</section>
</section>

<section id="node_counting">
	<h2>Order Determination</h2>
	<p>
		Suppose we want to determine a binary tree's order (the number of nodes
		in the binary tree). Given what we know about traversals, one way to do
		so is to traverse the entire tree, counting each time we visit a node:
	</p>
	<div class="tabs">
		<ul>
			<li>Pseudo</li>
			<li>C</li>
			<li>C++</li>
			<li>Java</li>
		</ul>
		<div class="p">
			<p>
				Below, we have a function called <var>TreeOrder()</var>. This
				function takes a <var>Node</var> pointer as an argument, and
				returns an <var>int</var>. Inside <var>TreeOrder()</var>, we have
				two local variables, <var>x</var> and <var>y</var>. These variables
				will keep track of the count for the left-subtrees and
				right-subtrees respectively. As long as <var>root</var> is not
				<var>NULL</var>, we will traverse the subtrees. At some point, we
				reachl a leaf, in which case we go to line <var>6</var>:
				<var>return 0</var>. This ultimately leads to the final line in the
				if-block: <var>return x + y + 1</var>.
			</p>
			<div class="pseudosource">
				<ol class="alg">
					<li>TreeOrder(Node* root) -> int :</li>
					<ol>
						<li>int x, y;</li>
						<li>if (root != NULL):</li>
						<ol>
							<li>x = TreeOrder((*root).left_child);</li>
							<li>y = TreeOrder((*root).right_child);</li>
							<li>return x + y + 1;</li>
						</ol>
						<li>return 0;</li>
					</ol>
				</ol>
				<ol class="algc">
					<li>${O(1)}$</li>
					<li>${O(1)}$</li>
					<li>${O(1)}$</li>
					<li>${O(\lg n) \cup O(n)}$</li>
					<li>${O(\lg n) \cup O(n)}$</li>
					<li>${O(1)}$</li>
					<li>${O(1)}$</li>
				</ol>
			</div>
			<p>
				Notice that this algorithm uses postorder traversal. This isn't
				necessarily some arbitrary decision. For post applications, binary
				tree processing is done with post-order traversal.
			</p>
			<div class="c"></div>
			<div class="cpp"></div>
		</div>
	</div>
	<p>
		What if instead we wanted to only count the nodes with a degree of two?
		To do so, we use the following:
	</p>
	<ol class="alg">
		<li>TreeOrder2(Node* root) -> int :</li>
		<ol>
			<li>int x, y;</li>
			<li>if (root != NULL):</li>
			<ol>
				<li>x = TreeOrder2((*root).left_child);</li>
				<li>y = TreeOrder2((*root).right_child);</li>
				<li>if ((*root).left_child && (*root).right_child):</li>
				<ol>
					<li>return x + y + 1;</li>
				</ol>
				<li>else</li>
				<ol>
					<li>return x + y;</li>
				</ol>
			</ol>
			<li>return 0;</li>
		</ol>
	</ol>
	<section id="summing_all_elements_in_a_tree">
		<h3>Summing All Elements in a Tree</h3>
		<p>To sum all of the elements in a tree, we use the following:</p>
		<ol class="alg">
			<li>TreeSum(Node* root) -> int :</li>
			<ol>
				<li>int x, y;</li>
				<li>if (root != NULL):</li>
				<ol>
					<li>x = TreeSum((*root).left_child);</li>
					<li>y = TreeSum((*root).right_child);</li>
					<li>return x + y (*root).data</li>
				</ol>
				<li>return 0;</li>
			</ol>
		</ol>
	</section>
</section>

<section id="binary_search_trees">
	<h2>Binary Search Trees</h2>
	<p>
		Now that we have the basics of binary trees down, we can now consider
		one of the most useful data structures in computer science &mdash;
		<b>binary search trees</b>.
	</p>
	<p>
		The binary search tree, on its face, looks like any other binary tree
		we've seen:
	</p>
	<div id="bst_intro"></div>
	<p>
		There is, however, a key property that makes it unique enough to merit
		its own name:
	</p>
	<dfn>
		<small>Definition: Binary Search Tree</small>
		<p>
			A binary tree is a binary search tree iff for any node ${n}$ in the
			tree, all nodes with a value less than ${n's}$ weight are found in
			${n}$'s left-subtree, and all nodes with a weight greater than
			${n's}$ weight are found in ${n}$'s right-subtree.
		</p>
	</dfn>
	<p>
		In the definition above, the term <i>weight</i> &mdash; borrowing from
		graph theory &mdash; can be substituted with any value where the
		comparison operators apply. For example, the node's weight could be an
		integer, a floating point number, or perhaps even strings that map to
		particular numberic values. The key point is, in a binary search tree,
		we can look at any node ${n,}$ and rest assured that all the nodes in
		${n}$'s left-subtree contain values than ${n}$'s value, and all the
		nodes in ${n}$'s right-subtree contain values greater than ${n.}$ For
		example, in the tree above, we can see that <var>30</var>, the root
		node, has <var>15</var> to its left and <var>50</var> to its right. And
		for the node containig <var>50</var>, we see <var>40</var> to its left
		and <var>60</var> to its right.
	</p>
	<p>
		Because of this property, binary search trees make searching much
		faster. In fact, we can think of binary search trees as the data
		structure implementation of the binary search algorithm, as we saw with
		arrays. Recall that with the binary search algorithm on arrays, we had
		to sort elements first. The binary search tree skips that step through
		its data structure. This is made apparent when we examine the binary
		search tree's inorder traversal sequence. For the tree above, the
		inorder traversal sequence is:
	</p>
	<div id="bst_array_1"></div>
	<p>
		The binary search tree is not without its limitations. The most obvious
		limitation: <i>Binary search trees cannot have duplicates</i>. This
		limitation is implied by the data structure. We have to nodes with
		lesser values to the left, and nodes with greater values to the right.
		There's no less-than-or-equal-to or greater-than-or-equal-to.
	</p>
	<p>
		Another limitation is traversal generation. All binary search trees are
		binary trees, so to generate the tree with traversal generation, we
		must specify an inorder traversal sequence and either a preorder
		traversal sequence or a postorder traversal sequence. With an inorder
		traversal sequence alone, there are many possible binary search trees.
	</p>
	<p>
		Keeping these limitations in mind, let's now consider how searching
		actually occurs for a binary search tree.
	</p>

	<section id="searching">
		<h3>Searching a Binary Search Tree</h3>
		<p>
			Searching through a binary search tree is very simple. Consider the
			following tree:
		</p>
		<div id="bst_search_example"></div>
		<p>
			Suppose we wanted to find the element <var>40</var>. First, we take a
			pointer and start at the root:
		</p>
		<div id="bst_search_example1"></div>
		<p>
			With the pointer <var>p</var> set, we read <var>p</var>'s pointee's
			value, and compare it against the key. In this case, we see that
			<var>40 &nlt; 30</var>, so we move <var>p</var> to the current
			pointee's right-child:
		</p>
		<div id="bst_search_example2"></div>
		<p>
			Given <var>p</var>'s new pointee, we perform the procedure again. The
			comparison returns <var>40 &lt; 50</var>, so we move <var>p</var> to
			the current pointee's left-child:
		</p>
		<div id="bst_search_example3"></div>
		<p>
			Comparing the pointee's value to our key, we see that
			<var>40 = 40</var>, and the search concludes &mdash; we've found our
			match. What if the key were instead <var>39</var>? In that case, we
			would get to the node labeled <var>40</var> above, then set
			<var>p</var> to node <var>40</var>'s left-child. But, because there
			is no such node, <var>p</var> is set to <var>NULL</var>. We use this
			fact to return an unsuccesful search &mdash; if <var>p</var> is
			<var>NULL</var> at any point before the key is found, there is no
			match.
		</p>
		<p>A recursive implementation might look like:</p>
		<div class="pseudosource">
			<ol class="alg">
				<li>fn search(Node* root, int key) -> Node*:</li>
				<ol>
					<li>if (root === NULL):</li>
					<ol>
						<li>return NULL;</li>
					</ol>
					<li>if (key === (*root).data):</li>
					<ol>
						<li>return root;</li>
					</ol>
					<li>else if (key &lt; (*root).data):</li>
					<ol>
						<li>search((*root).left_child, key);</li>
					</ol>
					<li>else:</li>
					<ol>
						<li>search((*root).right_child, key);</li>
					</ol>
				</ol>
			</ol>
			<ol class="algc">
				<li>
					<var>search()</var> is a function that takes a node pointer,
					called <var>root</var>, and an <var>int</var>, the search key. If
					the search key is found, a pointer to the node containing the key
					is returned. Otherwise, the <var>NULL</var> pointer is returned.
				</li>
				<li>
					The failure condition. If <var>root</var> is <var>NULL</var>,
					execute the instruction below. Otherwise, go to instruction
					<var>3</var>.
				</li>
				<li>Return <var>NULL</var>.</li>
				<li>
					The successful condition. If <var>root</var>'s data matches the
					key, execute the instruction below. Otherwise, go to insruction
					<var>5</var>.
				</li>
				<li>Return <var>root</var> (the node containing the key).</li>
				<li>
					If <var>key</var> is less than the data inside <var>root</var>,
					execute the instruction below. Otherwise, go to instruction
					<var>8</var>.
				</li>
				<li>
					Execute the function <var>search((*root).left_child, key)</var>.
				</li>
				<li>
					If none of the preceding conditions were met, execute the
					instruction below.
				</li>
				<li>
					Execute the function <var>search((*root).right_child, key)</var>.
				</li>
			</ol>
		</div>
		<p>
			To illustrate the function above, we'll apply it to the previous
			tree. First, we pass the tree's <var>root</var> pointer, and a key.
			Suppose we're looking for the key <var>60</var>. We make the first
			call, <var>search(root, 60)</var>. First, we check if
			<var>root = NULL</var>. It is not, so we can proceed.
		</p>
		<p>
			We chck if <var>30 = 60</var>. No. <var>30 ≠ 60.</var> We go to the
			next prong, which asks if <var>30 &lt; 60</var>. Again no. So, we
			jump to the default prong &mdash; make a recursive call,
			<var>((*root).right_child, 60)</var>. Since the right child of the
			root is <var>50</var>, for readability, we'll denote this as
			<var>search(root(50), 60)</var>:
		</p>
		<div id="binary_search_trace"></div>
		<p>
			Making this call, we check if <var>root(50) = NULL</var>. No. So we
			go to the next prong, and check if <var>60 = root(50)</var>. It's not
			&mdash; <var>60 ≠ 50</var>. Check the next prong. Is
			<var>60 &lt; 15</var>? No. We jump to the default prong, and wow we
			make the call <var>search(root(50).right_child, 60)</var>. This
			translates to <var>search(root(60), 60):</var>
		</p>
		<div id="binary_search_trace2"></div>
		<p>
			Again we check if <var>root(60) = NULL</var>. It isn't, so we can
			proceed. Prong 2: Is <var>60 = root(60).data</var>? Yes.
			<var>60 = 60</var>. We've found our match.
		</p>
		<p>Alternatively, we can search with iteration:</p>
		<div class="pseudosource">
			<ol class="alg">
				<li>fn search(Node* root, int key) -> Node* :</li>
				<ol>
					<li>while (root != NULL):</li>
					<ol>
						<li>if (key === (*root).data):</li>
						<ol>
							<li>return root;</li>
						</ol>
						<li>else if (key &lt; (*root).data):</li>
						<ol>
							<li>root = (*root).left_child;</li>
						</ol>
						<li>else:</li>
						<ol>
							<li>root = (*root).right_child;</li>
						</ol>
					</ol>
				</ol>
			</ol>
			<ol class="algc">
				<li>
					<var>search()</var> is an iterative function that takes a node
					pointer, called <var>root</var>, and an <var>int</var>, the
					search key. If the search key is found, a pointer to the node
					containing the key is returned. Otherwise, the
					<var>NULL</var> pointer is returned.
				</li>
				<li>
					As long as <var>root</var> is not <var>NULL</var>, execute the
					instructions below.
				</li>
				<li>
					If the <var>key</var> matches the <var>root</var>'s data, execute
					the instruction below. Otherwise, go to instruction <var>4</var>.
				</li>
				<li>Return <var>root</var>.</li>
				<li>
					If <var>key</var> is less than the <var>root</var>'s data,
					execute the instruction below. Otherwise, go to instruction
					<var>6</var>.
				</li>
				<li>Set <var>root</var> as its left-child.</li>
				<li>
					If none of the preceding condiitions are met, execute the
					instruction below.
				</li>
				<li>Set <var>root</var> as its right-child.</li>
			</ol>
		</div>
		<section id="time_complexity">
			<h4>Time Complexity</h4>
			<p>
				Examining the binary search tree's search algorithm, we see that
				the the algorithm's complexity depends on the tree's height. And as
				we know, a binary tree's height ${H}$ is bounded:
			</p>
			<figure>$$ \log_{2} n \leq H \leq n $$</figure>
			<p>
				Thus, in the best case scenario, searching a binary tree takes
				${O(\log_{2} n),}$ and in the worst case scenario, it takes
				${O(n).}$
			</p>
		</section>
	</section>
</section>

<section id="inserting_into_binary_tree">
	<h2>Inserting into a Binary Tree</h2>
	<p>We're given the following tree:</p>
	<div id="tree_insert_1"></div>
	<p>The challenge:</p>
	<p class="bq">
		Insert a node containing the value <var>38</var> if, and only if, the
		tree does not contain the value <var>38</var>.
	</p>
	<p>
		Now that we know how to search a binary tree, this problem isn't that
		complicated. All we have to do is search the binary tree for the value
		<var>38</var>. If the value <var>38</var> doesn't exist, we insert the
		node at the position that resulted in <var>root = NULL</var>.
	</p>
	<p>
		Searching for the value <var>38</var>, we end up at the
		<var>node(40)</var>. The point where <var>root = NULL</var> is when we
		assigned <var>root</var> the value <var>node(40).left_child</var>,
		which does not exist. Thus, the value <var>38</var> must be inserited
		as the left-child of <var>node(40)</var>.
	</p>
	<p>
		To implement the algorithm, we can use a tail pointer, call it
		<var>t</var>, and a driver pointer, <var>d</var>. As long as
		<var>d</var> moves, <var>t</var> follows. When <var>d</var> reaches the
		leaf <var>node(40)</var>, <var>t</var> is at <var>node(50)</var>.
		Because <var>38 ≠ 40</var>, <var>t</var> moves to the left-child of
		<var>40</var>, which is <var>NULL</var>. All that's left to do is refer
		to <var>d</var>'s left-child &mdash; pointed at by <var>t</var> &mdash;
		to create and insert the new node <var>node(38)</var>. The procedure:
	</p>
	<ol class="alg">
		<li>fn Insert(Node *root, int key):</li>
		<ol>
			<li>Node *t = NULL;</li>
			<li>while (root != NULL):</li>
			<ol>
				<li>t = root;</li>
				<li>if (key == (*root).data): return;</li>
				<li>else if (key &lt; (*root).data):</li>
				<ol>
					<li>root = (*root).left_child;</li>
				</ol>
				<li>else: root = (*root).right_child;</li>
			</ol>
			<li>Node *new_node;</li>
			<li>new_node = new Node(key);</li>
			<li>if ((*new_node).data &lt; (*t).data):</li>
			<ol>
				<li>(*t).left_child = p;</li>
			</ol>
			<li>else:</li>
			<ol>
				<li>(*t).right_child = p;</li>
			</ol>
		</ol>
	</ol>
	<p>We can also implement this recursively:</p>
	<ol class="alg">
		<li>Node* insert(Node* p, int key):</li>
		<ol>
			<li>Node *t;</li>
			<li>if (p == NULL):</li>
			<ol>
				<li>t = new Node(key);</li>
				<li>return t;</li>
			</ol>
			<li>if (key &lt; (*p).data):</li>
			<ol>
				<li>(*p).left_child = insert((*p).left_child, key);</li>
			</ol>
			<li>else if (key &gt; (*p).data)</li>
			<ol>
				<li>(*p).right_child = insert((*p).right_child, key);</li>
			</ol>
			<li>return t;</li>
		</ol>
	</ol>
</section>

<section id="bst_constructor">
	<h2>BST Generator</h2>
	<p>
		Now that we know how to insert nodes into a binary search tree,
		generating an entire binary tree from scratch is almost trivial. We can
		just insert keys one at a time, using the <var>Insert()</var> function
		we saw earlier:
	</p>
	<ol class="alg">
		<li>newBST(int array[], int nodeCount) -> BST* :</li>
		<ol>
			<li>TreeNode* first_node = newTreeNode(array[0]);</li>
			<li>BST* new_tree = malloc(sizeof(BST));</li>
			<li>(*new_tree).root = first_node;</li>
			<li>for (int i = 1; i &lt; nodeCount; i++):</li>
			<ol>
				<li>insert((*new_tree).root, _arr[i]);</li>
			</ol>
			<li>return new_tree;</li>
		</ol>
	</ol>
</section>

<section id="deleting_from_a_binary_search_tree">
	<h2>BST Node Removal</h2>
	<p>We have the following tree:</p>
	<div id="bst_delete_1"></div>
	<p>
		Now suppose that we're asked to delete a node associated with a
		particular value in the tree. Call it the <i>target node</i>. How might
		we do so? Once again, because we know how to search for nodes, deleting
		is <i>almost</i> trivial, at least for tree's leaves. We just to search
		for the particular node containing the key, then delete if found. For
		the leaves, this is straightforward. If we wanted to delete the node
		containing <var>70</var>, we just have call
		<var>search(root, 70)</var>, then, when we get to <var>70</var>,
		delete:
	</p>
	<div id="bst_delete_2"></div>
	<p>
		All that's left to do after deleting <var>node(70)</var> is to ensure
		its parent, <var>node(60)</var> has its left-child pointer set to
		<var>NULL</var>. Now, we emphasized <i>almost</i> trivial because
		there's a bit of a troublesome case: Deleting branch nodes. For
		example, suppose we were asked to delete the node containing
		<var>60</var>. If we just blindly deleted the node, we'd end up with:
	</p>
	<div id="bst_delete_3"></div>
	<p>
		We've partitioned the tree, and that's likely not what we intended. But
		even if we did, assuming the only way to access the tree was through a
		single <var>root</var> pointer, the other tree &mdash;
		<var>node(55)</var> &mdash; is lost in memory; from a practical
		perspective, we've essentially destroyed it.
	</p>
	<p>
		To avoid this problem: Before deletion, always check if the target node
		is a branch node or a leaf node. If the target node is a branch node
		with only one child, as is the case with <var>node(60)</var>, then the
		target node must take its parent's place after deletion:
	</p>
	<div id="bst_delete_4"></div>
	<p>
		This avoids partitioning, but only for deleting uniparous nodes. What
		if we were now asked to delete <var>node(50)</var>? Once again, blindly
		deleting causes a partition:
	</p>
	<div id="bst_delete_5"></div>
	<p>
		There are several ways to avoid this problem. One way is to fill the
		newly-emptied position with the target node's
		<i>inorder predecesor</i>. In other words, fill the vacancy with the
		node that comes before the target node within the tree's inorder
		traversal sequence. For our tree above, the inorder traversal sequence
		is:
	</p>
	<figure>
		$$ \lang 10, 15, 20, 30, {\color{forestgreen}{40}},
		{\color{indianred}{50}}, {\color{dodgerblue}55} \rang $$
	</figure>
	<p>
		and we can see that <var>node(40)</var> comes before
		<var>node(50)</var>. Above, we've also indicated the blue-colored
		<var>node(55)</var>, <var>node(50)</var>'s <i>inorder successor</i>.
		Thus, if we delete a biparous node, we can choose either the inorder
		predecesor or the inorder successor to fill the vacancy:
	</p>
	<div class="col2">
		<figure class="block">
			<div id="bst_delete_inorder_predecesor"></div>
			<figcaption>Inorder predecesor succession.</figcaption>
		</figure>
		<figure class="block">
			<div id="bst_delete_inorder_successor"></div>
			<figcaption>Inorder successor succession.</figcaption>
		</figure>
	</div>
	<p>
		Given the binary search tree's structure, finding either of these
		successors is easy enough, per the following lemmas:
	</p>
	<dfn>
		<small>definition: inorder predecesor</small>
		<p>
			Let ${N}$ be a node in a binary search tree ${B.}$ The
			<b>inorder predecesor</b> of ${N}$ is the rightmost child of ${B}$'s
			left subtree.
		</p>
	</dfn>
	<dfn>
		<small>definition: inorder successor</small>
		<p>
			Let ${N}$ be a node in a binary search tree ${B.}$ The
			<b>inorder successor</b> of ${N}$ is the leftmost child of ${B}$'s
			right subtree.
		</p>
	</dfn>
	<p>
		We call this vacancy-filling technique <i>inorder-succession</i>.
		Having given a broad overview of how the technique works, let's point
		out some of the flaws with this technique. First, suppose we had the
		following tree:
	</p>
	<div id="removal_degenerate_tree"></div>
	<p>The inorder traversal squence for this tree is:</p>
	<figure>$$ \lang 10, 20, 30, 70, 80, 90 \rang $$</figure>
	<p>
		If we deleted <var>node(20)</var> using inorder-successor-succession,
		then we suddenly have to perform several successions:
	</p>
	<table class="trace">
		<tbody>
			<tr>
				<td colspan="2">Step 0.</td>
			</tr>
			<tr>
				<td>Before deletion. No changes.</td>
				<td>
					<div>$$ \lang 10, 20, 30, 70, 80, 90 \rang $$</div>
					<div id="t1"></div>
				</td>
			</tr>
			<tr>
				<td colspan="2">Step 1.</td>
			</tr>
			<tr>
				<td>
					Remove <var>node(20)</var>. There's a vacancy that must be
					filled, and because we're using inorder-successor-succession,
					<var>node(30)</var> must rise to fill the vacancy. In this case,
					it becomes the left-child of <var>node(90)</var>.
				</td>
				<td>
					<div>$$ \lang 10, 30, \square, 70, 80, 90 \rang $$</div>
					<div id="t2"></div>
				</td>
			</tr>
			<tr>
				<td colspan="2">Step 2.</td>
			</tr>
			<tr>
				<td>
					The previous step results in a vacancy, and now
					<var>node(70)</var> must succeed.
				</td>
				<td>
					<div>$$ \lang 10, 30, 70, \square, 80, 90 \rang $$</div>
					<div id="t3"></div>
				</td>
			</tr>
			<tr>
				<td colspan="2">Step 3.</td>
			</tr>
			<tr>
				<td>Now <var>node(80)</var> must succeed.</td>
				<td>
					<div>$$ \lang 10, 30, 70, 80, \square, 90 \rang $$</div>
					<div id="t4"></div>
				</td>
			</tr>
			<tr>
				<td colspan="2">Step 4.</td>
			</tr>
			<tr>
				<td>
					And finally, <var>node(90)</var> must succeed, which means
					<var>node(30)</var> must succeed.
				</td>
				<td>
					<div>$$ \lang 10, 30, 70, 80, 90 \rang $$</div>
					<div id="t5"></div>
				</td>
			</tr>
		</tbody>
	</table>
	<p>
		<span class="title"><b>time complexity.</b></span> Examining this
		process, we see that the time complexity for removing nodes depends on
		the tree's height. We must search &mdash; i.e., traverse &mdash; the
		tree and modify accordingly.
	</p>
</section>

<section id="bst_generation_traversal">
	<h2>BST Traversal Generation</h2>
	<p>
		Earlier, we saw that we can generate a binary search tree by
		iteratively calling the <var>insert()</var> function. We can, however,
		also generate a BST through preorder-traversal (or
		postorder-traversal). Moreover, unlike the previous sections where we
		saw how we needed an additional inorder-traversal sequence, we can
		generate a binary search tree with preorder- or postorder-traversal
		alone. Let's start with preorder-traversal.
	</p>
	<p>We're given the following preorder-traversal sequence:</p>
	<div id="bst_traversal_generation_array"></div>
	<p>
		Alongside this array, we also need an auxiliary data structure, a
		stack:
	</p>
	<div id="bst_traversal_generation_stack"></div>
	<p>
		With the sequence and the stack, we can begin. We start by focusing on
		the first element of the sequence. In this case, <var>pre[0]=30</var>.
		We create a node and have two pointers point to it, the
		<var>root</var> pointer, and a temporary pointer <var>p</var>:
	</p>
	<div class="col2">
		<div id="bst_gen_arr1"></div>
		<div id="bst_gen_trav1"></div>
		<div id="bst_gen_stack1"></div>
	</div>
	<p>
		Now we focus on the next element, <var>pre[1]=20</var>. We make a
		check: <var>pre[0] &lt; 30</var>. True. Because it's true, we perform
		the following steps:
	</p>
	<ol>
		<li>Create a new node with a temporary pointer <var>t</var>.</li>
		<li>Make <var>p</var>'s left-child pointer point to the new node.</li>
		<li>Push the address of <var>p</var>'s pointee into the stack.</li>
		<li>Move <var>p</var> to the newly created node.</li>
	</ol>
	<p>Thus, we have:</p>
	<div class="col2">
		<div id="bst_gen_arr2"></div>
		<div id="bst_gen_trav2"></div>
		<div id="bst_gen_stack2"></div>
	</div>
	<p>
		Now we move to the next element in the sequence, <var>pre[2]=10</var>.
		We perform the check again: <var>pre[2] &lt; 20</var>. True. Again, we
		create a new node with a temporary pointer <var>t</var>, make
		<var>p</var>'s left-child pointer to the new node, push the address of
		<var>p</var>'s pointee into the stack, and move <var>p</var> to the
		newly created node:
	</p>
	<div class="col2">
		<div id="bst_gen_arr3"></div>
		<div id="bst_gen_trav3"></div>
		<div id="bst_gen_stack3"></div>
	</div>
	<p>
		Move the next element, <var>pre[3]=15</var>. Check:
		<var>pre[3] &lt; 10</var>. False. So, <var>node(15)</var> should be the
		right-child of <var>node(10)</var>. But not so fast. We have to be
		careful here. Suppose <var>pre[3]</var> was <var>28</var> instead. If
		that were the case, then blindly attaching <var>node(28)</var> as the
		right-child of <var>node(10)</var> would cause a problem &mdash;
		<var>28</var> is greater than <var>25</var>, and any node greater than
		<var>25</var> should be in <var>node(25)</var>'s right-subtree, not its
		left. Accordingly, we have two possibilities when
		<var>node(i) &lt; node(i-1)</var> (i.e., when the node we're about to
		insert has a value less than the node we just inserted):
	</p>
	<ol>
		<li><var>node(i-1) &lt; node(i) &lt; stackTop(node)</var></li>
		<li><var>node(i-1) &lt; stackTop(node) &lt; node(i)</var></li>
	</ol>
	<p>
		The first case is when the node we're about to insert has a value
		greater than the node we just inserted, but less than the value of the
		node at the stack's topframe. (The node at the stack's topframe is the
		node we inserted just before the last node we inserted). If the first
		case is true, then we proceed to inserting the new node as the
		right-child. In this case, it is, so we perform the following:
	</p>
	<ol>
		<li>Create a new node as the pointee of <var>t.</var></li>
		<li>Make <var>p</var>'s right-child point to <var>t</var>.</li>
		<li>Set <var>p</var>'s new pointee as <var>t</var>.</li>
	</ol>
	<p>
		Importantly, we <em>do not</em> push <var>p</var> onto the stack. Why
		don't we push <var>p</var>? Because if we pushed <var>p</var> onto the
		stack, then the stack's topmost frame would contain the address of
		<var>Node(10)</var>. But we don't need that address in there. The
		stack's sole purpose is to keep track of which nodes could still have
		children. The moment we assign a right-child to a node, there are no
		other possible children the node can have, because the sequence we're
		given is the inorder traversal sequence &mdash; there are no
		left-children for a particular node once we've been given its
		right-child.
	</p>
	<p>That said, performing the above results in:</p>
	<div class="col2">
		<div id="bst_gen_arr4"></div>
		<div id="bst_gen_trav4"></div>
		<div id="bst_gen_stack4"></div>
	</div>
	<p>
		Now we go to the next element &mdash; <var>pre[4]=25</var>. Check once
		more: <var>pre[4] &lt; 15</var>. False. We've hit another false case,
		so we make the additional check we saw earlier. Is
		<var>pre[4] &gt; (*p).data</var>? I.e., is <var>25 &gt; 15</var>? Yes.
		Check the second possibility: Is <var>pre[4] &lt; stackTop(node)</var>?
		No, <var>25 &nlt; 20</var>.
	</p>
	<p>
		Here, the second case is true. So, we pop the stack, and move
		<var>p</var> to that address <var>node(20)</var>. Then we must compare
		again: <var>25 &lt; 20</var>? False. Once more we make a check: Is
		<var>pre[4] &lt; stackTop(node)</var>? Yes. <var>25 &lt; 30.</var> Now
		we can continue the normal course &mdash; attach <var>node(25)</var> as
		the right-child of <var>node(20)</var>, with <var>p</var> pointing to
		the new node:
	</p>
	<div class="col2">
		<div id="bst_gen_arr5"></div>
		<div id="bst_gen_trav5"></div>
		<div id="bst_gen_stack5"></div>
	</div>
	<p>
		Next: <var>pre[5]=40</var>. First check:
		<var>pre[5] &lt; (*p).data</var>. False; <var>40 &nlt; 25.</var> Second
		check: <var>pre[5] &gt; (*p).data</var>. True. Third check: Is
		<var>pre[5] &lt; peek(stack)->data</var> False. So, we have to pop the
		stack. <var>p = pop(stack)</var>. Now <var>p</var> points to
		<var>node(30)</var>, and we go through checks again. This results in:
	</p>
	<div class="col2">
		<div id="bst_gen_arr6"></div>
		<div id="bst_gen_trav6"></div>
		<div id="bst_gen_stack6"></div>
	</div>
	<p>The process continues for the remaining elements. The algorithm:</p>
	<ol class="alg">
		<li>fn createPre(int pre[], int n):</li>
		<ol>
			<li>Stack _stack = newStack(5);</li>
			<li>Node *t;</li>
			<li>int i = 0;</li>
			<li>root = newNode();</li>
			<li>(*root).data = pre[i];</li>
			<li>i++;</li>
			<li>Node* p = root;</li>
			<li>while (i &lt; n):</li>
			<ol>
				<li>if (pre[i] < (*p).data):</li>
				<ol>
					<li>t = newNode(pre[i++]);</li>
					<li>(*p).left_child = t;</li>
					<li>push(_stack, p);</li>
					<li>p = t;</li>
				</ol>
				<li>
					else if ((pre[i] > (*p).data) && (pre[i] < peek(stack)->data)):
				</li>
				<ol>
					<li>t = newNode(pre[i++]);</li>
					<li>(*p).right_child = t;</li>
					<li>p = t;</li>
				</ol>
				<li>else:</li>
				<ol>
					<li>p = pop(stack);</li>
				</ol>
			</ol>
		</ol>
	</ol>
</section>

<section id="binary_search_tree_costs">
	<h2>Binary Search Tree Costs</h2>
	<p>
		As with all data structures, there are costs to binary search trees.
		The BST's most significant cost is the lack of control over order of
		insertion. For example, the following traversal sequences have the same
		keys, but generate two different trees:
	</p>
	<div class="split">
		<figure class="block">
			<div id="bst_cost_arr1"></div>
			<div id="bst_cost_tree_1"></div>
			<figcaption>Tree ${\texttt{T}_1}$</figcaption>
		</figure>
		<figure class="block">
			<div id="bst_cost_arr2"></div>
			<div id="bst_cost_tree_2"></div>
			<figcaption>Tree ${\texttt{T}_2}$</figcaption>
		</figure>
	</div>
	<p>
		Notice that ${\texttt{T}_1}$ has a height of ${2,}$ while
		${\texttt{T}_2}$ has a height of ${6.}$ Two different heights for the
		same set of keys! This shows that a BST's height depends on the order
		of key insertion.
	</p>
	<p>
		Can we control the order of insertion? With what we have so far, no.
		Ultimately, how the keys are inserted is up to the user. If the user
		inserts the keys according to ${\texttt{T}_1}$'s traversal sequence,
		then they'll get the tree ${\texttt{T}_1.}$ But if they insert the keys
		according to ${\texttt{T}_2}$ then they'll get the tree
		${\texttt{T}_2.}$
	</p>
	<p>
		Because of this problem, we need a way to control the height of a
		binary search tree. Fortunately, there's a solution &mdash;
		<a href="">AVL trees</a>.
	</p>
</section>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script type="module" src="../../../static/numerc/CDemo.mjs"></script>
<script type="module" src="../../../static/numerc/csmd/csmd.mjs"></script>
<!-- <script type="module" src="../../../static/numerc/csmd/cdemo/cdemo.mjs"></script> -->
<script
	type="module"
	src="../../../static/numerc/scripts/cpp_tree.js"
></script>

{% endblock %}
