{% extends '../layout.html' %} {% load static %} {% block description %}
<meta
	name="description"
	content="Introduction to object-oriented programming in C++"
/>
{% endblock %} {% block title %}
<title>Classes in C++</title>
{% endblock %} {% block content %}
<h1>Classes</h1>
<section id="intro">
	<p>
		In this essay, we explore object-oriented programming (OOP) in C++. OOP is
		the reigning paradigm in modern programming. A core goal of this essay is to
		understand why the OOP status quo continues, as well as reasons for why this
		may or may not change in the future.
	</p>
	<p>
		The cornerstone of object-oriented programming is the ability to construct
		our own data types. We know that there are types provided natively by a
		language, what we might call
		<i>primitive types</i>.<sup></sup> In C++, these types include
		<var>char</var>, <var>int</var>, <var>double</var>, <var>bool</var>,
		<var>float</var>, etc.
	</p>
	<div class="note">
		<p>
			Primitive types are also called <i>base types</i> or <i>atomic types</i>.
		</p>
	</div>
	<p>
		Although we can solve many problems with just these types, having such a
		small set of types can feel restrictive and stuffy. What if we have data
		that should be paired together? The airline passenger isn't just a number;
		they have a name, an age, gender, address, consumer preferences, mileage
		quantity, and possibly a special customer status. The solar system isn't
		just an array of eight planets; there are moons, dwarf planets, revolution
		paths, which themselves have related data.
	</p>
	<p>
		Related data doesn't even just occur with discrete entities. Mathematical
		formulas might be classified according to fields. We might have a formula
		related to probability, another related to geometry, another to calculus,
		another to number theory.
	</p>
	<p>
		Trying to model these complex ideas with just primitive types is painful.
		Worse, what if we need to change those models? What we need is an
		<i>abstraction</i> &mdash; <b>higher-order data types</b>.
	</p>
	<p>
		Recall that a data type is a set consisting of two subsets: a set of values,
		called the data type's <b>domain</b>, and a <b>set of operations</b> on
		those values. For example, the data type <var>int</var> is a data type
		pre-defined by C++. The values it represents are the integers (specifically
		${-2^{31}}$ to ${2^{31}}$), and the operations we may perform on those
		values are the various arithmetic and comparison operators (<span
			class="monoText"
			>+</span
		>, <var>*</var>, <var>%</var>, etc.).
	</p>
	<p>
		With object-oriented programming, we write C++ code to define new data
		types. We say that an <b>object</b> is an entity that holds a
		<i>data-type value</i> &mdash; you can manipulate the data type value by
		using the object's data-type operations. The practice of defining new data
		types and manipulating objects holding data-type values is called
		<b>data abstraction</b>.
	</p>
	<p>The foundational principle of object-oriented programming:</p>
	<figure class="math-display">
		<div class="rule">
			<p>
				<span class="topic">Principle.</span> Always separate data from
				operations on that data.
			</p>
		</div>
	</figure>
	<p>
		Notice that with the primitive data types, we were never really worried
		about how the data type represents the values. Of course, we know how the
		data is represented (bits allocated in memory), but when using the data
		types, we rarely stopped to consider the data type's implementation. This is
		precisely what data types are supposed to do. For the data type user, the
		only concern should be the <i>operations</i> that can be performed with that
		data type. Of course, the story is different for the data type implementer.
		The implementer must always think about both the set of values represented,
		as well as the operations that can be performed on those values.
	</p>
	<figure class="math-display">
		<div class="rule">
			<p>
				<span class="topic">Principle.</span> A data type should not require the
				user to know how the data type is implemented.
			</p>
		</div>
	</figure>
</section>

<section id="classes">
	<h2>The Class</h2>
	<p>
		The C++ <var>class</var> provides a way to define data types. In a
		<var>class</var>, we specify the data-type values and implement the
		data-type operations. Let's write a simple class for a rectangle:
	</p>
	<pre class="language-cpp"><code>
		class Rectangle {
			int width;
			int height;
			int area() {
				return width * height;
			}
			int perimeter() {
				return 2 * (width + height);
			}
		};
		
	</code></pre>
	<p>
		Above, we created a class called <var>Rectangle</var>. This is a new data
		type. It has two <i>properties</i>, <var>width</var> and <var>height</var>,
		of type <var>int</var>. It also has two functions &mdash; called
		<i>methods</i> &mdash; which have a return type of <var>int</var>.
	</p>
	<p>Now, let's try using this new class:</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		class Rectangle {
			int width;
			int height;
			int area() {
				return width * height;
			}
			int perimeter() {
				return 2 * (width + height);
			}
		};
		
		int main() {
			Rectangle r1;
			r1.width = 7;
			r1.height = 2;
			return 0;
		}
	</code></pre>
	<p>
		Above, we created an <i>objects</i> of type <var>Rectangle</var>. This
		object is named <var>r1</var>. Alternatively, we say that <var>r1</var> is
		an <i>instance</i> of the class <var>Rectangle</var>. Having created these
		two objects, we attempt to assign to <var>r1</var>'s properties &mdash;
		<var>width</var> and <var>height</var> &mdash; that <var>int</var> values
		<var>7</var> and <var>2</var> respectively. The compiler's response:
	</p>
	<pre class="language-bash"><code>
		rectangle.cpp:17:5: error: 'width' is a private member of 'Rectangle'
						r1.width = 7;
							^
		rectangle.cpp:5:6: note: implicitly declared private here
						int width;
								^
		rectangle.cpp:18:5: error: 'height' is a private member of 'Rectangle'
						r1.height = 2;
							^
		rectangle.cpp:6:6: note: implicitly declared private here
						int height;
								^
		2 errors generated.
	</code></pre>
	<p>
		We get back an error. Why? We're seeing this error because of the concept of
		<b>visibility</b>. By default, all class properties and methods are
		<var>private</var>. This is an example of an <b>access modifier</b>. If a
		property or method is <var>private</var>, then
		<span class="underlineText">only</span> functions within the class have
		access to the class's properties or methods. Functions outside of the class
		&mdash; e.g., <var>main()</var> &mdash; do not have access to the private
		properties or methods. We can fix this by appending the keyword
		<var>public</var>:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		class Rectangle {
			public:
				int width;
				int height;
				int area() {
					return width * height;
				}
				int perimeter() {
					return 2 * (width + height);
				}
		};
		
		int main() {
			Rectangle r1;
			r1.width = 7;
			r1.height = 2;
			return 0;
		}
	</code></pre>
	<p>
		By appending the keyword <var>public</var>, we have effectively made the
		class's properties and methods visible &mdash; i.e., available for use
		&mdash; to any part of our program. Now let's try using the methods:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		class Rectangle {
			public:
				int width;
				int height;
				int area() {
					return width * height;
				}
				int perimeter() {
					return 2 * (width + height);
				}
		};
		
		int main() {
			Rectangle r1;
			r1.width = 7;
			r1.height = 2;
			cout << r1.area() << endl;
			cout << r1.perimeter() << endl;
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		14
		18
	</code></pre>
	<p>
		It works. Notice the use of dots, or periods, to access properties and
		methods. This is called <b>dot notation</b>, and is a common syntactic
		approach for accessing properties and methods in object-oriented
		languages.<sup></sup>
	</p>
	<div class="note">
		<p>
			The use of <b>dot notation</b> can be traced back to Simula 67, the
			language widely credited as the first object-oriented language. However,
			there is evidence of the dot notation being used even further back: The
			PL/I language for the IBM 360 used dot notation to specify fields in a
			record.
		</p>
	</div>
</section>

<section id="accessors">
	<h2>Access Modifiers</h2>
	<p>
		In the examples above, we set the properties and methods in our classes
		<var>public</var>. This is not always a good idea. For starters, having them
		set to <var>public</var> implies that anyone has access to them. This can be
		very dangerous, depending on what our class is being used for. How do we
		ensure that properties and methods are hidden? I.e., only the class has
		access to its methods and properties? For that, we need
		<b>access modifiers</b>. Access modifiers are also called
		<i>accessors</i> or <i>access specifiers</i>.
	</p>
	<p>
		In C++, there are three access modifiers:
		<var><mark>public</mark></var
		>, <var><mark>protected</mark></var
		>, and <var><mark>private</mark></var
		>. We'll look at each of them in turn.
	</p>
</section>

<section id="private_access">
	<h3>The Private Keyword</h3>
	<p>
		By default, all properties and methods in a C++ class are set to
		<var>private</var>. This means that outside of the class containing those
		properties and methods, no access is provided. For example:
	</p>
	<pre class="language-cpp"><code>
		// we don't have to write out 'private', but we do so here to be explicit
		class Cylinder {
			private:
				double pi = 3.14;
				double radius;
				double height;
			public:
				double surfaceArea() {
					return 2 * pi * radius * (radius + height);
				}
				double volume() {
					return pi * radius * radius * height;
				}
		};
	</code></pre>
	<p>
		By default, all of the properties in class
		<var>Cylinder</var> is set to <var>private</var>. However, we set the
		methods <var>public</var>, because those are functions we would like to
		access directly. Now, because the properties of <var>Cylinder</var> are set
		to <var>private</var>, we cannot access them in <var>main()</var>, nor
		anywhere else outside of <var>class Cylinder</var>'s definition. But this
		means that the methods <var>surfaceArea()</var> and <var>volume()</var> are
		essentially useless, because we don't have a way to set the values of
		<var>radius</var> and <var>height</var>. But we want to keep the properties
		<var>private</var>
		<span class="underlineText">and</span> be still be able to initialize them
		outside of the <var>class</var> definition. Can we do so? It seems like we
		can't.
	</p>
	<p>
		Oh but we can. We can get around the
		<var>private</var> barrier by setting some function in the inside the class
		as <var>public</var>. Think of it as leaving a tiny gap, or window, for us
		to access the class.
	</p>
	<p>
		Let's start with one of the properties,
		<var>radius</var>. To be able to initialize this property, we just need a
		<var>public</var> method that initializes the property:
	</p>
	<pre class="language-cpp"><code>
		class Cylinder {
			double pi = 3.14;
			double radius;
			double height;
			public:
				double surfaceArea() {
					return 2 * pi * radius * (radius + height);
				}
				double volume() {
					return pi * radius * radius * height;
				}
				void setRadius(double r) {
					radius = r; // remember you don't need a return for void return types
				}
				void setHeight(double h) {
					height = h;
				}
		};
	</code></pre>
	<p>
		The functions <var>setRadius()</var> and <var>setHeight()</var> are set to
		<var>public</var>, and they are what allow us to access to initialize the
		properties <var>radius</var> and <var>height</var>, even if they are set to
		<var>private</var>. Let's try it:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		class Cylinder {
			double pi = 3.14;
			double radius;
			double height;
			public:
				double surfaceArea() {
					return 2 * pi * radius * (radius + height);
				}
				double volume() {
					return pi * radius * radius * height;
				}
				void setRadius(double r) {
					radius = r; // remember you don't need a return for void return types
				}
				void setHeight(double h) {
					height = h;
				}
		};
		
		int main() {
			Cylinder cindy = Cylinder();
			cindy.setRadius(3.2);
			cindy.setHeight(8.6);
			cout << cindy.surfaceArea() << endl;
			cout << cindy.volume() << endl;
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		237.133
		276.521
	</code></pre>
	<p>
		Great. It works. Unfortunately, we can't directly access
		<var>radius</var> and <var>height</var> because they're still set to
		<var>private</var>. But what if we need the <var>radius</var> and
		<var>height</var>? Well, we'll just write another <var>public</var> method,
		one that retrieves <var>radius</var> and <var>height</var>:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		class Cylinder {
			double pi = 3.14;
			double radius;
			double height;
			public:
				double surfaceArea() {
					return 2 * pi * radius * (radius + height);
				}
				double volume() {
					return pi * radius * radius * height;
				}
				void setRadius(double r) {
					radius = r; // remember you don't need a return for void return types
				}
				double getRadius() {
					return radius;
				}
				void setHeight(double h) {
					height = h;
				}
				double getHeight() {
					return height;
				}
		};
		
		int main() {
			Cylinder cindy = Cylinder();
			cindy.setRadius(3.2);
			cindy.setHeight(8.6);
			cout << cindy.getRadius() << endl;
			cout << cindy.getHeight() << endl;
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		3.2
		8.6
	</code></pre>
	<p>
		Above, we wrote two new functions,
		<var>getRadius()</var> and <var>getHeight()</var>, both of which are of type
		<var>double</var>, since they return a <var>double</var>. Let's think a
		little more carefully about what this means. The methods
		<var>getRadius()</var> and <var>getHeight()</var> are one way streets. We
		can only <i>retrieve</i> the values assigned to the properties
		<var>radius</var> and <var>height</var>, but in no way can we use them to
		<i>modify</i> the values assigned. This effectively ensures that
		<var>radius</var> and <var>height</var> remain <var>private</var>; we cannot
		modify them, we can only read them. Hence the term <i>access modifier</i>,
		rather than something like &#8220;visibility modifier.&#8221; In other
		words, the access modifier only restricts the ability to write; it doesn't
		necessarily restrict the ability to read.
	</p>
	<p>
		The methods <var>setRadius()</var> and <var>setHeight()</var> are examples
		of what we call <b>setters</b>. Setters are methods for
		<i>initializing</i>
		properties in a class definition. The methods
		<var>getRadius()</var> and <var>getHeight()</var> are examples of
		<b>getters</b>: methods that <i>retrieve</i>, or <i>read</i>, the values
		assigned to properties in a class definition.<sup></sup>
	</p>
	<div class="note">
		<p>
			Getters are also called <i>accessors</i>, and setters are also called
			<i>mutators</i>. These methods are more broadly called
			<i>property functions</i>.
		</p>
	</div>
	<p>
		With getters and setters, we can now be more elaborate in how class
		properties are initialized. For example, there's a troubling aspect to our
		properties and methods: What if the user sets a property to negative? That
		would make no sense mathematically, because the lengths, widths, heights,
		radii, volumes, etc. of geometric figures cannot be negative. Accordingly,
		we should ensure that these values are always positive:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		class Maths {
			public:
				template&lt;class T&gt;
				T abs(T x) {
					if (x < 0) { return -1 * x; }
					else { return x; }
				}
		};
		
		class Cylinder {
			double pi = 3.14;
			double radius;
			double height;
			public:
				double surfaceArea() {
					return 2 * pi * radius * (radius + height);
				}
				double volume() {
					return pi * radius * radius * height;
				}
				void setRadius(double r) {
					radius = abs(r);
				}
				double getRadius() {
					return radius;
				}
				void setHeight(double h) {
					height = abs(h);
				}
				double getHeight() {
					return height;
				}
		};
		
		int main() {
			Cylinder cindy = Cylinder();
			cindy.setRadius(-1.2);
			cindy.setHeight(-4.3);
			cout << cindy.getRadius() << endl;
			cout << cindy.getHeight() << endl;
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		1.2
		4.3
	</code></pre>
	<p>
		Above, we wrote a separate class, <var>Maths</var>, which provides a method
		called <var>abs</var>. We then call that method in <var>Cylinder</var> to
		ensure the values set for <var>Radius</var> and <var>Height</var> are
		positive only.
	</p>
</section>

<section id="constructors">
	<h2>Constructors</h2>
	<p>
		In the examples above, we initialized the properties of
		<var>Cylinder()</var> with special methods &mdash; getters and setters.
		Getters and setters, however, should not be the default way we initialize
		properties. To understand why, let's think more abstractly about what a
		class does. A class is akin to a factory. It produces objects that have
		certain properties and can do certain things. When we write:
	</p>
	<pre class="language-cpp"><code>
		Cylinder cindy = Cylinder();
	</code></pre>
	<p>
		we are asking the <var>Cylinder</var> factory to give us a cylinder. Does it
		make sense for that cylinder to have no radius and height? Of course not.
		Every cylinder has a radius and a height. The same goes for other objects.
		when we order a <var>Cake()</var>, it would be odd for the cake not to have
		ingredients or volume. It's an <i>object</i>.
	</p>
	<p>
		Of course, there are objects in the world where we order the recipe or
		instructions, but not the object itself. Those transactions are best modeled
		with getters and setters. These processes, however, are the exception rather
		than the rule.
	</p>
	<p>
		Having said that, when we order something from a factory, we want to
		specifically state the properties our ordered object should have. For
		example, when we order a <var>Cylinder()</var>, we should state what the
		<var>Cylinder()</var>'s radius and height should be. This is especially
		important because in C++, when we order an object without its properties
		initialized (using the code we wrote above), the properties have
		<i>garbage values</i>. It's akin to a factory sending us some random
		cylinder.
	</p>
	<p>
		So how do we ensure that the factory doesn't send us a random cylinder? By
		ensuring that the factory forces us to specify what the cylinder's radius
		and height should be. To do so, we use a
		<b>constructor</b>. A constructor is a method we write inside a class that
		is automatically called when we create an instance of that class. I.e.,
		whenever we order a particular object, we must specify what that object's
		properties are.
	</p>
	<p>
		There are four different types of constructors in C++: (1) the
		<b>default constructor</b>; (2) <b>non-parameterized constructor</b>; (3)
		<b>parameterized constructor</b>; and (4) <b>copy constructor</b>. Of these
		four, the last three are constructors that we write. The default constructor
		is the constructor provided by the compiler. There are several other
		constructors, but we will focus on the latter three first. To do so, let's
		write a new class called
		<var>Cuboid</var>
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		class Maths {
			public:
				template&lt;class T&gt;
				T abs(T x) {
					if (x < 0) { return -1 * x; }
					else { return x; }
				}
		};
		
		class Cuboid {
			double length;
			double width;
			double height;
		
			public:
				double volume() {
					return length * width * height;
				}
				double surfaceArea() {
					return 2 * ((length * width) + (width * height) + (height * length));
				}
				double lateralSurfaceArea() {
					return 2 * ((width * height) + (height * length));
				}
				// Getters and setters
				void setLength(double l) {
					length = Maths().abs(l);
				}
				double getLength() {
					return length;
				}
				void setWidth(double w) {
					width = w;
				}
				double getWidth() {
					return width;
				}
				void setHeight(double h) {
					height = h;
				}
				double getHeight() {
					return height;
				}
		};
		
		int main() {
			return 0;
		}
	</code></pre>

	<p>
		Notice how many getters and setters we have. This evidences yet another
		problem with getters and setters: The more properties we have that must be
		initialized, the more getters and setters we have to write. Constructors
		allow us to define our <var>Cuboid</var> class more concisely. Before we see
		how much more concise our code can be, let's first consider what the
		constructor does.
	</p>
	<p>
		The constructor is just another function (or method to be precise). First,
		let's consider the
		<i>non-parameterized constructor</i>. This is a constructor that performs
		one task: If we call the constructor without passing it any arguments, it
		creates a new object whose properties are initialized with
		<i>default values</i>:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		class Maths {
			public:
				template&lt;class T&gt;
				T abs(T x) {
					if (x < 0) { return -1 * x; }
					else { return x; }
				}
		};
		
		class Cuboid {
			double length;
			double width;
			double height;
		
			public:
				double volume() {
					return length * width * height;
				}
				double surfaceArea() {
					return 2 * ((length * width) + (width * height) + (height * length));
				}
				double lateralSurfaceArea() {
					return 2 * ((width * height) + (height * length));
				}
				// Getters and setters
				void setLength(double l) {
					length = Maths().abs(l);
				}
				double getLength() {
					return length;
				}
				void setWidth(double w) {
					width = w;
				}
				double getWidth() {
					return width;
				}
				void setHeight(double h) {
					height = h;
				}
				double getHeight() {
					return height;
				}
				// Non-parameterized constructor
				Cuboid() {
					length = 1.0;
					width = 1.0;
					height = 1.0;
				}
		};
		
		int main() {
			return 0;
		}
	</code></pre>
	<p>
		Now whenever we write <var>Cuboid()</var>, we will create a
		<var>Cuboid</var> object whose properties are all initialized to
		<var>1.0</var>. The non-parameterized constructor ensures that we never get
		back an object whose properties are initialized to garbage values.
	</p>
	<p>
		But what if the user passes an argument? For that case, we write a
		<i>parameterized constructor</i>. This constructor will take the arguments,
		and <span class="underlineText">set</span> the properties to those values.
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		class Maths {
			public:
				template&lt;class T&gt;
				T abs(T x) {
					if (x < 0) { return -1 * x; }
					else { return x; }
				}
		};
		
		class Cuboid {
			double length;
			double width;
			double height;
		
			public:
				double volume() {
					return length * width * height;
				}
				double surfaceArea() {
					return 2 * ((length * width) + (width * height) + (height * length));
				}
				double lateralSurfaceArea() {
					return 2 * ((width * height) + (height * length));
				}
				// Getters and setters
				void setLength(double l) {
					length = Maths().abs(l);
				}
				double getLength() {
					return length;
				}
				void setWidth(double w) {
					width = w;
				}
				double getWidth() {
					return width;
				}
				void setHeight(double h) {
					height = h;
				}
				double getHeight() {
					return height;
				}
				// Non-parameterized constructor
				Cuboid() {
					length = 1.0;
					width = 1.0;
					height = 1.0;
				}
				// Parameterized constructor
				Cuboid(double l, double w, double h) {
					setLength(l);
					setWidth(w);
					setHeight(h);
				}
		};
		
		int main() {
			return 0;
		}
	</code></pre>
	<p>
		Notice that with the parameterized constructor, we take the arguments, and
		use those arguments as arguments to the setters. This has the effect of
		initializing all of the <var>Cuboid</var> object's properties. With the
		parameterized constructor, we can now clean up our code. The setters are all
		redundant. We can simply take the arguments passed to the parameterized
		constructor and assign them directly, rather than passing them into separate
		functions:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		class Maths {
			public:
				template&lt;class T&gt;
				T abs(T x) {
					if (x < 0) { return -1 * x; }
					else { return x; }
				}
		};
		
		class Cuboid {
			double length;
			double width;
			double height;
		
			public:
				double volume() {
					return length * width * height;
				}
				double surfaceArea() {
					return 2 * ((length * width) + (width * height) + (height * length));
				}
				double lateralSurfaceArea() {
					return 2 * ((width * height) + (height * length));
				}
				// Getters
				double getLength() {
					return length;
				}
				double getWidth() {
					return width;
				}
				double getHeight() {
					return height;
				}
				// Non-parameterized constructor
				Cuboid() {
					length = 1.0;
					width = 1.0;
					height = 1.0;
				}
				// Parameterized constructor
				Cuboid(double l, double w, double h) {
					length = l;
					width = w;
					height = h;
				}
		};
		
		int main() {
			return 0;
		}
	</code></pre>
	<p>
		The non-paramterized constructor is also redundant because we can pass
		default values to functions:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		class Maths {
			public:
				template&lt;class T&gt;
				T abs(T x) {
					if (x < 0) { return -1 * x; }
					else { return x; }
				}
		};
		
		class Cuboid {
			double length;
			double width;
			double height;
		
			public:
				// Constructor
				Cuboid(double l=1.0, double w=1.0, double h=1.0) {
					length = Maths().abs(l);
					width = Maths().abs(w);
					height = Maths().abs(h);
				}
				// Methods
				double volume() {
					return length * width * height;
				}
				double surfaceArea() {
					return 2 * ((length * width) + (width * height) + (height * length));
				}
				double lateralSurfaceArea() {
					return 2 * ((width * height) + (height * length));
				}
				// Getters
				double getLength() {
					return length;
				}
				double getWidth() {
					return width;
				}
				double getHeight() {
					return height;
				}
		};
		
		int main() {
			return 0;
		}
	</code></pre>
	<p>
		Finally, a helpful constructor to write alongside the parameterized
		constructor is a <i>copy constructor</i>. This constructor creates a copy of
		an existing object:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		class Maths {
			public:
				template&lt;class T&gt;
				T abs(T x) {
					if (x < 0) { return -1 * x; }
					else { return x; }
				}
		};
		
		class Cuboid {
			double length;
			double width;
			double height;
		
			public:
				// Constructor
				Cuboid(double l=1.0, double w=1.0, double h=10) {
					length = Maths().abs(l);
					width = Maths().abs(w);
					height = Maths().abs(h);
				}
				// Copy Constructor
				Cuboid(Cuboid &c) {
					length = c.length;
					width = c.width;
					height = c.height;
				}
				// Methods
				double volume() {
					return length * width * height;
				}
				double surfaceArea() {
					return 2 * ((length * width) + (width * height) + (height * length));
				}
				double lateralSurfaceArea() {
					return 2 * ((width * height) + (height * length));
				}
				// Getters
				double getLength() {
					return length;
				}
				double getWidth() {
					return width;
				}
				double getHeight() {
					return height;
				}
				
		};
		
		int main() {
			Cuboid c1 = Cuboid(2.0, 3.0, 5.0);
			Cuboid c2 = Cuboid(c1);
			cout << c1.volume() << endl;
			cout << c2.volume() << endl;
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		30
		30
	</code></pre>
</section>

<section id="deep_copy_constructor">
	<h3>Deep Copy Constructor</h3>
	<p>
		Because copy constructors use references, there's an underlying problem we
		might potentially encounter whenever we use them. Consider a class called
		<var>A</var> (for the sake of simplicity, we will think of this outside the
		context of a real-world application and keep the properties public):
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		class A {
		public:
			int x;
			int *p;
			A(int n) {
				x = n;
				p = new int[x];
			}
			A(A &t) {
				x = t.x;
				p = t.p;
			}
		};
		
		int main() {
			return 0;
		}
	</code></pre>
	<p>
		The class <var>A</var> has two properties: <var>x</var>, which takes an
		<var>int</var> value, and <var>*p</var>, which is a pointer.
	</p>
	<p>
		Next, the class <var>A</var> also has two methods. First, a parameterized
		constructor, which assigns to <var>x</var> the argument passed as
		<var>n</var>. Additionally, the parameterized constructor initializes
		<var>p</var> with a new <var>int</var> array, of size <var>x</var> (which is
		the value of <var>n</var>, the integer passed as argument). Thus, whenever
		we create an instance of <var>A</var>, we create a new <var>int</var> array
		in the heap.
	</p>
	<p>
		The class <var>A</var> also contains a copy constructor, which takes as
		argument a reference, <var>&t</var>. That argument is a reference to an
		existing instance of <var>A</var>. Inside the copy constructor, we assign to
		<var>x</var> the <var>x</var> property of the existing
		<var>A</var> instance, and to <var>p</var> the pointer property
		<var>p</var> of the existing <var>A</var> instance.
	</p>
	<p>Instantiating:</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
			
		class A {
		public:
			int x;
			int *p;
			public:
				A(int n) {
					x = n;
					p = new int[x];
				}
				A(A &t) {
					x = t.x;
					p = t.p;
				}
		};
		
		int main() {
			A foo = A(3);
			return 0;
		}
	</code></pre>
	<p>
		We've now created an instance of <var>A</var> called <var>foo</var>. That
		instance has a property <var>x</var>, containing the <var>int 3</var>. More
		importantly, it contains a pointer property <var>p</var>, which points to an
		array in the heap of size 5. Now what happens when we create a copy of
		<var>foo</var>?
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		class A {
		public:
			int x;
			int *p;
			public:
				A(int n) {
					x = n;
					p = new int[x];
				}
				A(A &t) {
					x = t.x;
					p = t.p;
				}
		};
		
		int main() {
			A foo = A(3);
			A boo = A(foo);
			return 0;
		}
	</code></pre>
	<p>
		We've created a copy of <var>foo</var> called <var>boo</var>. Did
		<var>boo</var> create a new array of its own? Well, we can check by
		outputting the address. If <var>boo</var> created its own array, they should
		be different:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		class A {
		public:
			int x;
			int *p;
				A(int n) {
					x = n;
					p = new int[x];
				}
				A(A &t) {
					x = t.x;
					p = t.p;
				}
		};
		
		int main() {
			A foo = A(3);
			A boo = A(foo);
			foo.p[0] = 1;
			cout << foo.p << endl;
			cout << boo.p << endl;
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		0x7fc6f1405c00
		0x7fc6f1405c00
	</code></pre>
	<p>
		They're the same address. The copy of <var>foo</var>, named <var>boo</var>,
		didn't create its own array. We now have two pointers pointing to the same
		array in the heap. This is something we have to be very careful with. If we
		want a copy to have its own array in the heap, we must write a
		<i>deep copy constructor</i>:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		class A {
		public:
			int x;
			int *p;
				A(int n) {
					x = n;
					p = new int[x];
				}
				A(A &t) {
					x = t.x;
					p = new int[x]; // revision
				}
		};
		
		int main() {
			A foo = A(3);
			A boo = A(foo);
			foo.p[0] = 1;
			cout << foo.p << endl;
			cout << boo.p << endl;
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		0x7fe603c05c00
		0x7fe603c05c10
	</code></pre>
	<p>
		Having revised our copy constructor, we now see that copies create their own
		arrays.
	</p>
</section>

<section id="scope_resolution">
	<h2>Scope Resolution</h2>
	<p>
		Let's consider a simple class called
		<var>Rectangle</var>:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		class Rectangle {
			double length;
			double height;
			public:
				Rectangle(double l = 1.0, double h = 1.0) {
					length = l;
					height = h;
				}
				// method
				double area() { return length * height; }
				double perimeter() { return 2 * (length + height); }
		};
		
		int main() {
			Rectangle r = Rectangle(2.1, 4.7);
			cout << r.area() << endl;
			cout << r.perimeter() << endl;
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		9.87
		13.6
	</code></pre>
	<p>
		While the class above works fine, it doesn't exactly coincide with C++'s
		approach to OOP. For starters, a core rule of OOP is to hide away the
		implementation details. Here, we can clearly see how the methods
		<var>perimeter()</var> and <var>area()</var> are implemented. The first step
		to ensuring they're hidden is to use the <b>scope resolution operator</b>,
		denoted with <var>::</var> (two colons).
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		class Rectangle {
			double length;
			double height;
			public:
				Rectangle(double l=1.0, double h=1.0);
				double area();
				double perimeter();
		};
		
		int main() {
			Rectangle r = Rectangle(2.1, 4.7);
			cout << r.area() << endl;
			cout << r.perimeter() << endl;
			return 0;
		}
		
		Rectangle::Rectangle(double l, double h) {
			length = l;
			height = h;
		};
		double Rectangle::area() { return length * height; }
		double Rectangle::perimeter() { return 2 * (length + height); }
	</code></pre>
	<pre class="language-bash"><code>
		9.87
		13.6
	</code></pre>
	<p>
		Notice how we moved the implementations to below the
		<var>main()</var> function. On first glance, this appears even worse than
		the original implementation, because now the code looks even longer.
		However, the idea is to hide away these implementation details. What we want
		to do next is move these implementations into separate files. First, we
		create two files in the same directory: (1) a file called
		<var>Rectangle.cpp</var>, (2) a file called <var>Rectangle.h</var>, and (3)
		a file called <var>main.cpp</var>.
	</p>
	<p>Inside the <var>Rectangle.cpp</var> file, we write:</p>
	<pre class="language-cpp"><code>
		#include "Rectangle.h"
		Rectangle::Rectangle(double l, double h) {
			length = l;
			height = h;
		};
		double Rectangle::area() { return length * height; }
		double Rectangle::perimeter() { return 2 * (length + height); }
	</code></pre>
	<p>Inside the <var>Rectangle.h</var> file, we write:</p>
	<pre class="language-cpp"><code>
		#ifndef RECTANGLE_H
		#define RECTANGLE_H

		class Rectangle {
			double length;
			double height;
			public:
				Rectangle(double l=1.0, double h=1.0);
				double area();
				double perimeter();
		};
		#endif
	</code></pre>
	<p>Finally, inside the <var>main.cpp</var>, we have:</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		#include "Rectangle.h"
		using namespace std;
		
		int main() {
			Rectangle r = Rectangle(2.1, 4.7);
			cout << r.area() << endl;
			cout << r.perimeter() << endl;
			return 0;
		}
	</code></pre>
	<p>
		Now, to run the main program, we have to compile the
		<var>Rectangle.cpp</var> file and the <var>main.cpp</var> file separately:
	</p>
	<pre class="language-bash"><code>
		g++ -c Rectangle.cpp
		g++ -c main.cpp
	</code></pre>
	<p>
		This will output two object files,
		<var>Rectangle.o</var> and <var>main.o</var>. Because we now have to
		separate object files, we'll need to link them into a single executable.
		We'll call this single object file <var>mainProgram</var>:
	</p>
	<pre class="language-bash"><code>
		g++ -o mainProgram main.o Rectangle.o
	</code></pre>
	<p>Then when we execute the single executable:</p>
	<pre class="language-bash"><code>
		./mainProgram
		9.87
		13.6
	</code></pre>
	<p>
		It works as expected. This seems like a lot of trouble, but notice what
		we've done: First, we've cleanly separated all of the different parts of our
		program: (1) The main program resides in its own file; (2) the
		<var>Rectangle</var> class resides its own file; and (3) the implementation
		details of the <var>Rectangle</var> class reside in their own files. Then,
		even better, the <var>Rectangle</var> class can be passed around and use
		with any other program we write. We do not have to copy and paste code. All
		we need to do is place the executable elsewhere, and link it. Even better,
		the implementation details are completely hidden away from the user.
	</p>
	<p>
		Now, we might be thinking, that's so much work! We have to compile each of
		these files separately and then link them ourselves? Is separation really
		worth it for all the time spent? The answer is yes, it is. The amount of
		time used to keep all of these different components separate is far less
		than the amount of time we would spend having to debug and improve massive
		source code files. Furthermore, the premise that compiling these files
		separately takes too much time is not necessarily true. This is precisly why
		we use <i>make files</i>.
	</p>
</section>

<section id="make_files">
	<h2>Make Files</h2>
	<p>
		On UNIX systems, <var>make</var> is a tool provided to simplify building
		executables from different project modules. In our
		<var>Rectangle</var> example above, we have three separate modules:
		<var>main.cpp</var>, <var>Rectangle.cpp</var>, and
		<var>mainProgram</var> (the final executable containing all of the
		individual executables, linked). A <var>make</var> file is simply a text
		file that the <var>make</var> command referencs to build the
		<b>targets</b> &mdash; the modules we want built.
	</p>
	<p>
		The basic idea behind <var>make</var> is this: We want to be able to write
		<var>make ${t}$</var>, where ${t}$ is some target file, after which ${t}$ is
		built. We also want to write things like <var>make clean</var>, upon which
		the <var>rm</var> command is executed on certain files (thereby
		&#8220;cleaning up&#8221; previous executables).
	</p>
	<p>
		To see how all this works, let's write a
		<var>make</var> file for our <var>Rectangle</var> example above. First, we
		note all the different modules we have: (1) <var>main.cpp</var> (the main
		driver of our program); (2) <var>Rectangle.h</var> (the header file for the
		<var>Rectangle</var> class); and (3) <var>Rectangle.cpp</var> (the C++
		implementation file for the <var>Rectangle</var> class).
	</p>
	<p>
		Now, when run <var>g++ -c main.cpp</var>, we generate the object file
		(executable), <var>main.o</var>. And when we write
		<var>g++ -c Rectangle.cpp</var>, we generate the object file
		<var>Rectangle.o</var>. These are two individual compilations, resulting in
		two individual executables. For our program to run, we need a single
		executable, where <var>main.o</var> and <var>Rectangle.o</var> are linked.
	</p>
	<p>
		To link those files, we write:
		<var>g++ -o main main.o Rectangle.o</var>. The single word
		<var>main</var> is just the name of the final executable. We could just as
		easily written it, <var>mainProgram</var> (as we did previously), or
		<var>mainDriver</var>, or <var>program</var>. Ideally, it should be
		descriptive.
	</p>
	<p>
		We can run this entire process by executing
		<var>make</var>. To do so, we create a new file called <var>Makefile</var>,
		in the same directory as our project. Inside <var>Makefile</var>, we write
		the following:
	</p>
	<pre class="language-bash"><code>
		CC = g++
		CFLAGS = -Wall -g
		clean:
			$(RM) main Rectangle
		main: main.o Rectangle.o
			$(CC) $(CFLAGS) -o main main.o Rectangle.o
	</code></pre>
	<p>
		Let's go over what the symbols in this file mean. First,
		<var>CC</var> and <var>CFLAGS</var> are constants. The
		<var>CC</var> constant indicates which C compiler to use. In this case, we
		indicated the <var>g++</var> compiler. We could also have indicated
		<var>gcc</var>.
	</p>
	<p>
		The <var>CFLAGS</var> constant indicates what flags we should pass to the
		compilation command. The <var>-g</var> flags tells the compiler to include
		debugging information in the executable file. The <var>-Wall</var> flag
		tells the compiler to include compiler warnings.
	</p>
	<p>
		The next two symbols, <var>clean</var> and <var>main</var>, are
		<i>targets</i>. Targets can be file names used as input, or the name of an
		action to be carried out. In the case where it's the name of an action such
		as <var>clean</var>, we effectively create a new rule, called
		<var>make clean</var>. When we execute <var>make clean</var>, we execute the
		command <var>$(RM) main Rectangle</var>, or, in bash terms,
		<var>rm main.o rectangle.o</var>. This effectively cleans up the object
		files we have in our project.
	</p>
	<p>
		When we execute <var>make main</var>, we execute the command
		<var>CC CFLAGS -o main main.o Rectangle.o</var>. This command evaluates to,
		<var>g++ -Wall -g -o main main.o Rectangle.o</var>. Notice that this is the
		line we executed when we didn't have the makefile. The only difference is
		now we just need to write <var>make main</var>.
	</p>
	<p>Here's a slightly better makefile:</p>
	<pre class="language-bash"><code>
		CC = g++
		CFLAGS = -Wall -g
		objects = main.o Rectangle.o
		all: $(objects)
		clean:
			$(RM) *.o all
	</code></pre>
	<p>
		With the implementation above, we list all of the files we want compiled in
		a variable called <var>objects</var>. That variable is then used for the
		target <var>all</var>. When execute <var>make all</var>, the files
		<var>main.cpp</var> and <var>Rectangle.cpp</var> are compiled and linked.
	</p>
	<p>
		To summarize, using scope resolution, we've separated our files program into
		the following:
	</p>

	<pre class="language-cpp"><code>
			// Rectangle.cpp
			#include "Rectangle.h"
			Rectangle::Rectangle(double l, double h) {
				length = l;
				height = h;
			};
			double Rectangle::area() { return length * height; }
			double Rectangle::perimeter() { return 2 * (length + height); }
		</code></pre>
	<pre class="language-cpp"><code>
			// Rectangle.h
			#ifndef RECTANGLE_H
			#define RECTANGLE_H
	
			class Rectangle {
				double length;
				double height;
				public:
					Rectangle(double l=1.0, double h=1.0);
					double area();
					double perimeter();
			};
			#endif
		</code></pre>
	<pre class="language-cpp"><code>
			// main.cpp
			#include &lt;iostream&gt;
			#include "Rectangle.h"
			using namespace std;
			
			int main() {
				Rectangle r = Rectangle(2.1, 4.7);
				cout << r.area() << endl;
				cout << r.perimeter() << endl;
				return 0;
			}
		</code></pre>
</section>

<section id="inline_functions">
	<h2>Inline Functions</h2>
	<p>Consider the following functions:</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		class Foo {
			public:
				void func1() {
					cout << "Hi" << endl;
				}
				void func2();
		};
		
		void Foo::func2() {
			cout << "Hi" << endl;
		}
		
		int main() {
			Foo x;
			x.func1();
			x.func2();
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		Hi
		Hi
	</code></pre>
	<p>
		Notice that the function <var>func1</var> is defined inside the class
		definition for <var>Foo</var>, while <var>func2</var> is defined outside the
		definition through scope resolution.
	</p>
	<p>
		Both <var>func1</var> and <var>func2</var> perform the same computation;
		namely, outputting the string <var>"Hi"</var> to the console. However, both
		functions go about it differently.
	</p>
	<p>
		the function <var>func1</var> is an <b>inline function</b>, while the
		function <var>func2</var> is a <b>non-inline function</b>. What's the
		difference between an inline function and a non-inline function?
	</p>
	<p>
		With an inline function, the machine code is &#8220;copied-and-pasted&#8221;
		directly into the function that calls functions. In this case, the function
		<var>func1()</var> has its machine code directly pasted into the
		<var>main()</var> function's machine code. In contrast, the function
		<var>func2()</var> will have its machine code allocated in a separate stack.
	</p>
	<p>
		If we want <var>func2()</var> to be treated as an inline function, we simply
		include the <var>inline</var> keyword:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		class Foo {
			public:
				void func1() {
					cout << "Hi" << endl;
				}
				inline void func2();
		};
		
		void Foo::func2() {
			cout << "Hi" << endl;
		}
		
		int main() {
			Foo x;
			x.func1();
			x.func2();
			return 0;
		}
	</code></pre>
</section>

<section id="this">
	<h2>The Keyword This</h2>
	<p>Suppose we wrote a class called <var>City</var>:</p>
	<pre class="language-cpp"><code>
		#include &lt;string&gt;
		using namespace std;
		
		class City {
			string city_name;
			int population;
			City(string cn = "uninitialized", int p = 0) {
				city_name = cn;
				population = p;
			}
		};
		
		int main() {
			return 0;
		}
	</code></pre>
	<p>
		The code above runs well, but notice the constructor's parameters. Those
		names &mdash; <var>cn</var> and <var>p</var> &mdash; are pretty bad. Names
		should always be descriptive. We could get around this problem by simply
		writing a more descriptive name, but what would be more descriptive than
		<var>city_name</var>? We don't want to use something like
		<var>cityName</var>; differentiating names purely on the way they look is
		almost always a bad idea. What if we instead just used the original
		identifiers, <var>city_name</var> and <var>population</var>?
	</p>
	<pre class="language-cpp"><code>
		#include &lt;string&gt;
		using namespace std;
		
		class City {
			string city_name;
			int population;
			City(string city_name = "uninitialized", int population = 0) {
				city_name = city_name;
				population = population;
			}
		};
		
		int main() {
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		city.cpp:8:13: warning: explicitly assigning value of variable of type 'std::__1::string' (aka 'basic_string&lt;char&gt;') to itself [-Wself-assign-overloaded]
					city_name = city_name;
					~~~~~~~~~ ^ ~~~~~~~~~
		city.cpp:9:14: warning: explicitly assigning value of variable of type 'int' to itself [-Wself-assign]
					population = population;
					~~~~~~~~~~ ^ ~~~~~~~~~~
		city.cpp:6:6: warning: private field 'population' is not used [-Wunused-private-field]
		int population;
	</code></pre>
	<p>
		Nope. Not a good idea. The compiler can't differentiate between the variable
		<var>city_name</var> and <var>population</var> inside the class, and the
		parameters <var>city_name</var> and <var>population</var>. And fairly so;
		just reading those two lines looks off.
	</p>
	<p>The solution? Use the <var>this</var> keyword:</p>
	<pre class="language-cpp"><code>
		#include &lt;string&gt;
		using namespace std;
		
		class City {
			string city_name;
			int population;
			City(string city_name = "uninitialized", int population = 0) {
				this->city_name = city_name;
				this->population = population;
			}
		};
		
		int main() {
			return 0;
		}
	</code></pre>
	<p>
		Compiling the code above, we don't get any problems. The
		<var>this</var> keyword operates as it sounds like. It tells the
		<var>compiler</var>, &#8220;I'm refer to
		<span class="underlineText">this object's</span> variable.&#8221;
	</p>
</section>

<section id="static">
	<h2>The Static Keyword</h2>
	<p>
		The keyword <var>static</var> in C++ has two different meanings depending on
		context. There are four contexts for using <var>static</var>:
	</p>
	<figure>
		<ol>
			<li>
				<b>Static variables</b> &mdash; a static variable that exists
				<em>outside</em> of a class or struct.
			</li>
			<li>
				<b>Static functions</b> &mdash; a static function that exists
				<em>outside</em> of a class or struct.
			</li>
			<li>
				<b>Static properties</b> &mdash; a static variable that exists
				<em>inside</em> of a class or struct.
			</li>
			<li>
				<b>Static methods</b> &mdash; a static function that exists
				<em>inside</em> of a class of struct.
			</li>
		</ol>
	</figure>

	<section id="static_variables">
		<p>
			<span class="topic">Static Variables.</span> Static variables or are
			variables that are only visible inside the translation unit they were
			defined in. For example, consider the static variable below:
		</p>
		<pre class="language-cpp"><code>
			static int s_Variable = 7;
		</code></pre>
		<p>
			In C++, the convention is to append <var><mark>s_</mark></var> to a static
			variable identifier.
		</p>
		<p>
			Writing the line above effectively changes the way the linker works. When
			the linker comes to defining all of the symbols in our program, it will
			not look outside of the translation unit's scope for the definition of
			<var>s_Variable</var>. This is best examined by linking two separate
			<var>.cpp</var> files. First, a file called <var>statics.cpp</var>, inside
			of which is the following:
		</p>
		<pre class="language-cpp"><code>
			static int s_Variable = 7;
		</code></pre>
		<p>Then a file called <var>driver.cpp</var>, inside of which is:</p>
		<pre class="language-cpp"><code>
			int s_Variable = 8;
			int main() {
				return 0;
			}
		</code></pre>
		<p>Compiling and linking the two files:</p>
		<pre class="language-bash"><code>
			$ g++ -c statics.cpp
			$ g++ -c driver.cpp
			$ g++ -o main statics.o driver.o
		</code></pre>
		<p>
			We have no issues compiling. Now, notice what happens when we remove the
			<var>static</var> keyword inside <var>statics.cpp</var>:
		</p>
		<pre class="language-bash"><code>
			$ g++ -c statics.cpp
			$ g++ -c driver.cpp
			$ g++ -o main statics.o driver.o
			duplicate symbol '_s_Variable' in:
					statics.o
					driver.o
			ld: 1 duplicate symbol for architecture x86_64
			clang: error: linker command failed with exit code 1 (use -v to see invocation)
		</code></pre>
		<p>
			We're seeing this output because now we have two global variables,
			<var>s_Variable</var>, with the same name. In the previous scenario, when
			we had the keyword <var>static</var> included in <var>statics.cpp</var>,
			the linker only looked for the definition of <var>s_Variable</var> inside
			<var>statics.cpp</var>. Removing that keyword, the linker went on to
			examine <var>driver.cpp</var>.
		</p>
		<p>
			We could avoid this problem by using <b>external linkage</b>. Inside
			<var>statics.cpp</var>, we avoid initialization, and write:
		</p>
		<pre class="language-cpp"><code>
			extern int s_Variable;
		</code></pre>
		<p>while keeping the same code for <var>driver.cpp</var>:</p>
		<pre class="language-cpp"><code>
			int s_Variable = 7;
			int main() {
				return 0;
			}
		</code></pre>
		<p>Compiling:</p>
		<pre class="language-bash"><code>
			$ g++ -c statics.cpp
			$ g++ -c driver.cpp
			$ g++ -o main statics.o driver.o
		</code></pre>
		<p>
			We get no errors. By using the keyword <var><mark>extern</mark></var
			>, we notify the linker that the definition for <var>s_Variable</var> is
			found in a file external to <var>statics.cpp</var>.
		</p>
	</section>

	<section id="static_functions">
		<p>
			<span class="topic">Static Functions.</span> The same idea extends to
			static functions. Suppose we have the following function definition in
			<var>statics.cpp</var>:
		</p>
		<pre class="language-cpp"><code>
			static void Function() {}
		</code></pre>
		<p>And the following in <var>driver.cpp</var>:</p>
		<pre class="language-cpp"><code>
			void Function() {}
			int main() {
				return 0;
			}
		</code></pre>
		<p>
			There are no problems with compiling. But the moment we remove the keyword
			<var>static</var>, we will get a duplicate-symbol error.
		</p>
	</section>

	<section id="static_properties">
		<p>
			<span class="topic">Static Properties.</span> Static properties are
			variables that are visible to all instances of the class or struct.
			Essentially, this means that across all instances of some class/struct
			${x,}$ given some static property ${p,}$ there is only one instance of
			${p}$ for all instances of the class/struct ${x.}$
		</p>
		<p>For example, here is a simple struct called <var>point</var>:</p>
		<pre class="language-cpp"><code>
			#include &lt;iostream&gt;
			struct Point {
				int x, y;
				void Print() {
					std::cout << x << ", " << y << std::endl;
				}
			};
			
			void Function() {}
			int main() {
				Point p1;
				p1.x = 1;
				p1.y = 1;
				Point p2 = {3, 3};
			
				p1.Print();
				p2.Print();
				return 0;
			}
		</code></pre>
		<pre class="language-bash"><code>
			$ g++ -c driver.cpp
			$ g++ -o driver driver.o
				1, 1
				3, 3
		</code></pre>
		<p>
			This works as we'd expect. Now, notice what happens when write the keyword
			<var>static</var>:
		</p>
		<pre class="language-cpp"><code>
			#include &lt;iostream&gt;
			struct Point {
				static int x, y;
				void Print() {
					std::cout << x << ", " << y << std::endl;
				}
			};
			
			// We have to define x and y somewhere for static to work
			int Point::x;
			int Point::y;
			
			void Function() {}
			int main() {
				Point p1;
				p1.x = 1;
				p1.y = 1;
				Point p2;
				p2.x = 3;
				p2.y = 3;
			
				p1.Print();
				p2.Print();
				return 0;
			}
		</code></pre>
		<pre class="language-bash"><code>
			$ g++ -c driver.cpp
			$ g++ -o driver driver.o
				3, 3
				3, 3
		</code></pre>
		<p>
			We're seeing the output above because we've changed the static properties
			<var>x</var> and <var>y</var>. There are is only one instance of
			<var>x</var> and only one instance of <var>y</var> for all instances of
			<var>Point</var>. Modifying <var>x</var> and <var>y</var> for any given
			instance will modify it for all. In actuality, it's non-sensical to refer
			to the static properties <var>x</var> and <var>y</var> the way we did in
			the example above. What we're really writing is:
		</p>
		<pre class="language-cpp"><code>
			#include &lt;iostream&gt;
			struct Point {
				static int x, y;
				void Print() {
					std::cout << x << ", " << y << std::endl;
				}
			};
			
			int Point::x;
			int Point::y;
			
			void Function() {}
			int main() {
				Point p1;

				Point::x = 1;
				Point::y = 1;

				Point p2;

				Point::x = 3;
				Point::y = 3;
			
				p1.Print();
				p2.Print();
				return 0;
			}
		</code></pre>
	</section>

	<section id="static_methods">
		<p>
			<span class="topic">Static Methods.</span> Static methods are member
			functions that do not require a class or struct instance to be called. In
			other words, given some class/struct ${C}$ with a member function ${m,}$
			we do not need an instance of ${C}$ to call ${m.}$
		</p>
		<pre class="language-cpp"><code>
			#include &lt;iostream&gt;
			struct Point {
				static int x, y;
				static void Print() {
					std::cout << x << ", " << y << std::endl;
				}
			};
			
			int Point::x;
			int Point::y;
			
			void Function() {}
			int main() {
				Point p1;
				Point::x = 1;
				Point::y = 1;
				Point p2;
				Point::x = 3;
				Point::y = 3;
			
				Point::Print();
				return 0;
			}
		</code></pre>
		<pre class="language-bash"><code>
			$ g++ -c driver.cpp
			$ g++ -o driver driver.cpp
			$ ./driver
				3, 3
		</code></pre>
		<p>
			Notice that we do not need an instance of <var>Point</var> to call the
			member function <var>Print()</var>. Importantly, static methods
			<em>cannot</em> access non-static properties. In other words, if we have a
			static method, it can only access static properties. This stems from the
			fact that static methods do not have class instances. This in turn
			originates in the fact that classes are really just syntactic sugar for
			functions with a hidden parameter &mdash; an instance of itself, the
			instance of the class. When we prepend the keyword
			<var>static</var> before the function's identifier, we are essentially
			writing the method <i>outside</i> of the class:
		</p>
		<pre class="language-cpp"><code>
			#include &lt;iostream&gt;
			struct Point {
				int x, y;
			};

			static void Print() {
				std::cout << x << ", " << y << std::endl;
			}
			
			int Point::x;
			int Point::y;
			
			void Function() {}
			int main() {
				Point p1;

				Point::x = 1;
				Point::y = 1;

				Point p2;

				Point::x = 3;
				Point::y = 3;
			
				p1.Print();
				p2.Print();
				return 0;
			}
		</code></pre>
		<p>
			Viewing it in this way, it should be apparent why we cannot call static
			methods on non-static properties. The method has no idea what those
			properties are. But, if we placed a parameter in the method, it suddenly
			works:
		</p>
		<pre class="language-cpp"><code>
			#include &lt;iostream&gt;
			struct Point {
				int x, y;
			};

			static void Print(Point p) {
				std::cout << p.x << ", " << p.y << std::endl;
			}
			
			int Point::x;
			int Point::y;
			
			void Function() {}
			int main() {
				Point p1;

				Point::x = 1;
				Point::y = 1;

				Point p2;

				Point::x = 3;
				Point::y = 3;
			
				p1.Print();
				p2.Print();
				return 0;
			}
		</code></pre>
	</section>

	<!-- <section id="static_variables">
		<h3>Static Variables</h3>
		<p>
			To understand how static variables work, it's worth reviewing three key
			concepts: scope, duration, and linkage.
		</p>
		<p>
			<span class="topic">Scope.</span> A variable's <i>scope</i> denotes where
			in our file we can access a variable. In C++, there are two kinds of
			scope: (i) <i>local scope</i>, and (ii) <i>global scope</i>. Variables
			defined in the global scope are accessible from anywhere in our program.
			Variables defined in the local scope are accessible only to the locations
			defined as &#8220;local.&#8221; For example, if we initialized
			<var>int a = 1</var> inside a function <var>foo()</var>'s body,
			<var>int a = 1</var> is accessible only inside <var>foo()</var>.
		</p>
		<p>
			<span class="topic">Duration.</span> A variable's <b>duration</b>, or
			<b>lifetime</b>, denotes how long a variable lives. Or, more specifically,
			it determines when a variable is created, and when a variable is
			destroyed. There are two types of lifetimes: (a)
			<i>automatic storage duration</i>, and (b) <i>static storage duration</i>.
		</p>
		<p>
			Variables with a local or block scope have automatic storage duration. For
			example, consider our function <var>foo()</var>. Once <var>foo()</var> has
			finished executing, <var>int a = 1</var> is destroyed. In contrast,
			variables that are either (i) within global scope or (ii) local variables
			with the <var>static</var> specifier, have static storage duration.
		</p>
		<p>
			<span class="topic">Linkage.</span> The term <b>linkage</b> refers to
			whether a variable can accessed (or linked) in a file other than where
			it's defined. There are two kinds of linkage: (i) internal linkage, and
			(ii) external linkage. To understand the distinction between these two
			varieties, it's critical to understand how <a href="">linking</a> works.
		</p>
		<p>
			Recall that when we execute our source code, the compiler generates a
			<i>translation unit</i>. <b>Internal linkage</b> refers to variables only
			within the scope of the translation unit. <b>External linkage</b> refers
			to variables that exist beyond the translation unit; i.e., the variables
			are accessible throughout the entire program.
		</p>
		<p>
			Internal linkage applies to variables that: (a) have block scope and
			global scope, block scope file scope, blockscope and global namespace
			scope. External linkage applies to variables with
			<span class="underlineText">only</span> global scope, file scope, or
			global namespace scope.
		</p>
	</section> -->
</section>

<section id="inheritance">
	<h2>Inheritance</h2>
	<p>
		As C++ supports object-oriented programming, inheritance is unusurprisingly
		supported in the language. There are, however, some significant differences
		between inheritance in C++ and inheritance in a language like Java.
	</p>
</section>

<section id="pointers_to_objects">
	<h2>Heap v. Stack Objects</h2>
	<p>
		We saw in earlier sections that we can create values of primitive types in
		either the stack or the heap. We also saw that we can create pointers to
		those values. We can do the same with classes. Let's first consider how to
		create pointers to objects.
	</p>
	<h3>Pointers to Objects</h3>
	<p>Let's write another class, called <var>Circle</var>:</p>
	<pre class="language-cpp"><code>
		class Circle {
			public:
				double radius;
				double pi = 3.14;
		
				double area() {
					return pi * (radius * radius);
				}
				double perimeter() {
					return 2 * pi * radius;
				}
		};
	</code></pre>
	<p>
		Now suppose we want to create a pointer to a
		<var>Circle</var> object (i.e., an instance of <var>Circle</var>). To do so,
		we write the following:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		class Circle {
			public:
				double radius;
				double pi = 3.14;
		
				double area() {
					return pi * (radius * radius);
				}
				double perimeter() {
					return 2 * pi * radius;
				}
		};
		
		int main() {
			Circle c; // create a Circle object, called 'c' in the STACK
			Circle *p; // Create a pointer 'p' of type Circle
			p = &amp;c; // p now points to the Circle object, 'c'
			return 0;
		}
	</code></pre>
	<p>
		Above, we instantiated the class <var>Circle</var>, creating a
		<var>Circle</var> object with the identifier <var>c</var>. The object
		<var>c</var> lives in the stack. After creating <var>c</var>, we then
		created a pointer <var>p</var> of type <var>Circle</var>. Finally, when we
		wrote <var>p = &c</var>, we are saying, &#8220;This pionter
		<var>p</var> points to the object <var>c</var>.&#8221; Because pointer
		<var>p</var> points to the address where <var>c</var> is located, we can
		assign properties to it via pointer:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		class Circle {
			public:
				double radius;
				double pi = 3.14;
		
				double area() {
					return pi * (radius * radius);
				}
				double perimeter() {
					return 2 * pi * radius;
				}
		};
		
		int main() {
			Circle c; // create a Circle object, called 'c' in the STACK
			Circle *p; // Create a pointer 'p' of type Circle
			p = &amp;c; // p now points to the Circle object, 'c'
			p->radius = 3.2;
			cout << p->area() << endl;
			cout << p->perimeter() << endl;
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		32.1536
		20.096
	</code></pre>
	<p>
		Notice the syntax. To instantiate a property of
		<var>c</var> with a pointer, we wrote <var>p->radius</var>. To call the
		methods of <var>c</var> with a pointer, we wrote <var>p->area()</var> and
		<var>p->perimeter()</var> respectively.
	</p>

	<h3>Storing Objects in the Heap</h3>
	<p>
		We can store class instances in the heap, just as we would store values of
		primitive types.
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		class Trapezoid {
			public:
				double side_a;
				double side_b;
				double height;
				double area() {
					return ((side_a + side_b) * height) / 2;
				}
		};
		
		int main() {
			Trapezoid *ptr; // declare a pointer ptr
			ptr = new Trapezoid; // create a Trapezoid in the heap
			ptr->side_a = 3.2;
			ptr->side_b = 6.1;
			ptr->height = 8.9;
			cout << ptr->area() << endl;
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		41.385
	</code></pre>
	<p>
		Above, we stored a <var>Trapezoid</var> object in the heap via the pointer
		<var>ptr</var>. Notice the keyword <var>new</var>. This keyword tells C++
		that we are instantiating the class <var>Trapezoid</var>; i.e., creating a
		<i>new</i> instance of <var>Trapezoid</var>. Then, using the arrow operator,
		<var>-></var>, we initialized the properties of that <var>Trapezoid</var>,
		pointed to by <var>ptr</var>. Alternatively, we can write the pointer
		declaration, initialization all in one line:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		class Trapezoid {
			public:
				double side_a;
				double side_b;
				double height;
				double area() {
					return ((side_a + side_b) * height) / 2;
				}
		};
		
		int main() {
			Trapezoid *ptr = new Trapezoid();
			ptr->side_a = 2.2;
			ptr->side_b = 5.3;
			ptr->height = 3.8;
			double ptrArea = ptr->area();
			cout << ptrArea << endl;
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		14.25
	</code></pre>
</section>

{% endblock %}
