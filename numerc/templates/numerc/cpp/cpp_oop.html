{% extends '../layout.html' %} {% load static %} {% block description %}
<meta
	name="description"
	content="Introduction to object-oriented programming in C++"
/>
{% endblock %} {% block title %}
<title>Classes in C++</title>
{% endblock %} {% block content %}
<h1>Classes</h1>
<section id="intro">
	<p>
		In this essay, we explore object-oriented programming (OOP) in C++. OOP is
		the reigning paradigm in modern programming. A core goal of this essay is to
		understand why the OOP status quo continues, as well as reasons for why this
		may or may not change in the future.
	</p>
	<p>
		The cornerstone of object-oriented programming is the ability to construct
		our own data types. We know that there are types provided natively by a
		language, what we might call
		<span class="italicsText">primitive types</span>.
		<span class="marginnote"
			>Primitive types are also called
			<span class="italicsText">base types</span> or
			<span class="italicsText">atomic types</span>.</span
		>
		In C++, these types include <span class="monoText">char</span>,
		<span class="monoText">int</span>, <span class="monoText">double</span>,
		<span class="monoText">bool</span>, <span class="monoText">float</span>,
		etc.
	</p>
	<p>
		Although we can solve many problems with just these types, having such a
		small set of types can feel restrictive and stuffy. What if we have data
		that should be paired together? The airline passenger isn't just a number;
		they have a name, an age, gender, address, consumer preferences, mileage
		quantity, and possibly a special customer status. The solar system isn't
		just an array of eight planets; there are moons, dwarf planets, revolution
		paths, which themselves have related data.
	</p>
	<p>
		Related data doesn't even just occur with discrete entities. Mathematical
		formulas might be classified according to fields. We might have a formula
		related to probability, another related to geometry, another to calculus,
		another to number theory.
	</p>
	<p>
		Trying to model these complex ideas with just primitive types is painful.
		Worse, what if we need to change those models? What we need is an
		<span class="italicsText">abstraction</span> &mdash;
		<span class="term">higher-order data types</span>.
	</p>
	<p>
		Recall that a data type is a set consisting of two subsets: a set of values,
		called the data type's <span class="term">domain</span>, and a
		<span class="term">set of operations</span> on those values. For example,
		the data type <span class="monoText">int</span> is a data type pre-defined
		by C++. The values it represents are the integers (specifically ${-2^{31}}$
		to ${2^{31}}$), and the operations we may perform on those values are the
		various arithmetic and comparison operators (<span class="monoText">+</span
		>, <span class="monoText">*</span>, <span class="monoText">%</span>, etc.).
	</p>
	<p>
		With object-oriented programming, we write C++ code to define new data
		types. We say that an <span class="term">object</span> is an entity that
		holds a <span class="italicsText">data-type value</span> &mdash; you can
		manipulate the data type value by using the object's data-type operations.
		The practice of defining new data types and manipulating objects holding
		data-type values is called <span class="term">data abstraction</span>.
	</p>
	<p>The foundational principle of object-oriented programming:</p>
	<figure class="math-display">
		<div class="rule">
			<p>
				<span class="topic">Principle.</span> Always separate data from
				operations on that data.
			</p>
		</div>
	</figure>
	<p>
		Notice that with the primitive data types, we were never really worried
		about how the data type represents the values. Of course, we know how the
		data is represented (bits allocated in memory), but when using the data
		types, we rarely stopped to consider the data type's implementation. This is
		precisely what data types are supposed to do. For the data type user, the
		only concern should be the <span class="italicsText">operations</span> that
		can be performed with that data type. Of course, the story is different for
		the data type implementer. The implementer must always think about both the
		set of values represented, as well as the operations that can be performed
		on those values.
	</p>
	<figure class="math-display">
		<div class="rule">
			<p>
				<span class="topic">Principle.</span> A data type should not require the
				user to know how the data type is implemented.
			</p>
		</div>
	</figure>
</section>

<section id="classes">
	<h2><span class="monoText">class</span></h2>
	<p>
		The C++ <span class="monoText">class</span> provides a way to define data
		types. In a <span class="monoText">class</span>, we specify the data-type
		values and implement the data-type operations. Let's write a simple class
		for a rectangle:
	</p>
	<pre class="language-cpp"><code>
		class Rectangle {
			int width;
			int height;
			int area() {
				return width * height;
			}
			int perimeter() {
				return 2 * (width + height);
			}
		};
		
	</code></pre>
	<p>
		Above, we created a class called <span class="monoText">Rectangle</span>.
		This is a new data type. It has two
		<span class="italicsText">properties</span>,
		<span class="monoText">width</span> and
		<span class="monoText">height</span>, of type
		<span class="monoText">int</span>. It also has two functions &mdash; called
		<span class="italicsText">methods</span> &mdash; which have a return type of
		<span class="monoText">int</span>.
	</p>
	<p>Now, let's try using this new class:</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		class Rectangle {
			int width;
			int height;
			int area() {
				return width * height;
			}
			int perimeter() {
				return 2 * (width + height);
			}
		};
		
		int main() {
			Rectangle r1;
			r1.width = 7;
			r1.height = 2;
			return 0;
		}
	</code></pre>
	<p>
		Above, we created an <span class="italicsText">objects</span> of type
		<span class="monoText">Rectangle</span>. This object is named
		<span class="monoText">r1</span>. Alternatively, we say that
		<span class="monoText">r1</span> is an
		<span class="italicsText">instance</span> of the class
		<span class="monoText">Rectangle</span>. Having created these two objects,
		we attempt to assign to <span class="monoText">r1</span>'s properties
		&mdash; <span class="monoText">width</span> and
		<span class="monoText">height</span> &mdash; that
		<span class="monoText">int</span> values <span class="monoText">7</span> and
		<span class="monoText">2</span> respectively. The compiler's response:
	</p>
	<pre class="language-bash"><code>
		rectangle.cpp:17:5: error: 'width' is a private member of 'Rectangle'
						r1.width = 7;
							^
		rectangle.cpp:5:6: note: implicitly declared private here
						int width;
								^
		rectangle.cpp:18:5: error: 'height' is a private member of 'Rectangle'
						r1.height = 2;
							^
		rectangle.cpp:6:6: note: implicitly declared private here
						int height;
								^
		2 errors generated.
	</code></pre>
	<p>
		We get back an error. Why? Because by default, all class properties and
		methods are <span class="monoText">private</span>. This is an example of an
		<span class="term">access modifier</span>. If a property or method is
		<span class="monoText">private</span>, then
		<span class="underlineText">only</span> the class has access to the
		properties or methods. Nowhere else in the code do we have access to those
		properties or methods. So how do we fix this? By appending the keyword
		<span class="monoText">public</span>:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		class Rectangle {
			public:
				int width;
				int height;
				int area() {
					return width * height;
				}
				int perimeter() {
					return 2 * (width + height);
				}
		};
		
		int main() {
			Rectangle r1;
			r1.width = 7;
			r1.height = 2;
			return 0;
		}
	</code></pre>
	<p>
		By appending the keyword <span class="monoText">public</span>, we have
		effectively made the class's properties and methods available for any part
		of our program to see and use. Now let's try using the methods:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		class Rectangle {
			public:
				int width;
				int height;
				int area() {
					return width * height;
				}
				int perimeter() {
					return 2 * (width + height);
				}
		};
		
		int main() {
			Rectangle r1;
			r1.width = 7;
			r1.height = 2;
			cout << r1.area() << endl;
			cout << r1.perimeter() << endl;
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		14
		18
	</code></pre>
	<p>
		It works. Notice the use of dots, or periods, to access properties and
		methods. This is called <span class="term">dot notation</span>, and is a
		common syntactic approach for accessing properties and methods in
		object-oriented languages.
		<span class="marginnote"
			>The use of <span class="term">dot notation</span> can be traced back to
			Simula 67, the language widely credited as the first object-oriented
			language. However, there is evidence of the dot notation being used even
			further back: The PL/I language for the IBM 360 used dot notation to
			specify fields in a record.</span
		>
	</p>
</section>

<section id="pointers_to_objects">
	<h2>Objects in the Stack, Objects in the Heap</h2>
	<p>
		We saw in earlier sections that we can create values of primitive types in
		either the stack or the heap. We also saw that we can create pointers to
		those values. We can do the same with classes. Let's first consider how to
		create pointers to objects.
	</p>
	<h3>Pointers to Objects</h3>
	<p>Let's write another class, called <span class="monoText">Circle</span>:</p>
	<pre class="language-cpp"><code>
		class Circle {
			public:
				double radius;
				double pi = 3.14;
		
				double area() {
					return pi * (radius * radius);
				}
				double perimeter() {
					return 2 * pi * radius;
				}
		};
	</code></pre>
	<p>
		Now suppose we want to create a pointer to a
		<span class="monoText">Circle</span> object (i.e., an instance of
		<span class="monoText">Circle</span>). To do so, we write the following:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		class Circle {
			public:
				double radius;
				double pi = 3.14;
		
				double area() {
					return pi * (radius * radius);
				}
				double perimeter() {
					return 2 * pi * radius;
				}
		};
		
		int main() {
			Circle c; // create a Circle object, called 'c' in the STACK
			Circle *p; // Create a pointer 'p' of type Circle
			p = &amp;c; // p now points to the Circle object, 'c'
			return 0;
		}
	</code></pre>
	<p>
		Above, we instantiated the class <span class="monoText">Circle</span>,
		creating a <span class="monoText">Circle</span> object with the identifier
		<span class="monoText">c</span>. The object
		<span class="monoText">c</span> lives in the stack. After creating
		<span class="monoText">c</span>, we then created a pointer
		<span class="monoText">p</span> of type
		<span class="monoText">Circle</span>. Finally, when we wrote
		<span class="monoText">p = &c</span>, we are saying, &#8220;This pionter
		<span class="monoText">p</span> points to the object
		<span class="monoText">c</span>.&#8221; Because pointer
		<span class="monoText">p</span> points to the address where
		<span class="monoText">c</span> is located, we can assign properties to it
		via pointer:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		class Circle {
			public:
				double radius;
				double pi = 3.14;
		
				double area() {
					return pi * (radius * radius);
				}
				double perimeter() {
					return 2 * pi * radius;
				}
		};
		
		int main() {
			Circle c; // create a Circle object, called 'c' in the STACK
			Circle *p; // Create a pointer 'p' of type Circle
			p = &amp;c; // p now points to the Circle object, 'c'
			p->radius = 3.2;
			cout << p->area() << endl;
			cout << p->perimeter() << endl;
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		32.1536
		20.096
	</code></pre>
	<p>
		Notice the syntax. To instantiate a property of
		<span class="monoText">c</span> with a pointer, we wrote
		<span class="monoText">p->radius</span>. To call the methods of
		<span class="monoText">c</span> with a pointer, we wrote
		<span class="monoText">p->area()</span> and
		<span class="monoText">p->perimeter()</span> respectively.
	</p>

	<h3>Storing Objects in the Heap</h3>
	<p>
		We can store class instances in the heap, just as we would store values of
		primitive types.
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		class Trapezoid {
			public:
				double side_a;
				double side_b;
				double height;
				double area() {
					return ((side_a + side_b) * height) / 2;
				}
		};
		
		int main() {
			Trapezoid *ptr; // declare a pointer ptr
			ptr = new Trapezoid; // create a Trapezoid in the heap
			ptr->side_a = 3.2;
			ptr->side_b = 6.1;
			ptr->height = 8.9;
			cout << ptr->area() << endl;
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		41.385
	</code></pre>
	<p>
		Above, we stored a <span class="monoText">Trapezoid</span> object in the
		heap via the pointer <span class="monoText">ptr</span>. Notice the keyword
		<span class="monoText">new</span>. This keyword tells C++ that we are
		instantiating the class <span class="monoText">Trapezoid</span>; i.e.,
		creating a <span class="italicsText">new</span> instance of
		<span class="monoText">Trapezoid</span>. Then, using the arrow operator,
		<span class="monoText">-></span>, we initialized the properties of that
		<span class="monoText">Trapezoid</span>, pointed to by
		<span class="monoText">ptr</span>. Alternatively, we can write the pointer
		declaration, initialization all in one line:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		class Trapezoid {
			public:
				double side_a;
				double side_b;
				double height;
				double area() {
					return ((side_a + side_b) * height) / 2;
				}
		};
		
		int main() {
			Trapezoid *ptr = new Trapezoid();
			ptr->side_a = 2.2;
			ptr->side_b = 5.3;
			ptr->height = 3.8;
			double ptrArea = ptr->area();
			cout << ptrArea << endl;
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		14.25
	</code></pre>
</section>

<section id="accessors">
	<h2>Access Modifiers</h2>
	<p>
		In the examples above, we set the properties and methods in our classes
		<span class="monoText">public</span>. This is not always a good idea. For
		starters, having them set to <span class="monoText">public</span> implies
		that anyone has access to them. This can be very dangerous, depending on
		what our class is being used for. How do we ensure that properties and
		methods are hidden? I.e., only the class has access to its methods and
		properties? For that, we need <span class="term">access modifiers</span>.
		<span class="marginnote"
			>Access modifiers are also called
			<span class="italicsText">accessors</span> or
			<span class="italicsText">access specifiers</span>.</span
		>
	</p>
	<p>
		In C++, there are three access modifiers:
		<span class="monoText">public</span>,
		<span class="monoText">protected</span>, and
		<span class="monoText">private</span>. We'll look at each of them in turn.
	</p>

	<h3><span class="monoText">private</span></h3>
	<p>
		By default, all properties and methods in a C++ class are set to
		<span class="monoText">private</span>. This means that outside of the class
		containing those properties and methods, no access is provided. For example:
	</p>
	<pre class="language-cpp"><code>
		// we don't have to write out 'private', but we do so here to be explicit
		class Cylinder {
			private:
				double pi = 3.14;
				double radius;
				double height;
			public:
				double surfaceArea() {
					return 2 * pi * radius * (radius + height);
				}
				double volume() {
					return pi * radius * radius * height;
				}
		};
	</code></pre>
	<p>
		By default, all of the properties in class
		<span class="monoText">Cylinder</span> is set to
		<span class="monoText">private</span>. However, we set the methods
		<span class="monoText">public</span>, because those are functions we would
		like to access directly. Now, because the properties of
		<span class="monoText">Cylinder</span> are set to
		<span class="monoText">private</span>, we cannot access them in
		<span class="monoText">main()</span>, nor anywhere else outside of
		<span class="monoText">class Cylinder</span>'s definition. But this means
		that the methods <span class="monoText">surfaceArea()</span> and
		<span class="monoText">volume()</span> are essentially useless, because we
		don't have a way to set the values of
		<span class="monoText">radius</span> and
		<span class="monoText">height</span>. But we want to keep the properties
		<span class="monoText">private</span>
		<span class="underlineText">and</span> be still be able to initialize them
		outside of the <span class="monoText">class</span> definition. Can we do so?
		It seems like we can't.
	</p>
	<p>
		Oh but we can. We can get around the
		<span class="monoText">private</span> barrier by setting some function in
		the inside the class as <span class="monoText">public</span>. Think of it as
		leaving a tiny gap, or window, for us to access the class.
	</p>
	<p>
		Let's start with one of the properties,
		<span class="monoText">radius</span>. To be able to initialize this
		property, we just need a <span class="monoText">public</span> method that
		initializes the property:
	</p>
	<pre class="language-cpp"><code>
		class Cylinder {
			double pi = 3.14;
			double radius;
			double height;
			public:
				double surfaceArea() {
					return 2 * pi * radius * (radius + height);
				}
				double volume() {
					return pi * radius * radius * height;
				}
				void setRadius(double r) {
					radius = r; // remember you don't need a return for void return types
				}
				void setHeight(double h) {
					height = h;
				}
		};
	</code></pre>
	<p>
		The functions <span class="monoText">setRadius()</span> and
		<span class="monoText">setHeight()</span> are set to
		<span class="monoText">public</span>, and they are what allow us to access
		to initialize the properties <span class="monoText">radius</span> and
		<span class="monoText">height</span>, even if they are set to
		<span class="monoText">private</span>. Let's try it:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		class Cylinder {
			double pi = 3.14;
			double radius;
			double height;
			public:
				double surfaceArea() {
					return 2 * pi * radius * (radius + height);
				}
				double volume() {
					return pi * radius * radius * height;
				}
				void setRadius(double r) {
					radius = r; // remember you don't need a return for void return types
				}
				void setHeight(double h) {
					height = h;
				}
		};
		
		int main() {
			Cylinder cindy = Cylinder();
			cindy.setRadius(3.2);
			cindy.setHeight(8.6);
			cout << cindy.surfaceArea() << endl;
			cout << cindy.volume() << endl;
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		237.133
		276.521
	</code></pre>
	<p>
		Great. It works. Unfortunately, we can't directly access
		<span class="monoText">radius</span> and
		<span class="monoText">height</span> because they're still set to
		<span class="monoText">private</span>. But what if we need the
		<span class="monoText">radius</span> and
		<span class="monoText">height</span>? Well, we'll just write another
		<span class="monoText">public</span> method, one that retrieves
		<span class="monoText">radius</span> and
		<span class="monoText">height</span>:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		class Cylinder {
			double pi = 3.14;
			double radius;
			double height;
			public:
				double surfaceArea() {
					return 2 * pi * radius * (radius + height);
				}
				double volume() {
					return pi * radius * radius * height;
				}
				void setRadius(double r) {
					radius = r; // remember you don't need a return for void return types
				}
				double getRadius() {
					return radius;
				}
				void setHeight(double h) {
					height = h;
				}
				double getHeight() {
					return height;
				}
		};
		
		int main() {
			Cylinder cindy = Cylinder();
			cindy.setRadius(3.2);
			cindy.setHeight(8.6);
			cout << cindy.getRadius() << endl;
			cout << cindy.getHeight() << endl;
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		3.2
		8.6
	</code></pre>
	<p>
		Above, we wrote two new functions,
		<span class="monoText">getRadius()</span> and
		<span class="monoText">getHeight()</span>, both of which are of type
		<span class="monoText">double</span>, since they return a
		<span class="monoText">double</span>. Let's think a little more carefully
		about what this means. The methods
		<span class="monoText">getRadius()</span> and
		<span class="monoText">getHeight()</span> are one way streets. We can only
		<span class="italicsText">retrieve</span> the values assigned to the
		properties <span class="monoText">radius</span> and
		<span class="monoText">height</span>, but in no way can we use them to
		<span class="italicsText">modify</span> the values assigned. This
		effectively ensures that <span class="monoText">radius</span> and
		<span class="monoText">height</span> remain
		<span class="monoText">private</span>; we cannot modify them, we can only
		read them. Hence the term <span class="italicsText">access modifier</span>,
		rather than something like &#8220;visibility modifier.&#8221; In other
		words, the access modifier only restricts the ability to write; it doesn't
		necessarily restrict the ability to read.
	</p>
	<p>
		The methods <span class="monoText">setRadius()</span> and
		<span class="monoText">setHeight()</span> are examples of what we call
		<span class="term">setters</span>. Setters are methods for
		<span class="italicsText">initializing</span>
		properties in a class definition. The methods
		<span class="monoText">getRadius()</span> and
		<span class="monoText">getHeight()</span> are examples of
		<span class="term">getters</span>: methods that
		<span class="italicsText">retrieve</span>, or
		<span class="italicsText">read</span>, the values assigned to properties in
		a class definition.
		<label for="getset" class="margin-toggle">&#8853;</label>
		<input type="checkbox" id="getset" class="margin-toggle" />
		<span class="marginnote"
			>Getters are also called <span class="italicsText">accessors</span>, and
			setters are also called <span class="italicsText">mutators</span>. These
			methods are more broadly called
			<span class="italicsText">property functions</span>.</span
		>
	</p>
	<p>
		With getters and setters, we can now be more elaborate in how class
		properties are initialized. For example, there's a troubling aspect to our
		properties and methods: What if the user sets a property to negative? That
		would make no sense mathematically, because the lengths, widths, heights,
		radii, volumes, etc. of geometric figures cannot be negative. Accordingly,
		we should ensure that these values are always positive:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		class Maths {
			public:
				template&lt;class T&gt;
				T abs(T x) {
					if (x < 0) { return -1 * x; }
					else { return x; }
				}
		};
		
		class Cylinder {
			double pi = 3.14;
			double radius;
			double height;
			public:
				double surfaceArea() {
					return 2 * pi * radius * (radius + height);
				}
				double volume() {
					return pi * radius * radius * height;
				}
				void setRadius(double r) {
					radius = abs(r);
				}
				double getRadius() {
					return radius;
				}
				void setHeight(double h) {
					height = abs(h);
				}
				double getHeight() {
					return height;
				}
		};
		
		int main() {
			Cylinder cindy = Cylinder();
			cindy.setRadius(-1.2);
			cindy.setHeight(-4.3);
			cout << cindy.getRadius() << endl;
			cout << cindy.getHeight() << endl;
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		1.2
		4.3
	</code></pre>
	<p>
		Above, we wrote a separate class, <span class="monoText">Maths</span>, which
		provides a method called <span class="monoText">abs</span>. We then call
		that method in <span class="monoText">Cylinder</span> to ensure the values
		set for <span class="monoText">Radius</span> and
		<span class="monoText">Height</span> are positive only.
	</p>
</section>

<section id="constructors">
	<h2>Constructors</h2>
	<p>
		In the examples above, we initialized the properties of
		<span class="monoText">Cylinder()</span> with special methods &mdash;
		getters and setters. Getters and setters, however, should not be the default
		way we initialize properties. To understand why, let's think more abstractly
		about what a class does. A class is akin to a factory. It produces objects
		that have certain properties and can do certain things. When we write:
	</p>
	<pre class="language-cpp"><code>
		Cylinder cindy = Cylinder();
	</code></pre>
	<p>
		we are asking the <span class="monoText">Cylinder</span> factory to give us
		a cylinder. Does it make sense for that cylinder to have no radius and
		height? Of course not. Every cylinder has a radius and a height. The same
		goes for other objects. when we order a
		<span class="monoText">Cake()</span>, it would be odd for the cake not to
		have ingredients or volume. It's an <span class="italicsText">object</span>.
	</p>
	<p>
		Of course, there are objects in the world where we order the recipe or
		instructions, but not the object itself. Those transactions are best modeled
		with getters and setters. These processes, however, are the exception rather
		than the rule.
	</p>
	<p>
		Having said that, when we order something from a factory, we want to
		specifically state the properties our ordered object should have. For
		example, when we order a <span class="monoText">Cylinder()</span>, we should
		state what the <span class="monoText">Cylinder()</span>'s radius and height
		should be. This is especially important because in C++, when we order an
		object without its properties initialized (using the code we wrote above),
		the properties have <span class="italicsText">garbage values</span>. It's
		akin to a factory sending us some random cylinder.
	</p>
	<p>
		So how do we ensure that the factory doesn't send us a random cylinder? By
		ensuring that the factory forces us to specify what the cylinder's radius
		and height should be. To do so, we use a
		<span class="term">constructor</span>. A constructor is a method we write
		inside a class that is automatically called when we create an instance of
		that class. I.e., whenever we order a particular object, we must specify
		what that object's properties are.
	</p>
	<p>
		There are four different types of constructors in C++: (1) the
		<span class="term">default constructor</span>; (2)
		<span class="term">non-parameterized constructor</span>; (3)
		<span class="term">parameterized constructor</span>; and (4)
		<span class="term">copy constructor</span>. Of these four, the last three
		are constructors that we write. The default constructor is the constructor
		provided by the compiler. There are several other constructors, but we will
		focus on the latter three first. To do so, let's write a new class called
		<span class="monoText">Cuboid</span>
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
			using namespace std;
			
			class Maths {
				public:
					template&lt;class T&gt;
					T abs(T x) {
						if (x < 0) { return -1 * x; }
						else { return x; }
					}
			};
			
			class Cuboid {
				double length;
				double width;
				double height;
			
				public:
					double volume() {
						return length * width * height;
					}
					double surfaceArea() {
						return 2 * ((length * width) + (width * height) + (height * length));
					}
					double lateralSurfaceArea() {
						return 2 * ((width * height) + (height * length));
					}
					// Getters and setters
					void setLength(double l) {
						length = Maths().abs(l);
					}
					double getLength() {
						return length;
					}
					void setWidth(double w) {
						width = w;
					}
					double getWidth() {
						return width;
					}
					void setHeight(double h) {
						height = h;
					}
					double getHeight() {
						return height;
					}
			};
			
			int main() {
				return 0;
			}
	</code></pre>

	<p>
		Notice how many getters and setters we have. This evidences yet another
		problem with getters and setters: The more properties we have that must be
		initialized, the more getters and setters we have to write. Constructors
		allow us to define our <span class="monoText">Cuboid</span> class more
		concisely. Before we see how much more concise our code can be, let's first
		consider what the constructor does.
	</p>
	<p>
		The constructor is just another function (or method to be precise). First,
		let's consider the
		<span class="italicsText">non-parameterized constructor</span>. This is a
		constructor that performs one task: If we call the constructor without
		passing it any arguments, it creates a new object whose properties are
		initialized with <span class="italicsText">default values</span>:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		class Maths {
			public:
				template&lt;class T&gt;
				T abs(T x) {
					if (x < 0) { return -1 * x; }
					else { return x; }
				}
		};
		
		class Cuboid {
			double length;
			double width;
			double height;
		
			public:
				double volume() {
					return length * width * height;
				}
				double surfaceArea() {
					return 2 * ((length * width) + (width * height) + (height * length));
				}
				double lateralSurfaceArea() {
					return 2 * ((width * height) + (height * length));
				}
				// Getters and setters
				void setLength(double l) {
					length = Maths().abs(l);
				}
				double getLength() {
					return length;
				}
				void setWidth(double w) {
					width = w;
				}
				double getWidth() {
					return width;
				}
				void setHeight(double h) {
					height = h;
				}
				double getHeight() {
					return height;
				}
				// Non-parameterized constructor
				Cuboid() {
					length = 1.0;
					width = 1.0;
					height = 1.0;
				}
		};
		
		int main() {
			return 0;
		}
	</code></pre>
	<p>
		Now whenever we write <span class="monoText">Cuboid()</span>, we will create
		a <span class="monoText">Cuboid</span> object whose properties are all
		initialized to <span class="monoText">1.0</span>. The non-parameterized
		constructor ensures that we never get back an object whose properties are
		initialized to garbage values.
	</p>
	<p>
		But what if the user passes an argument? For that case, we write a
		<span class="italicsText">parameterized constructor</span>. This constructor
		will take the arguments, and <span class="underlineText">set</span> the
		properties to those values.
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		class Maths {
			public:
				template&lt;class T&gt;
				T abs(T x) {
					if (x < 0) { return -1 * x; }
					else { return x; }
				}
		};
		
		class Cuboid {
			double length;
			double width;
			double height;
		
			public:
				double volume() {
					return length * width * height;
				}
				double surfaceArea() {
					return 2 * ((length * width) + (width * height) + (height * length));
				}
				double lateralSurfaceArea() {
					return 2 * ((width * height) + (height * length));
				}
				// Getters and setters
				void setLength(double l) {
					length = Maths().abs(l);
				}
				double getLength() {
					return length;
				}
				void setWidth(double w) {
					width = w;
				}
				double getWidth() {
					return width;
				}
				void setHeight(double h) {
					height = h;
				}
				double getHeight() {
					return height;
				}
				// Non-parameterized constructor
				Cuboid() {
					length = 1.0;
					width = 1.0;
					height = 1.0;
				}
				// Parameterized constructor
				Cuboid(double l, double w, double h) {
					setLength(l);
					setWidth(w);
					setHeight(h);
				}
		};
		
		int main() {
			return 0;
		}
	</code></pre>
	<p>
		Notice that with the parameterized constructor, we take the arguments, and
		use those arguments as arguments to the setters. This has the effect of
		initializing all of the <span class="monoText">Cuboid</span> object's
		properties. With the parameterized constructor, we can now clean up our
		code. The setters are all redundant. We can simply take the arguments passed
		to the parameterized constructor and assign them directly, rather than
		passing them into separate functions:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		class Maths {
			public:
				template&lt;class T&gt;
				T abs(T x) {
					if (x < 0) { return -1 * x; }
					else { return x; }
				}
		};
		
		class Cuboid {
			double length;
			double width;
			double height;
		
			public:
				double volume() {
					return length * width * height;
				}
				double surfaceArea() {
					return 2 * ((length * width) + (width * height) + (height * length));
				}
				double lateralSurfaceArea() {
					return 2 * ((width * height) + (height * length));
				}
				// Getters
				double getLength() {
					return length;
				}
				double getWidth() {
					return width;
				}
				double getHeight() {
					return height;
				}
				// Non-parameterized constructor
				Cuboid() {
					length = 1.0;
					width = 1.0;
					height = 1.0;
				}
				// Parameterized constructor
				Cuboid(double l, double w, double h) {
					length = l;
					width = w;
					height = h;
				}
		};
		
		int main() {
			return 0;
		}
	</code></pre>
	<p>
		The non-paramterized constructor is also redundant because we can pass
		default values to functions:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		class Maths {
			public:
				template&lt;class T&gt;
				T abs(T x) {
					if (x < 0) { return -1 * x; }
					else { return x; }
				}
		};
		
		class Cuboid {
			double length;
			double width;
			double height;
		
			public:
				// Constructor
				Cuboid(double l=1.0, double w=1.0, double h=1.0) {
					length = Maths().abs(l);
					width = Maths().abs(w);
					height = Maths().abs(h);
				}
				// Methods
				double volume() {
					return length * width * height;
				}
				double surfaceArea() {
					return 2 * ((length * width) + (width * height) + (height * length));
				}
				double lateralSurfaceArea() {
					return 2 * ((width * height) + (height * length));
				}
				// Getters
				double getLength() {
					return length;
				}
				double getWidth() {
					return width;
				}
				double getHeight() {
					return height;
				}
		};
		
		int main() {
			return 0;
		}
	</code></pre>
	<p>
		Finally, a helpful constructor to write alongside the parameterized
		constructor is a <span class="italicsText">copy constructor</span>. This
		constructor creates a copy of an existing object:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		class Maths {
			public:
				template&lt;class T&gt;
				T abs(T x) {
					if (x < 0) { return -1 * x; }
					else { return x; }
				}
		};
		
		class Cuboid {
			double length;
			double width;
			double height;
		
			public:
				// Constructor
				Cuboid(double l=1.0, double w=1.0, double h=10) {
					length = Maths().abs(l);
					width = Maths().abs(w);
					height = Maths().abs(h);
				}
				// Copy Constructor
				Cuboid(Cuboid &c) {
					length = c.length;
					width = c.width;
					height = c.height;
				}
				// Methods
				double volume() {
					return length * width * height;
				}
				double surfaceArea() {
					return 2 * ((length * width) + (width * height) + (height * length));
				}
				double lateralSurfaceArea() {
					return 2 * ((width * height) + (height * length));
				}
				// Getters
				double getLength() {
					return length;
				}
				double getWidth() {
					return width;
				}
				double getHeight() {
					return height;
				}
				
		};
		
		int main() {
			Cuboid c1 = Cuboid(2.0, 3.0, 5.0);
			Cuboid c2 = Cuboid(c1);
			cout << c1.volume() << endl;
			cout << c2.volume() << endl;
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		30
		30
	</code></pre>

	<h3>Deep Copy Constructor</h3>
	<p>
		Because copy constructors use references, there's an underlying problem we
		might potentially encounter whenever we use them. Consider a class called
		<span class="monoText">A</span> (for the sake of simplicity, we will think
		of this outside the context of a real-world application and keep the
		properties public):
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		class A {
		public:
			int x;
			int *p;
			A(int n) {
				x = n;
				p = new int[x];
			}
			A(A &t) {
				x = t.x;
				p = t.p;
			}
		};
		
		int main() {
			return 0;
		}
	</code></pre>
	<p>
		The class <span class="monoText">A</span> has two properties:
		<span class="monoText">x</span>, which takes an
		<span class="monoText">int</span> value, and
		<span class="monoText">*p</span>, which is a pointer.
	</p>
	<p>
		Next, the class <span class="monoText">A</span> also has two methods. First,
		a parameterized constructor, which assigns to
		<span class="monoText">x</span> the argument passed as
		<span class="monoText">n</span>. Additionally, the parameterized constructor
		initializes <span class="monoText">p</span> with a new
		<span class="monoText">int</span> array, of size
		<span class="monoText">x</span> (which is the value of
		<span class="monoText">n</span>, the integer passed as argument). Thus,
		whenever we create an instance of <span class="monoText">A</span>, we create
		a new <span class="monoText">int</span> array in the heap.
	</p>
	<p>
		The class <span class="monoText">A</span> also contains a copy constructor,
		which takes as argument a reference, <span class="monoText">&t</span>. That
		argument is a reference to an existing instance of
		<span class="monoText">A</span>. Inside the copy constructor, we assign to
		<span class="monoText">x</span> the <span class="monoText">x</span> property
		of the existing <span class="monoText">A</span> instance, and to
		<span class="monoText">p</span> the pointer property
		<span class="monoText">p</span> of the existing
		<span class="monoText">A</span> instance.
	</p>
	<p>Instantiating:</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
			
		class A {
		public:
			int x;
			int *p;
			public:
				A(int n) {
					x = n;
					p = new int[x];
				}
				A(A &t) {
					x = t.x;
					p = t.p;
				}
		};
		
		int main() {
			A foo = A(3);
			return 0;
		}
	</code></pre>
	<p>
		We've now created an instance of <span class="monoText">A</span> called
		<span class="monoText">foo</span>. That instance has a property
		<span class="monoText">x</span>, containing the
		<span class="monoText">int 3</span>. More importantly, it contains a pointer
		property <span class="monoText">p</span>, which points to an array in the
		heap of size 5. Now what happens when we create a copy of
		<span class="monoText">foo</span>?
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		class A {
		public:
			int x;
			int *p;
			public:
				A(int n) {
					x = n;
					p = new int[x];
				}
				A(A &t) {
					x = t.x;
					p = t.p;
				}
		};
		
		int main() {
			A foo = A(3);
			A boo = A(foo);
			return 0;
		}
	</code></pre>
	<p>
		We've created a copy of <span class="monoText">foo</span> called
		<span class="monoText">boo</span>. Did
		<span class="monoText">boo</span> create a new array of its own? Well, we
		can check by outputting the address. If
		<span class="monoText">boo</span> created its own array, they should be
		different:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		class A {
		public:
			int x;
			int *p;
				A(int n) {
					x = n;
					p = new int[x];
				}
				A(A &t) {
					x = t.x;
					p = t.p;
				}
		};
		
		int main() {
			A foo = A(3);
			A boo = A(foo);
			foo.p[0] = 1;
			cout << foo.p << endl;
			cout << boo.p << endl;
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		0x7fc6f1405c00
		0x7fc6f1405c00
	</code></pre>
	<p>
		They're the same address. The copy of <span class="monoText">foo</span>,
		named <span class="monoText">boo</span>, didn't create its own array. We now
		have two pointers pointing to the same array in the heap. This is something
		we have to be very careful with. If we want a copy to have its own array in
		the heap, we must write a
		<span class="italicsText">deep copy constructor</span>:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		class A {
		public:
			int x;
			int *p;
				A(int n) {
					x = n;
					p = new int[x];
				}
				A(A &t) {
					x = t.x;
					p = new int[x]; // revision
				}
		};
		
		int main() {
			A foo = A(3);
			A boo = A(foo);
			foo.p[0] = 1;
			cout << foo.p << endl;
			cout << boo.p << endl;
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		0x7fe603c05c00
		0x7fe603c05c10
	</code></pre>
	<p>
		Having revised our copy constructor, we now see that copies create their own
		arrays.
	</p>
</section>

<section id="scope_resolution">
	<h2>Scope Resolution</h2>
	<p>
		Let's consider a simple class called
		<span class="monoText">Rectangle</span>:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		class Rectangle {
			double length;
			double height;
			public:
				Rectangle(double l = 1.0, double h = 1.0) {
					length = l;
					height = h;
				}
				// method
				double area() { return length * height; }
				double perimeter() { return 2 * (length + height); }
		};
		
		int main() {
			Rectangle r = Rectangle(2.1, 4.7);
			cout << r.area() << endl;
			cout << r.perimeter() << endl;
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		9.87
		13.6
	</code></pre>
	<p>
		While the class above works fine, it doesn't exactly coincide with C++'s
		approach to OOP. For starters, a core rule of OOP is to hide away the
		implementation details. Here, we can clearly see how the methods
		<span class="monoText">perimeter()</span> and
		<span class="monoText">area()</span> are implemented. The first step to
		ensuring they're hidden is to use the
		<span class="term">scope resolution operator</span>, denoted with
		<span class="monoText">::</span> (two colons).
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		class Rectangle {
			double length;
			double height;
			public:
				Rectangle(double l=1.0, double h=1.0);
				double area();
				double perimeter();
		};
		
		int main() {
			Rectangle r = Rectangle(2.1, 4.7);
			cout << r.area() << endl;
			cout << r.perimeter() << endl;
			return 0;
		}
		
		Rectangle::Rectangle(double l, double h) {
			length = l;
			height = h;
		};
		double Rectangle::area() { return length * height; }
		double Rectangle::perimeter() { return 2 * (length + height); }
	</code></pre>
	<pre class="language-bash"><code>
		9.87
		13.6
	</code></pre>
	<p>
		Notice how we moved the implementations to below the
		<span class="monoText">main()</span> function. On first glance, this appears
		even worse than the original implementation, because now the code looks even
		longer. However, the idea is to hide away these implementation details. What
		we want to do next is move these implementations into separate files. First,
		we create two files in the same directory: (1) a file called
		<span class="monoText">Rectangle.cpp</span>, (2) a file called
		<span class="monoText">Rectangle.h</span>, and (3) a file called
		<span class="monoText">main.cpp</span>.
	</p>
	<p>Inside the <span class="monoText">Rectangle.cpp</span> file, we write:</p>
	<pre class="language-cpp"><code>
		#include "Rectangle.h"
		Rectangle::Rectangle(double l, double h) {
			length = l;
			height = h;
		};
		double Rectangle::area() { return length * height; }
		double Rectangle::perimeter() { return 2 * (length + height); }
	</code></pre>
	<p>Inside the <span class="monoText">Rectangle.h</span> file, we write:</p>
	<pre class="language-cpp"><code>
		#ifndef RECTANGLE_H
		#define RECTANGLE_H

		class Rectangle {
			double length;
			double height;
			public:
				Rectangle(double l=1.0, double h=1.0);
				double area();
				double perimeter();
		};
		#endif
	</code></pre>
	<p>Finally, inside the <span class="monoText">main.cpp</span>, we have:</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		#include "Rectangle.h"
		using namespace std;
		
		int main() {
			Rectangle r = Rectangle(2.1, 4.7);
			cout << r.area() << endl;
			cout << r.perimeter() << endl;
			return 0;
		}
	</code></pre>
	<p>
		Now, to run the main program, we have to compile the
		<span class="monoText">Rectangle.cpp</span> file and the
		<span class="monoText">main.cpp</span> file separately:
	</p>
	<pre class="language-bash"><code>
		g++ -c Rectangle.cpp
		g++ -c main.cpp
	</code></pre>
	<p>
		This will output two object files,
		<span class="monoText">Rectangle.o</span> and
		<span class="monoText">main.o</span>. Because we now have to separate object
		files, we'll need to link them into a single executable. We'll call this
		single object file <span class="monoText">mainProgram</span>:
	</p>
	<pre class="language-bash"><code>
		g++ -o mainProgram main.o Rectangle.o
	</code></pre>
	<p>Then when we execute the single executable:</p>
	<pre class="language-cpp"><code>
		./mainProgram
		9.87
		13.6
	</code></pre>
	<p>
		It works as expected. This seems like a lot of trouble, but notice what
		we've done: First, we've cleanly separated all of the different parts of our
		program: (1) The main program resides in its own file; (2) the
		<span class="monoText">Rectangle</span> class resides its own file; and (3)
		the implementation details of the
		<span class="monoText">Rectangle</span> class reside in their own files.
		Then, even better, the <span class="monoText">Rectangle</span> class can be
		passed around and use with any other program we write. We do not have to
		copy and paste code. All we need to do is place the executable elsewhere,
		and link it. Even better, the implementation details are completely hidden
		away from the user.
	</p>
	<p>
		Now, we might be thinking, that's so much work! We have to compile each of
		these files separately and then link them ourselves? Is separation really
		worth it for all the time spent? The answer is yes, it is. The amount of
		time used to keep all of these different components separate is far less
		than the amount of time we would spend having to debug and improve massive
		source code files. Furthermore, the premise that compiling these files
		separately takes too much time is not necessarily true. This is precisly why
		we use <span class="italicsText">make files</span>.
	</p>
</section>

<section id="make_files">
	<h2>Make Files</h2>
	<p>
		On UNIX systems, <span class="monoText">make</span> is a tool provided to
		simplify building executables from different project modules. In our
		<span class="monoText">Rectangle</span> example above, we have three
		separate modules: <span class="monoText">main.cpp</span>,
		<span class="monoText">Rectangle.cpp</span>, and
		<span class="monoText">mainProgram</span> (the final executable containing
		all of the individual executables, linked). A
		<span class="monoText">make</span> file is simply a text file that the
		<span class="monoText">make</span> command referencs to build the
		<span class="term">targets</span> &mdash; the modules we want built.
	</p>
	<p>
		The basic idea behind <span class="monoText">make</span> is this: We want to
		be able to write <span class="monoText">make ${t}$</span>, where ${t}$ is
		some target file, after which ${t}$ is built. We also want to write things
		like <span class="monoText">make clean</span>, upon which the
		<span class="monoText">rm</span> command is executed on certain files
		(thereby &#8220;cleaning up&#8221; previous executables).
	</p>
	<p>
		To see how all this works, let's write a
		<span class="monoText">make</span> file for our
		<span class="monoText">Rectangle</span> example above. First, we note all
		the different modules we have: (1)
		<span class="monoText">main.cpp</span> (the main driver of our program); (2)
		<span class="monoText">Rectangle.h</span> (the header file for the
		<span class="monoText">Rectangle</span> class); and (3)
		<span class="monoText">Rectangle.cpp</span> (the C++ implementation file for
		the <span class="monoText">Rectangle</span> class).
	</p>
	<p>
		Now, when run <span class="monoText">g++ -c main.cpp</span>, we generate the
		object file (executable), <span class="monoText">main.o</span>. And when we
		write <span class="monoText">g++ -c Rectangle.cpp</span>, we generate the
		object file <span class="monoText">Rectangle.o</span>. These are two
		individual compilations, resulting in two individual executables. For our
		program to run, we need a single executable, where
		<span class="monoText">main.o</span> and
		<span class="monoText">Rectangle.o</span> are linked.
	</p>
	<p>
		To link those files, we write:
		<span class="monoText">g++ -o main main.o Rectangle.o</span>. The single
		word <span class="monoText">main</span> is just the name of the final
		executable. We could just as easily written it,
		<span class="monoText">mainProgram</span> (as we did previously), or
		<span class="monoText">mainDriver</span>, or
		<span class="monoText">program</span>. Ideally, it should be descriptive.
	</p>
	<p>
		We can run this entire process by executing
		<span class="monoText">make</span>. To do so, we create a new file called
		<span class="monoText">Makefile</span>, in the same directory as our
		project. Inside <span class="monoText">Makefile</span>, we write the
		following:
	</p>
	<pre class="language-bash"><code>
		CC = g++
		CFLAGS = -Wall -g
		clean:
			$(RM) main Rectangle
		main: main.o Rectangle.o
			$(CC) $(CFLAGS) -o main main.o Rectangle.o
	</code></pre>
	<p>
		Let's go over what the symbols in this file mean. First,
		<span class="monoText">CC</span> and
		<span class="monoText">CFLAGS</span> are constants. The
		<span class="monoText">CC</span> constant indicates which C compiler to use.
		In this case, we indicated the <span class="monoText">g++</span> compiler.
		We could also have indicated <span class="monoText">gcc</span>.
	</p>
	<p>
		The <span class="monoText">CFLAGS</span> constant indicates what flags we
		should pass to the compilation command. The
		<span class="monoText">-g</span> flags tells the compiler to include
		debugging information in the executable file. The
		<span class="monoText">-Wall</span> flag tells the compiler to include
		compiler warnings.
	</p>
	<p>
		The next two symbols, <span class="monoText">clean</span> and
		<span class="monoText">main</span>, are
		<span class="italicsText">targets</span>. Targets can be file names used as
		input, or the name of an action to be carried out. In the case where it's
		the name of an action such as <span class="monoText">clean</span>, we
		effectively create a new rule, called
		<span class="monoText">make clean</span>. When we execute
		<span class="monoText">make clean</span>, we execute the command
		<span class="monoText">$(RM) main Rectangle</span>, or, in bash terms,
		<span class="monoText">rm main.o rectangle.o</span>. This effectively cleans
		up the object files we have in our project.
	</p>
	<p>
		When we execute <span class="monoText">make main</span>, we execute the
		command <span class="monoText">CC CFLAGS -o main main.o Rectangle.o</span>.
		This command evaluates to,
		<span class="monoText">g++ -Wall -g -o main main.o Rectangle.o</span>.
		Notice that this is the line we executed when we didn't have the makefile.
		The only difference is now we just need to write
		<span class="monoText">make main</span>.
	</p>
	<p>Here's a slightly better makefile:</p>
	<pre class="language-bash"><code>
		CC = g++
		CFLAGS = -Wall -g
		objects = main.o Rectangle.o
		all: $(objects)
		clean:
			$(RM) *.o all
	</code></pre>
	<p>
		With the implementation above, we list all of the files we want compiled in
		a variable called <span class="monoText">objects</span>. That variable is
		then used for the target <span class="monoText">all</span>. When execute
		<span class="monoText">make all</span>, the files
		<span class="monoText">main.cpp</span> and
		<span class="monoText">Rectangle.cpp</span> are compiled and linked.
	</p>
	<p>
		To summarize, using scope resolution, we've separated our files program into
		the following:
	</p>

	<pre class="language-cpp"><code>
			// Rectangle.cpp
			#include "Rectangle.h"
			Rectangle::Rectangle(double l, double h) {
				length = l;
				height = h;
			};
			double Rectangle::area() { return length * height; }
			double Rectangle::perimeter() { return 2 * (length + height); }
		</code></pre>
	<pre class="language-cpp"><code>
			// Rectangle.h
			#ifndef RECTANGLE_H
			#define RECTANGLE_H
	
			class Rectangle {
				double length;
				double height;
				public:
					Rectangle(double l=1.0, double h=1.0);
					double area();
					double perimeter();
			};
			#endif
		</code></pre>
	<pre class="language-cpp"><code>
			// main.cpp
			#include &lt;iostream&gt;
			#include "Rectangle.h"
			using namespace std;
			
			int main() {
				Rectangle r = Rectangle(2.1, 4.7);
				cout << r.area() << endl;
				cout << r.perimeter() << endl;
				return 0;
			}
		</code></pre>
</section>

<section id="inline_functions">
	<h2>Inline Functions</h2>
	<p>Consider the following functions:</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		class Foo {
			public:
				void func1() {
					cout << "Hi" << endl;
				}
				void func2();
		};
		
		void Foo::func2() {
			cout << "Hi" << endl;
		}
		
		int main() {
			Foo x;
			x.func1();
			x.func2();
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		Hi
		Hi
	</code></pre>
	<p>
		Notice that the function <span class="monoText">func1</span> is defined
		inside the class definition for <span class="monoText">Foo</span>, while
		<span class="monoText">func2</span> is defined outside the definition
		through scope resolution.
	</p>
	<p>
		Both <span class="monoText">func1</span> and
		<span class="monoText">func2</span> perform the same computation; namely,
		outputting the string <span class="monoText">"Hi"</span> to the console.
		However, both functions go about it differently.
	</p>
	<p>
		the function <span class="monoText">func1</span> is an
		<span class="term">inline function</span>, while the function
		<span class="monoText">func2</span> is a
		<span class="term">non-inline function</span>. What's the difference between
		an inline function and a non-inline function?
	</p>
	<p>
		With an inline function, the machine code is &#8220;copied-and-pasted&#8221;
		directly into the function that calls functions. In this case, the function
		<span class="monoText">func1()</span> has its machine code directly pasted
		into the <span class="monoText">main()</span> function's machine code. In
		contrast, the function <span class="monoText">func2()</span> will have its
		machine code allocated in a separate stack.
	</p>
	<p>
		If we want <span class="monoText">func2()</span> to be treated as an inline
		function, we simply include the
		<span class="monoText">inline</span> keyword:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		class Foo {
			public:
				void func1() {
					cout << "Hi" << endl;
				}
				inline void func2();
		};
		
		void Foo::func2() {
			cout << "Hi" << endl;
		}
		
		int main() {
			Foo x;
			x.func1();
			x.func2();
			return 0;
		}
	</code></pre>
</section>

<section id="this">
	<h2><span class="monoText">this</span></h2>
	<p>Suppose we wrote a class called <span class="monoText">City</span>:</p>
	<pre class="language-cpp"><code>
		#include &lt;string&gt;
		using namespace std;
		
		class City {
			string city_name;
			int population;
			City(string cn = "uninitialized", int p = 0) {
				city_name = cn;
				population = p;
			}
		};
		
		int main() {
			return 0;
		}
	</code></pre>
	<p>
		The code above runs well, but notice the constructor's parameters. Those
		names &mdash; <span class="monoText">cn</span> and
		<span class="monoText">p</span> &mdash; are pretty bad. Names should always
		be descriptive. We could get around this problem by simply writing a more
		descriptive name, but what would be more descriptive than
		<span class="monoText">city_name</span>? We don't want to use something like
		<span class="monoText">cityName</span>; differentiating names purely on the
		way they look is almost always a bad idea. What if we instead just used the
		original identifiers, <span class="monoText">city_name</span> and
		<span class="monoText">population</span>?
	</p>
	<pre class="language-cpp"><code>
		#include &lt;string&gt;
		using namespace std;
		
		class City {
			string city_name;
			int population;
			City(string city_name = "uninitialized", int population = 0) {
				city_name = city_name;
				population = population;
			}
		};
		
		int main() {
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		city.cpp:8:13: warning: explicitly assigning value of variable of type 'std::__1::string' (aka 'basic_string&lt;char&gt;') to itself [-Wself-assign-overloaded]
					city_name = city_name;
					~~~~~~~~~ ^ ~~~~~~~~~
		city.cpp:9:14: warning: explicitly assigning value of variable of type 'int' to itself [-Wself-assign]
					population = population;
					~~~~~~~~~~ ^ ~~~~~~~~~~
		city.cpp:6:6: warning: private field 'population' is not used [-Wunused-private-field]
		int population;
	</code></pre>
	<p>
		Nope. Not a good idea. The compiler can't differentiate between the variable
		<span class="monoText">city_name</span> and
		<span class="monoText">population</span> inside the class, and the
		parameters <span class="monoText">city_name</span> and
		<span class="monoText">population</span>. And fairly so; just reading those
		two lines looks off.
	</p>
	<p>The solution? Use the <span class="monoText">this</span> keyword:</p>
	<pre class="language-cpp"><code>
		#include &lt;string&gt;
		using namespace std;
		
		class City {
			string city_name;
			int population;
			City(string city_name = "uninitialized", int population = 0) {
				this->city_name = city_name;
				this->population = population;
			}
		};
		
		int main() {
			return 0;
		}
	</code></pre>
	<p>
		Compiling the code above, we don't get any problems. The
		<span class="monoText">this</span> keyword operates as it sounds like. It
		tells the <span class="monoText">compiler</span>, &#8220;I'm refer to
		<span class="underlineText">this object's</span> variable.&#8221;
	</p>
</section>

{% endblock %}
