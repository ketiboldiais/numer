{% extends '../layout.html' %} {% load static %} {% block description %}
<meta name="description" content="Notes on the queue data structure." />
{% endblock %} {% block title %}
<title>Queue</title>
{% endblock %} {% block content %}
<h1>The Queue</h1>
<section id="intro">
	<p>
		In this section, we discuss the <b>queue</b> data structure. Like the
		stack, the queue is a logical data structure premised on an
		foundational operating principle &mdash;
		<b>first-in-first-out (FIFO)</b>. For example, in the diagram below,
		suppose <var>A</var> enters first, then <var>B</var>, then
		<var>C</var>, then <var>D</var>:
	</p>
	<div id="queueIntro"></div>
	<p>
		The first to exit is <var>A</var>. The second is <var>B</var>. The
		third is <var>C</var>. And the fourth is <var>D</var>. We call the
		entities in a queue &mdash; e.g., <var>A</var>, <var>B</var>,
		<var>C</var>, and <var>D</var> above &mdash; <b>queuers</b> or
		<b>elements</b>. The name <i>queue</i> is fitting &mdash; it's like
		standing in a line at the bank, waiting for the next available teller.
	</p>
	<p>
		The queue has two special positions, the <b>front</b> (denoted below as
		<var>f</var>), and the <b>rear</b> (denoted below as <var>r</var>).
	</p>
	<div id="queueFrontRear"></div>
	<p>
		Consistent with a queue in real life, to delete a queuer from the
		queue, we remove the element currently occupying the <i>front</i>:
	</p>
	<div id="queueDequeue"></div>
	<p>
		And to insert a queuer into the queue, we append an element to the
		<i>rear:</i>
	</p>
	<div id="queueEnqueue"></div>
	<p>
		By convention, inserting a queuer is called
		<b>enqueue</b>, and removing a queuer is called <b>dequeue</b>.
	</p>
</section>

<section id="implementations">
	<h2>Implementations</h2>
	<p>
		Like we saw with the stack, there are two kinds of queues: the
		<b>bounded queue</b>, implemented with a <i>static array</i>, and the
		<b>unbounded queue</b>, implemented with a <i>linked list</i>. We
		consider each below.
	</p>
	<p>
		For both bounded queues and unbounded queues, we want the following
		properties and operations:
	</p>
	<ol>
		<li>
			A <var><mark>length</mark></var> property, representing the current
			number of queuers in the queue.
		</li>
		<li>
			An <var><mark>isEmpty()</mark></var> operation, returning
			<var>true</var> if the queue contains no queuers and
			<var>false</var> if it does.
		</li>
		<li>
			An <var><mark>enqueue()</mark></var> operation, for inserting a
			queuer.
		</li>
		<li>
			A <var><mark>dequeue()</mark></var> operation, for removing a queuer.
		</li>
		<li>
			A <var><mark>peek()</mark></var> operation, for retrieving the value
			a queuer holds.
		</li>
	</ol>
</section>

<section id="static_queue">
	<h2>RP Bounded Queue</h2>
	<p>
		Implementing the bounded queue with an array is simple. In the diagram
		below, the static array implementation is presented to the right, and
		the bounded queue is presented to the left.
	</p>
	<div class="split">
		<ol class="array">
			<li>
				<ul>
					<li>2</li>
					<li>0</li>
				</ul>
			</li>
			<li>
				<ul>
					<li>3</li>
					<li>1</li>
				</ul>
			</li>
			<li>
				<ul>
					<li>7</li>
					<li>2</li>
				</ul>
			</li>
			<li>
				<ul>
					<li>5</li>
					<li>3</li>
				</ul>
			</li>
		</ol>
		<div id="staticQueue1"></div>
	</div>
	<p>
		With the static queue, we implement all of the properties mentioned in
		the preceding section, with two additional properties and operations:
	</p>
	<ol>
		<li>
			A <var><mark>capacity</mark></var> property, representing the maximum
			number of queuers the queue can hold.
		</li>
		<li>
			A <var><mark>availableSpace()</mark></var> operation, which returns
			how much available space there is in the queue.
		</li>
		<li>
			An <var><mark>isFull()</mark></var> operation, returning
			<var>true</var> if the queue's capacity has been reached; otherwise
			<var>false</var>.
		</li>
	</ol>
	<p>
		To implement the properties and operations above, we must first answer
		the following question:
	</p>
	<dfn>
		<p>
			Do we want one pointer for the queue's rear, or two pointers, one for
			the front and one for the rear?
		</p>
	</dfn>
	<p>
		Generally, with bounded queues, we want two pointers. But, there may be
		situations where a single pointer to the rear suffices. For
		conciseness, we call the single pointer implementation the
		<b>rear-pointed (RP) queue</b>, and the two pointer approach the
		<b>front-rear-pointed (FRP) queue</b>. We consider both in tandem.
	</p>
	<p>
		For both the RP approach and the FRP approach, an implementation in C
		can be done with a <var>struct</var>. Below is the RP implementation.
	</p>
	<pre class="language-c"><code>
		struct Queue {
			int capacity;
			int length;
			int rear;
			int* Q;
		}
	</code></pre>
	<p>
		Above, we see the properties examined earlier. The
		<var>int</var> pointer <var>Q</var> is a pointer to an array in the
		heap, which is the data structure implementing the bounded queue.
	</p>
	<p>
		<span class="topic">Constructor.</span> Below is a the RP bounded
		approach's implementation in C:
	</p>
	<pre class="language-c"><code>
		struct Queue* newQueue(int maxSize) {
			struct Queue* queue = malloc(sizeof(struct Queue));
			(*queue).capacity = maxSize;
			(*queue).length = 0;
			(*queue).rear = -1;
			(*queue).Q = malloc(sizeof(int) * maxSize);
			return queue;
		}
	</code></pre>
	<p>
		This is not that different from what we saw with stacks. With the
		constructor in place, we can now consider the various properties and
		methods.
	</p>

	<p>
		<span class="topic">Destructor.</span> For languages without automatic
		memory management like C and C++, we'll also want a destructor:
	</p>
	<pre class="language-c"><code>
		void freeQueue(struct Queue** queue) {
			free((*(*queue)).Q);
			free(*queue);
			*queue = NULL;
		}
	</code></pre>

	<section id="is_full">
		<h3>Capacity Guard</h3>
		<p>
			Because the bounded queue has maximum number of queuers it can store,
			we need a capacity guard for the other operations to use. Using the C
			code as a base for our pseudocode examples, a capacity guard might
			look like the following:
		</p>
		<ol class="alg">
			<li>fn isFull(Queue* queue) -> bool:</li>
			<ol>
				<li>return (*queue).length == (*queue).capacity;</li>
			</ol>
		</ol>
		<p>
			The implementation relies on the queue's properties
			<var>length</var> and capacity. If the queue's length equals its
			capacity, the queue has reached its limit, and we can't enqueue any
			further.
		</p>
		<div class="demo">
			<button>C</button>
			<div class="implementation">
				<p>
					Here's an implementation in C. Note that this relies on the
					<var>stdbool.h</var> header file.
				</p>
				<pre class="language-c"><code>
					bool isFull(struct Queue* queue) {
						return (*queue).height == (*queue).capacity;
					}
				</code></pre>
			</div>
		</div>
	</section>

	<section id="is_empty">
		<h3>Empty Guard</h3>
		<p>
			Alongside the capacity guard, we also want an <i>empty guard</i>.
			This allows us ensure we aren't dequeuing an empty queue:
		</p>
		<ol class="alg">
			<li>fn isEmpty(Queue* queue) -> bool:</li>
			<ol>
				<li>return (*queue).length == 0;</li>
			</ol>
		</ol>
		<p>
			Like the capacity guard, the empty guard relies on the queue's
			<var>length</var> property to determine if the queue is empty. If the
			queue's length is ${0,}$ then we know that the queue is empty and we
			should be trying to perform operations like dequeuing.
		</p>
		<div class="demo">
			<button>C</button>
			<div class="implementation">
				<p>
					Here's an implementation in C. Again, this relies on the
					<var>stdbool.h</var> header file. Of course, we can just return
					<var>0</var> for false and <var>1</var> for true. We use the
					<var>stdbool.h</var> header file purely for readability and
					semantics.
				</p>
				<pre class="language-c"><code>
					bool isEmpty(struct Queue* queue) {
						return (*queue).height == 0;
					}
				</code></pre>
			</div>
		</div>
	</section>

	<section id="space_available">
		<h3>Space Count</h3>
		<p>
			This isn't a necessary operation for bounded queues, but it's a
			nice-to-have. The <var>availableSpace()</var> operation returns how
			many spots in the queue we have left for use:
		</p>
		<ol class="alg">
			<li>fn spaceAvailable(Queue* queue) -> int:</li>
			<ol>
				<li>return (*queue).capacity - (*queue).height;</li>
			</ol>
		</ol>
		<p>
			The procedure is simple: Compute the difference between the queue's
			capacity and the current height.
		</p>
		<p>
			With these basic operations and properties implemented, we can now
			consider the core operations for the bounded queue,
			<var><mark>enqueue()</mark></var> and
			<var><mark>dequeue()</mark></var
			>.
		</p>
		<div class="demo">
			<button>C</button>
			<div class="implementation">
				<p>
					Here's an implementation in C. Not all that different from the
					pseudocode:
				</p>
				<pre class="language-c"><code>
					int availableSpace(struct Queue* queue) {
						return (*queue).capacity - (*queue).height;
					}
				</code></pre>
			</div>
		</div>
	</section>

	<section id="enqueue">
		<h3>Enqueuing an RP Bounded Queue</h3>
		<p>
			To enqueue with the bounded queue, we must first have a pointer
			<var>r</var>, corresponding to the queue's rear. Initially,
			<var>r = -1</var>. To insert a new element into the queue &mdash;
			enqueue &mdash; we move <var>r</var> to the next location (i.e.,
			increment <var>r</var>).
		</p>
		<p>For example, suppose we had a static queue of size 5:</p>
		<div class="split">
			<ol class="array">
				<li>
					<ul>
						<li>&ThickSpace;</li>
						<li>0</li>
					</ul>
				</li>
				<li>
					<ul>
						<li>&ThickSpace;</li>
						<li>1</li>
					</ul>
				</li>
				<li>
					<ul>
						<li>&ThickSpace;</li>
						<li>2</li>
					</ul>
				</li>
				<li>
					<ul>
						<li>&ThickSpace;</li>
						<li>3</li>
					</ul>
				</li>
				<li>
					<ul>
						<li>&ThickSpace;</li>
						<li>4</li>
					</ul>
				</li>
			</ol>
			<div id="staticQueueInsert"></div>
		</div>
		<p>
			We begin by moving the pointer <var>r</var> to the first index in the
			array:
		</p>
		<div class="split">
			<ol class="array">
				<li>
					<ul>
						<li>&ThickSpace;</li>
						<li>0</li>
						<li>r</li>
					</ul>
				</li>
				<li>
					<ul>
						<li>&ThickSpace;</li>
						<li>1</li>
					</ul>
				</li>
				<li>
					<ul>
						<li>&ThickSpace;</li>
						<li>2</li>
					</ul>
				</li>
				<li>
					<ul>
						<li>&ThickSpace;</li>
						<li>3</li>
					</ul>
				</li>
				<li>
					<ul>
						<li>&ThickSpace;</li>
						<li>4</li>
					</ul>
				</li>
			</ol>
			<div id="staticQueueInsert"></div>
		</div>
		<p>Then, we insert the relevant data, say <var>2</var>:</p>
		<div class="split">
			<ol class="array">
				<li>
					<ul>
						<li>2</li>
						<li>0</li>
						<li>r</li>
					</ul>
				</li>
				<li>
					<ul>
						<li>&ThickSpace;</li>
						<li>1</li>
					</ul>
				</li>
				<li>
					<ul>
						<li>&ThickSpace;</li>
						<li>2</li>
					</ul>
				</li>
				<li>
					<ul>
						<li>&ThickSpace;</li>
						<li>3</li>
					</ul>
				</li>
				<li>
					<ul>
						<li>&ThickSpace;</li>
						<li>4</li>
					</ul>
				</li>
			</ol>
			<div id="staticQueueInsert1"></div>
		</div>
		<p>
			If we want to add another element, we just increment <var>r</var> and
			continue. In pseudocode:
		</p>
		<ol class="alg">
			<li>fn enqueue(Queue* queue) -> void:</li>
			<ol>
				<li>if (isFull(queue)):</li>
				<ol>
					<li>printf("Enqueue prohibited: Queue is full.")</li>
				</ol>
				<li>else:</li>
				<ol>
					<li>(*queue).rear++;</li>
					<li>(*queue).Q[ (*queue).rear ] = data;</li>
					<li>(*queue).height++;</li>
				</ol>
			</ol>
		</ol>
		<p>
			The enqueue procedure is the same for both the RP bounded queue and
			FRP bounded queue. We just need to increment the
			<var>rear</var> pointer, assign the data, and increment the
			<var>height</var> property.
		</p>
		<div class="demo">
			<button>C</button>
			<div class="implementation">
				<p>Below is an implementation in C:</p>
				<pre class="language-c"><code>
					#include &lt;stdlib.h&gt;
					#include &lt;stdio.h&gt;
					#include &lt;stdbool.h&gt;
					
					<details><summary>struct Queue </summary>{
						int capacity;
						int height;
						int rear;
						int* Q; 
					};</details>
					<details><summary>struct Queue* newQueue(int maxSize) </summary>{
						struct Queue* queue = malloc(sizeof(struct Queue));
						(*queue).capacity = maxSize;
						(*queue).height = 0;
						(*queue).rear = -1;
						(*queue).Q = malloc(sizeof(int) * maxSize);
						return queue;
					}</details>
					<details><summary>bool isFull(struct Queue* queue) </summary>{
						return (*queue).height == (*queue).capacity;
					}</details>
					<details><summary>bool isEmpty(struct Queue* queue) </summary>{
						return (*queue).height == 0;
					}</details>
					<details><summary>int availableSpace(struct Queue* queue) </summary>{
						return (*queue).capacity - (*queue).height;
					}</details>

					void enqueue(struct Queue* queue, int data) {
						if (isFull(queue)) {
							printf("Enqueue prohibitied: Queue is full.\n");
						} else {
							(*queue).rear++;
							(*queue).Q[(*queue).rear] = data;
							(*queue).height++;
						}
					}
				</code></pre>
			</div>
		</div>

		<section id="rushing">
			<p>
				<span class="topic">Rush-in.</span> As an aside, a useful operation
				to have with queues is the <b>rush-in</b>. Essentially, enqueuing
				multiple elements into the queue with a loop:
			</p>
			<ol class="alg">
				<li>fn rushIn(Queue* queue, int array[], int arraySize):</li>
				<ol>
					<li>if (arraySize > availableSpace(queue)):</li>
					<ol>
						<li>print "Insufficient space to rush into queue.";</li>
					</ol>
					<li>else if (arraySize < 0):</li>
					<ol>
						<li>print "Invalid array size: Negative number.";</li>
					</ol>
					<li>else:</li>
					<ol>
						<li>for (int i = 0; i < arraySize; i++):</li>
						<ol>
							<li>enqueue(queue, array[i])</li>
						</ol>
					</ol>
				</ol>
			</ol>
			<p>
				This is where the <var>availableSpace()</var> operation comes in
				handy. If the size passed as an argument is greater than the amount
				of available space, no enqueuing is performed.
			</p>
			<div class="demo">
				<button>C</button>
				<div class="implementation">
					<p>Below is an implementation in C:</p>
					<pre class="language-c"><code>
						#include &lt;stdlib.h&gt;
						#include &lt;stdio.h&gt;
						#include &lt;stdbool.h&gt;
						
						<details><summary>struct Queue </summary>{
							int capacity;
							int height;
							int rear;
							int* Q; 
						};</details>
						<details><summary>struct Queue* newQueue(int maxSize) </summary>{
							struct Queue* queue = malloc(sizeof(struct Queue));
							(*queue).capacity = maxSize;
							(*queue).height = 0;
							(*queue).rear = -1;
							(*queue).Q = malloc(sizeof(int) * maxSize);
							return queue;
						}</details>
						<details><summary>bool isFull(struct Queue* queue) </summary>{
							return (*queue).height == (*queue).capacity;
						}</details>
						<details><summary>bool isEmpty(struct Queue* queue) </summary>{
							return (*queue).height == 0;
						}</details>
						<details><summary>int availableSpace(struct Queue* queue) </summary>{
							return (*queue).capacity - (*queue).height;
						}</details>
						<details><summary>void enqueue(struct Queue* queue, int data) </summary>{
							if (isFull(queue)) {
								printf("Enqueue prohibitied: Queue is full.\n");
							} else {
								(*queue).rear++;
								(*queue).Q[(*queue).rear] = data;
								(*queue).height++;
							}
						}</details>

						void rushIn(struct Queue* queue, int dataArray[], int dataArraySize) {
							if (dataArraySize > availableSpace(queue)) {
								printf("Insufficient space to rush into queue.\n");
							}
							else if (dataArraySize < 0) {
								printf("Invalid array size: Negative number.\n");
							} 
							else {
								for (int i = 0; i < dataArraySize; i++) {
									enqueue(queue, dataArray[i]);
								}
							}
						}
					</code></pre>
				</div>
			</div>
		</section>
	</section>

	<section id="dequeue">
		<h3>Dequeuing an RP Bounded Queue</h3>
		<p>
			Where the RP and FRP approaches differ is with the
			<var>dequeue()</var> operation. With just a single pointer to rear
			&mdash; the RP approach &mdash; we must <i>left shift</i> the array's
			elements. This is because dequeuing with an array implementation
			effectively means removing the element at index ${0.}$ If performed
			no left shift, then we'd have a gap in the array, we and we do not
			want that. The RP implementation is thus:
		</p>
		<ol class="alg">
			<li>fn dequeue(Queue* queue) -> void:</li>
			<ol>
				<li>if (isEmpty(queue)):</li>
				<ol>
					<li>println "Nothing to dequeue: Queue is empty.";</li>
				</ol>
				<li>else:</li>
				<ol>
					<li>for (int i = 0; i < (*queue).height; i++):</li>
					<ol>
						<li>(*queue).Q[i] = (*queue).Q[i+1];</li>
					</ol>
					<li>(*queue).rear--;</li>
					<li>(*queue).height--;</li>
				</ol>
			</ol>
		</ol>
		<p>
			With the RP approach, dequeuing requires iterating over the array,
			shifting the elements to the left. This takes ${O(n)}$ time. For such
			a simple data structure like the queue, this is generally not
			desired. For most applications, we instead want the FRP approach:
			have two pointers, one for <var>front</var> and the other for
			<var>rear</var>.
		</p>
		<div class="demo">
			<button>C</button>
			<div class="implementation">
				<p>
					Here's an implementation of the <var>dequeue()</var> function for
					an RP bounded queue:
				</p>
				<pre class="language-c"><code>
					void dequeue(struct Queue* queue) {
						if (isEmpty(queue)) {
							printf("Nothing to dequeue: Queue is empty.\n");
						} else {
							for (int i = 0; i < (*queue).height; i++) {
								(*queue).Q[i] = (*queue).Q[i+1];
							}
							(*queue).rear--;
							(*queue).height--;
						}
					}
				</code></pre>
				<p>Testing this function:</p>
				<pre class="language-c"><code>
					#include &lt;stdlib.h&gt;
					#include &lt;stdio.h&gt;
					#include &lt;stdbool.h&gt;
					<details><summary>struct Queue </summary>{
						int capacity;
						int height;
						int rear;
						int* Q; 
					};</details>
					<details><summary>struct Queue* newQueue(int maxSize) </summary>{
						struct Queue* queue = malloc(sizeof(struct Queue));
						(*queue).capacity = maxSize;
						(*queue).height = 0;
						(*queue).rear = -1;
						(*queue).Q = malloc(sizeof(int) * maxSize);
						return queue;
					}</details>
					<details><summary>bool isFull(struct Queue* queue) </summary>{
						return (*queue).height == (*queue).capacity;
					}</details>
					<details><summary>bool isEmpty(struct Queue* queue) </summary>{
						return (*queue).height == 0;
					}</details>
					<details><summary>int availableSpace(struct Queue* queue) </summary>{
						return (*queue).capacity - (*queue).height;
					}</details>
					<details><summary>void enqueue(struct Queue* queue, int data) </summary>{
						if (isFull(queue)) {
							printf("Enqueue prohibitied: Queue is full.\n");
						} else {
							(*queue).rear++;
							(*queue).Q[(*queue).rear] = data;
							(*queue).height++;
						}
					}</details>
					<details><summary>void dequeue(struct Queue* queue) </summary>{
						if (isEmpty(queue)) {
							printf("Nothing to dequeue: Queue is empty.\n");
						} else {
							for (int i = 0; i < (*queue).height; i++) {
								(*queue).Q[i] = (*queue).Q[i+1];
							}
							(*queue).rear--;
							(*queue).height--;
						}
					}</details>
					<details><summary>void rushIn(struct Queue* queue, int dataArray[], int dataArraySize) </summary>{
						if (dataArraySize > availableSpace(queue)) {
							printf("Insufficient space to rush into queue.\n");
						}
						else if (dataArraySize < 0) {
							printf("Invalid array size: Negative number.\n");
						} 
						else {
							for (int i = 0; i < dataArraySize; i++) {
								enqueue(queue, dataArray[i]);
							}
						}
					}</details>
					<details><summary>void printQueue(struct Queue* queue) </summary>{
						struct Queue* p = queue;
						if (isEmpty(queue)) {
							printf("Empty queue.\n");
						} else {
							printf("|");
							for (int i = 0; i < (*queue).height; i++) {
								printf(" %d |", (*p).Q[i]);
							}
							printf("\n");
						}
					}</details>
					int main() {
						const int size = 3;
						int arr[] = {1,2,3};
						struct Queue* queue = newQueue(size);
						rushIn(queue, arr, 3);
						printQueue(queue);
						dequeue(queue);
						printQueue(queue);
						return 0;
					}
				</code></pre>
				<pre class="language-bash"><code>
					| 1 | 2 | 3 |
					| 2 | 3 |
				</code></pre>
			</div>
		</div>
	</section>
</section>

<section id="frp_bounded_queue">
	<h2>Single-use FRP Bounded Queue</h2>
	<p>
		With the FRP bounded queue, we have two pointers, <var>rear</var> and
		<var>front</var>:
	</p>
	<ol class="alg">
		<li>struct Queue:</li>
		<ol>
			<li>int capacity;</li>
			<li>int length;</li>
			<li>int rear;</li>
			<li>int front;</li>
			<li>{T}* Q;</li>
			<li>Queue(int size):</li>
			<ol>
				<li>capacity = size;</li>
				<li>length = 0;</li>
				<li>rear = -1;</li>
				<li>front = -1;</li>
				<li>Q = allocate(sizeof({T}) * size)</li>
			</ol>
		</ol>
	</ol>
	<p>
		To see why two pointers is useful, let's consider an example. Suppose
		we had the following queue, alongside its array implementation:
	</p>
	<div class="split">
		<div id="frpArray"></div>
		<div id="frpQueue"></div>
	</div>
	<p>
		There are two pointers, <var>r</var> (the <var>rear</var>) and
		<var>f</var> (the <var>front</var>). The pointer <var>f</var> is not
		displayed because initially, <var>f = -1</var>. Now let's say the first
		queuer is dequeued:
	</p>
	<div class="split">
		<div id="frpArrayDequeue0"></div>
		<div id="frpQueueDequeue0"></div>
	</div>
	<p>
		As we saw with the RP queue, dequeuing results in an empty space at the
		front of the queue. And with the RP queue, the remedy for this is to
		shift all of the elements to the left, filling the newly emptied
		position, much like how people in a line shift forward.
	</p>
	<p>
		With people, this is not that big of a deal. A small step forward
		miniscule. For computers, however, having so many queuers perform an
		operation is inefficient. Is there a more efficient way to do this? It
		turns out yes. Instead of having everyone in line at the bank shift
		towards the teller, just have the teller shift towards the next
		customer:
	</p>
	<div class="split">
		<div id="frpArrayDequeue1"></div>
		<div id="frpQueueDequeue1"></div>
	</div>
	<p>
		Examining the diagram, we see that the <var>f</var> queuer will always
		be <var>Q[f+1]</var>. For example, say we start with an empty queue of
		capacity ${4:}$
	</p>
	<div class="split">
		<div id="frpArray1_0"></div>
		<div id="frpQueue1_0"></div>
	</div>
	<p>Now say we rush-in two queuers, ${5}$ and ${8:}$</p>
	<div class="split">
		<div id="frpArray1_1"></div>
		<div id="frpQueue1_1"></div>
	</div>
	<p>
		At no point in the rush-in do we increment <var>f</var>, which is
		initially <var>f = -1</var>. The pointer <var>f</var> is incremented
		only if we dequeue. As such, the front element is still
		<var>Q[f+1]</var>, which in this case, is <var>Q[0]</var>.
	</p>
	<p>When we dequeue, <var>f</var> increments:</p>
	<div class="split">
		<div id="frpArray1_2"></div>
		<div id="frpQueue1_2"></div>
	</div>
	<p>When we enqueue say, the new queuers ${2}$ and ${9,}$ we get:</p>
	<div class="split">
		<div id="frpArray1_3"></div>
		<div id="frpQueue1_3"></div>
	</div>
	<p>Implementing the <var>dequeue()</var> procedure:</p>
	<ol class="alg">
		<li>fn dequeue(Queue* queue) -> void:</li>
		<ol>
			<li>if (isEmpty(queue)):</li>
			<ol>
				<li>println "Nothing to dequeue: Queue is empty.";</li>
			</ol>
			<li>else:</li>
			<ol>
				<li>(*queue).front++;</li>
				<li>(*queue).height--;</li>
			</ol>
		</ol>
	</ol>
	<p>
		Examining the procedure above, we see that the algorithm consists
		entirely of basic steps &mdash; ${O(1)}$ time. Compare this with the RP
		bounded queue, where it took ${O(n)}$ time to dequeue elements.
	</p>

	<p>
		At this point, we might have a lot of questions. How does this impact
		all of the other operations? What about the gaps? Didn't the RP bounded
		queue employ a left-shift in the first place because of gaps in the
		array implementation? These are all fair questions, and we address them
		carefully in turn.
	</p>

	<section id="is_empty">
		<h3>Empty Guard</h3>
		<p>
			The first question we should address is the empty guard; answers to
			the other questions will build on the answer to this first question.
			What condition should we test for when the FRP bounded queue is
			empty? Well, let's consider an example.
		</p>
		<p>
			Suppose we have the following queue and its array implementation:
		</p>
		<div class="split">
			<div id="frpArray2_0"></div>
			<div id="frpQueue2_0"></div>
		</div>
		<ol class="alg">
			<li>f = 0;</li>
			<li>r = 3</li>
		</ol>
		<p>As we can see, we've already dequeued once. If we dequeue again:</p>
		<div class="split">
			<div id="frpArray2_1"></div>
			<div id="frpQueue2_1"></div>
		</div>
		<ol class="alg">
			<li>f = 1;</li>
			<li>r = 3</li>
		</ol>
		<p>And again:</p>
		<div class="split">
			<div id="frpArray2_2"></div>
			<div id="frpQueue2_2"></div>
		</div>
		<ol class="alg">
			<li>f = 2;</li>
			<li>r = 3</li>
		</ol>
		<p>And dequeuing one more time:</p>
		<div class="split">
			<div id="frpArray2_3"></div>
			<div id="frpQueue2_3"></div>
		</div>
		<ol class="alg">
			<li>f = 3;</li>
			<li>r = 3</li>
		</ol>
		<p>Then, dequeuing one last time:</p>
		<div class="split">
			<div id="frpArray2_4"></div>
			<div id="frpQueue2_4"></div>
		</div>
		<p></p>
		<ol class="alg">
			<li>fn isEmpty(*Queue queue) -> bool:</li>
			<ol>
				<li>return (*queue).front == (*queue).rear;</li>
			</ol>
		</ol>
		<p>
			Note that this is all a matter of interpretation. In a language like
			C, the data is more than likely still inside the array. But even if
			it was, it's essentially lost, because the only way we can interact
			with the queue is through the front and rear pointers.
		</p>
	</section>

	<section id="full_guard">
		<h3>Capacity Guard</h3>
		<p>For the capacity guard, we will use the following function:</p>
		<ol class="alg">
			<li>fn isFull(*Queue queue) -> bool:</li>
			<ol>
				<li>return (*queue).r == capacity - 1;</li>
			</ol>
		</ol>
		<p>
			This corresponds to the fact that if <var>rear</var> equals the last
			index in the array, we've reached capacity.
		</p>
	</section>

	<section id="enqueue">
		<h3>Enqueue</h3>
		<p>For enqueuing a queuer, we use the following procedure:</p>
		<ol class="alg">
			<li>fn enqueue(Queue* queue, {T} data):</li>
			<ol>
				<li>if (isFull(*queue)):</li>
				<ol>
					<li>print "Queue is full"</li>
				</ol>
				<li>else:</li>
				<ol>
					<li>(*queue).rear++;</li>
					<li>(*queue).Q[(*queue).rear] = data;</li>
				</ol>
			</ol>
		</ol>
		<p>
			Examining this procedure, we see that the dequeue procedure runs in
			constant time &mdash; ${O(1).}$
		</p>
	</section>

	<section id="dequeue">
		<h3>Dequeue</h3>
		<p>For dequeuing a queuer, we use the following procedure:</p>
		<ol class="alg">
			<li>fn dequeue(Queue* queue) -> {T}:</li>
			<ol>
				<li>int x = -1;</li>
				<li>if (isEmpty(*queue)):</li>
				<ol>
					<li>print "Nothing to dequeue; queue is empty."</li>
				</ol>
				<li>else:</li>
				<ol>
					<li>(*queue).front++;</li>
					<li>x = (*queue).Q[(*queue).front];</li>
				</ol>
				<li>return x;</li>
			</ol>
		</ol>
		<p>
			Examining this procedure, we see that the dequeue procedure runs in
			constant time &mdash; ${O(1).}$
		</p>
	</section>

	<section id="frp_costs">
		<h3>Single-use FRP Drawbacks</h3>
		<p>
			If we thought about FRPs carefully, we might have noticed a few
			drawbacks. Suppose we had the following queue:
		</p>
		<div id="frp_problem_0"></div>
		<p>If we dequeue twice, we get:</p>
		<div id="frp_problem_1"></div>
		<p>
			Because of the way we've implemented <var>isFull()</var> and
			<var>isEmpty()</var>, we cannot reuse the space previously occupied
			by the dequeued queuer. If dequeued all of the elements:
		</p>
		<div id="frp_problem_2"></div>
		<p>
			and executed <var>isEmpty()</var>, we would get back <var>true</var>,
			since <var>front > rear</var>. Given this restriction, we call such
			FRPs <b>single-use FRP-bounded queues</b>. While single-use FRPs are
			useful for certain problems, most problems would be better served by
			reusing the freed spaces. To do so, we must use either: a
			<i>Resetting FRP</i> or a <i>circular queue.</i>
		</p>
	</section>
</section>

<section id="multi-use_frp">
	<h2>Resetting FRPs</h2>
	<p>
		A <b>multi-use FRP</b> is an FRP that reuses a dequeued element's newly
		available space. The multi-use FRP's implementation is, for the most
		part, the same as the single-use FRP, but with
		<b>pointer resetting</b>.
	</p>
	<p>
		The solution is simple: The moment <var>isEmpty()</var> returns
		<var>true</var>, re-initialize <var>front</var> and <var>rear</var> to
		<var>-1</var>. For example, consider the following queue:
	</p>
	<div id="multi_use_frp1"></div>
	<p>If we dequeued all of the elements:</p>
	<div id="multi_use_frp2"></div>
	<p>
		we immediately reset the pointers <var>front</var> and
		<var>rear</var> to <var>-1</var>:
	</p>
	<div id="multi_use_frp3"></div>
	<p>
		This allows us to reuse the dequeued element's spaces. Accordinly,
		implementing the resetting FRP is just a matter of writing a new
		function called <var>reset</var>:
	</p>
	<ol class="alg">
		<li>fn reset(Queue* queue) -> void:</li>
		<ol>
			<li>if (isEmpty(*queue)):</li>
			<ol>
				<li>(*queue).front = -1;</li>
				<li>(*queue).rear = -1;</li>
			</ol>
			<li>else:</li>
			<ol>
				<li>print "Cannot reset; queue is not empty."</li>
			</ol>
		</ol>
	</ol>
	<p>
		The problem, however, is that there's a catch: We can only reuse the
		dequeued spaces only if the array is empty. This means that in the
		situation:
	</p>
	<div id="multi_use_frp4"></div>
	<p>
		We cannot use the dequeued space, because the queue is not empty.
		Because of this limitation, we want to a <b>circular queue</b>.
	</p>
</section>

<section id="circular_queue">
	<h2>Circular Queues</h2>
	<p>
		Circular queues are the solution to the problems posed by single-use
		FRPs and resetting FRPs. First, instead of starting
		<var>front</var> and <var>rear</var> at <var>-1</var>, we start them at
		<var>0</var>. For example, suppose we had a queue with a capacity of
		${6:}$
	</p>
	<div id="circ1"></div>
	<p>
		Say we enqueue the value <var>1</var>. So the rear pointer
		<var>r</var> increments, and initializes the value <var>1</var> at
		index ${1:}$
	</p>
	<div id="circ2"></div>
	<p>
		The index that <var>f</var> points to, ${0}$ in this case, must be left
		empty. Wherever <var>f</var> is pointing, that location must be left
		empty. Let's say we filled the rest of queue spaces:
	</p>
	<div id="circ3"></div>
	<p>Now let's say we dequeue two queuers:</p>
	<div id="circ4"></div>
	<p>
		and we want to enqueue the element <var>2</var>. For single-use FRPs
		and resetting FRPs, we saw that we cannot enqueue here. For circular
		queues, however, we definitely can: Move <var>r</var> back to
		<var>0</var>, and enqueue:
	</p>
	<div id="circ5"></div>
	<p>
		At this point, the queue is <em>full</em>. Remember, we cannot use the
		space <var>f</var> points to. If we allow <var>r</var> to point at this
		space, then both <var>f</var> and <var>r</var> are equal. And if both
		<var>f</var> and <var>r</var> are equal, then the queue is empty.
	</p>
	<p>
		To insert the element <var>7</var>, we simply increment
		<var>r</var> and enqueue:
	</p>
	<div id="circ6"></div>
	<p>
		Let's consider another example, this time visualizing the circular
		queue. We visualize the circular queue
	</p>
	<div id="circular_queue_linear"></div>
	<p>as:</p>
	<div id="circular_queue1"></div>
	<p>
		Thinking of the circular queue in this way, it's more apparent what we
		have to do to bring <var>r</var> back to the first index ${0}$ once
		it's reached the last index &mdash; through the modulus operator.
		Consider the table of values, where ${r}$ is the value of
		<var>rear</var>, and <var>s</var> is the circular queue's capacity:
	</p>
	<table class="alg">
		<thead>
			<th>${r}$</th>
			<th>${(r + 1) \bmod s}$</th>
		</thead>
		<tbody>
			<tr>
				<td>${0}$</td>
				<td>${1 \bmod 5 = 1}$</td>
			</tr>
			<tr>
				<td>${1}$</td>
				<td>${2 \bmod 5 = 2}$</td>
			</tr>
			<tr>
				<td>${2}$</td>
				<td>${3 \bmod 5 = 3}$</td>
			</tr>
			<tr>
				<td>${3}$</td>
				<td>${4 \bmod 5 = 4}$</td>
			</tr>
			<tr>
				<td>${4}$</td>
				<td>${5 \bmod 5 = 0}$</td>
			</tr>
			<tr>
				<td>${0}$</td>
				<td>${1 \bmod 5 = 1}$</td>
			</tr>
			<tr>
				<td>${1}$</td>
				<td>${2 \bmod 5 = 2}$</td>
			</tr>
			<tr>
				<td>${2}$</td>
				<td>${3 \bmod 5 = 3}$</td>
			</tr>
			<tr>
				<td>${3}$</td>
				<td>${4 \bmod 5 = 4}$</td>
			</tr>
			<tr>
				<td>${4}$</td>
				<td>${5 \bmod 5 = 0}$</td>
			</tr>
		</tbody>
	</table>
	<p>
		Notice how we're going back to ${0}$ once we've reached the inex ${4.}$
		This is precisely what we want.
	</p>
	<section id="empty_guard">
		<h3>Circular Queue: Capacity Guard</h3>
		<p>
			Following our previous analysis, the circular queue's capacity guard
			is implemented as such:
		</p>
		<ol class="alg">
			<li>fn isFull(Queue* q) -> bool:</li>
			<ol>
				<li>rear = (*q).rear + 1;</li>
				<li>front = (*q).front;</li>
				<li>max = (*q).capacity;</li>
				<li>return rear % max == front;</li>
			</ol>
		</ol>
		<p>
			Examining this procedure, we see that <var>isFull()</var> takes
			${O(1)}$ time to execute.
		</p>
	</section>

	<section id="empty_guard">
		<h3>Circular Queue: Empty Guard</h3>
		<p>The empty guard is no different from the FRP's empty guard:</p>
		<ol class="alg">
			<li>fn isEmpty(Queue* q) -> bool:</li>
			<ol>
				<li>return (*queue).front == (*queue).rear;</li>
			</ol>
		</ol>
		<p>Needless to say, this function takes ${O(1)}$ time to execute.</p>
	</section>

	<section id="enqueue">
		<h3>Circular Queue: Enqueue</h3>
		<p>To enqueue into a circular queue, we use the following:</p>
		<ol class="alg">
			<li>fn enqueue(Queue* queue, {T} data) -> void:</li>
			<ol>
				<li>if isFull(*queue):</li>
				<ol>
					<li>print "Queue is full, enqueue prohibited."</li>
				</ol>
				<li>else:</li>
				<ol>
					<li>(*queue).rear = ((*queue).rear + 1) % (*queue).size;</li>
					<li>(*queue).Q[(*queue).rear] = data;</li>
				</ol>
			</ol>
		</ol>
		<p>
			Again, this procedure has a time complexity of ${O(1).}$ Thus, the
			circular queue's <var>enqueue()</var> procedure runs in constant
			time.
		</p>
	</section>

	<section id="dequeue">
		<h3>Circular Queue: Dequeue</h3>
		<p>The circular queue's dequeue operation appears as such:</p>
		<ol class="alg">
			<li>fn dequeue(Queue* queue) -> {T}:</li>
			<ol>
				<li>{T} data = NULL;</li>
				<li>if (isEmpty(queue)):</li>
				<ol>
					<li>printf "Queue is empty, dequeue prohibited."</li>
				</ol>
				<li>else:</li>
				<ol>
					<li>(*queue).front = ((*queue).front + 1) % (*queue).size;</li>
					<li>data = (*queue).Q[(*queue).front];</li>
				</ol>
				<li>return data;</li>
			</ol>
		</ol>
		<p>
			This procedure has a time complexity of ${O(1)}$ &mdash; constant
			time.
		</p>
	</section>
</section>

<section id="linked_list_implementation">
	<h2>Linked List Queues</h2>
	<p>
		Queues implemented with linked lists are called <b>linked queues</b>.
		Recall that the queue is a first-in-first-out data structure. As such,
		we must account for this characteristic when implementing a linked
		queue.
	</p>
	<p>Consider the following queue:</p>
	<div id="linked_queue_intro"></div>
	<p>Implementing this as a linked list, we have:</p>
	<div id="linked_queue_intro_LL"></div>
	<p>
		Initially, the front pointer <var>f</var> and the rear pointer
		<var>r</var> should be <var>NULL</var>. Thus, when we create the first
		node for the queue above, we create the node with a pointer
		<var>t</var>, then have the pointers <var>f</var> and
		<var>r</var> point to this new node:
	</p>
	<div id="linked_queue_intro_LL_1"></div>
	<p>
		Once we have the first node established, we can begin queuing and
		dequeuing.
	</p>

	<section id="empty_guard">
		<h3>Empty Guard</h3>
		<p>For the linked list queue, the empty guard is as follows:</p>
		<ol class="alg">
			<li>fn isEmpty(*Queue queue) -> bool:</li>
			<ol>
				<li>return (*queue).front == NULL;</li>
			</ol>
		</ol>
		<p>
			Notice that we're simply testing if <var>front</var> is
			<var>NULL</var>. If it is, then we can conclude that the queue is
			empty.
		</p>
	</section>

	<section id="capacity_guard">
		<h3>Capacity Guard</h3>
		<p>The capacity guard looks like:</p>
		<ol class="alg">
			<li>fn isFull(Node* n) -> bool:</li>
			<ol>
				<li>return n == NULL;</li>
			</ol>
		</ol>
		<p>
			Notice that we're testing if a particular node pointer is the null
			pointer. We do so because with linked lists, we can dequeue and
			enqueue (nodes) as much as we want, so long as the pointer returned
			from allocating space is not null. If it is null, then we've run out
			of heap memory &mdash; i.e., the queue is full.
		</p>
	</section>

	<section id="enqueue">
		<h3>Enqueue</h3>
		<p>The enqueue procedure:</p>
		<ol class="alg">
			<li>fn enqueue(Queue* queue, {T} data) -> void:</li>
			<ol>
				<li>Node *t = new Node;</li>
				<li>if (isFull(t)):</li>
				<ol>
					<li>print "Queue is full."</li>
				</ol>
				<li>else:</li>
				<ol>
					<li>(*t).data = data;</li>
					<li>if ((*queue).front == NULL):</li>
					<ol>
						<li>(*queue).front = rear = t;</li>
					</ol>
					<li>else:</li>
					<ol>
						<li>(*queue).rear->next = t;</li>
						<li>(*queue).rear = t;</li>
					</ol>
				</ol>
			</ol>
		</ol>
	</section>

	<section id="dequeue">
		<h3>Dequeue</h3>
		<p>The dequeue procedure appears as follows:</p>
		<ol class="alg">
			<li>{T} dequeue(struct Queue* queue):</li>
			<ol>
				<li>{T} datum = MIN_INT;</li>
				<li>Node* p;</li>
				<ol>
					<li>if (isEmpty(queue)):</li>
					<ol>
						<li>print "Nothing to dequeue; returning MIN_INT";</li>
					</ol>
					<li>else:</li>
					<ol>
						<li>p = (*queue).front</li>
						<li>(*queue).front = (*(*queue).front).next;</li>
						<li>datum = (*p).data;</li>
						<li>free(p);</li>
					</ol>
				</ol>
				<li>return datum;</li>
			</ol>
		</ol>
		<p>
			In this implementation, we return the data bound to the dequeued
			queuer. And as with many of the other procedures, this procedure has
			a time complexity of ${O(1)}$ &mdash; constant time.
		</p>
	</section>
</section>

<section id="DEqueue">
	<h2>Deque</h2>
	<p>
		The <b>double-ended queue</b> (appreviated <b>deque</b>, pronounced
		<i>deck</i>), is a queue where insertion and deletion can be done on
		both the front- and rear-ends of the queue.
	</p>
	<p>
		For FRPs, circular queues, and linked-list queues, we've used both
		front and rear pointers. Moreover, to enqueue we've used the rear
		pointer, and to dequeue we've used the rear pointer exclusively. I.e.,
		we can only insert and remove queuers from the front of the queue. For
		the deque, however, we can enqueue and dequeue from both ends of the
		queue.
	</p>
	<div class="split">
		<table class="alg">
			<tr>
				<td><b>Queue</b></td>
				<td>insert</td>
				<td>delete</td>
			</tr>
			<tr>
				<td><var>front</var></td>
				<td>${\color{indianred} \times}$</td>
				<td>${\color{green} \checkmark}$</td>
			</tr>
			<tr>
				<td><var>rear</var></td>
				<td>${\color{green} \checkmark}$</td>
				<td>${\color{indianred} \times}$</td>
			</tr>
		</table>
		<table class="alg">
			<tr>
				<td><b>Deque</b></td>
				<td>insert</td>
				<td>delete</td>
			</tr>
			<tr>
				<td><var>front</var></td>
				<td>${\color{green} \checkmark}$</td>
				<td>${\color{green} \checkmark}$</td>
			</tr>
			<tr>
				<td><var>rear</var></td>
				<td>${\color{green} \checkmark}$</td>
				<td>${\color{green} \checkmark}$</td>
			</tr>
		</table>
	</div>
	<p>
		Because of this trait, deques are much more like a deck of cards than
		they are a line of queuers &mdash; it's easy to take one card off
		either end of the deck, but harder to extract an individual card from
		the deck's center.
	</p>
	<p>For example, suppose we had the following deque:</p>
	<div id="deque_intro"></div>
	<p>
		Initially, both <var>f</var> (the front pointer) and <var>r</var> (the
		rear pointer), are <var>-1</var>. Let's insert the dequer
		<var>3</var> with the rear pointer:
	</p>
	<div id="deque_intro1"></div>
	<p>Let's insert three more dequers:</p>
	<div id="deque_intro2"></div>
	<p>Now let's delete a dequer using the front pointer:</p>
	<div id="deque_intro_delete1"></div>
	<p>Deleting once more with the front pointer:</p>
	<div id="deque_intro_delete2"></div>
	<p>
		So far, this doesn't look all that different from what we've seen with
		queues. So what's the difference? We can insert a new dequer with the
		front pointer. We simply use the front pointer to assign the new
		dequer, followed by a decrement of the front pointer's value. Say we
		wanted to insert the dequer <var>3</var>:
	</p>
	<div id="deque_intro_front_insert"></div>
	<p>We can insert once more:</p>
	<div id="deque_intro_front_insert1"></div>
	<p>
		At this point, the front pointer <var>f</var> is <var>-1</var>, and we
		use that as a condition indicating that we cannot insert towards the
		<var>front</var> any further.
	</p>
</section>

<section id="input_restricted_deques">
	<h2>Input-restricted Deques</h2>
	<p>
		The <b>input-restricted deque (indeque)</b> is a deque where insertion
		can only be done with the rear, but deletion may be done on both the
		front- and rear-ends.
	</p>
</section>

<section id="output_restricted_deques">
	<h2>Output-restricted Deques</h2>
	<p>
		The <b>output-restricted deque (outdeque)</b> is a deque where deletion
		can only be done with the front, but insertion may be done on both the
		front- and rear-ends.
	</p>
</section>

<section id="priority_queues">
	<h2>Priority Queues</h2>
	<p>
		A <b>priority queue</b> is a queue with priority constraints for
		enqueuing and dequeuing. There are two ways to implement these priority
		contraints:
	</p>
	<ol>
		<li>Establishing a priority criteria, or</li>
		<li>assigning priority to particular elements.</li>
	</ol>
	<p>For example, consider the following priority queue:</p>
	<div id="priority_queue_intro"></div>
	<p>
		In the priority queue above, ${3}$ corresponds to the lowest priority,
		and ${1}$ corresponds to the highest priority. To implement the
		priority queue above, we use arrays (or linked lists) corresponding to
		each priority.
	</p>
	<table class="priorityQueue">
		<tr>
			<td>P1</td>
			<td>A</td>
			<td>B</td>
			<td>F</td>
		</tr>
		<tr>
			<td>P2</td>
			<td>C</td>
			<td>E</td>
			<td></td>
		</tr>
		<tr>
			<td>Priority3</td>
			<td>D</td>
			<td></td>
			<td></td>
		</tr>
	</table>
</section>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script src="../../../static/numerc/queue.js"></script>
<script type="module" src="../../../static/numerc/CDemo.mjs"></script>
<script
	type="module"
	src="../../../static/numerc/scripts/cpp_queue.js"
></script>
{% endblock %}
