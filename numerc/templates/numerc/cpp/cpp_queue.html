{% extends '../layout.html' %} {% load static %} {% block description %}
<meta name="description" content="Notes on the queue data structure." />
{% endblock %} {% block title %}
<title>Queue</title>
{% endblock %} {% block content %}
<h1>The Queue</h1>
<section id="intro">
	<p>
		In this section, we discuss the <b>queue</b> data structure. Like the
		stack, the queue is a logical data structure premised on an
		foundational operating principle &mdash;
		<b>first-in-first-out (FIFO)</b>. For example, in the diagram below,
		suppose <var>A</var> enters first, then <var>B</var>, then
		<var>C</var>, then <var>D</var>:
	</p>
	<div id="queueIntro"></div>
	<p>
		The first to exit is <var>A</var>. The second is <var>B</var>. The
		third is <var>C</var>. And the fourth is <var>D</var>. We call the
		entities in a queue &mdash; e.g., <var>A</var>, <var>B</var>,
		<var>C</var>, and <var>D</var> above &mdash; <b>queuers</b> or
		<b>elements</b>. The name <i>queue</i> is fitting &mdash; it's like
		standing in a line at the bank, waiting for the next available teller.
	</p>
	<p>
		The queue has two special positions, the <b>front</b> (denoted below as
		<var>f</var>), and the <b>rear</b> (denoted below as <var>r</var>).
	</p>
	<div id="queueFrontRear"></div>
	<p>
		Consistent with a queue in real life, to delete a queuer from the
		queue, we remove the element currently occupying the <i>front</i>:
	</p>
	<div id="queueDequeue"></div>
	<p>
		And to insert a queuer into the queue, we append an element to the
		<i>rear:</i>
	</p>
	<div id="queueEnqueue"></div>
	<p>
		By convention, inserting a queuer is called
		<b>enqueue</b>, and removing a queuer is called <b>dequeue</b>.
	</p>
</section>

<section id="implementations">
	<h2>Implementations</h2>
	<p>
		Like we saw with the stack, there are two kinds of queues: the
		<b>bounded queue</b>, implemented with a <i>static array</i>, and the
		<b>unbounded queue</b>, implemented with a <i>linked list</i>. We
		consider each below.
	</p>
	<p>
		For both bounded queues and unbounded queues, we want the following
		properties and operations:
	</p>
	<ol>
		<li>
			A <var><mark>length</mark></var> property, representing the current
			number of queuers in the queue.
		</li>
		<li>
			An <var><mark>isEmpty()</mark></var> operation, returning
			<var>true</var> if the queue contains no queuers and
			<var>false</var> if it does.
		</li>
		<li>
			An <var><mark>enqueue()</mark></var> operation, for inserting a
			queuer.
		</li>
		<li>
			A <var><mark>dequeue()</mark></var> operation, for removing a queuer.
		</li>
		<li>
			A <var><mark>peek()</mark></var> operation, for retrieving the value
			a queuer holds.
		</li>
	</ol>
</section>

<section id="static_queue">
	<h2>RP Bounded Queue</h2>
	<p>
		Implementing the bounded queue with an array is simple. In the diagram
		below, the static array implementation is presented to the right, and
		the bounded queue is presented to the left.
	</p>
	<div class="split">
		<ol class="array">
			<li>
				<ul>
					<li>2</li>
					<li>0</li>
				</ul>
			</li>
			<li>
				<ul>
					<li>3</li>
					<li>1</li>
				</ul>
			</li>
			<li>
				<ul>
					<li>7</li>
					<li>2</li>
				</ul>
			</li>
			<li>
				<ul>
					<li>5</li>
					<li>3</li>
				</ul>
			</li>
		</ol>
		<div id="staticQueue1"></div>
	</div>
	<p>
		With the static queue, we implement all of the properties mentioned in
		the preceding section, with two additional properties and operations:
	</p>
	<ol>
		<li>
			A <var><mark>capacity</mark></var> property, representing the maximum
			number of queuers the queue can hold.
		</li>
		<li>
			A <var><mark>availableSpace()</mark></var> operation, which returns
			how much available space there is in the queue.
		</li>
		<li>
			An <var><mark>isFull()</mark></var> operation, returning
			<var>true</var> if the queue's capacity has been reached; otherwise
			<var>false</var>.
		</li>
	</ol>
	<p>
		To implement the properties and operations above, we must first answer
		the following question:
	</p>
	<dfn>
		<p>
			Do we want one pointer for the queue's rear, or two pointers, one for
			the front and one for the rear?
		</p>
	</dfn>
	<p>
		Generally, with bounded queues, we want two pointers. But, there may be
		situations where a single pointer to the rear suffices. For
		conciseness, we call the single pointer implementation the
		<b>rear-pointed (RP) queue</b>, and the two pointer approach the
		<b>front-rear-pointed (FRP) queue</b>. We consider both in tandem.
	</p>
	<p>
		For both the RP approach and the FRP approach, an implementation in C
		can be done with a <var>struct</var>. Below is the RP implementation.
	</p>
	<pre class="language-c"><code>
		struct Queue {
			int capacity;
			int length;
			int rear;
			int* Q;
		}
	</code></pre>
	<p>
		Above, we see the properties examined earlier. The
		<var>int</var> pointer <var>Q</var> is a pointer to an array in the
		heap, which is the data structure implementing the bounded queue.
	</p>
	<p>
		<span class="topic">Constructor.</span> Below is a the RP bounded
		approach's implementation in C:
	</p>
	<pre class="language-c"><code>
		struct Queue* newQueue(int maxSize) {
			struct Queue* queue = malloc(sizeof(struct Queue));
			(*queue).capacity = maxSize;
			(*queue).length = 0;
			(*queue).rear = -1;
			(*queue).Q = malloc(sizeof(int) * maxSize);
			return queue;
		}
	</code></pre>
	<p>
		This is not that different from what we saw with stacks. With the
		constructor in place, we can now consider the various properties and
		methods.
	</p>

	<p>
		<span class="topic">Destructor.</span> For languages without automatic
		memory management like C and C++, we'll also want a destructor:
	</p>
	<pre class="language-c"><code>
		void freeQueue(struct Queue** queue) {
			free((*(*queue)).Q);
			free(*queue);
			*queue = NULL;
		}
	</code></pre>

	<section id="is_full">
		<h3>Capacity Guard</h3>
		<p>
			Because the bounded queue has maximum number of queuers it can store,
			we need a capacity guard for the other operations to use. Using the C
			code as a base for our pseudocode examples, a capacity guard might
			look like the following:
		</p>
		<ol class="alg">
			<li>fn isFull(Queue* queue) -> bool:</li>
			<ol>
				<li>return (*queue).length == (*queue).capacity;</li>
			</ol>
		</ol>
		<p>
			The implementation relies on the queue's properties
			<var>length</var> and capacity. If the queue's length equals its
			capacity, the queue has reached its limit, and we can't enqueue any
			further.
		</p>
		<div class="demo">
			<button>C</button>
			<div class="implementation">
				<p>
					Here's an implementation in C. Note that this relies on the
					<var>stdbool.h</var> header file.
				</p>
				<pre class="language-c"><code>
					bool isFull(struct Queue* queue) {
						return (*queue).height == (*queue).capacity;
					}
				</code></pre>
			</div>
		</div>
	</section>

	<section id="is_empty">
		<h3>Empty Guard</h3>
		<p>
			Alongside the capacity guard, we also want an <i>empty guard</i>.
			This allows us ensure we aren't dequeuing an empty queue:
		</p>
		<ol class="alg">
			<li>fn isEmpty(Queue* queue) -> bool:</li>
			<ol>
				<li>return (*queue).length == 0;</li>
			</ol>
		</ol>
		<p>
			Like the capacity guard, the empty guard relies on the queue's
			<var>length</var> property to determine if the queue is empty. If the
			queue's length is ${0,}$ then we know that the queue is empty and we
			should be trying to perform operations like dequeuing.
		</p>
		<div class="demo">
			<button>C</button>
			<div class="implementation">
				<p>
					Here's an implementation in C. Again, this relies on the
					<var>stdbool.h</var> header file. Of course, we can just return
					<var>0</var> for false and <var>1</var> for true. We use the
					<var>stdbool.h</var> header file purely for readability and
					semantics.
				</p>
				<pre class="language-c"><code>
					bool isEmpty(struct Queue* queue) {
						return (*queue).height == 0;
					}
				</code></pre>
			</div>
		</div>
	</section>

	<section id="space_available">
		<h3>Space Count</h3>
		<p>
			This isn't a necessary operation for bounded queues, but it's a
			nice-to-have. The <var>availableSpace()</var> operation returns how
			many spots in the queue we have left for use:
		</p>
		<ol class="alg">
			<li>fn spaceAvailable(Queue* queue) -> int:</li>
			<ol>
				<li>return (*queue).capacity - (*queue).height;</li>
			</ol>
		</ol>
		<p>
			The procedure is simple: Compute the difference between the queue's
			capacity and the current height.
		</p>
		<p>
			With these basic operations and properties implemented, we can now
			consider the core operations for the bounded queue,
			<var><mark>enqueue()</mark></var> and
			<var><mark>dequeue()</mark></var
			>.
		</p>
		<div class="demo">
			<button>C</button>
			<div class="implementation">
				<p>
					Here's an implementation in C. Not all that different from the
					pseudocode:
				</p>
				<pre class="language-c"><code>
					int availableSpace(struct Queue* queue) {
						return (*queue).capacity - (*queue).height;
					}
				</code></pre>
			</div>
		</div>
	</section>

	<section id="enqueue">
		<h3>Enqueuing an RP Bounded Queue</h3>
		<p>
			To enqueue with the bounded queue, we must first have a pointer
			<var>r</var>, corresponding to the queue's rear. Initially,
			<var>r = -1</var>. To insert a new element into the queue &mdash;
			enqueue &mdash; we move <var>r</var> to the next location (i.e.,
			increment <var>r</var>).
		</p>
		<p>For example, suppose we had a static queue of size 5:</p>
		<div class="split">
			<ol class="array">
				<li>
					<ul>
						<li>&ThickSpace;</li>
						<li>0</li>
					</ul>
				</li>
				<li>
					<ul>
						<li>&ThickSpace;</li>
						<li>1</li>
					</ul>
				</li>
				<li>
					<ul>
						<li>&ThickSpace;</li>
						<li>2</li>
					</ul>
				</li>
				<li>
					<ul>
						<li>&ThickSpace;</li>
						<li>3</li>
					</ul>
				</li>
				<li>
					<ul>
						<li>&ThickSpace;</li>
						<li>4</li>
					</ul>
				</li>
			</ol>
			<div id="staticQueueInsert"></div>
		</div>
		<p>
			We begin by moving the pointer <var>r</var> to the first index in the
			array:
		</p>
		<div class="split">
			<ol class="array">
				<li>
					<ul>
						<li>&ThickSpace;</li>
						<li>0</li>
						<li>r</li>
					</ul>
				</li>
				<li>
					<ul>
						<li>&ThickSpace;</li>
						<li>1</li>
					</ul>
				</li>
				<li>
					<ul>
						<li>&ThickSpace;</li>
						<li>2</li>
					</ul>
				</li>
				<li>
					<ul>
						<li>&ThickSpace;</li>
						<li>3</li>
					</ul>
				</li>
				<li>
					<ul>
						<li>&ThickSpace;</li>
						<li>4</li>
					</ul>
				</li>
			</ol>
			<div id="staticQueueInsert"></div>
		</div>
		<p>Then, we insert the relevant data, say <var>2</var>:</p>
		<div class="split">
			<ol class="array">
				<li>
					<ul>
						<li>2</li>
						<li>0</li>
						<li>r</li>
					</ul>
				</li>
				<li>
					<ul>
						<li>&ThickSpace;</li>
						<li>1</li>
					</ul>
				</li>
				<li>
					<ul>
						<li>&ThickSpace;</li>
						<li>2</li>
					</ul>
				</li>
				<li>
					<ul>
						<li>&ThickSpace;</li>
						<li>3</li>
					</ul>
				</li>
				<li>
					<ul>
						<li>&ThickSpace;</li>
						<li>4</li>
					</ul>
				</li>
			</ol>
			<div id="staticQueueInsert1"></div>
		</div>
		<p>
			If we want to add another element, we just increment <var>r</var> and
			continue. In pseudocode:
		</p>
		<ol class="alg">
			<li>fn enqueue(Queue* queue) -> void:</li>
			<ol>
				<li>if (isFull(queue)):</li>
				<ol>
					<li>printf("Enqueue prohibited: Queue is full.")</li>
				</ol>
				<li>else:</li>
				<ol>
					<li>(*queue).rear++;</li>
					<li>(*queue).Q[ (*queue).rear ] = data;</li>
					<li>(*queue).height++;</li>
				</ol>
			</ol>
		</ol>
		<p>
			The enqueue procedure is the same for both the RP bounded queue and
			FRP bounded queue. We just need to increment the
			<var>rear</var> pointer, assign the data, and increment the
			<var>height</var> property.
		</p>
		<div class="demo">
			<button>C</button>
			<div class="implementation">
				<p>Below is an implementation in C:</p>
				<pre class="language-c"><code>
					#include &lt;stdlib.h&gt;
					#include &lt;stdio.h&gt;
					#include &lt;stdbool.h&gt;
					
					<details><summary>struct Queue </summary>{
						int capacity;
						int height;
						int rear;
						int* Q; 
					};</details>
					<details><summary>struct Queue* newQueue(int maxSize) </summary>{
						struct Queue* queue = malloc(sizeof(struct Queue));
						(*queue).capacity = maxSize;
						(*queue).height = 0;
						(*queue).rear = -1;
						(*queue).Q = malloc(sizeof(int) * maxSize);
						return queue;
					}</details>
					<details><summary>bool isFull(struct Queue* queue) </summary>{
						return (*queue).height == (*queue).capacity;
					}</details>
					<details><summary>bool isEmpty(struct Queue* queue) </summary>{
						return (*queue).height == 0;
					}</details>
					<details><summary>int availableSpace(struct Queue* queue) </summary>{
						return (*queue).capacity - (*queue).height;
					}</details>

					void enqueue(struct Queue* queue, int data) {
						if (isFull(queue)) {
							printf("Enqueue prohibitied: Queue is full.\n");
						} else {
							(*queue).rear++;
							(*queue).Q[(*queue).rear] = data;
							(*queue).height++;
						}
					}
				</code></pre>
			</div>
		</div>

		<section id="rushing">
			<p>
				<span class="topic">Rush-in.</span> As an aside, a useful operation
				to have with queues is the <b>rush-in</b>. Essentially, enqueuing
				multiple elements into the queue with a loop:
			</p>
			<ol class="alg">
				<li>fn rushIn(Queue* queue, int array[], int arraySize):</li>
				<ol>
					<li>if (arraySize > availableSpace(queue)):</li>
					<ol>
						<li>print "Insufficient space to rush into queue.";</li>
					</ol>
					<li>else if (arraySize < 0):</li>
					<ol>
						<li>print "Invalid array size: Negative number.";</li>
					</ol>
					<li>else:</li>
					<ol>
						<li>for (int i = 0; i < arraySize; i++):</li>
						<ol>
							<li>enqueue(queue, array[i])</li>
						</ol>
					</ol>
				</ol>
			</ol>
			<p>
				This is where the <var>availableSpace()</var> operation comes in
				handy. If the size passed as an argument is greater than the amount
				of available space, no enqueuing is performed.
			</p>
			<div class="demo">
				<button>C</button>
				<div class="implementation">
					<p>Below is an implementation in C:</p>
					<pre class="language-c"><code>
						#include &lt;stdlib.h&gt;
						#include &lt;stdio.h&gt;
						#include &lt;stdbool.h&gt;
						
						<details><summary>struct Queue </summary>{
							int capacity;
							int height;
							int rear;
							int* Q; 
						};</details>
						<details><summary>struct Queue* newQueue(int maxSize) </summary>{
							struct Queue* queue = malloc(sizeof(struct Queue));
							(*queue).capacity = maxSize;
							(*queue).height = 0;
							(*queue).rear = -1;
							(*queue).Q = malloc(sizeof(int) * maxSize);
							return queue;
						}</details>
						<details><summary>bool isFull(struct Queue* queue) </summary>{
							return (*queue).height == (*queue).capacity;
						}</details>
						<details><summary>bool isEmpty(struct Queue* queue) </summary>{
							return (*queue).height == 0;
						}</details>
						<details><summary>int availableSpace(struct Queue* queue) </summary>{
							return (*queue).capacity - (*queue).height;
						}</details>
						<details><summary>void enqueue(struct Queue* queue, int data) </summary>{
							if (isFull(queue)) {
								printf("Enqueue prohibitied: Queue is full.\n");
							} else {
								(*queue).rear++;
								(*queue).Q[(*queue).rear] = data;
								(*queue).height++;
							}
						}</details>

						void rushIn(struct Queue* queue, int dataArray[], int dataArraySize) {
							if (dataArraySize > availableSpace(queue)) {
								printf("Insufficient space to rush into queue.\n");
							}
							else if (dataArraySize < 0) {
								printf("Invalid array size: Negative number.\n");
							} 
							else {
								for (int i = 0; i < dataArraySize; i++) {
									enqueue(queue, dataArray[i]);
								}
							}
						}
					</code></pre>
				</div>
			</div>
		</section>
	</section>

	<section id="dequeue">
		<h3>Dequeuing an RP Bounded Queue</h3>
		<p>
			Where the RP and FRP approaches differ is with the
			<var>dequeue()</var> operation. With just a single pointer to rear
			&mdash; the RP approach &mdash; we must <i>left shift</i> the array's
			elements. This is because dequeuing with an array implementation
			effectively means removing the element at index ${0.}$ If performed
			no left shift, then we'd have a gap in the array, we and we do not
			want that. The RP implementation is thus:
		</p>
		<ol class="alg">
			<li>fn dequeue(Queue* queue) -> void:</li>
			<ol>
				<li>if (isEmpty(queue)):</li>
				<ol>
					<li>println "Nothing to dequeue: Queue is empty.";</li>
				</ol>
				<li>else:</li>
				<ol>
					<li>for (int i = 0; i < (*queue).height; i++):</li>
					<ol>
						<li>(*queue).Q[i] = (*queue).Q[i+1];</li>
					</ol>
					<li>(*queue).rear--;</li>
					<li>(*queue).height--;</li>
				</ol>
			</ol>
		</ol>
		<p>
			With the RP approach, dequeuing requires iterating over the array,
			shifting the elements to the left. This takes ${O(n)}$ time. For such
			a simple data structure like the queue, this is generally not
			desired. For most applications, we instead want the FRP approach:
			have two pointers, one for <var>front</var> and the other for
			<var>rear</var>.
		</p>
		<div class="demo">
			<button>C</button>
			<div class="implementation">
				<p>
					Here's an implementation of the <var>dequeue()</var> function for
					an RP bounded queue:
				</p>
				<pre class="language-c"><code>
					void dequeue(struct Queue* queue) {
						if (isEmpty(queue)) {
							printf("Nothing to dequeue: Queue is empty.\n");
						} else {
							for (int i = 0; i < (*queue).height; i++) {
								(*queue).Q[i] = (*queue).Q[i+1];
							}
							(*queue).rear--;
							(*queue).height--;
						}
					}
				</code></pre>
				<p>Testing this function:</p>
				<pre class="language-c"><code>
					#include &lt;stdlib.h&gt;
					#include &lt;stdio.h&gt;
					#include &lt;stdbool.h&gt;
					<details><summary>struct Queue </summary>{
						int capacity;
						int height;
						int rear;
						int* Q; 
					};</details>
					<details><summary>struct Queue* newQueue(int maxSize) </summary>{
						struct Queue* queue = malloc(sizeof(struct Queue));
						(*queue).capacity = maxSize;
						(*queue).height = 0;
						(*queue).rear = -1;
						(*queue).Q = malloc(sizeof(int) * maxSize);
						return queue;
					}</details>
					<details><summary>bool isFull(struct Queue* queue) </summary>{
						return (*queue).height == (*queue).capacity;
					}</details>
					<details><summary>bool isEmpty(struct Queue* queue) </summary>{
						return (*queue).height == 0;
					}</details>
					<details><summary>int availableSpace(struct Queue* queue) </summary>{
						return (*queue).capacity - (*queue).height;
					}</details>
					<details><summary>void enqueue(struct Queue* queue, int data) </summary>{
						if (isFull(queue)) {
							printf("Enqueue prohibitied: Queue is full.\n");
						} else {
							(*queue).rear++;
							(*queue).Q[(*queue).rear] = data;
							(*queue).height++;
						}
					}</details>
					<details><summary>void dequeue(struct Queue* queue) </summary>{
						if (isEmpty(queue)) {
							printf("Nothing to dequeue: Queue is empty.\n");
						} else {
							for (int i = 0; i < (*queue).height; i++) {
								(*queue).Q[i] = (*queue).Q[i+1];
							}
							(*queue).rear--;
							(*queue).height--;
						}
					}</details>
					<details><summary>void rushIn(struct Queue* queue, int dataArray[], int dataArraySize) </summary>{
						if (dataArraySize > availableSpace(queue)) {
							printf("Insufficient space to rush into queue.\n");
						}
						else if (dataArraySize < 0) {
							printf("Invalid array size: Negative number.\n");
						} 
						else {
							for (int i = 0; i < dataArraySize; i++) {
								enqueue(queue, dataArray[i]);
							}
						}
					}</details>
					<details><summary>void printQueue(struct Queue* queue) </summary>{
						struct Queue* p = queue;
						if (isEmpty(queue)) {
							printf("Empty queue.\n");
						} else {
							printf("|");
							for (int i = 0; i < (*queue).height; i++) {
								printf(" %d |", (*p).Q[i]);
							}
							printf("\n");
						}
					}</details>
					int main() {
						const int size = 3;
						int arr[] = {1,2,3};
						struct Queue* queue = newQueue(size);
						rushIn(queue, arr, 3);
						printQueue(queue);
						dequeue(queue);
						printQueue(queue);
						return 0;
					}
				</code></pre>
				<pre class="language-bash"><code>
					| 1 | 2 | 3 |
					| 2 | 3 |
				</code></pre>
			</div>
		</div>
	</section>
</section>

<section id="frp_bounded_queue">
	<h2>FRB Bounded Queue</h2>
	<p>
		With the FRP bounded queue, we have two pointers, <var>rear</var> and
		<var>front</var>:
	</p>
	<ol class="alg">
		<li>class Queue:</li>
		<ol>
			<li>&lt;T&gt; capacity;</li>
			<li>&lt;T&gt; length;</li>
			<li>&lt;T&gt; rear;</li>
			<li>&lt;T&gt; front;</li>
			<li>&lt;T&gt;* Q;</li>
			<li>Queue(&lt;T&gt; size):</li>
			<ol>
				<li>&lt;T&gt; capacity = size;</li>
				<li>&lt;T&gt; length = 0;</li>
				<li>&lt;T&gt; rear = -1;</li>
				<li>&lt;T&gt; front = -1;</li>
				<li>&lt;T&gt;* Q = allocate(sizeof(&lt;T&gt;) * size)</li>
			</ol>
		</ol>
	</ol>
	<p>
		To see why two pointers is useful, let's consider an example. Suppose
		we had the following queue, alongside its array implementation:
	</p>
	<div class="split">
		<div id="frpArray"></div>
		<div id="frpQueue"></div>
	</div>
	<p>
		There are two pointers, <var>r</var> (the <var>rear</var>) and
		<var>f</var> (the <var>front</var>). The pointer <var>f</var> is not
		displayed because initially, <var>f = -1</var>. Now let's say the first
		queuer is dequeued:
	</p>
	<div class="split">
		<div id="frpArrayDequeue0"></div>
		<div id="frpQueueDequeue0"></div>
	</div>
	<p>
		As we saw with the RP queue, dequeuing results in an empty space at the
		front of the queue. And with the RP queue, the remedy for this is shift
		all of the elements to the left, filling up newly emptied position,
		much like how people in a line shift forward.
	</p>
	<p>
		With people, it's not that big of a deal. A small step forward
		miniscule. For computers, however, having so many queuers perform an
		operation is inefficient. Is there a more efficient way to do this? It
		turns out yes. Instead of having everyone in line at the bank shift
		towards the teller, just have the teller shift towards the next
		customer:
	</p>
	<div class="split">
		<div id="frpArrayDequeue1"></div>
		<div id="frpQueueDequeue1"></div>
	</div>
	<p>
		Examining the diagram, we see that the <var>f</var> queuer will always
		be <var>Q[f+1]</var>. For example, say we start with an empty queue of
		capacity ${4:}$
	</p>
	<div class="split">
		<div id="frpArray1_0"></div>
		<div id="frpQueue1_0"></div>
	</div>
	<p>Now say we rush-in two queuers, ${5}$ and ${8:}$</p>
	<div class="split">
		<div id="frpArray1_1"></div>
		<div id="frpQueue1_1"></div>
	</div>
	<p>
		At no point in the rush-in do we increment <var>f</var>, which is
		initially <var>f = -1</var>. The pointer <var>f</var> is incremented
		only if we dequeue. As such, the front element is still
		<var>Q[f+1]</var>, which in this case, is <var>Q[0]</var>.
	</p>
	<p>When we dequeue, <var>f</var> increments:</p>
	<div class="split">
		<div id="frpArray1_2"></div>
		<div id="frpQueue1_2"></div>
	</div>
	<p>When we enqueue say, the new queuers ${2}$ and ${9,}$ we get:</p>
	<div class="split">
		<div id="frpArray1_3"></div>
		<div id="frpQueue1_3"></div>
	</div>
	<p>Implementing the <var>dequeue()</var> procedure:</p>
	<ol class="alg">
		<li>fn dequeue(Queue* queue) -> void:</li>
		<ol>
			<li>if (isEmpty(queue)):</li>
			<ol>
				<li>println "Nothing to dequeue: Queue is empty.";</li>
			</ol>
			<li>else:</li>
			<ol>
				<li>(*queue).front++;</li>
				<li>(*queue).height--;</li>
			</ol>
		</ol>
	</ol>
	<p>
		Examining the procedure above, we see that the algorithm consists
		entirely of basic steps &mdash; ${O(1)}$ time. Compare this with the RP
		bounded queue, where it took ${O(n)}$ time to dequeue elements.
	</p>
	<p>
		At this point, we might have a lot of questions. How does the impact
		all of the other operations? What about the gaps? Didn't the RP bounded
		queue employ a left-shift in the first place because of gaps in the
		array implementation? These are all fair questions, and we now address
		them in turn.
	</p>

	<section id="is_empty">
		<h3>Empty Guard</h3>
		<p>
			The first question we should address is the empty guard; answers to
			the other questions will build on the answer to this first question.
			What condition should we test for when the FRP bounded queue is
			empty? Well, let's consider an example.
		</p>
		<p>
			Suppose we have the following queue and its array implementation:
		</p>
		<div class="split">
			<div id="frpArray2_0"></div>
			<div id="frpQueue2_0"></div>
		</div>
		<ol class="alg">
			<li>f = 0;</li>
			<li>r = 3</li>
		</ol>
		<p>As we can see, we've already dequeued once. If we dequeue again:</p>
		<div class="split">
			<div id="frpArray2_1"></div>
			<div id="frpQueue2_1"></div>
		</div>
		<ol class="alg">
			<li>f = 1;</li>
			<li>r = 3</li>
		</ol>
		<p>And again:</p>
		<div class="split">
			<div id="frpArray2_2"></div>
			<div id="frpQueue2_2"></div>
		</div>
		<ol class="alg">
			<li>f = 2;</li>
			<li>r = 3</li>
		</ol>
	</section>
	<p>And dequeuing one more time:</p>
	<div class="split">
		<div id="frpArray2_3"></div>
		<div id="frpQueue2_3"></div>
	</div>
	<ol class="alg">
		<li>f = 3;</li>
		<li>r = 3</li>
	</ol>
	<p>
		Once we get to the point where <var>f == r</var> (the
		<var>front</var> is the same as the <var>rear</var>), then we conclude
		that the queue is emptied. The implementation:
	</p>
	<ol class="alg">
		<li>fn isEmpty(*Queue queue) -> bool:</li>
		<ol>
			<li>return (*queue).front == (*queue).rear;</li>
		</ol>
	</ol>
	<p>
		Note that this is all a matter of interpretation. In a language like C,
		the data is more than likely still inside the array. But even if it
		was, it's essentially lost, because the only way we can interact with
		the queue is through the front and rear pointers.
	</p>
</section>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script src="../../../static/numerc/queue.js"></script>
<script type="module" src="../../../static/numerc/CDemo.mjs"></script>
<script
	type="module"
	src="../../../static/numerc/scripts/cpp_queue.js"
></script>
{% endblock %}
