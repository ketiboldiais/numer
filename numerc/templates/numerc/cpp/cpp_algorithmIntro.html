{% extends '../layout.html' %} {% load static %} 

{% block description %}
<meta name="description" content="Introduction to C++ algorithms, data structures versus abstract types">
{% endblock %}
{% block title %}
<title>C++ Introduction to Algorithms</title>
{% endblock %}

{% block content %}
<section id="alg_intro">
	<p>
		An <span class="term">algorithm</span> is a solution to a
		<span class="term">computational problem</span>. As a solution, it is a
		sequence of computational steps that consumes a set of
		<span class="term">inputs</span> and produces a set of
		<span class="term">outputs</span>.
	</p>

	<p>
		Because of this definition, the way a problem is stated determines the
		relationship between inputs and outputs. We will use certain notations to
		state problems. For example, if the problem asks, "Sort the numbers into
		non-decreasing order," we would write:
	</p>

	<figure class="math-display">
		<div class="rule">
			<p>${s \coloneqq}$ ${\lang a_1, a_2, \ldots, a_n \rang}$</p>
			<p>
				${f(s) \coloneqq}$ ${\lang a_1', a_2', \ldots, a_n' \rang}$ : ${a_1'
				\leq a_2' \leq \ldots \leq a_n'}$
			</p>
		</div>
	</figure>

	<p>
		In the notation above, we use ${s}$ to denote the input. Of course, we are
		free to use whatever variable we would like. We use ${f(s)}$ to denote the
		output, where ${f}$ is the actual algorithm itself. We can use any other
		variable. For example, ${r}$ and ${t(r),}$ ${g}$ and ${h(g).}$ The symbol
		${\coloneqq}$ reads "defined as," and the colon is read "such that."
		Finally, the brackets ${\lang \ldots \rang}$ indicate a sequence.
	</p>

	<p>
		The problem above is an example of a
		<span class="term">sorting problem</span>. This is a particularly important
		problem in computer science, because numerous algorithms rely on its
		solution (for example, many
		<span class="italicsText">search algorithms</span> assume values are
		sorted).
	</p>

	<p>
		When we write algorithms, we want our algorithms to be
		<span class="italicsText">correct</span>. An algorithm is correct if, and
		only if, it halts at the correct output (in other words, the algorithm stops
		the moment it finds a correct output). An incorrect algorithm is one that
		halts at the incorrect output, or one that never halts.
	</p>

	<p>
		<span class="topic">Performance is currency.</span> At the end of the day,
		we study algorithms because of performance. With efficient and correct
		algorithms, we can obtain other things &mdash; security and features. Some
		programmers prefer Python over C, even if C is so much faster. Why? For a
		variety of reasons &mdash; Python is more readable, more user-friendly, more
		widely used, more abstracted, and so on. The cost, however, is performance.
		Python's memory management algorithms may not be the best approach for our
		problem. Python's garbage collection algorithms may be not how we would like
		our data handled. However, we may be willing to take on those costs because
		we've written well-performing algorithms.
	</p>
</section>

<section id="data_structures_v_abstract_data_types">
	<p>
		<span class="topic">Data Structures v. Abstract Data Types.</span> After
		programming for some time, we might ask, what is the difference between a
		data structure and an abstract data type?
	</p>
	<p>
		A <span class="italicsText">data structure</span> is a collection. It
		contains data, relationships between data, and operations to be applied to
		the data. Data structures are very explicity &mdash; they state exactly what
		and how tasks are performed.
	</p>
	<p>
		In contrast, an <span class="italicsText">abstract data type</span> is
		something that defines a particular datum's behavior from the perspective of
		its user. In creating an abstract data type, we only describe what task must
		be done. We do not explicitly state how that that task should be done.
	</p>
</section>
{% endblock %}
