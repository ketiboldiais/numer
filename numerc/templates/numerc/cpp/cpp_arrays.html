{% extends '../layout.html' %} {% load static %} {% block description %}
<meta name="description" content="Overview of arrays in C++" />
{% endblock %} {% block title %}
<title>C++ Arrays & Vectors</title>
{% endblock %} {% block content %}
<h1>C++ Arrays & Vectors</h1>
<section id="arrays">
	<p>
		Arrays are the simplest data structure. Physically, arrays occupy a
		contiguous region of memory in the computer. We can initialize an array in
		C++ with the following:
	</p>

	<pre class="language-cpp"><code>
		int main() {
			int x[5] = { 1, 2, 3, 4, 5 };
			cout << x << endl;
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		0x7ffeeb1462d0
	</code></pre>

	<p>
		The line above declares a variable <span class="monoText">arr</span>, which
		will store an <span class="monoText">int</span> array of size 10. In other
		words, an array that can <span class="underlineText">only</span> take 10
		values of type <span class="monoText">int</span>.
	</p>
	<p>
		The output we see above is a
		<span class="italicsText">memory address</span>. Specifically, it's the
		memory address for where the array begins. This evidences the fact that an
		array, physically, is a contiguous region in memory.
	</p>
	<p>
		We can access individual elements in the array with square-bracket syntax:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
			
			
		int main() {
			int x[5] = { 1, 2, 3, 4, 5 };
			cout << x[0] << endl;
			cout << x[1] << endl;
			cout << x[2] << endl;
			cout << x[3] << endl;
			cout << x[4] << endl;
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		1
		2
		3
		4
		5
	</code></pre>
	<p>
		Notice that like most other languages, C++ indexes its arrays starting from
		0. This means that if we start a loop at 0 and use ${i}$ as a counter, then
		the last element in the array is ${n-1,}$ where ${n}$ is the size of the
		array. E.g., the size of the array above is 5, but the last element's index
		is 4. This is point where many beginning programmers make mistakes, most
		commonly seen in a
		<span class="italicsText">fence post problem</span> &mdash; going one unit
		beyond the limit. This can lead to frustrating bugs like an out-of-bounds
		error:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		
		int main() {
			int x[5] = { 1, 2, 3, 4, 5 };
			cout << x[5] << endl;
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		main.cpp:7:10: warning: array index 5 is past the end of the array (which contains 5 elements) [-Warray-bounds]
        cout << x[5] << endl;
                ^ ~
		main.cpp:6:2: note: array 'x' declared here
						int x[5] = { 1, 2, 3, 4, 5 };
						^
		1 warning generated.
	</code></pre>

	<p>Let's print out all the elements in the array:</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		
		int main() {
			int x[5] = { 1, 2, 3, 4, 5 };
			size_t LengthOfx = sizeof x / sizeof x[0];
			for (int i = 0; i < LengthOfx; i++) {
				cout << x[i] << endl;
			}
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		1
		2
		3
		4
		5
	</code></pre>
	<p>
		Above, we used the <span class="monoText">sizeof</span> operator to obtain
		the array's length. The <span class="monoText">sizeof</span> operator is a
		built-in operator that returns the number of bytes allocated to a particular
		variable. Thus, when we call <span class="monoText">sizeof x</span>, we are
		asking for the number of bytes for the
		<span class="italicsText">entire</span> array. To obtain the actual length
		of the array, we need to divide that number by the number of bytes for each
		element in the array.
	</p>
	<p>
		Alternatively, starting with C++11, we can use a
		<span class="term">range-based loop</span>:
		<span class="marginnote"
			>The range-based loop is also called a
			<span class="term">for-each loop</span>.</span
		>
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		int main() {
			int x[5] = { 1, 2, 3, 4, 5 };
			cout << "[ ";
			for (auto i : x)
				cout << i << ", ";
			cout << "]" << endl;
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		[ 1, 2, 3, 4, 5, ]
	</code></pre>
	<p>
		Note that the code above was compiled with the following
		<span class="monoText">make</span> file:
	</p>
	<pre class="language-bash"><code>
		CXX=g++
		CXXFLAGS=-g -Wall -MMD -std=c++20
		clean:
			$(RM) *.o *.d output
	</code></pre>
	<p>
		The <span class="monoText">auto</span> keyword is used to infer the type of
		an array. We could've used <span class="monoText">int</span> just as well.
	</p>
</section>

<section id="multidimensional_arrays">
	<h2>Grids; Matrices</h2>
	<p>
		A <span class="term">grid</span>, or <span class="term">matrix</span>, is an
		abstraction of a <span class="term">multidimensional array</span>. A
		multidimensional array is simply an array whose elements are themselves
		arrays. For example, a 2-dimensional array is an array whose elements
		arrays. A 3-dimensional array is an array whose elements are 2-dimensional
		arrays. And a 4-dimensional array is an array whose elements are
		3-dimensional array arrays. We can visualize these multi-dimensional arrays
		as such:
	</p>
	<figure>
		<img
			src="{% static 'images/multi_dimensional_array.svg' %}"
			alt="A 1-dimensional array looks like a row of boxes, a 2-dimensional array looks like a grid of boxes, and a 3-dimensional array looks like a box of boxes."
			loading="lazy"
			class="forty-p"
		/>
	</figure>
	<p>For example, here is a 2-dimensional array:</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		
		int main(int argc, char *argv[]) {
		
			int a[3][3] = &lcub;{0, 1, 2}, {3, 4, 5}, {6, 7, 8}&rcub;;
		
			cout << "i a[i][j]" << endl;
			for (int i = 0; i < 3; i++) {
				for (int j = 0; j < 3; j++) {
					cout << i << " " << a[i][j] << endl;
				}
			}

			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		i a[i][j]
		0 0
		0 1
		0 2
		1 3
		1 4
		1 5
		2 6
		2 7
		2 8
	</code></pre>
	<p>
		Notice how we must use a nested for loop to target each element in the
		nested array.
	</p>
	<p><span class="topic">Pointers & Grids.</span> </p>
</section>

<section id="array_exercises">
	<h3>Exercises</h3>
	<p>
		Because of how important arrays are in computer science, it's critical that
		we are comfortable with using them. Below are some exercises.
	</p>
	<div class="compare">
		<ol>
			<li>
				Given the array:
				<span class="monoText">[3, 9, 11, 23, 14, 10, 34, 18, 27]</span>,
				compute the sum of all the elements.
			</li>
			<details class="answer">
				<summary>Solution</summary>
				<p>Here is one possible solution:</p>
				<pre class="language-cpp"><code>
					#include &lt;iostream&gt;
					using namespace std;
					
					
					int main() {
						int arr[] = { 3, 9, 11, 23, 14, 10, 34, 18, 27 };
						int sum = 0;
						for(int i:arr)
							sum += i;
						cout << (int)sum << endl;
						return 0;
					}
				</code></pre>
				<pre class="language-bash"><code>
					149
				</code></pre>
			</details>
			<li>Given the same array above, return the maximum.</li>
			<details class="answer">
				<summary>Solution</summary>
				<pre class="language-cpp"><code>
					#include &lt;iostream&gt;
					using namespace std;
					
					
					int main() {
						int arr[] = { 3, 9, 11, 23, 14, 10, 34, 18, 27 };
						size_t LengthOfArr = sizeof(arr) / sizeof(arr[0]);
						int max = arr[0];
						for (int i = 0; i < LengthOfArr; i++) {
							if (arr[i] > max) {
								max = arr[i];
							}
						}
						cout << (int)max << endl;
						return 0;
					}
				</code></pre>
				<pre class="language-bash"><code>
					34
				</code></pre>
			</details>
			<li>Given the same array, return the minimum.</li>
			<details class="answer">
				<summary>Solution</summary>
				<pre class="language-cpp"><code>
						#include &lt;iostream&gt;
						using namespace std;
						
						
						int main() {
							int arr[] = { 3, 9, 11, 23, 14, 10, 34, 18, 27 };
							size_t LengthOfArr = sizeof(arr) / sizeof(arr[0]);
							int max = arr[0];
							for (int i = 0; i < LengthOfArr; i++) {
								if (arr[i] < max) {
									max = arr[i];
								}
							}
							cout << (int)max << endl;
							return 0;
						}
					</code></pre>
				<pre class="language-bash"><code>
						3
					</code></pre>
			</details>
			<li>
				Given the array above, determine (i.e., return true, or 1) if the
				element 67 is in the array; otherwise false (0).
			</li>
			<details class="answer">
				<summary>Solution</summary>
				<pre class="language-cpp"><code>
					#include &lt;iostream&gt;
					using namespace std;
					
					
					int main() {
						int arr[] = { 3, 9, 11, 23, 14, 10, 34, 18, 27 };
						size_t LengthOfArr = sizeof(arr) / sizeof(arr[0]);
						int queryElement = 67;
						bool result = false;
						for (int i = 0; i < LengthOfArr; i++)
						{
							if (arr[i] == queryElement) {
								result = true;
							}
						}
						cout << result << endl;
						return 0;
					}
				</code></pre>
				<pre class="language-bash"><code>
					0
				</code></pre>
			</details>
		</ol>
	</div>
	<p>
		The last exercise above is an example of a
		<span class="term">linear search</span> algorithm. We are searching for a
		particular element. Given very large arrays, we can suspect that this is a
		grossly inefficient algorithm. Why? Because the computer must check, one by
		one, whether the value exists. In this case, the number 67 doesn't exist in
		the array. The computer had to go through all of the elements to make that
		determination!
	</p>
</section>

<section id="vectors">
	<h2>Vectors</h2>
	<p>
		As we can likely tell, arrays in C++ are restrictive and somewhat dangerous.
		They are examples of
		<span class="italicsText">static lists</span> &mdash; an indexed list of
		elements with a <span class="underlineText">fixed</span> size. We cannot
		delete elements, nor can we insert elements (at least not without the use of
		pointers). We can resize them, but it's a long and unwieldy process. Perhaps
		worst of all, C++ allows us to index out of the array's bounds. Contrast
		this with a language like Python, which provides
		<span class="italicsText">dynamic lists</span> &mdash; lists that can grow
		and shrink as needed. For most tasks involving an array-based data
		structure, that's what we want &mdash; a dynamic list.
	</p>
	<p>
		Through the standard library, C++ provides dynamic lists. Where Python
		simply calls them a list, C++ opts for <span class="term">vectors</span>. To
		use vectors in our program, we will have to use a preprocessor:
		<span class="monoText">#include &lt;vector&gt;. Example:</span>
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		#include &lt;vector&gt;
		using namespace std;
		
		int main() {
			vector&lt;int&gt; arrNums {22, 48, 92, 44};
			cout << arrNums[1] << endl;
			arrNums[1] = 14;
			cout << arrNums[1] << endl;
		}
	</code></pre>
	<pre class="language-bash"><code>
		48
		14
	</code></pre>
	<p>
		Notice that we can using the usual indexing methods. More importantly, we
		can mutate the array. Vectors in C++ also come with a variety of member
		functions. Some of the most common ones:
	</p>
	<figure class="table">
		<table class="truth_table">
			<thead>
				<th style="text-align: center">Member Function</th>
				<th style="text-align: center">Description</th>
				<th style="text-align: center">Comment</th>
			</thead>
			<tbody>
				<tr>
					<td><span class="monoText">${v}$.push_back(${val}$)</span></td>
					<td>Appends the value ${val}$ to the end of the vector ${v.}$</td>
					<td></td>
				</tr>
				<tr>
					<td><span class="monoText">${v}$.clear()</span></td>
					<td>Removes all elements in the vector ${v.}$</td>
					<td></td>
				</tr>
				<tr>
					<td><span class="monoText">${v}$[${i}$]</span></td>
					<td>Returns the value at index ${i}$</td>
					<td>
						Alternative syntax: <span class="monoText">${v}$.get(${i}$)</span>
					</td>
				</tr>
				<tr>
					<td><span class="monoText">${v}$.insert(${i}$, ${val}$)</span></td>
					<td>Inserts the element ${val}$ just before index ${i}$</td>
					<td>Operation shifts the subsequent elements to the right.</td>
				</tr>
				<tr>
					<td><span class="monoText">${v}$.empty()</span></td>
					<td>Returns true if ${v}$ contains no elements; else false.</td>
					<td></td>
				</tr>
				<tr>
					<td><span class="monoText">${v}$.erase(${i}$)</span></td>
					<td>
						Removes <span class="underlineText">and</span> returns the value at
						index ${i.}$
					</td>
					<td>Operation shifts subsequent elements to the left.</td>
				</tr>
				<tr>
					<td><span class="monoText">${v}$[${i}$] = ${val}$</span></td>
					<td>Replaces the element at index ${i}$ with the value ${val.}$</td>
					<td>
						Alternative syntax:
						<span class="monoText">${v}$.assign(${i}$, ${val}$)</span>
					</td>
				</tr>
				<tr>
					<td><span class="monoText">${v}$.size()</span></td>
					<td>Returns the number of elements in the vector.</td>
					<td></td>
				</tr>
			</tbody>
		</table>
	</figure>
	<p>
		Vectors in C++ are implemented via templates.<label
			for="vectorTemplates"
			class="margin-toggle"
			><sup></sup
		></label>
		<input
			type="checkbox"
			id="vectorTemplates"
			class="margin-toggle sidenote-number"
		/>
		<span class="marginnote"
			>For more information on templates,
			<a href="{% url 'numerc:cpp_templates' %}"
				><i>See</i> Metaprogramming: Templates</a
			>.</span
		>
		Accordingly, we can create vectors with elements of any established type, so
		long as we specify it in the angle brackets. E.g.,
		<span class="monoText">vector&lt;double&gt;</span>, or
		<span class="monoText">vector&lt;std::string&gt;</span>.
	</p>
	<p>
		<span class="topic">When should we use a vector?</span> The vector type
		represents an indexed, linear, and homogenous collection. Accordingly, we
		want to use a vector whenever we're dealing with a homogenous list. For
		example, a list of prices, names, an order of true or false values, or even
		an ordered list of ordered lists (although, we'll see that we might want to
		use a better data structure for lists of the lists, the
		<span class="italicsText">grid</span>).
	</p>
	<p>
		Vectors are useful because they provide several features: (1) We can obtain
		the list's size; (2) we can safely access the list (i.e., if we go out of
		bounds, we'll get an error); (3) storage is automatically handled (i.e., it
		grows and shrinks without us having to do anything); (4) we can insert and
		remove; and (5) we can produce deep-copies on assignment, as well as pass-
		and return-by-value.
	</p>
</section>

<section id="grids">
	<h2>Grids</h2>
	<p></p>
</section>

{% endblock %}
