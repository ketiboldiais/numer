{% extends '../layout.html' %} {% load static %} {% block description %}
<meta
	name="description"
	content="How to perform complexity analysis: An overview of Big O notation, theta notation, omega notation, time complexity, and space complexity."
/>
<meta name="author" content="Ketib Oldiais" />
<meta
	name="keywords"
	content="complexity analysis, C++, Big O notation, theta notation, omega notation, time complexity, space complexity, complexity analysis exercises"
/>
{% endblock %} {% block title %}
<title>Complexity Analysis</title>
{% endblock %} {% block content %}
<h1>Complexity Analysis: The Analysis of Algorithms</h1>
<section id="intro">
	<p>
		<span class="drop">T</span>his section provides a general overview of
		algorithmic analysis in programming terms. We present the motivating
		question, its answer, as well as illustrations of the answer applied. The
		materials that follow assume a basic understanding of functions, limits,
		sequences, and series (i.e., comfort with ideas from a basic calculus and
		discrete mathematics course).
	</p>
	<p>
		One concern for analyzing algorithms is
		<span class="italicsText">efficiency</span>. While this is the most common
		concern, it is second to another &mdash;
		<span class="italicsText">correctness</span>. If an algorithm is incorrect,
		its efficiency is unimportant.<label for="unimpt" class="margin-toggle"
			><sup></sup
		></label>
		<input type="checkbox" id="unimpt" class="margin-toggle sidenote-number" />
		<span class="marginnote"
			>For the most part. In later sections, we will see how analyzing the
			efficiency of an incorrect algorithm can lead to insight elsewhere.</span
		>
		In these materials, we suppose that we've gotten over the correctness
		hurdle, and focus on efficiency.
	</p>
	<p>
		The most common procedure for analyzing algorithms is determining the amount
		of <span class="italicsText">time</span> an algorithm takes to execute. In
		essence, how long it takes a given algorithm to solve a particular problem.
		To do so, however, we need some agreed-upon method for quantifying time. We
		can't rely on units like seconds, because every machine is different.
		Solving some differential equation on a small mobile phone will be slower
		than running the same search on a super computer. Although it may be useful
		to know how fast the search runs on one device over another, it's not the
		principal concern in the analysis of algorithms. The search algorithm is the
		same for both the small mobile and the super computer. What we want to know
		is how the algorithm compares to another search algorithm,
		<span class="italicsText">regardless of device</span>.
	</p>
	<p>
		Occasionally, analyzing algorithms requires determining the amount of
		<span class="italicsText">space</span> an algorithm takes to execute. For
		example, one algorithm ${A}$ might be faster than algorithm ${B}$ but
		requires a significant amount of memory. Determining space complexity can
		often be immensely. Perhaps algorithms ${C}$ and ${D}$ take the same amount
		of time, but ${C}$ consumes less memory.
	</p>
	<p>
		So how do we determine the amount of time or space an algorithm takes? The
		first step is to count the number of operations performed as a function of
		${n,}$ where ${n}$ is the number of input values. In these first few
		sections, we will count the exact number of operations. However, as we
		progress, we will learn that we rarely count every operation. Some
		operations are counted, others ignored.
	</p>
</section>

<section id="exercises">
	<h2 class="pset">Exercises</h2>
	<p>Compute the Big-O complexity of the algorithms below.</p>
	<ol class="ex grid" data-colcade="columns: .grid-col, items: .grid-item">
		<div class="grid-col grid-col--1"></div>
		<div class="grid-col grid-col--2"></div>
		<div class="grid-col grid-col--3"></div>
		<div class="grid-col grid-col--4"></div>

		<li class="grid-item">
			<pre class="language-cpp"><code>
				int main() {
					int n = 10; // n could be any number
					int sum = 0;
					float pi = 3.14;

					for (int i = 1; i < n; i += 3) {
						cout << pi << endl;
						for (int j = 1; j < n; j+= 2) {
							sum += 1;
							cout << sum << endl;
						}
					}
				}
			 </code></pre>
			<details class="answer">
				<summary>Solution</summary>
				<p>We can determine the number of operations by way of a table:</p>
				<table class="alg">
					<thead>
						<th>Statement</th>
						<th>Number of Executions</th>
						<th>Comment</th>
					</thead>
					<tbody>
						<tr>
							<td><span class="monoText">int n = 10;</span></td>
							<td>1</td>
							<td></td>
						</tr>
						<tr>
							<td><span class="monoText">int sum = 0;</span></td>
							<td>1</td>
							<td></td>
						</tr>
						<tr>
							<td><span class="monoText">float pie = 3.14;</span></td>
							<td>1</td>
							<td></td>
						</tr>
						<tr>
							<td><span class="monoText">int i = 1;</span></td>
							<td>1</td>
							<td></td>
						</tr>
						<tr>
							<td><span class="monoText">i < n;</span></td>
							<td>${\left\lfloor \dfrac{n}{3} \right\rfloor + 1}$</td>
							<td>
								The test condition is checked after each iteration. Thus, it's
								checked at iteration ${1,}$ then iteration ${1+3=4,}$ then
								${4+3=7,}$ then ${7+3=10}$ &mdash; a total of ${4}$ executions.
							</td>
						</tr>
						<tr>
							<td><span class="monoText">i += 3;</span></td>
							<td>${\left\lfloor \dfrac{n}{3} \right\rfloor}$</td>
							<td>
								The increment is performed only if the test condition is true.
								Thus, starting at ${i = 1,}$ the first increment occurs: ${i = 1
								+ 3 = 4.}$ At ${i = 4,}$ the second increment occurs: ${i = 4 +
								3 = 7.}$ At ${i = 7,}$ the third increment occurs: ${i = 7 + 3 =
								10.}$ After the third increment, ${i \nless 10,}$ so no further
								increments are made.
							</td>
						</tr>
						<tr>
							<td><span class="monoText">cout << pi << endl;</span></td>
							<td>${\left\lfloor \dfrac{n}{3} \right\rfloor}$</td>
							<td>
								Like the increment, the print line occurs only if the outer
								for-loop's test condition is true. Thus, there are three
								executions.
							</td>
						</tr>
						<tr>
							<td><span class="monoText">int j = 1;</span></td>
							<td>${\left\lfloor \dfrac{n}{3} \right\rfloor}$</td>
							<td>
								Like the print line, the initializer for the inner for-loop
								occurs only if the outer for-loop's test condition is true.
								Thus, this initialization executes three times.
							</td>
						</tr>
						<tr>
							<td><span class="monoText">j < n;</span></td>
							<td>
								${\left\lfloor \dfrac{n}{3} \right\rfloor \left( \left\lfloor
								\dfrac{n}{2} \right\rfloor + 1 \right)}$
							</td>
							<td>
								The test condition for inner for-loop is checked after each
								iteration. Thus, it's checked at iteration ${1,}$ then at
								iteration ${1 + 2 = 3,}$ then ${3 + 2 = 5,}$ then ${5 + 2 = 7,}$
								then ${7 + 2 = 9,}$ then ${9 + 2 = 11.}$ This is a total of
								${6}$ iterations. Because the inner for-loop executes at each
								iteration of the outer for-loop, we multiply the number of
								iterations of the inner for-loop by the number of iterations for
								the outer-for loop.
							</td>
						</tr>
						<tr>
							<td><span class="monoText">j += 2;</span></td>
							<td>
								${\left\lfloor \dfrac{n}{3} \right\rfloor \left( \left\lfloor
								\dfrac{n}{2} \right\rfloor \right)}$
							</td>
							<td>
								The increment occurs only if the test condition is true. Thus,
								we have an increment after ${j = 1,}$ then another increment
								after ${j = 3,}$ another after ${j = 5,}$ another after ${j =
								7,}$ and the last one after ${j = 9.}$ This is a total of ${5}$
								increments, which translates to the number of times the inner
								for-loop's body is executed. We multiply this number by the
								number of times the outer for-loop's body is executed.
							</td>
						</tr>
						<tr>
							<td><span class="monoText">sum += 1;</span></td>
							<td>
								${\left\lfloor \dfrac{n}{3} \right\rfloor \left( \left\lfloor
								\dfrac{n}{2} \right\rfloor \right)}$
							</td>
							<td>
								This assignment executes the number of times the inner
								for-loop's body is executed &mdash; ${5.}$ We then multiply this
								number by the number of times the outer for-loop's body is
								executed.
							</td>
						</tr>
						<tr>
							<td><span class="monoText">cout << sum << endl;</span></td>
							<td>
								${\left\lfloor \dfrac{n}{3} \right\rfloor \left( \left\lfloor
								\dfrac{n}{2} \right\rfloor \right)}$
							</td>
							<td>
								The print line executes the number of times the inner for-loop's
								body is executed, which is ${5.}$ We again multiply this number
								by the number of times the outer for-loop's body is executed.
							</td>
						</tr>
					</tbody>
				</table>
				<p>
					The running time complexity is the sum of all the execution times
					above:
				</p>
				<figure>
					<div>
						<p>
							$\small 1 + 1 + 1 + 1 + \dfrac{n}{3} + 1 + \dfrac{n}{3} +
							\dfrac{n}{3} + \dfrac{n}{3}\left( \dfrac{n}{2} + 1 \right) +
							\left( \dfrac{n}{3} \right)\left( \dfrac{n}{2} \right) + \left(
							\dfrac{n}{3} \right)\left( \dfrac{n}{2} \right) + \left(
							\dfrac{n}{3} \right)\left( \dfrac{n}{2} \right)$
						</p>
					</div>
				</figure>
				<p>Simplifying (where ${S}$ is the sum above):</p>
				<figure>
					<div>
						$$ \begin{aligned} S &= 5 + \dfrac{5n}{3} + \dfrac{4n^2}{6} \\[1em]
						&= 5 + \dfrac{5n}{3} + \dfrac{2n^2}{3} \\[1em] &= \dfrac{2n^2 + 5n +
						15}{3} \end{aligned} $$
					</div>
				</figure>
				<p>
					To find the Big O complexity, we drop the leading constants: ${2, 5,
					15, \dfrac{1}{3}.}$ This leaves us with ${n + n^2.}$ And then we drop
					the lower order terms, in this case, ${n.}$ This leaves us with
					${n^2.}$ Thus, the time complexity for the program above is
					${O(n^2).}$
				</p>
			</details>
		</li>

		<li class="grid-item">
			<pre class="language-cpp"><code>
				int main() {
					int n = 10; // n could be any number
					int sum = 0;
					float pi = 3.14;

					for (int i = n; i >= 1; i -= 3) {
						cout << pi << endl;
						for (int j = n; j >= 0; j--) {
							sum += 1;
						}
					}
					cout << sum << endl;
				}
			</code></pre>
			<details class="answer" open>
				<summary>Solution</summary>
				<table class="alg">
					<thead>
						<th>Statement</th>
						<th>Number of Executions</th>
						<th>Comment</th>
					</thead>
					<tbody>
						<tr>
							<td><span class="monoText">int n = 10;</span></td>
							<td>1</td>
							<td rowspan="4">
								These are basic steps. They execute exactly once.
							</td>
						</tr>
						<tr>
							<td><span class="monoText">int sum = 0;</span></td>
							<td>1</td>
						</tr>
						<tr>
							<td><span class="monoText">float pi = 3.14</span></td>
							<td>1</td>
						</tr>
						<tr>
							<td><span class="monoText">int i = n;</span></td>
							<td>1</td>
						</tr>
						<tr>
							<td><span class="monoText">i >= 1</span></td>
							<td>${\left\lceil \dfrac{n}{3} \right\rceil + 1}$</td>
							<td>
								Where ${n = 10,}$ the condition is evaluated ${5}$ times (it is
								true ${\left\lceil \dfrac{n}{3} \right\rceil}$ times and false
								once).
							</td>
						</tr>
						<tr>
							<td><span class="monoText">i -= 3</span></td>
							<td>${\left\lceil \dfrac{n}{3} \right\rceil}$</td>
							<td>
								The decrement is performed only if the test condition is true.
								Thus, we have a decrement after ${i = 10,}$ after ${i = 7,}$
								after ${i = 3,}$ and finally after ${i = 1.}$ This yields a
								total of ${4}$ decrements, corresponding to the expression
								${\left\lceil \dfrac{n}{3} \right\rceil.}$ This is effectively
								the number of times the loop executes.
							</td>
						</tr>
						<tr>
							<td><span class="monoText">cout << pi << endl;</span></td>
							<td>${\left\lceil \dfrac{n}{3} \right\rceil}$</td>
							<td>
								The print line is performed only if the test condition is true,
								which corresponds to the number of times the decrement operation
								executes, which in turn corresponds to the number of times the
								body of the loop executes.
							</td>
						</tr>
					</tbody>
				</table>
			</details>
		</li>
	</ol>
</section>

{% endblock %}
