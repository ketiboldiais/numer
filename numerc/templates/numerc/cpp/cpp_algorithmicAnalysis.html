{% extends '../layout.html' %} {% load static %} {% block description %}
<meta
	name="description"
	content="Algorithmic Analysis: An overview of Big O notation, theta notation, omega notation, time complexity, and space complexity."
/>
{% endblock %} {% block title %}
<title>Analysis of Algorithms</title>
{% endblock %} {% block content %}
<h1>Analysis of Algorithms</h1>
<section id="intro">
	<p>
		<span class="drop">T</span>his section provides a general overview of
		algorithmic analysis in programming terms. We present the motivating
		question, its answer, as well as illustrations of the answer applied. The
		materials that follow assume a basic understanding of functions, limits,
		sequences, and series (i.e., comfort with ideas from a basic calculus and
		discrete mathematics course).
	</p>
	<p>
		One concern for analyzing algorithms is
		<span class="italicsText">efficiency</span>. While this is the most common
		concern, it is second to another &mdash;
		<span class="italicsText">correctness</span>. If an algorithm is incorrect,
		its efficiency is unimportant.<label for="unimpt" class="margin-toggle"
			><sup></sup
		></label>
		<input type="checkbox" id="unimpt" class="margin-toggle sidenote-number" />
		<span class="marginnote"
			>For the most part. In later sections, we will see how analyzing the
			efficiency of an incorrect algorithm can lead to insight elsewhere.</span
		>
		In these materials, we suppose that we've gotten over the correctness
		hurdle, and focus on efficiency.
	</p>
	<p>
		The most common procedure for analyzing algorithms is determining the amount
		of <span class="italicsText">time</span> an algorithm takes to execute. In
		essence, how long it takes a given algorithm to solve a particular problem.
		To do so, however, we need some agreed-upon method for quantifying time. We
		can't rely on units like seconds, because every machine is different.
		Solving some differential equation on a small mobile phone will be slower
		than running the same search on a super computer. Although it may be useful
		to know how fast the search runs on one device over another, it's not the
		principal concern in the analysis of algorithms. The search algorithm is the
		same for both the small mobile and the super computer. What we want to know
		is how the algorithm compares to another search algorithm,
		<span class="italicsText">regardless of device</span>.
	</p>
	<p>
		Occasionally, analyzing algorithms requires determining the amount of
		<span class="italicsText">space</span> an algorithm takes to execute. For
		example, one algorithm ${A}$ might be faster than algorithm ${B}$ but
		requires a significant amount of memory. Determining space complexity can
		often be immensely. Perhaps algorithms ${C}$ and ${D}$ take the same amount
		of time, but ${C}$ consumes less memory.
	</p>
	<p>
		So how do we determine the amount of time or space an algorithm takes? The
		first step is to count the number of operations performed as a function of
		${n,}$ where ${n}$ is the number of input values. In these first few
		sections, we will count the exact number of operations. However, as we
		progress, we will learn that we rarely count every operation. Some
		operations are counted, others ignored.
	</p>
</section>

{% endblock %}
