{% extends '../layout.html' %} {% load static %} {% block description %}
<meta name="description" content="Notes on algorithms for strings." />
{% endblock %} {% block title %}
<title>String Algorithms</title>
{% endblock %} {% block content %}
<h1>Algorithms for Strings</h1>
<section id="intro">
	<p>
		<span class="drop">I</span>n this section, we present several useful
		algorithms for strings. As we know, a
		<span class="term">character set</span> is the set of character codes a
		language can process. Because computers only understand zeroes and ones,
		each character in the set is assigned an integer value, which can be
		represented in zeroes and ones. This process is called
		<span class="term">encoding</span> &mdash; transforming information from one
		format into another.
	</p>
	<p>
		In the early days of computing, the only characters necessary for
		computation were unaccented English characters (along with constructs like
		the linefeed, bell, and whitespace). All of these symbols &mdash; ${128}$ in
		total &mdash; formed the character set
		<span class="boldText">ASCII</span> (American Standard Code for Information
		Interchange).
	</p>
	<p>
		Because there were ${128}$ ASCII characters, the integers from ${0}$ to
		${127}$ were used to represent each character. Because the highest possible
		integer representation is ${127}$ &mdash; in binary, ${111~1111_{[2]}}$
		&mdash; seven bits were sufficient for representing all ${128}$ characters.
		However, by the time ASCII was developed, the smallest possible unit in
		computer memory a user could reference was a byte (eight bits). Accordingly,
		ASCII characters &mdash; in C and C++, a
		<span class="monoText">char</span> value &mdash; take up 1 byte of memory.
		Because of this allocation, ASCII's users and developers found themselves
		with an additional bit. And with eight bits, the integers ${128}$ to ${255}$
		were available for mapping &mdash; users now had access to ${256}$ possible
		characters.
	</p>
	<p>
		The result was a lost-in-translation situation of painful magnitude.
		Governments, companies, independent developers, and users were coming up
		with their own ways of using the extra bit (i.e., the other 128 available
		integers). Documents, code, and data sent from one entity to the next could
		not be read because of conflicting standards. One user used
		<span class="monoText">132</span> to represent
		<span class="monoText">&szlig;</span>, the other used it for
		<span class="monoText">&pi;</span> &mdash;
		<span class="monoText">2&pi;r</span> became
		<span class="monoText">2&szlig;r</span> and
		<span class="monoText">gro&szlig;</span> became
		<span class="monoText">gro&pi;</span>.
	</p>
	<p>
		Responding to the discord, IBM introduced
		<span class="term">code pages</span> &mdash; systems mapping values to
		characters in an encoding system. In IBM's code pages, the integers ${0}$
		through ${127}$ were always mapped to the ASCII characters, and the integers
		${128}$ to ${255}$ (called the <span class="term">extended codes</span>)
		were mapped to some language variation of the user's choice. For example,
		with code page 437, the extended codes were mapped to characters specific to
		IBM computers: diactritics (accented letters), icons, and system-specific
		symbols. For code page 737, the extended codes mapped to Greek letters, and
		for code page 826, the extended codes mapped to Turkish letters. With
		multiple code pages, users could simply swap code pages as needed. The
		mathematician might work predominantly with the Greek letter code page, but
		when reading a German paper, she could switch to the German code page. All
		${256}$ characters (the ${128}$ original ASCII characters and the ${128}$
		additional characters from a code page) constitute an
		<span class="term">extended ASCII character set</span>.
	</p>
	<p>
		Because every ASCII encoding requires exactly 1 byte, we say that ASCII uses
		a <span class="term">fixed-width encoding system</span>. This is a good
		point to clarify an important distinction: There's a difference between the
		character set (ASCII set) and the character set's
		<span class="term">encoding system</span> (ASCII encoding). The encoding
		system is the way the characters in the set are represented in memory. In
		extended ASCII, characters are encoded as eight-bit character codes, as we
		stated earlier.
	</p>
	<p>
		As the internet grew, consumers recognized that eight bits, ${256}$
		characters, were insufficient. And rightly so &mdash; the average Chinese
		user demands about ${7~000}$ characters for expressive use (from roughly
		${50~000}$ possible characters). As exchanging text between systems &mdash;
		rather than entire systems or parts of the systems themselves &mdash; became
		prevalent, a paradigm shift in the encoding community occured. Rather than
		thinking of a character as a symbol with one, specified representation in
		computer memory, we think of a character as a concept that can be
		represented in multiple ways. In practice, we call the former paradigm a
		<span class="term">fixed-width encoding system</span>, and the latter a
		<span class="term">variable-width encoding system</span>.
	</p>
	<p>
		For example, the letter <span class="monoText">A</span> in ASCII encoding
		employs the former paradigm. It is always represented as:
	</p>
	<figure>
		<div>
			<p>${\texttt{A} \to \texttt{0100 0001}}$</p>
		</div>
	</figure>
	<p>
		Under the new paradigm, we map each character to a concept. That concept,
		called a <span class="term">code point</span>, can then be deciphered by the
		computer in whatever way it sees fit (using more bits or bytes as
		necessary):
	</p>
	<figure>
		<div>
			<p>${\texttt{A} \to \texttt{U+0001}}$</p>
		</div>
		<figcaption>
			The number <span class="monoText">0001</span> is a hexadecimal number.
		</figcaption>
	</figure>
	<p>
		The character set employing this new paradigm is called
		<span class="term">Unicode</span>.<label for="unicode" class="margin-toggle"
			><sup></sup
		></label>
		<input type="checkbox" id="unicode" class="margin-toggle sidenote-number" />
		<span class="marginnote"
			>The name &#8220;Unicode&#8221; is a morphological blending of
			<span class="italicsText">unique</span>,
			<span class="italicsText">unified</span>,
			<span class="italicsText">universal</span>, and
			<span class="italicsText">encoding</span>.</span
		>
		Above, the symbol <span class="monoText">U+0001</span> is a code point. The
		code point is simply a number associated with a particular idea. That idea
		could be a letter, a mathematical symbol, a numeral, whitespace, tab, or an
		emoji. How that number is deciphered and stored as bits is up to the
		computer. As of the time of this writing, Unicode (now at version 14.0) has
		${144~697}$ ideas mapped, with ${1~112~064}$ code points in reserve.
	</p>
	<p>
		This entire discussion reveals a critical point when working with strings:
		There's no such thing as &#8220;plain text.&#8221; Instructing a computer to
		change some <span class="monoText">int</span> value to &#8220;plain
		text&#8221; is akin to asking the bureau de change, &#8220;Convert these
		dollars to currency.&#8221; The only way a computer can separate
		<span class="monoText">1</span> from <span class="monoText">"1"</span> or
		understand that we're asking for the character
		<span class="monoText">&phi;</span> is if we explicitly provide the encoding
		encoding system to use. And it's considered best practice to explicitly
		define encoding whenever possible because there are multiple encoding
		systems:
	</p>
	<ul>
		<li>
			In <span class="boldText">ASCII</span>, the characters are encoded as a
			sequence of ${7}$ bits. This is a fixed-width encoding system, so only
			${128}$ characters can be represented. The characters mapped to the
			integers ${0}$ to ${31}$ are non-printable characters, while the
			characters from ${32}$ to ${127}$ comprise the printable characters often
			called &#8220;plain text.&#8221;
		</li>
		<li>
			Like ASCII, <span class="boldText">Extended ASCII</span> is a fixed-width
			encoding system, but with mappings for the additional ${128}$ characters
			(or really, any characters beyond the original ${128}$). The name
			&#8220;extended ASCII&#8221; is informal. This is just ASCII, but with
			characters encoded as a sequence of 8 bits and the user providing some
			additional encodings (whether that's through a personal code page or
			another system, like Unicode) for additional numbers.
		</li>
		<li>
			<span class="boldText">OEM Code Pages</span> or
			<span class="boldText">IBM Code Pages</span> are fixed-width encoding
			systems for the additional ${128}$ characters resulting from the unused
			eighth bit in ASCII. As such, characters in this encoding system are
			encoded as a sequence of 8 bits. There are multitudes of code pages,
			mapping the additional ${128}$ characters to various symbols depending on
			language, field, country, or computer system.
		</li>
		<li>
			The <span class="boldText">ANSI Code Pages</span> are Microsoft's
			equivalent to the IBM and OEM code pages, so characters here are also
			encoded as a fixed-width sequence of 8 bits. Contrary to popular belief,
			these pages were never standardized by ANSI (the
			<span class="italicsText">American National Standards Institute</span>, a
			private non-profit aimed at standardization). Microsoft intended to
			standardize one of their pages through ANSI and prepended to draft's title
			&#8220;ANSI&#8221;, but no such standardization occurred.
		</li>
		<li>
			<span class="boldText">UTF-8</span>, <span class="boldText">UTF-16</span>,
			and <span class="boldText">UTF-32</span> are the most common systems used
			to convert Unicode code points to bits. Remember, Unicode is a system
			mapping concepts to code points; this process is distinct from converting
			the code points to bits. For example, the smiley face emoji (a concept) is
			mapped to a specific a code point:
			<figure>
				<div>
					<p>&#128522; ${~~~\to~~}$ <span class="monoText">U+1F60A</span></p>
				</div>
			</figure>
			The number <span class="monoText">U+1F60A</span> is a code point. The
			letter <span class="monoText">U</span> stands for
			<span class="italicsText">Unicode</span> and the number
			<span class="monoText">1F60A</span> is a hexadecimal number. To convert
			this code point into bits, the computer system looks for the encoding
			system we've defined. In Unicode, these systems are called
			<span class="term">Unicode Translation Formats</span> (hence
			&#8220;UTF&#8221;). Importantly, the number following UTF (e.g., the 8 in
			UTF-8) does not specify how many bits the code point is translated into.
			Instead, it specifies the <span class="italicsText">size</span> of each
			code unit from translating the hexadecimal number. Thus, in UTF-8, the
			Unicode code point (the magic number <span class="monoText">1F60A</span>)
			is stored in memory as a sequence of 8-bits. Hence, every code point
			<span class="monoText">0</span> to <span class="monoText">7f</span> (${0}$
			to ${127}$ in decimal &mdash; the ASCII characters) is stored in exactly 1
			byte. Code points beyond that are stored using 2, 3, or 4 bytes.
			Similarly, in UTF-32, the code units resulting from translating the code
			point are stored as sequences of 32 bits, and for UTF-16, a sequence of 16
			bits.
		</li>
	</ul>
	<p>
		Note how we said that UTF-8, UTF-16, and UTF-32 are the most common options.
		We say this because Unicode can be encoded through a wide variety of
		encoding systems: UTF-7, UCS, UCS-2 (now obsolete), ASCII, and many others.
		These other encoding systems continue to exist because the operations of
		other standards necessitate their use. For example, the standard for URL
		encoding is set by RFC 1738, which effectively provides that only a subset
		of the original ASCII characters can be used: We can't use non-printable
		characters and we can't use any of these characters:
	</p>
	<figure>
		<div>
			<p>
				<span class="monoText">""</span> &ThickSpace;
				<span class="monoText">&lt;</span> &ThickSpace;
				<span class="monoText">&gt;</span> &ThickSpace;
				<span class="monoText">#</span> &ThickSpace;
				<span class="monoText">{</span> &ThickSpace;
				<span class="monoText">}</span> &ThickSpace;
				<span class="monoText">|</span> &ThickSpace;
				<span class="monoText">^</span> &ThickSpace;
				<span class="monoText">\</span> &ThickSpace;
				<span class="monoText">~</span> &ThickSpace;
				<span class="monoText">[</span> &ThickSpace;
				<span class="monoText">]</span> &ThickSpace;
				<span class="monoText">`</span> &ThickSpace;
				<span>space</span>
			</p>
		</div>
	</figure>
	<p>
		If any of the characters above are used directly (i.e., maybe our directory
		name has a space, resulting in a space in the URL), an encoding algorithm is
		used:
	</p>
	<ol class="recipe">
		<li>Find the ISO 8859-1 code point for the illegal character.</li>
		<li>Convert the code point to two hexadecimal characters.</li>
		<li>
			Append a percentage sign, <span class="monoText">%</span>, to the front of
			the two hex characters.
		</li>
	</ol>
	<p>
		For example, the single whitespace character is an illegal character under
		RFC 1738. Applying the algorithm above, the whitespace is replaced with a
		<span class="monoText">%20</span>. Thus, when we see a
		<span class="monoText">%20</span> in a URL, we immediately know that
		whoever, or whatever, created that URL included a whitespace, inadvertently
		or otherwise. Similar algorithms exist for when we use characters that
		cannot be encoded. The
		<span class="italicsText">replacement character</span> &thinsp; � &thinsp;
		is often used to replace characters that cannot be encoded.
	</p>
	<p>
		In sum, whenever we work with strings, it's important to always keep the
		encoding system in the back of our minds. This can be particularly helpful
		when analyzing and designing string algorithms:
	</p>
	<figure>
		<table class="api">
			<thead>
				<th>Encoding System</th>
				<th>Lengths</th>
				<th>Memory Consumption</th>
			</thead>
			<tbody>
				<tr>
					<td><span class="boldText">ASCII</span></td>
					<td>A sequence of 7 bits.</td>
					<td>Constant memory consumption; essentially 1 byte.</td>
				</tr>
				<tr>
					<td><span class="boldText">&#8220;Extended ASCII&#8221;</span></td>
					<td>A sequence of 8 bits.</td>
					<td>Constant memory consumption: 1 byte.</td>
				</tr>
				<tr>
					<td><span class="boldText">UTF-7</span></td>
					<td>A sequence of 7 bits.</td>
					<td>Constant memory consumption; essentially 1 byte.</td>
				</tr>
				<tr>
					<td><span class="boldText">IBM/OEM Code Maps</span></td>
					<td>A sequence of 8 bits.</td>
					<td>Constant memory consumption: 1 byte.</td>
				</tr>
				<tr>
					<td><span class="boldText">ANSI Code Maps</span></td>
					<td>A sequence of 8 bits.</td>
					<td>Constant memory consumption: 1 byte.</td>
				</tr>
				<tr>
					<td><span class="boldText">ISO 8859</span></td>
					<td>A sequence of 8 bits.</td>
					<td>Constant memory consumption: 1 byte.</td>
				</tr>
				<tr>
					<td><span class="boldText">UTF-8</span></td>
					<td>Each code unit is a sequence of 8 bits.</td>
					<td>
						Variable memory consumption; a character can take up 1, 2, 3, or 4
						bytes. At a minimum, a character is 1 byte.
					</td>
				</tr>
				<tr>
					<td><span class="boldText">UTF-16</span></td>
					<td>
						Each code unit is a sequence of 16 bits. The smallest possible
						memory consumption is 2 bytes, the largest is 4 bytes.
					</td>
					<td>
						Variable memory consumption; a character can take up 2, 3, or 4
						bytes. At a minimum, a character is 2 bytes.
					</td>
				</tr>
				<tr>
					<td><span class="boldText">UTF-32</span></td>
					<td>A sequence of 32 bits.</td>
					<td>Constant memory consumption: 4 bytes.</td>
				</tr>
				<tr>
					<td><span class="boldText">UCS-2</span> (obsolete)</td>
					<td>A sequence of 16 bits.</td>
					<td>Constant memory consumption: 2 bytes.</td>
				</tr>
				<tr>
					<td><span class="boldText">UCS-4</span> (obsolete)</td>
					<td>A sequence of 32 bits.</td>
					<td>Constant memory consumption: 4 bytes.</td>
				</tr>
			</tbody>
		</table>
	</figure>
	<p>
		To simplify our algorithms, we will be working almost exclusively with
		ASCII, where every character takes up 1 byte of memory. This will allow us
		to explore some of the limitations of such algorithms when a different
		encoding system is used. Because the original ASCII characters are widely
		used, it's helpful to memorize the following facts:
	</p>
	<figure>
		<ol class="numd">
			<li>
				The uppercase letters <span class="monoText">A</span> through
				<span class="monoText">Z</span> are mapped to the integers in the range
				${[65, 90].}$
			</li>
			<li>
				The lower case letters <span class="monoText">a</span> through
				<span class="monoText">z</span> are mapped to the integers in the range
				${[97, 122].}$
			</li>
			<li>
				The uppercase letters come &#8220;before&#8221; the lower case letters
				in terms of their integer equivalents.
			</li>
			<li>
				The numerals <span class="monoText">0</span> through
				<span class="monoText">9</span> are mapped to the integers in the range
				${[48, 57].}$
			</li>
			<li>
				The ranges of integers ${[32, 47],}$ ${[58, 64],}$ ${[91, 96],}$ and
				${[123, 127]}$ map to special characters like
				<span class="monoText">()</span> and <span class="monoText">/</span>.
			</li>
			<li>
				The range of integers ${[0, 31]}$ map to
				<span class="italicsText">control characters</span> (these are
				non-printable characters).
			</li>
			<li>The integer ${32}$ is mapped to whitespace.</li>
			<li>
				The integer ${10}$ is mapped to linefeed (i.e., the result of hitting
				enter on the keyboard; a new line).
			</li>
		</ol>
	</figure>
</section>

<section id="character_values">
	<h3>Characters</h3>
	<p>
		In some languages, there is distinction between characters and strings.
		However, because there is a distinction in C and C++, we briefly revisit it.
	</p>
	<p>
		In C, a <span class="monoText">char</span> value is an ASCII character, and
		it takes up exactly 1 byte. Because we restrict ourselves to the original
		ASCII characters, of the 8 bits in the byte, only 7 of those bits are used.
		Those 7 bits constitute some integer &mdash; the character's ASCII code. For
		example, for the character <span class="monoText">A</span> is actually the
		integer <span class="monoText">65</span>, stored in memory as:
	</p>
	<figure>
		<div>
			<p>${\large \texttt{0100 0001}}$</p>
		</div>
	</figure>
	<p>We can see this is the case with the following code:</p>
	<pre class="language-c"><code>
		int main() {
			char temp = 'A';
			printf("temp = %c", temp);
			printf("temp = %d", temp);
		}
	</code></pre>
	<pre class="language-bash"><code>
		temp = A
		temp = 65
	</code></pre>
	<p>
		Similarly, when we use <span class="monoText">cout</span> in C++, the
		compiler knows that the variable <span class="monoText">temp</span> is a
		<span class="monoText">char</span> variable, and outputs to the console a
		string rather than the integer values. If we wanted to output the integer
		values, we must cast the <span class="monoText">char</span> value to an
		<span class="monoText">int</span>.
	</p>
</section>

<section id="strings">
	<h3>Strings</h3>
	<div class="mainIdea">
		<p>
			A string (C string) is an array of
			<span class="monoText">char</span> values.
		</p>
	</div>
	<p>
		In C, an array of <span class="monoText">char</span> values is a
		<span class="term">string</span>. In C++, this type of string is called a
		<span class="term">C string</span> (as we know, the other string type is
		class-implemented, but we will limit ourselves to C strings for now). Thus,
		when we write:
	</p>
	<pre class="language-c"><code>
		int main() {
			char word[5];
		}
	</code></pre>
	<p>
		we declare an array called <span class="monoText">word</span> whose values
		are <span class="monoText">char</span>s. In other words, a string of size
		${5.}$ We can then initialize the string:
	</p>
	<pre class="language-c"><code>
		int main() {
			char w[5];
			w = {'h', 'e', 'l', 'l', 'o'};
		}
	</code></pre>
	<p>Visually:</p>
	<figure>
		<table class="string">
			<tbody>
				<tr>
					<td>${w}$</td>
					<td>'h'</td>
					<td>'e'</td>
					<td>'l'</td>
					<td>'l'</td>
					<td>'o'</td>
				</tr>
				<tr>
					<td>${i}$</td>
					<td>0</td>
					<td>1</td>
					<td>2</td>
					<td>3</td>
					<td>4</td>
				</tr>
			</tbody>
		</table>
	</figure>
	<p>We can also create strings without explicitly providing a size:</p>
	<pre class="language-c"><code>
		int main() {
			char w[] = {'h', 'e', 'l', 'l', 'o'};
		}
	</code></pre>
	<p>Or even avoid using characters all together:</p>
	<pre class="language-c"><code>
		int main() {
			char w[] = {104, 101, 108, 108, 111};
		}
	</code></pre>
	<p>Now, if we wrote:</p>
	<pre class="language-c"><code>
		int main() {
			char w[5] = {'h', 'e'};
		}
	</code></pre>
	<p>We would have the following in memory:</p>
	<figure>
		<table class="string">
			<tbody>
				<tr>
					<td>${w}$</td>
					<td>'h'</td>
					<td>'e'</td>
					<td><span class="redText">0</span></td>
					<td><span class="redText">0</span></td>
					<td><span class="redText">0</span></td>
				</tr>
				<tr>
					<td>${i}$</td>
					<td>0</td>
					<td>1</td>
					<td>2</td>
					<td>3</td>
					<td>4</td>
				</tr>
			</tbody>
		</table>
	</figure>
	<p>
		If we initialize only some of the elements in the array with
		<span class="monoText">char</span> values, the remaining uninitialized
		spaces are effectively zero. Because C strings are arrays of
		<span class="monoText">char</span> values, we have the following
		observation:
	</p>
	<figure>
		<div class="rule">
			<p>
				<span class="topic">Theorem.</span> Given an array of
				<span class="monoText">char</span> values with a size ${S,}$ if ${n}$
				elements are initialized and ${n < S,}$ the resulting string has a
				length ${\ell < S.}$
			</p>
		</div>
	</figure>
	<p>
		Given the fact above, we have a problem: How do we know where a string
		terminates? We can't rely on the size of the array, because it isn't
		guaranteed that the string ends there. The solution in C and C++ is to use a
		control character <span class="monoText">NUL</span>.<label
			for="string_term"
			class="margin-toggle"
			><sup></sup
		></label>
		<input
			type="checkbox"
			id="string_term"
			class="margin-toggle sidenote-number"
		/>
		<span class="marginnote"
			>The NUL character is an example of a
			<span class="term">string terminator</span> or
			<span class="term">string delimiter</span>. Effectively, a character
			that's used to denote the end of a string. This means that the character
			just before the string terminator is the last character in the
			string.</span
		>
		Visually, it is represented as <span class="monoText">'\0'</span>, and it
		has the ASCII code <span class="monoText">0</span>. Note that that is
		difference between the ASCII <span class="monoText">NUL</span>, the ASCII
		<span class="monoText">0</span>, and the literal
		<span class="monoText">0</span>:
	</p>
	<pre class="language-c"><code>
		int main {
			char ascii_NUL = '\0';
			char zero = '0';
			int zero = 0;
		}
	</code></pre>
	<p>
		The character zero is represented in hexadecimal as
		<span class="monoText">0x30</span>, and the character NUL is represented in
		hexadecimal as <span class="monoText">0x00</span>. The NUL character, as an
		<span class="monoText">int</span>, is <span class="monoText">0</span>. The
		zero character, as an <span class="monoText">int</span>, is
		<span class="monoText">30</span>.
	</p>
	<p>
		Accordingly, the partially initialized character array we saw is actually
		implemented as:
	</p>
	<figure>
		<table class="string">
			<tbody>
				<tr>
					<td>${w}$</td>
					<td>'h'</td>
					<td>'e'</td>
					<td><span class="blueText">\0</span></td>
					<td><span class="redText">0</span></td>
					<td><span class="redText">0</span></td>
				</tr>
				<tr>
					<td>${i}$</td>
					<td>0</td>
					<td>1</td>
					<td>2</td>
					<td>3</td>
					<td>4</td>
				</tr>
			</tbody>
		</table>
	</figure>
	<p>
		Note that this implementation behavior is not universal. In languages like
		Java, the length of string is built into the string itself. But in languages
		like C, the length is determined only if, and only after, the string
		delimiter is found. As such, C strings are formed only if we include a
		<span class="monoText">\0</span> as the last element in the array:
	</p>
	<pre class="language-c"><code>
		int main() {
			char w[5] = {'h', 'e', '\0'};
		}
	</code></pre>
	<p>
		Without the string delimiter, the <span class="monoText">char</span> array
		is just an array of <span class="monoText">char</span> values. Once we
		include the delimiter, the <span class="monoText">char</span> array is
		interpreted as a string.
	</p>
	<p>We can, of course, omit the size:</p>
	<pre class="language-c"><code>
		int main() {
			char w[] = {'h', 'e', '\0'};
		}
	</code></pre>
	<p>When we write the above code, there are several things to keep in mind:</p>
	<figure>
		<ol class="numd">
			<li>The size of the array is 3.</li>
			<li>The length of the array is 3.</li>
			<li>The length of the <span class="italicsText">string</span> is 2.</li>
		</ol>
	</figure>
	<p>
		The most common way to initialize a C string, however, is the following:
	</p>
	<pre class="language-c"><code>
		int main() {
			char w[] = "hello";
		}
	</code></pre>
	<p>
		When we use double quotes, the C compiler automatically includes the string
		delimiter after the last character. Thus, when we see this code, the
		previous analysis applies. The size of the array is 6. The length of the
		array is 6. The length of the string is 5.
	</p>
</section>

<section id="length_of_string">
	<h2>Finding the Length of a String</h2>
	<p>
		The first algorithm we consider is the
		<span class="term">string-length algorithm</span>. Although this algorithm
		is simple, it is fundamental to the implementations of many string
		algorithms. Consider the following string:
	</p>
	<pre class="language-c"><code>
		int main() {
			char S[] = "welcome";
		}
	</code></pre>
	<p>In memory, this string is implemented as:</p>
	<figure>
		<table class="string">
			<tbody>
				<tr>
					<td>${S}$</td>
					<td>'w'</td>
					<td>'e'</td>
					<td>'l'</td>
					<td>'c'</td>
					<td>'o'</td>
					<td>'m'</td>
					<td>'e'</td>
					<td><span class="redText">'\0'</span></td>
				</tr>
				<tr>
					<td>${i}$</td>
					<td>0</td>
					<td>1</td>
					<td>2</td>
					<td>3</td>
					<td>4</td>
					<td>5</td>
					<td>6</td>
					<td>7</td>
				</tr>
			</tbody>
		</table>
	</figure>
	<p>
		To find the length of this string, we simply iterate until we reach the NUL
		character (the string delimiter, <span class="monoText">\0</span>). Thus,
		whichever index we stop at is the length of the string:
	</p>
	<figure>
		<ol class="alg">
			<li>${f}$ stringLength(char[] S):</li>
			<ol>
				<li>let int i = 0;</li>
				<li>while (S[i] != '\0'):</li>
				<ol>
					<li>i++;</li>
				</ol>
				<li>return i;</li>
			</ol>
		</ol>
	</figure>
	<p>
		Because we must traverse the array, if there are ${n}$ elements, we must
		perform the non-equality comparison ${n}$ times. Accordingly, this algorithm
		has time complexity of ${O(n)}$ &mdash; linear time.
	</p>
</section>

<section id="letter_casing">
	<h2>Letter-casing Algorithms</h2>
	<p>
		The next algorithm we consider is changing all the letters in a string to
		the another case. For example, given the following string:
	</p>
	<pre class="language-c"><code>
		int main() {
			char S[] = "warning";
		}
	</code></pre>
	<p>We want to output:</p>
	<pre class="language-bash"><code>
		WARNING
	</code></pre>
	<p>
		Alternatively, if the string is <span class="monoText">"WARNING"</span>, we
		want to output <span class="monoText">"warning"</span>. This procedure is
		called <span class="term">letter casing</span>.<label
			for="capital"
			class="margin-toggle"
			><sup></sup
		></label>
		<input type="checkbox" id="capital" class="margin-toggle sidenote-number" />
		<span class="marginnote"
			>Two asides: First, letter casing is distinct from
			<span class="italicsText">capitalization</span>. We do not capitalize
			letters; we capitalize <span class="italicsText">words</span>. When we
			capitalize a word, we <span class="italicsText">uppercase</span> the first
			letter, and ensure the rest of the word's letters are
			<span class="italicsText">lowercase</span>. Second, the terms
			&#8220;uppercase&#8221; and &#8220;lowercase&#8221; stem from the original
			printing press. The
			<span class="italicsText">majuscule letters</span> (what we informally
			call uppercase letters), were kept in the top drawer of the press (the
			&#8220;upper case&#8221;), while the
			<span class="italicsText">minuscule letters</span> (the lowercase
			letters), were kept in the drawer below (the &#8220;lower
			case&#8221;).</span
		>
		The simplest letter casing algorithm comes from two helpful facts in the
		ASCII table:
	</p>

	<ul>
		<li>
			The uppercase letters <span class="monoText">A</span> through
			<span class="monoText">Z</span> are mapped to the integers ${65}$ through
			${90}$ respectively.
		</li>
		<li>
			The lowercase letters <span class="monoText">a</span> through
			<span class="monoText">z</span> are mapped to the integers ${97}$ through
			${122}$ respectively.
		</li>
	</ul>

	<p>
		Because there are exactly 26 letters, these ranges consist of 26 consecutive
		integers. And because they are consecutive, the difference between a
		letter's uppercase and its lowercase is constant:
	</p>
	<figure>
		<div>
			$$ \begin{aligned} &\texttt{a} - \texttt{A} = 97 - 65 = 32 \\ &\texttt{b}
			- \texttt{B} = 98 - 66 = 32 \\ &\texttt{c} - \texttt{C} = 99 - 67 = 32 \\
			&\vdots \\ &\texttt{y} - \texttt{Y} = 121 - 89 = 32 \\ &\texttt{z} -
			\texttt{Z} = 122 - 90 = 32 \end{aligned} $$
		</div>
	</figure>
	<p>
		Thus, if we want all of the lowercase letters in a string to be uppercase,
		we must <span class="underlineText">subtract</span> 32 to each lowercase
		letter. If we want to all of the uppercase letters in a string to be
		lowercase, we must <span class="underlineText">add</span> 32 to each
		uppercase letter. Stating this explicitly, where ${s_i}$ is some letter:
	</p>
	<figure>
		<ol class="numd">
			<li>
				Uppercase to lowercase &ThickSpace; &rightarrow; &ThickSpace; ${s_i +
				32}$
			</li>
			<li>
				Lowercase to uppercase &ThickSpace; &rightarrow; &ThickSpace; ${s_i -
				32}$
			</li>
		</ol>
	</figure>
	<p>Implementing the algorithm for lower-casing:</p>
	<figure>
		<ol class="alg">
			<li>${f}$ lowerCase(char S[]):</li>
			<ol>
				<li>for (int i = 0; S[i] != '\0'; i++):</li>
				<ol>
					<li>S[i] = S[i] + 32;</li>
				</ol>
				<li>return S;</li>
			</ol>
		</ol>
	</figure>
	<p>And for upper-casing:</p>
	<figure>
		<ol class="alg">
			<li>${f}$ upperCase(char S[]):</li>
			<ol>
				<li>for (int i = 0; S[i] != '\0'; i++):</li>
				<ol>
					<li>S[i] = S[i] - 32;</li>
				</ol>
				<li>return S;</li>
			</ol>
		</ol>
	</figure>
	<p>
		Importantly, for both of the algorithms above, we make the following
		assumptions:
	</p>
	<figure>
		<ol class="numd">
			<li>
				The <span class="monoText">char</span> array
				<span class="monoText">S</span> is comprised entirely of English
				letters.
			</li>
			<li>
				The <span class="monoText">char</span> array
				<span class="monoText">S</span> is comprised of either all uppercase
				letters or all lower case letters, but not both.
			</li>
		</ol>
	</figure>

	<section id="upper_to_lower_and_vice_versa">
		<h3>Case Toggling</h3>
		<p>
			Keeping the first assumption &mdash; the
			<span class="monoText">char</span> array
			<span class="monoText">S</span> is comprised entirely of English letters
			&mdash; we consider an algorithm that performs the following:
		</p>
		<figure>
			<ol>
				<li>Uppercase all lowercase letters.</li>
				<li>Lowercase all uppercase letters.</li>
			</ol>
		</figure>
		<p>
			The procedure above is called <span class="term">case toggling</span>, and
			an algorithm for performing the procedure is called a
			<span class="term">case toggler</span>. For example, suppose we had the
			following string:
		</p>
		<pre class="language-c"><code>
			char S[] = "wElCome";
		</code></pre>
		<p>In memory, this string appears as:</p>
		<figure>
			<table class="string">
				<tbody>
					<tr>
						<td>${S}$</td>
						<td>'w'</td>
						<td>'E'</td>
						<td>'l'</td>
						<td>'C'</td>
						<td>'o'</td>
						<td>'m'</td>
						<td>'e'</td>
						<td>'\0'</td>
					</tr>
					<tr>
						<td>${i}$</td>
						<td>0</td>
						<td>1</td>
						<td>2</td>
						<td>3</td>
						<td>4</td>
						<td>5</td>
						<td>6</td>
						<td>7</td>
					</tr>
				</tbody>
			</table>
		</figure>
		<p>
			We can see that some of the letters are in uppercase, others lowercase.
			Case toggling results in:
		</p>
		<pre class="language-bash"><code>
			WeLcOME
		</code></pre>
		<p>
			The case toggler uses the same fact we employed before. If it's a
			lowercase letter, we subtract ${32,}$ and if it's an uppercase letter, we
			add ${32.}$ The additional implementation detail, however, is that we need
			tests for the two possibilities: (1) the lowercase letter, and (2) the
			uppercase letter. To construct these tests, we draw on the property common
			to all lowercase letters, and the property common to all uppercase
			letters:
		</p>
		<ol class="numd">
			<li>
				A lowercase letter is one of the integers in the range ${[97, 122].}$
			</li>
			<li>
				An uppercase letter is one of the integers in the range ${[65, 90].}$
			</li>
		</ol>
		<p>Relying on these facts, we have the following:</p>
		<figure>
			<ol class="alg">
				<li>${f}$ caseToggle(char S[]):</li>
				<ol>
					<li>for (int i = 0; S[i] != '\0'; i++):</li>
					<ol>
						<li>if (97 <= S[i] AND S[i] <= 122):</li>
						<ol>
							<li>S[i] -= 32;</li>
						</ol>
						<li>else if (65 <= S[i] AND S[i] <= 90):</li>
						<ol>
							<li>S[i] += 32;</li>
						</ol>
					</ol>
					<li>return S;</li>
				</ol>
			</ol>
		</figure>
		<p>
			Importantly, the test conditions above ensure that the increment ${32}$ or
			decrement ${32}$ only occur if the element in the array is an English
			letter. If there are special symbols like <span class="monoText">+</span>,
			<span class="monoText">&</span>, or whitespace, no change occurs.
		</p>
		<p>
			An alternative implementation is to use an old ASCII trick. The idea is to
			take advantage of the binary representations of the letters:
		</p>
		<figure>
			<pre class="language-pseudo"><code>
				a = 01100001    A = 01000001 
				b = 01100010    B = 01000010 
				c = 01100011    C = 01000011 
				d = 01100100    D = 01000100 
				e = 01100101    E = 01000101 
				f = 01100110    F = 01000110 
				g = 01100111    G = 01000111 
				h = 01101000    H = 01001000 
				i = 01101001    I = 01001001 
				j = 01101010    J = 01001010 
				k = 01101011    K = 01001011 
				l = 01101100    L = 01001100 
				m = 01101101    M = 01001101 
				n = 01101110    N = 01001110 
				o = 01101111    O = 01001111 
				p = 01110000    P = 01010000 
				q = 01110001    Q = 01010001 
				r = 01110010    R = 01010010 
				s = 01110011    S = 01010011 
				t = 01110100    T = 01010100 
				u = 01110101    U = 01010101 
				v = 01110110    V = 01010110 
				w = 01110111    W = 01010111 
				x = 01111000    X = 01011000 
				y = 01111001    Y = 01011001 
				z = 01111010    Z = 01011010 
			</code></pre>
		</figure>
		<p>
			Do we notice a pattern? The fifth bit is
			<span class="monoText">1</span> for lowercase letters, and
			<span class="monoText">0</span> for uppercase letters. Hence, to switch
			from upper to lowercase or from lower or uppercase, all we have to do is
			toggle this bit. We can do so with the bitwise XOR operator. All that's
			left is to ensure the <span class="monoText">char</span> value is within
			the range of letters:
		</p>
		<figure>
			<ol class="alg">
				<li>${f}$ caseToggle(char S[]):</li>
				<ol>
					<li>for (int i = 0; S[i] != '\0'; i++):</li>
					<ol>
						<li>if (</li>
						<ol>
							<li>(65 <= S[i] AND S[i] <= 90) OR</li>
							<li>(97 <= S[i] AND S[i] <= 122)):</li>
							<ol>
								<li>S[i] ^= 32;</li>
							</ol>
						</ol>
					</ol>
					<li>return S;</li>
				</ol>
			</ol>
		</figure>
	</section>
</section>

<section id="phone_counting">
	<h2>Phone Counting</h2>
	<p>
		In linguistics, vowels and consonants are more broadly called
		<span class="term">phones</span>. Algorithms that count vowels or consonants
		are called <span class="term">phone counters</span>. Let's consider some
		algorithms that count vowels or consonants.
	</p>
	<p>
		Setting aside linguistic technicalities for now, the set of vowels has a
		cardinality of five:
	</p>
	<figure>
		<div>
			<p>${V = \{ a,~e,~i,~o,~u \}}$</p>
		</div>
	</figure>
	<p>Suppose we are given the following string:</p>
	<pre class="language-c"><code>
			char S[] = "How are you"; 
	</code></pre>
	<p>For the algorithms below, we make the following assumption:</p>
	<p>
		<span class="topic">Vowel Counter.</span>
		We want to determine how many vowels are in this string. To do so, we need a
		<span class="term">vowel counter</span> &mdash; an algorithm for counting
		the vowels in a string. In this case, there are five vowels, and the
		remaining are consonants. Visualizing the string's implementation in memory:
	</p>
	<figure>
		<table class="string">
			<tr>
				<td>${S}$</td>
				<td>'H'</td>
				<td>'o'</td>
				<td>'w'</td>
				<td>' '</td>
				<td>'a'</td>
				<td>'r'</td>
				<td>'e'</td>
				<td>' '</td>
				<td>'y'</td>
				<td>'o'</td>
				<td>'u'</td>
				<td>'\0'</td>
			</tr>
			<tr>
				<td>${i}$</td>
				<td>0</td>
				<td>1</td>
				<td>2</td>
				<td>3</td>
				<td>4</td>
				<td>5</td>
				<td>6</td>
				<td>7</td>
				<td>8</td>
				<td>9</td>
				<td>10</td>
				<td>11</td>
			</tr>
		</table>
	</figure>
	<p>
		To count the number of vowels, we will iterate through the string. The first
		difficulty we encounter with this algorithm concerns the test conditions.
		The brute-force implementation is to check each of the ten possible test
		cases (there are five vowels, and they can be uppercase or lowercase):
	</p>
	<figure>
		<ol class="alg">
			<li>${f}$ vowelCount(char S[]):</li>
			<ol>
				<li>int vowelCount = 0;</li>
				<li>for (int i = 0; S[i] != '\0'; i++):</li>
				<ol>
					<li>if (</li>
					<ol>
						<li>S[i] = 'a' OR</li>
						<li>S[i] = 'e' OR</li>
						<li>S[i] = 'i' OR</li>
						<li>S[i] = 'o' OR</li>
						<li>S[i] = 'u' OR</li>
						<li>S[i] = 'A' OR</li>
						<li>S[i] = 'E' OR</li>
						<li>S[i] = 'I' OR</li>
						<li>S[i] = 'O' OR</li>
						<li>S[i] = 'U' OR ):</li>
						<ol>
							<li>vowelCount++;</li>
						</ol>
					</ol>
				</ol>
				<li>return vowelCount</li>
			</ol>
		</ol>
	</figure>
	<p>
		<span class="topic">Consonant Counter.</span> To implement the consonant
		counter, we rely on the fact that we can count the vowels. However, we must
		account for the fact that something that is not a vowel may or may not be a
		consonant. For a non-vowel to be a consonant, it must be within the range of
		English letters. Otherwise, it could be a control character or a special
		character.
	</p>
	<figure>
		<ol class="alg">
			<li>${f}$ consonantCount(char S[]):</li>
			<ol>
				<li>int consonantCount = 0;</li>
				<li>for (int i = 0; S[i] != '\0'; i++):</li>
				<ol>
					<li>if (</li>
					<ol>
						<li>S[i] = 'a' OR</li>
						<li>S[i] = 'e' OR</li>
						<li>S[i] = 'i' OR</li>
						<li>S[i] = 'o' OR</li>
						<li>S[i] = 'u' OR</li>
						<li>S[i] = 'A' OR</li>
						<li>S[i] = 'E' OR</li>
						<li>S[i] = 'I' OR</li>
						<li>S[i] = 'O' OR</li>
						<li>S[i] = 'U' OR ):</li>
						<ol>
							<li>continue;</li>
						</ol>
					</ol>
					<li>else if (</li>
					<ol>
						<li>65 <= S[i] AND S[i] <= 90 OR</li>
						<li>97 <= S[i] AND S[i] <= 122):</li>
						<ol>
							<li>consonantCount++;</li>
						</ol>
					</ol>
				</ol>
				<li>return consonantCount</li>
			</ol>
		</ol>
	</figure>
	<p>
		With consonant counters and vowel counters, we cannot avoid having to test
		the individual cases, at least where the string can contain anything other
		than letters. While there are a few optimizations we can make, they are
		essentially negligible; we still have to test the cases, and we still have
		to iterate. There are some very minor, negligible improvements we can make.
	</p>
	<p>
		First, the vowel counter. If we're processing actual words, one helpful fact
		from linguistics is that the most common vowels, from least to most, are the
		following:
	</p>
	<figure>
		<div>
			<p>${v = \lang e, a, i, o, u \rang}$</p>
		</div>
	</figure>
	<p>
		Furthermore, we're much more likely to encounter lowercase letters than
		uppercase letters. Thus, the minute improvement we can make to the vowel
		counter is changing the order of the test cases:
	</p>
	<figure>
		<ol class="alg">
			<li>${f}$ vowelCount(char S[]):</li>
			<ol>
				<li>int vowelCount = 0;</li>
				<li>for (int i = 0; S[i] != '\0'; i++):</li>
				<ol>
					<li>if (</li>
					<ol>
						<li>S[i] = 'e' OR</li>
						<li>S[i] = 'a' OR</li>
						<li>S[i] = 'i' OR</li>
						<li>S[i] = 'o' OR</li>
						<li>S[i] = 'u' OR</li>
						<li>S[i] = 'E' OR</li>
						<li>S[i] = 'A' OR</li>
						<li>S[i] = 'I' OR</li>
						<li>S[i] = 'O' OR</li>
						<li>S[i] = 'U' OR ):</li>
						<ol>
							<li>vowelCount++;</li>
						</ol>
					</ol>
				</ol>
				<li>return vowelCount</li>
			</ol>
		</ol>
	</figure>
	<p>
		For the consonant counter, one modification we can make is to move the
		letter range conditions to the very beginning. Since lowercase letters are
		more likely to occur than uppercase letters, we'll test for those first,
		relying on the short-circuiting of the OR statement.
	</p>
	<figure>
		<ol class="alg">
			<li>${f}$ consonantCount(char S[]):</li>
			<ol>
				<li>int consonantCount = 0;</li>
				<li>for (int i = 0; S[i] != '\0'; i++):</li>
				<ol>
					<li>if (</li>
					<ol>
						<li>(97 <= S[i] AND S[i] <= 122) OR</li>
						<li>(65 <= S[i] AND S[i] <= 90):</li>
						<ol>
							<li>if (</li>
							<ol>
								<li>S[i] = 'e' OR</li>
								<li>S[i] = 'a' OR</li>
								<li>S[i] = 'i' OR</li>
								<li>S[i] = 'o' OR</li>
								<li>S[i] = 'u' OR</li>
								<li>S[i] = 'E' OR</li>
								<li>S[i] = 'A' OR</li>
								<li>S[i] = 'I' OR</li>
								<li>S[i] = 'O' OR</li>
								<li>S[i] = 'U' OR ):</li>
								<ol>
									<li>continue;</li>
								</ol>
							</ol>
							<li>else: constantCount++;</li>
						</ol>
					</ol>
				</ol>
				<li>return consonantCount</li>
			</ol>
		</ol>
	</figure>
</section>

<section id="word_counter">
	<h2>Word Counter</h2>
	<p>
		Word count is a metric we encounter frequently. Word limits, word minimums,
		mean word count &mdash; these are properties that all rely on counting
		words. Consider this short sentence from the New York case
		<span class="italicsText">Stambovsky v. Ackley</span>, 169 A.D.2d 254 (N.Y.
		App. Div. 1991):<label for="contracts" class="margin-toggle"
			><sup></sup
		></label>
		<input
			type="checkbox"
			id="contracts"
			class="margin-toggle sidenote-number"
		/>
		<span class="marginnote"
			>Known as the &#8220;Ghostbusters ruling,&#8221;
			<span class="italicsText">Stambovsky</span> is a staple reading in U.S.
			contracts courses. The case concerned a buyer, Stambovsky, asking the
			court to rescind her contract purchasing a home from the seller, Ackley.
			Ackley failed to disclose that the home was haunted, despite perpetuating
			to locals the existence of poltergeists on the premises. The court found
			that Ackley was obligated to inform Stambovsky (a non-local) of the
			haunting and rescinded the contract.</span
		>
	</p>
	<pre class="language-c"><code>
		char S[] = "As a matter of law, the house is haunted."
	</code></pre>
	<p>
		To count the number of words in this sentence, we rely on the premise that
		each word is separated by a space:
	</p>
	<figure>
		<div>
			<p>
				${\small \text{As} \underbrace{~}_{\text{1}} \text{a}
				\underbrace{~}_{\text{2}} \text{matter} \underbrace{~}_{\text{3}}
				\text{of} \underbrace{~}_{\text{4}} \text{law,}
				\underbrace{~}_{\text{5}} \text{the} \underbrace{~}_{\text{6}}
				\text{house} \underbrace{~}_{\text{7}} \text{is}
				\underbrace{~}_{\text{8}} \text{haunted.}}$
			</p>
		</div>
	</figure>
	<p>
		Examining the above, we see that before and after each space is a word.
		Thus, all we must do is create a counter, and increment it whenever we
		encounter a space character. More explicitly:
	</p>
	<figure>
		<ol class="recipe">
			<li>Let ${w}$ be the number of words in the string ${S.}$</li>
			<li>
				Iterate over each character in the string, from ${i = 0}$ to ${i = n,}$
				where ${n}$ is the size of ${S.}$
			</li>
			<li>If ${S_i \neq \text{NUL},}$ proceed. Else, go to step 6.</li>
			<li>If ${S_i}$ is a space:</li>
			<ol>
				<li>Increment ${w.}$</li>
				<li>Increment ${i.}$</li>
				<li>Return to step 3.</li>
			</ol>
			<li>Else:</li>
			<ol>
				<li>Increment ${i.}$</li>
				<li>Return to step ${3.}$</li>
			</ol>
			<li>Return ${w + 1.}$ ${\blacksquare}$</li>
		</ol>
	</figure>
	<p>Implementing this algorithm:</p>
	<figure>
		<ol class="alg">
			<li>${f}$ wordCount(char S[]):</li>
			<ol>
				<li>int nWords = 1;</li>
				<li>for (int i = 0; S[i] != '\0'; i++):</li>
				<ol>
					<li>if (A[i] == ' '):</li>
					<ol>
						<li>nWords++;</li>
					</ol>
				</ol>
				<li>return nWords + 1;</li>
			</ol>
		</ol>
	</figure>
	<p>
		The algorithm above has several limitations. For one, it doesn't address the
		possibility of a string containing consecutive spaces. The consecutive
		space, when encountered, would be counted as a word. Fortunately, the patch
		is simple &mdash; ensure that the previous element is
		<span class="underlineText">not</span> a space character:
	</p>
	<figure>
		<ol class="alg">
			<li>${f}$ wordCount(char S[]):</li>
			<ol>
				<li>int nWords = 1;</li>
				<li>for (int i = 0; S[i] != '\0'; i++):</li>
				<ol>
					<li>if ((A[i] == ' ') AND (A[i--] != ' ')):</li>
					<ol>
						<li>nWords++;</li>
					</ol>
				</ol>
				<li>return nWords + 1;</li>
			</ol>
		</ol>
	</figure>
	<div class="demo">
		<div class="options">
			<button>C++</button>
			<button>Java</button>
		</div>
		<div class="implementation">
			<p>Here is a C++ implementation.</p>
			<pre class="language-cpp"><code>
				int main() {
					return 0;
				}
			</code></pre>
		</div>
		<div class="implementation">
			<pre class="language-java"><code>
				public class main() {
					return 0;
				}
			</code></pre>
		</div>
	</div>
</section>

<section id="string_validation">
	<h2>String Validations</h2>
	<p>
		The process of <span class="term">string validation</span> is to compare a
		string against a set criteria, and determining whether the string is
		compliant. For example, a website might not permit usernames with special
		symbols like <span class="monoText">*</span> and
		<span class="monoText">%</span>. Alternatively, a service may require such
		special symbols in the password, alongside digits and uppercase letters. To
		ensure compliance, we subject to a given string to a
		<span class="term">string validator</span>.
	</p>
</section>

<!-- <section id="proper_casing">
	<h2>Propercasing</h2>
</section> -->
{% endblock %}
