{% load static %}
<h2>Sorted Test</h2>
<p>
	Many algorithms on linked lists depend on whether a given linked list
	is sorted. By sorted linked list, we mean a linked list whose data
	fields are sorted according to a particular criteria. Most often, that
	criteria is numeric. For example, the following linked list is sorted:
</p>
<ul class="linkedlist">
	<ul>
		<li>
			<div>3</div>
			<div>0x200</div>
			<div>0x100</div>
		</li>
	</ul>
	<ul>
		<li>
			<div>5</div>
			<div>0x300</div>
			<div>0x200</div>
		</li>
	</ul>
	<ul>
		<li>
			<div>8</div>
			<div>0x400</div>
			<div>0x300</div>
		</li>
	</ul>
	<ul>
		<li>
			<div>12</div>
			<div>0x500</div>
			<div>0x400</div>
		</li>
	</ul>
	<ul>
		<li>
			<div>16</div>
			<div>0</div>
			<div>0x500</div>
		</li>
	</ul>
</ul>
<p>
	To determine if a linked list is sorted, we use a <b>sorted test</b>.
	The procedure is as follows:
</p>
<ol>
	<li>
		<p>
			First, we have a pointer to the first node, and some variable
			${m,}$ set to the smallest possible valube for the linked list's
			type. For example, with <var>int</var>, the smallest possible value
			is <var>-32768</var>. With a pointer on the first node, we check if
			${m < n(3)?}$
		</p>
		<ul class="linkedlist">
			<ul class="rhl">
				<li>
					<div>3</div>
					<div>0x200</div>
					<div><span class="redText">p</span></div>
				</li>
			</ul>
			<ul>
				<li>
					<div>5</div>
					<div>0x300</div>
					<div>0x200</div>
				</li>
			</ul>
			<ul>
				<li>
					<div>8</div>
					<div>0x400</div>
					<div>0x300</div>
				</li>
			</ul>
			<ul>
				<li>
					<div>12</div>
					<div>0x500</div>
					<div>0x400</div>
				</li>
			</ul>
			<ul>
				<li>
					<div>16</div>
					<div>0</div>
					<div>0x500</div>
				</li>
			</ul>
		</ul>
	</li>
	<li>
		<p>
			Clearly yes. So, we change ${m = 3,}$ move the pointer to the next
			node, and test, ${3 < n(5)?}$
		</p>
		<ul class="linkedlist">
			<ul>
				<li>
					<div>3</div>
					<div>0x200</div>
					<div>0x100</div>
				</li>
			</ul>
			<ul class="rhl">
				<li>
					<div>5</div>
					<div>0x300</div>
					<div><span class="redText">p</span></div>
				</li>
			</ul>
			<ul>
				<li>
					<div>8</div>
					<div>0x400</div>
					<div>0x300</div>
				</li>
			</ul>
			<ul>
				<li>
					<div>12</div>
					<div>0x500</div>
					<div>0x400</div>
				</li>
			</ul>
			<ul>
				<li>
					<div>16</div>
					<div>0</div>
					<div>0x500</div>
				</li>
			</ul>
		</ul>
	</li>
	<li>
		<p>
			Once more, yes. We mutate ${m}$ to ${m = 5,}$ and we move to the
			next node. Test again: Is ${5 < n(8)?}$
		</p>
		<ul class="linkedlist">
			<ul>
				<li>
					<div>3</div>
					<div>0x200</div>
					<div>0x100</div>
				</li>
			</ul>
			<ul>
				<li>
					<div>5</div>
					<div>0x300</div>
					<div>0x200</div>
				</li>
			</ul>
			<ul class="rhl">
				<li>
					<div>8</div>
					<div>0x400</div>
					<div><span class="redText">p</span></div>
				</li>
			</ul>
			<ul>
				<li>
					<div>12</div>
					<div>0x500</div>
					<div>0x400</div>
				</li>
			</ul>
			<ul>
				<li>
					<div>16</div>
					<div>0</div>
					<div>0x500</div>
				</li>
			</ul>
		</ul>
	</li>
	<li>
		<p>
			Once again, yes. We modify ${m}$ to ${m = 8,}$ and we move to the
			next node. Test: ${8 < 12?}$
		</p>
		<ul class="linkedlist">
			<ul>
				<li>
					<div>3</div>
					<div>0x200</div>
					<div>0x100</div>
				</li>
			</ul>
			<ul>
				<li>
					<div>5</div>
					<div>0x300</div>
					<div>0x200</div>
				</li>
			</ul>
			<ul>
				<li>
					<div>8</div>
					<div>0x400</div>
					<div>0x300</div>
				</li>
			</ul>
			<ul class="rhl">
				<li>
					<div>12</div>
					<div>0x500</div>
					<div><span class="redText">p</span></div>
				</li>
			</ul>
			<ul>
				<li>
					<div>16</div>
					<div>0</div>
					<div>0x500</div>
				</li>
			</ul>
		</ul>
	</li>
	<li>
		<p>Yes. Now ${m = 12.}$ Move to the next and test: ${12 < 16?}$</p>
		<ul class="linkedlist">
			<ul>
				<li>
					<div>3</div>
					<div>0x200</div>
					<div>0x100</div>
				</li>
			</ul>
			<ul>
				<li>
					<div>5</div>
					<div>0x300</div>
					<div>0x200</div>
				</li>
			</ul>
			<ul>
				<li>
					<div>8</div>
					<div>0x400</div>
					<div>0x300</div>
				</li>
			</ul>
			<ul>
				<li>
					<div>12</div>
					<div>0x500</div>
					<div>0x400</div>
				</li>
			</ul>
			<ul class="rhl">
				<li>
					<div>16</div>
					<div>0</div>
					<div><span class="redText">p</span></div>
				</li>
			</ul>
		</ul>
		<p>
			Yes. We've reached the end of the list, so we can determine the
			list is sorted. If any point we found that ${m \nleq n(d),}$ we
			would have concluded that the list is not sorted.
		</p>
	</li>
</ol>
<p>In pseudocode:</p>
<figure>
	<ol class="alg">
		<li>fn isSorted(Node* head) -> boolean</li>
		<ol>
			<li>int currentMin = MIN_INT;</li>
			<li>Node* p = head;</li>
			<li>while (p != NULL):</li>
			<ol>
				<li>if (p->data < currentMin):</li>
				<ol>
					<li>return false;</li>
				</ol>
				<li>else:</li>
				<ol>
					<li>currentMin = p->data;</li>
					<li>p = p->next;</li>
				</ol>
			</ol>
			<li>return true;</li>
		</ol>
	</ol>
</figure>
<div class="demo">
	<button>C++</button>
	<div class="implementation">
		<p>Here's an implementation in C++:</p>
		<pre class="language-cpp"><code>
			bool isSorted() {
				int min = INT_MIN;
				Node* p = head;
				while (p != NULL) {
					if (p->data < min) {
						return false;
					} else {
						min = p->data;
						p = p->next;
					}
				}
				return true;
		</code></pre>
		<p>Testing this implementation:</p>
		<pre class="language-cpp"><code>
			#include &lt;iostream&gt;
			#include &lt;stdbool.h&gt;
			
			struct Node {
				int data;
				Node* next;
				Node() {
					data = 0;
					next = NULL;
				}
				Node(int newData) {
					data = newData;
					next = NULL;
				}
			};
			
			class List {
				Node* head;
				Node* foot;
				public:
					List() {
						head = new Node();
						foot = head;
					}
					List(int data) {
						head = new Node(data);
						foot = head;
					}
					List(int arr[], int size) {
						head = new Node(arr[0]);
						foot = head;
						for (int i = 1; i < size; i++) {
							Node* freshNode = new Node(arr[i]);
							foot->next = freshNode;
							foot = freshNode;
						}
					}
					bool isSorted() {
						int min = INT_MIN;
						Node* p = head;
						while (p != NULL) {
							if (p->data < min) {
								return false;
							} else {
								min = p->data;
								p = p->next;
							}
						}
						return true;
					}
					void print() {
						Node* p = NULL;
						std::cout << "( ";
						if (head != NULL) {
							p = head;
							while (p->next != NULL) {
								std::cout << p->data << " ";
								p = p->next;
							}
						} else {
							std::cout << "empty";
						}
						std::cout << ")\n";
					}
			};
			
			int main() {
				int arr1[] = {1,2,3,4,5};
				int arr2[] = {1,2,8,4,5};
				List aList = List(arr1, 5);
				List bList = List(arr2, 5);
				aList.print();
				bList.print();
				std::cout << "Sorted: " << aList.isSorted() << std::endl;
				std::cout << "Sorted: " << bList.isSorted() << std::endl;
				return 0;
			}
		</code></pre>
		<pre class="language-bash"><code>
			( 1 2 3 4 )
			( 1 2 8 4 )
			Sorted: 1
			Sorted: 0
		</code></pre>
	</div>
</div>
