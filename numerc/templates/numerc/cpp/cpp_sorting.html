{% extends '../layout.html' %} {% load static %} {% block description %}
<meta
	name="description"
	content="Sorting algorithms: Selection sort, insertion sort, bubble sort, merge sort"
/>
{% endblock %} {% block title %}
<title>C++ Sorting Algorithms</title>
{% endblock %} {% block content %}

<h1>Sorting Algorithms</h1>
<section id="intro">
	<p>
		In this article, we examine several sorting algorithms. Sorting is the
		process of rearranging the elements of a collection, such that the
		elements follow some well-defined order. For example:
	</p>
	<figure>
		<table class="alg">
			<thead>
				<th>Collection</th>
				<th>Sort</th>
				<th>Result</th>
			</thead>
			<tbody>
				<tr>
					<td><var>[1, 3, 2, 5, 4]</var></td>
					<td>ascending</td>
					<td><var>[1, 2, 3, 4, 5]</var></td>
				</tr>
				<tr>
					<td><var>[1, 3, 2, 5, 4]</var></td>
					<td>descending</td>
					<td><var>[5, 4, 3, 2, 1]</var></td>
				</tr>
				<tr>
					<td><var>[c, a, d, b]</var></td>
					<td>alphabetical</td>
					<td><var>[a, b, c, d]</var></td>
				</tr>
				<tr>
					<td><var>[c, a, d, b]</var></td>
					<td>zetabetical</td>
					<td><var>[d, c, b, a]</var></td>
				</tr>
			</tbody>
		</table>
	</figure>
	<p>
		Sorting algorithms are ambivalent with respect to the order we decided
		on. As long as we have a well-defined rule for what the order is, the
		algorithms we'll examine are applicable. To keep things simple, we'll
		focus on numbers, but occassionally consider how using numbers
		naturally leads to other orders: Sorting by release year, sorting by
		price, sorting by reviews, sorting alphabetically, and so on.
	</p>
</section>

<section id="elementary_algorithms">
	<h2>Elementary Sorting Algorithms</h2>
	<p>
		In the following sections, we examine the elementary sorting
		algorithms: <i>bubble sort</i>, <i>selection sort</i>, and
		<i>insertion sort</i>.
	</p>
	<section id="bubble_sort">
		<h3>Bubble Sort</h3>
		<p>
			The first sorting algorithm we examine is <b>bubble sort</b>. The
			algorithm's name is derived from the fact that elements appear to
			bubble to the top as they're sorted. To illustrate, suppose we have
			the following unsorted collection, an array <var>A</var>, and we want
			to sort them in ascending order:
		</p>
		<figure class="block">
			<div id="bubble_sort_0"></div>
			<figcaption>The array <var>A</var></figcaption>
		</figure>
		<p>
			The algorithm works as follows. We start by comparing the first
			element and the element immediately after it (the second element). If
			the first element is greater than the second element, we swap. If the
			first element is less or equal to the second element, we leave the
			elements in place (no swapping). So, starting at the first and second
			elements:
		</p>
		<div id="bubble_sort_1"></div>
		<p>
			Here, we see that the first element is less than the second element,
			so we leave them as is. We move on to compare the second and third
			elements:
		</p>
		<div id="bubble_sort_2"></div>
		<p>
			The second element is greater than the third element, so we swap:
		</p>
		<div id="bubble_sort_3"></div>
		<p>
			Next, we compare the third and fourth elements. The third element is
			greater than the fourth element, so we swap:
		</p>
		<div id="bubble_sort_4"></div>
		<p>
			We've now gone through the entire array. This is our first pass.
			Notice that the largest element, <var>4</var>, <i>bubbled</i> to the
			top. Because the largest element is now at the end of the array, we
			do not have to perform a comparison against it. Now we go through a
			second pass:
		</p>
		<div id="bubble_sort_5"></div>
		<p>
			The first element is greater than the second element, so we swap:
		</p>
		<div id="bubble_sort_6"></div>
		<p>Then we compare the second and third elements:</p>
		<div id="bubble_sort_7"></div>
		<p>
			The second element is less than the third element, so no swap is
			performed. Because the fourth element is the largest element, we do
			not perform a comparison check. We also conclude that the next
			largest element, <var>3</var>, is in the correct position, so we do
			not perform a comparison against this element. Go through a third
			pass:
		</p>
		<div id="bubble_sort_8"></div>
		<p>
			We see that the the first element is less than the second element, so
			we do not perform a swap. This means that the next largest element,
			<var>2</var>, is in the correct position, and so too is <var>1</var>.
			This concludes our sort:
		</p>
		<div id="bubble_sort_9"></div>
		<div class="tabs">
			<ul>
				<li>Pseudocode</li>
				<li>JavaScript</li>
			</ul>
			<div class="pseudo">
				<p>
					Here, the <var>bubble_sort()</var> function has two parameters:
					An <var>array</var> of generic type, and a function labeled
					<var>order()</var> that returns a boolean. If the user does not
					supply the <var>order()</var> argument, we default to ascending
					order:
				</p>
				<ol class="alg">
					<li>bubble_sort(TYPE[] array, bool order()) -> TYPE[]:</li>
					<ol>
						<li>default order() = (a,b) => {return a &lt; b}</li>
						<li>var TYPE sortedArray = array</li>
						<li>var int i</li>
						<li>var int j</li>
						<li>for (i = length(sortedArray); i > 0; i--):</li>
						<ol>
							<li>for (j = 0; j &lt; i - 1; j++):</li>
							<ol>
								<li>
									if (!order(array[j], array[j + 1])) => swap(array, j)
								</li>
							</ol>
						</ol>
						<li>return sortedArray</li>
					</ol>
				</ol>
				<p>
					The code above has room for optimization. As it stands, our
					algorithm continues sorting to the end of the array. But that's
					not a requirement. The array could very well be sorted after the
					first pass &mdash; perhaps only two of the elements had to be
					swapped. Accordingly, we can make the following optimization:
				</p>
				<ol class="alg">
					<li>bubble_sort(TYPE[] array, bool order()) -> TYPE[]:</li>
					<ol>
						<li>default order() = (a,b) => {return a &lt; b}</li>
						<li>var TYPE sortedArray = array</li>
						<li>var int i</li>
						<li>var int j</li>
						<li>var bool noSwapsOccurred</li>
						<li>for (i = length(array); i > 0; i--):</li>
						<ol>
							<li>noSwapsOccurred = true</li>
							<li>for (j = 0; j &lt; i - 1; j++):</li>
							<ol>
								<li>if (!order(array[j], array[j + 1])):</li>
								<ol>
									<li>swap(array, j)</li>
									<li>noSwapsOccurred = false</li>
								</ol>
							</ol>
							<li>if (noSwapsOccurred) => break</li>
						</ol>
						<li>return sortedArray</li>
					</ol>
				</ol>
			</div>
			<div class="js">
				<p>Here's an implementation in JavaScript:</p>
				<pre class="language-javascript"><code>
					const bubbleSort = (arr) => {
						let sortedArray = deepCopy(arr);
						let end = sortedArray.length;
						let noSwapsOccurred;
						for (let i = end; i > 0; i--) {
							noSwapsOccurred = true;
							for (let j = 0; j &lt; i - 1; j++) {
								if (sortedArray[j] > sortedArray[j + 1]) {
									swap(sortedArray, j);
									noSwapsOccurred = false;
								}
							}
							if (noSwapsOccurred) break;
						}
						return sortedArray;
					};
				</code></pre>
				<p>
					Note that two auxiliary functions are used in the code above. The
					<var>deepCopy()</var> function generates a deep copy of the array
					object, and the <var>swap()</var> function performs the swapping:
				</p>
				<pre class="language-javascript"><code>
					// deepCopy() function
					const deepCopy = (inputObject) => {
						if (typeof inputObject !== "object" || inputObject === null) {
							return inputObject;
						}
						const outputObject = Array.isArray(inputObject) ? [] : {};
						for (let key in inputObject) {
							const value = inputObject[key];
							outputObject[key] = deepCopy(value);
						}
						return outputObject;
					};
					
					// swap() function
					const swap = (arr, j) => {
						let temp = arr[j];
						arr[j] = arr[j + 1];
						arr[j + 1] = temp;
					};
				</code></pre>
				<p>Testing:</p>
				<pre class="language-javascript"><code>
					const arr1 = [1, 3, 4, 2, 5];
					const arr2 = [2, 3, 5, 1, 4];
					const expected = [1, 2, 3, 4, 5];
	
					const test1 = new Test(bubbleSort(arr1), expected, "first test");
					const test2 = new Test(bubbleSort(arr2), expected, "second test");
					test1.run();
					test2.run();
				</code></pre>
				<pre class="language-bash"><code>
					first test passed 
						result: 1,2,3,4,5 
						expected: 1,2,3,4,5
					second test passed 
						result: 1,2,3,4,5 
						expected: 1,2,3,4,5
				</code></pre>
				<p>
					We can make our bubble sort more generic by having the user pass
					a function to specify the order they want the elements sorted. If
					an order isn't specified, we default to ascending order:
				</p>
				<pre class="language-javascript"><code>
					const bubbleSort = (arr, order = (a, b) => {return a &lt; b}) => {
						let sortedArray = deepCopy(arr);
						let end = sortedArray.length;
						let noSwapsOccurred;
						for (let i = end; i > 0; i--) {
							noSwapsOccurred = true;
							for (let j = 0; j &lt; i - 1; j++) {
								if (!order(sortedArray[j], sortedArray[j+1])) {
									swap(sortedArray, j);
									noSwapsOccurred = false;
								}
							}
							if (noSwapsOccurred) break;
						}
						return sortedArray;
					};
				</code></pre>
				<p>Testing:</p>
				<pre class="language-javascript"><code>
					const arr1 = [1,3,4,2,5];
					const arr1Sorted = bubbleSort(arr1)
					const expectedArr1 = [1,2,3,4,5];
					const arr2 = [2,3,5,1,4];
					const arr2Sorted = bubbleSort(arr2, (a, b) => {return a > b})
					const expectedArr2 = [5,4,3,2,1];
					
					const test1 = new Test(arr1Sorted, expectedArr1, "first test");
					const test2 = new Test(arr2Sorted, expectedArr2, "second test");
					test1.run();
					test2.run();
				</code></pre>
				<pre class="language-bash"><code>
					first test passed 
						result: 5,4,3,2,1 
						expected: 5,4,3,2,1
					second test passed 
						result: 1,2,3,4,5 
						expected: 1,2,3,4,5
				</code></pre>
			</div>
		</div>
	</section>

	<section id="selection_sort">
		<h3>Selection Sort</h3>
		<p>
			With bubble sort, we saw that in the worst-case scenario, the
			algorithm takes ${O(n^2)}$ time. This is not ideal. Let's consider
			another algorithm, <b>selection sort</b>. Once again, we'll
			illustrate with a simple example. Suppose we have the following
			unordered collection, an array called <var>A</var>:
		</p>
		<figure class="block">
			<div id="selection_sort_0"></div>
			<figcaption>The array <var>A</var></figcaption>
		</figure>
		<p>
			Selection sort works as follows. First, we go iterate over the
			collection, looking for the smallest value. To do so, we create a
			variable called <var>min</var>, and set it initially as
			<var>A[0]</var>:
		</p>
		<div id="selection_sort_1"></div>
		<p>
			Then, we compare the next element against the current <var>min</var>.
			If the next element is less than the current <var>min</var>, we set
			that element as the new <var>min</var>. In this case, comparing
			<var>A[1] &lt; min</var>, we get <var>true</var>, since
			<var>1 &lt; 4</var>. <var>1</var> is now our new <var>min</var>:
		</p>
		<div id="selection_sort_2"></div>
		<p>Now we compare <var>min</var> against <var>A[2]</var>:</p>
		<div id="selection_sort_2_1"></div>
		<p>
			Here, we get <var>false</var>, since <var>3 &nlt; 1</var>. So, we
			leave <var>A[2]</var> as is. Next, we compare <var>min</var> against
			<var>A[3]</var>:
		</p>
		<div id="selection_sort_2_2"></div>
		<p>
			Again we get <var>false</var>, so we leave <var>A[3]</var> as is.
			Compare <var>A[4]</var> against <var>min</var>:
		</p>
		<div id="selection_sort_2_3"></div>
		<p>
			False again, leave <var>A[4]</var> as is. Once we get to the last
			element in the collection, we've gone through one pass. Having done
			so, we swap <var>min</var> and the starting point of our first pass,
			the first element:
		</p>
		<div id="selection_sort_3"></div>
		<p>
			Making this swap, the smallest element is now in the correct place.
			So, we proceed to our second pass, starting at the second element. We
			set that element as <var>min</var>:
		</p>
		<div id="selection_sort_4"></div>
		<p>
			Compare <var>min</var> against the next element, <var>A[2]</var>.
		</p>
		<div id="selection_sort_4_1"></div>
		<p>
			We get <var>true</var> &mdash; <var>3 &lt; 4</var>. Set
			<var>A[2]</var> as the new <var>min</var>:
		</p>
		<div id="selection_sort_5"></div>
		<p>Compare <var>min</var> against the next element:</p>
		<div id="selection_sort_5_1"></div>
		<p>
			False: <var>5 &nlt; 3</var>. Leave <var>A[3]</var> as is. Compare
			<var>min</var> against the next element:
		</p>
		<div id="selection_sort_5_2"></div>
		<p>
			True: <var>2 &lt; 3</var>. <var>A[4]</var> is now the new
			<var>min</var>. We've reached the end of the collection. So, we swap
			the <var>min</var> with the starting element of our pass:
		</p>

		<div id="selection_sort_6"></div>
		<p>
			Enter another pass, starting at <var>A[2]</var>, and set that as the
			new <var>min</var>:
		</p>
		<div id="selection_sort_7"></div>
		<p>
			Compare <var>min</var> against the next element, <var>A[3]</var>:
		</p>
		<div id="selection_sort_7_1"></div>
		<p>
			We get false. <var>5 &nlt; 3</var>. Compare <var>min</var> against
			the next element, <var>A[4]</var>:
		</p>
		<div id="selection_sort_7_2"></div>
		<p>
			Again false. So, <var>A[2]</var> is in the correction position. We
			enter our next pass, starting at <var>A[3]</var>, setting
			<var>A[3]</var> as the new <var>min</var>:
		</p>
		<div id="selection_sort_7_3"></div>
		<p>
			Comparing <var>min</var> against the next element, <var>A[4]</var>:
		</p>
		<div id="selection_sort_7_4"></div>
		<p>
			We get <var>true</var>: <var>4 &lt; 5</var>. So, we set
			<var>A[4]</var> as the new <var>min</var>:
		</p>
		<div id="selection_sort_7_5"></div>
		<p>
			We've reached the end of our collection, so we swap. Doing so, our
			collection is now sorted:
		</p>
		<div id="selection_sort_7_6"></div>
		<div class="tabs">
			<ul>
				<li>Pseudocode</li>
				<li>JavaScript</li>
			</ul>
			<div class="pseudo">
				<ol class="alg">
					<li>selection_sort(TYPE[] array, bool order()) -> TYPE[]:</li>
					<ol>
						<li>default order() = (a,b) => {return a &lt; b}</li>
						<li>var TYPE sorted_array := array</li>
						<li>uint length := length(sorted_array)</li>
						<li>var uint i</li>
						<li>var uint j</li>
						<li>for (i := 0; i &lt; length; i++):</li>
						<ol>
							<li>let uint min := i</li>
							<li>for (j := 0; j &lt; length; j++):</li>
							<ol>
								<li>
									if (order(sorted_array[j], sorted_array[min])) => min :=
									j
								</li>
							</ol>
							<li>swap(sorted_array[i], sorted_array[min])</li>
						</ol>
						<li>return sorted_array</li>
					</ol>
				</ol>
			</div>
			<div class="javascript">
				<p>In JavaScript:</p>
				<pre class="language-javascript"><code>
					const selectionSort = (array, order = (a,b) => {return a &lt; b}) => {
						const sortedArray = Utils.deepCopy(array);
						const length = sortedArray.length;
						for (let i = 0; i &lt; length; i++) {
							let min = i;
							for (let j = i + 1; j &lt; length; j++) {
								if (order(sortedArray[j], sortedArray[min])) {
									min = j;
								}
							}
							Utils.swap(sortedArray, i, min)
						}
						return sortedArray;
					};
				</code></pre>
				<p>
					The code above uses two utility functions,
					<var>deepCopy()</var> and <var>swap()</var>, contained in a
					module called <var>Utils.mjs</var>:
				</p>
				<pre class="language-javascript"><code>
					class Utils {
						static deepCopy(inputObject) {
							if (typeof inputObject !== "object" || inputObject === null) {
								return inputObject;
							}
							const outputObject = Array.isArray(inputObject) ? [] : {};
							for (let key in inputObject) {
								const value = inputObject[key];
								outputObject[key] = this.deepCopy(value);
							}
							return outputObject;
						}
					
						static swap = (arr = null, a, b) => {
							if (arr !== null) {
								let temp = arr[a];
								arr[a] = arr[b];
								arr[b] = temp;
							} else {
								let temp = a;
								a = b;
								b = temp;
							}
						};
					}
					
					export default Utils;
				</code></pre>
				<p>Testing:</p>
				<pre class="language-javascript"><code>
					import Test from "../test/test.mjs";
	
					const arr1 = [3, 2, 1, 4, 5];
					const sortedArr1 = selectionSort(arr1);
					const expected1 = [1, 2, 3, 4, 5];
					const sortedArr2 = selectionSort(arr1, (a, b) => {return a > b});
					const expected2 = [5, 4, 3, 2, 1];
	
					const test1 = new Test(sortedArr1, expected1, "First test");
					const test2 = new Test(sortedArr2, expected2, "Second test");
					test1.run();
					test2.run();
				</code></pre>
				<pre class="language-bash"><code>
					First test passed
						result: 1,2,3,4,5
						expected: 1,2,3,4,5
					
					
					Second test passed
						result: 5,4,3,2,1
						expected: 5,4,3,2,1
				</code></pre>
			</div>
		</div>
	</section>

	<section id="insertion_sort">
		<h3>Insertion Sort</h3>
		<p>
			The third elementary sorting algorithm is <b>insertion sort</b>. With
			insertion sort, the unsorted collection consists of two portions: A
			sorted portion, and an unsorted portion. The idea: Gradually build
			the sorted portion by comparing each element against the last element
			placed in the sorted portion. Let's illustrate with an example.
		</p>
		<p>
			Suppose we have the following unordered collection, an array
			<var>A</var>, and we want to sort in ascending order:
		</p>
		<figure class="block">
			<div id="insort_0"></div>
			<figcaption>The array <var>A</var></figcaption>
		</figure>
		<p>
			We start by assuming the first element, <var>A[0] = 2</var>, is
			sorted.
		</p>
		<figure class="block">
			<div id="insort_1"></div>
			<figcaption>Assume <var>A[0]</var> is sorted.</figcaption>
		</figure>
		<p>
			We then compare the next element, <var>A[1] = 5</var> against the
			last sorted element (in this case, <var>A[0]</var>). The comparison
			is whether <var>A[0]</var> is greater than <var>A[1]</var>. If it is,
			then swap and continue comparing until we find a smaller element.
		</p>
		<figure class="block">
			<div id="insort_2"></div>
			<figcaption>Compare <var>A[1]</var> and <var>A[0]</var></figcaption>
		</figure>
		<p>
			Here, <var>A[1]</var> is in the correct position, since
			<var>5 &gt; 2</var>. So, we leave it as is, and assume it's sorted.
		</p>
		<figure class="block">
			<div id="insort_3"></div>
			<figcaption>
				<var>A[1]</var> is now in the sorted partition.
			</figcaption>
		</figure>
		<p>
			Then we move to the next element, <var>A[2]</var>. Again we compare:
		</p>
		<figure class="block">
			<div id="insort_4"></div>
			<figcaption><var>A[2] &gt; A[1]</var>?</figcaption>
		</figure>
		<p>
			Here, we get false. <var>3 &ngt; 5</var>. So, we swap
			<var>A[2]</var> and <var>A[1]</var>, followed by comparing
			<var>A[1]</var> against <var>A[0]</var>:
		</p>
		<figure class="block">
			<div id="insort_5"></div>
			<figcaption><var>A[2] &gt; A[0]</var>?</figcaption>
		</figure>
		<p>We get true, so we stop. Now we have three elements sorted:</p>
		<figure class="block">
			<div id="insort_6"></div>
			<figcaption>Swap <var>A[2]</var> and <var>A[0+1]</var></figcaption>
		</figure>
		<p>
			Go to the next element, <var>A[3]</var>, and compare it against the
			last element in the sorted partition:
		</p>
		<figure class="block">
			<div id="insort_7"></div>
			<figcaption><var>A[3] &gt; A[2]</var>?</figcaption>
		</figure>
		<p>False. Swap and compare it against the next element:</p>
		<figure class="block">
			<div id="insort_8"></div>
			<figcaption><var>A[3] &gt; A[1]</var>?</figcaption>
		</figure>
		<p>True. Leave the element there. Now we have four elements sorted:</p>
		<figure class="block">
			<div id="insort_9"></div>
			<figcaption><var>A[3] &gt; A[1]</var>?</figcaption>
		</figure>
		<p>
			Move to the next element, <var>A[4]</var>, and compare it against the
			last element in the sorted partition:
		</p>
		<figure class="block">
			<div id="insort_10"></div>
			<figcaption><var>A[4] &gt; A[3]</var>?</figcaption>
		</figure>
		<p>False. Swap and compare it against the next element:</p>
		<figure class="block">
			<div id="insort_11"></div>
			<figcaption><var>A[3] &gt; A[2]</var>?</figcaption>
		</figure>
		<p>False. Swap and compare it against the next element:</p>
		<figure class="block">
			<div id="insort_12"></div>
			<figcaption><var>A[2] &gt; A[1]</var>?</figcaption>
		</figure>
		<p>False again. Swap and compare it against the last element:</p>
		<figure class="block">
			<div id="insort_13"></div>
			<figcaption><var>A[1] &gt; A[0]</var>?</figcaption>
		</figure>
		<p>
			False again. So swap. At this point we've gone through all of the
			elements, so our sorting concludes:
		</p>
		<figure class="block">
			<div id="insort_14"></div>
			<figcaption>Sorted</figcaption>
		</figure>

		<section id="implementation">
			<h4>Implementation</h4>
			<div class="tabs">
				<ul>
					<li>Pseudocode</li>
					<li>JavaScript</li>
				</ul>
				<div class="pseudo">
					<ol class="alg">
						<li>
							insertion_sort(TYPE array, bool order()) -> TYPE array:
						</li>
						<ol>
							<li>var TYPE sorted_list = clone(list)</li>
							<li>const end = length(sorted_list)</li>
							<li>for (int i = 0; i &lt; end; i++):</li>
							<ol>
								<li>TYPE currentElement = sorted_list[i]</li>
								<li>var int j = i - 1</li>
								<li>
									while ( (j > 1) && (currentElement &lt; sorted_list[j])
									):
								</li>
								<ol>
									<li>sorted_list[j+1] = sorted_list[j]</li>
									<li>j--</li>
								</ol>
								<li>sorted_list[j+1] = currentElement</li>
							</ol>
							<li>return sorted_list</li>
						</ol>
					</ol>
				</div>
				<div class="js">
					<p>Here's an implementation in JavaScript:</p>
					<pre class="language-javascript"><code>
						import Utils from "../utilities/utils.js";
	
						const insertionSort = (list, order = (a, b) => { return a < b }) => {
							let sortedList = Utils.clone(list); // make a deep copy of the list
							const sortedListLength = sortedList.length;
							for (let i = 1; i &lt; sortedListLength; i++) {
								let currentElement = sortedList[i];
								let j = i - 1;
								while ((j > -1) && (order(currentElement, sortedList[j]))) {
									sortedList[j + 1] = sortedList[j];
									j--;
								}
								sortedList[j + 1] = currentElement;
							}
							return sortedList;
						}
					</code></pre>
				</div>
			</div>
		</section>

		<section id="time_complexity">
			<h4>Time Complexity</h4>
			<p>
				Like the bubble sort and selection sort, insertion sort requires
				iterating over the entire collection, and at each iteration, an
				iteration. Thus, selection sort has a time complexity, in the
				worst-case scenario, of ${O(n^2).}$ Indeed, the worst case scenario
				is if our collection's elements are completely reversed:
			</p>
			<figure>$$ \lang 5, 4, 3, 2, 1, 0 \rang $$</figure>
			<p>
				Insertion sort, however, performs well if the elements are nearly
				sorted. For example, if we have just one element out of place:
			</p>
			<figure>$$ \lang 1, 2, 3, 4, 5, 0 \rang $$</figure>
			<p>
				then we would only have to iterate over the collection once.
				Insertion sort also performs well if we have data coming in one at
				a time. For example, if we're steadily fed the numbers above,
				insertion sort can perform its comparisons as the data comes in.
			</p>
		</section>
	</section>

	<section id="summary">
		<h3>Summary</h3>
		<p>
			In sum, the elementary sorting algorithms all have a worst-case
			scenario time complexity of ${O(n^2).}$ Comparing each of these
			algorithms, we can see that selection sort fares the worst:
		</p>
		<figure class="block">
			<div id="elementary_sort_compare"></div>
			<figcaption>
				Red for ${O(n^2),}$ orange for ${O(n),}$ and green for ${O(1).}$
			</figcaption>
		</figure>
		<p>
			That said, the elementary algorithms work well in terms of space
			complexity. We do not need auxiliary data structures to perform the
			sort. Moreover, both insertion sort and bubble sort work best given
			small collections or nearly-sorted collections.
		</p>
	</section>
</section>

<section id="faster_algorithms">
	<h2>Faster Sorting Algorithms</h2>
	<p>
		Now that we have an understanding of the elementary sorting algorithms,
		we can now proceed to their more sophisticated and faster cousins.
	</p>

	<section id="merge_sort">
		<h3>Merge Sort</h3>
		<p>
			Invented in 1948 by one of the forebears of computer science &mdash;
			John von Neumann &mdash; merge sort is a fairly fast algorithm. The
			algorithm consists of two fundamental operations: (1) splitting, (2)
			merging, and (3) sorting. The algorithm relies on a basic assumption:
			an empty collection, or a collection of ${1,}$ is already sorted.
		</p>
		<p>Let's illustrate with the unsorted array <var>A</var>:</p>
		<figure class="block">
			<div id="msort_0"></div>
			<figcaption>The unsorted array <var>A</var></figcaption>
		</figure>
		<p>Merge sort begins by splitting the array <var>A</var> in half:</p>
		<div class="split">
			<figure class="block">
				<div id="msort_1"></div>
				<figcaption>Split the first partition</figcaption>
			</figure>
			<figure class="block">
				<div id="msort_2"></div>
				<figcaption>Split the second partition</figcaption>
			</figure>
		</div>
		<p>Then we split the resulting partitions in half:</p>
		<div class="split">
			<figure class="block">
				<div class="split">
					<div id="msort_3"></div>
					<div id="msort_4"></div>
				</div>
				<figcaption>Partition 1</figcaption>
			</figure>
			<figure class="block">
				<div class="split">
					<div id="msort_5"></div>
					<div id="msort_6"></div>
				</div>
				<figcaption>Partition 2</figcaption>
			</figure>
		</div>
		<p>And then again:</p>
		<div class="split">
			<div class="split">
				<div id="msort_7"></div>
				<div id="msort_8"></div>
				<div id="msort_9"></div>
				<div id="msort_10"></div>
			</div>
			<div class="split">
				<div id="msort_11"></div>
				<div id="msort_12"></div>
				<div id="msort_13"></div>
				<div id="msort_14"></div>
			</div>
		</div>
		<figcaption>Split into singletons</figcaption>
		<p>
			Once we've partitioned the entire collection into the individual
			elements, we begin the process of merging and sorting. Starting from
			left to right, we compare the number to the left with the number to
			the right and merge, with the smaller number coming first. Thus, for
			<var>[6]</var> and <var>[2]</var>, we get <var>[2, 6]</var>, for
			<var>[5] </var> and <var>[8]</var> we get <var>[5,8]</var> and so on:
		</p>
		<figure class="iblock">
			<div>
				<figure class="iblock">
					<div id="msort_15"></div>
					<div id="msort_16"></div>
				</figure>
				<div id="msort_17"></div>
			</div>
			<div>
				<figure class="iblock">
					<div id="msort_18"></div>
					<div id="msort_19"></div>
				</figure>
				<div id="msort_20"></div>
			</div>
			<div>
				<figure class="iblock">
					<div id="msort_21"></div>
					<div id="msort_22"></div>
				</figure>
				<div id="msort_23"></div>
			</div>
			<div>
				<figure class="iblock">
					<div id="msort_24"></div>
					<div id="msort_25"></div>
				</figure>
				<div id="msort_26"></div>
			</div>
		</figure>
		<figcaption>Merging two singletons into one</figcaption>
		<p>
			Notice how we now have four sorted arrays. We repeat the same
			process. Looking at the array <var>[2,6]</var> and the array
			<var>[5,8]</var>, we compare <var>2</var> against <var>5</var>.
			<var>2</var> is smaller, so that goes first. Then we compare
			<var>6</var> against <var>5</var>. <var>5</var> is smaller so that
			goes second. Then compare <var>6</var> against <var>8</var>.
			<var>6</var> is smaller, so that goes third, and <var>8</var> goes
			last.
		</p>
		<p>
			Performing this comparison on all four arrays, we get two sorted
			arrays:
		</p>
		<div class="split">
			<figure class="block">
				<div id="msort_27"></div>
				<figcaption>Sorted array 1</figcaption>
			</figure>
			<figure class="block">
				<div id="msort_28"></div>
				<figcaption>Sorted array 2</figcaption>
			</figure>
		</div>
		<p>
			The process repeats. Compare <var>2</var> against <var>1</var>.
			<var>1</var> is smaller so that goes first. Compare
			<var>2</var> against <var>3</var>. <var>2</var> is smaller, so that
			goes second. Compare <var>5</var> against <var>3</var>.
			<var>3</var> is smaller so that goes third. Compare
			<var>5</var> against <var>4</var>. <var>4</var> is smaller so that
			goes fourth. Performing all the comparisons, we end up with a sorted
			array:
		</p>
		<figure class="block">
			<div id="msort_29"></div>
			<figcaption>The sorted array <var>A</var></figcaption>
		</figure>

		<section id="implementation">
			<h4>Implementation</h4>
			<div class="tabs">
				<ul>
					<li>Pseudocode</li>
					<li>JavaScript</li>
				</ul>
				<div class="pseudo">
					<p>
						To implement the <var>merge_sort()</var> function, we first
						need an auxiliary function <var>merge()</var> to handle the
						merging:
					</p>
					<section class="pseuds">
						<ol class="alg">
							<li>
								merge(TYPE[] left_array, TYPE[] right_array, bool
								in_order()) -> TYPE[]:
							</li>
							<ol>
								<li>
									default in_order() := (a, b) -> { return a &lt; b }
								</li>
								<li>TYPE var result := []</li>
								<li>int var left_index := 0</li>
								<li>int var right_index := 0</li>
								<li>
									while (left_index &lt; length(left_array) && right_index
									&lt; length(right_array)):
								</li>
								<ol>
									<li>
										if (in_order(left_array(left_index),
										right_array(right_index))):
									</li>
									<ol>
										<li>append_to(result, left_array[left_index])</li>
										<li>left_index++</li>
									</ol>
									<li>else:</li>
									<ol>
										<li>append_to(result, right_array[right_index])</li>
										<li>right_index++</li>
									</ol>
								</ol>
								<li>while (left_index &lt; length(left_array)):</li>
								<ol>
									<li>append_to(result, left_array[left_index])</li>
									<li>left_index++</li>
								</ol>
								<li>while (right_index &lt; length(right_array)):</li>
								<ol>
									<li>append_to(result, right_array(right_index))</li>
									<li>right_index++</li>
								</ol>
								<li>return result</li>
							</ol>
						</ol>
						<ol class="algc">
							<li>
								Function signature. The function <var>merge()</var>
								takes three inputs: two arrays of generic
								<var>TYPE</var> and a boolean-output function, and returns
								one output: an array of generic <var>TYPE</var>.
							</li>
							<li>
								If the user doesn't supply the function argument, default
								to this function definition.
							</li>
							<li>
								Result is initially an empty array. The newly merged arrays
								are placed here.
							</li>
							<li>
								Since we're splitting the array in half, we need two
								indices to iterate through both halves.
								<var>left_index</var> keeps track of the left half.
							</li>
							<li>
								<var>right_index</var> keeps track of the right half.
							</li>
							<li>
								Iterate through both halves as long as there are elements
								in both. That is, as long as the left index is less than
								the left half's length, and the right index is less than
								the right half's length.
							</li>
							<li>
								Check: Is the current element in the left half is in the
								correct position relative to the current element in the
								right half? Here, <i>correct position</i> is defined
								according to the <var>in_order()</var> function, which
								defaults to ascending order if the user does not supply an
								order. Hence, in the default case, if the left half element
								is less than right half element, the left half element is
								in the correct position. In sum: If
								<var>in_order()</var> returns true, go to line 7.
								Otherwise, go to line 9.
							</li>
							<li>
								Append the left half element to the
								<var>result</var> array.
							</li>
							<li>Increment the left index.</li>
							<li>Go to line 10.</li>
							<li>
								Append the right half's element to the
								<var>result</var> array.
							</li>
							<li>
								Increment the right half's index and return to line 5
							</li>
							<li>
								After going through the array, there may be elements left
								over in the left half. If there are (the left index is
								still less than the left half's length), go to line 12.
								Otherwise, go to line 15.
							</li>
							<li>
								Append the current left half element to the
								<var>result</var> array.
							</li>
							<li>Increment the left half index and return to line 11.</li>
							<li>
								There may be elements left over in the right half. If there
								are (the right index is still less than the right half's
								length), go to line 16. Otherwise, go to line 17.
							</li>
							<li>
								Append the current right half element to the
								<var>result</var> array.
							</li>
							<li>Increment the left half index and return to line 15.</li>
							<li>Return the <var>result</var> array. END.</li>
						</ol>
					</section>
					<p>
						Once we have the <var>merge()</var> function, implementing
						<var>merge_sort()</var> comes down to recursion:
					</p>
					<ol class="alg">
						<li>
							merge_sort(TYPE[] array, bool in_order()) -> TYPE array:
						</li>
						<ol>
							<li>if (length(array) <= 1):</li>
							<ol>
								<li>return array;</li>
							</ol>
							<li>var uint start = 0</li>
							<li>var uint middle = floor(length(array) / 2)</li>
							<li>var uint end = length(array)</li>
							<li>
								TYPE left_array = merge_sort(clone(array, from:start,
								to:middle), in_order())
							</li>
							<li>
								TYPE right_array = merge_sort(clone(array, from:middle,
								to:end), in_order())
							</li>
							<li>return merge(left_array, right_array, in_order())</li>
						</ol>
					</ol>
				</div>
				<div class="js">
					<p>
						Here's an implementation in JavaScript. Note that there are
						several auxiliary functions used, namely the functions
						<var>arrayClone()</var>, <var>floor()</var>, and
						<var>merge()</var>.
					</p>
					<pre class="language-javascript"><code>
						import append from "../utilities/append.js";
						import arrayClone from "../utilities/arrayClone.js";
						import floor from "../utilities/floor.js";
						
						const merge = (leftArray, rightArray, order = (a, b) => {return a < b}) => {
							const result = [];
							let iL = 0;
							let iR = 0;
							while (iL < leftArray.length && iR < rightArray.length) {
								if (order(leftArray[iL],rightArray[iR])) {
									append(result, leftArray[iL]);
									iL++;
								} else {
									append(result, rightArray[iR]);
									iR++;
								}
							}
							while (iL < leftArray.length) {
								append(result, leftArray[iL]);
								iL++;
							}
							while (iR < rightArray.length) {
								append(result, rightArray[iR]);
								iR++;
							}
							return result;
						}
						
						
						const mergeSort = (list, order) => {
							if (list.length <= 1) {
								return list;
							}
							let mid   = floor(list.length / 2);
							let left  = mergeSort(arrayClone(list, 0, mid), order);
							let right = mergeSort(arrayClone(list, mid), order);
							return merge(left, right, order);
						};
						
						export default mergeSort;						
					</code></pre>
				</div>
			</div>
		</section>
	</section>

	<section id="quicksort">
		<h3>Quick Sort</h3>
		<p>Suppose we had the following unsorted array <var>A</var>:</p>
		<figure class="block">
			<div id="qsort0"></div>
			<figcaption>The unsorted array <var>A</var></figcaption>
		</figure>
		<p>
			First, we pick a random element in <var>A</var>. This is called the
			<var>pivot</var>. To keep things simple, let's just say we pick the
			first element, <var>5</var>. Mentally, we separate
			<var>pivot</var> from the other elements. All the other elements are
			in an array called <var>remains</var>.
		</p>
		<figure class="iblock">
			<div id="qsort1"></div>
			<div id="qsort2"></div>
		</figure>
		<figcaption>The unsorted array <var>A</var></figcaption>
		<p>
			Now we iterate over <var>remains</var>, comparing each element to the
			pivot. If the current element is less than the pivot, we place it an
			array called <var>left_of_pivot</var>, and if it's greater than the
			pivot, we place the element in an array called
			<var>right_of_pivot</var>. Making all of the comparisons, we end up
			with the following:
		</p>
		<figure class="iblock">
			<div id="qsort3"></div>
			<div id="qsort4"></div>
			<div id="qsort5"></div>
		</figure>
		<p>
			Notice that all of the elements are in place with respect to the
			pivot. This is how quicksort works. We pick a pivot, separate the
			elements, go to the resulting sets, pick a pivot, separate the
			elements, etc. So, we go the <var>left</var> set. We pick the first
			element as the pivot again, and separate. This gives us:
		</p>
		<figure class="iblock">
			<div id="qsort6"></div>
			<div id="qsort7"></div>
		</figure>
		<p>
			Comparing the pivot against each element in <var>remains</var>, we
			get:
		</p>
		<figure class="iblock">
			<div id="qsort8"></div>
			<div id="qsort9"></div>
			<div id="qsort10"></div>
		</figure>
		<p>
			At this point, we're reached three singletons. And what do we know
			about singletons? They're already sorted. Because these singletons
			are already sorted, we merge them into a single collection:
		</p>
		<div id="qsort11"></div>
		<p>
			Now we set <var>pivot</var> back to our very first pivot,
			<var>5</var>. This time, we have a sorted <var>left</var> and an
			unsorted <var>right</var>:
		</p>
		<figure class="iblock">
			<div id="qsort12"></div>
			<div id="qsort13"></div>
			<div id="qsort14"></div>
		</figure>
		<p>
			So, we focus on the <var>right</var>. We pick the first element as
			the pivot, and make the comparisons:
		</p>
		<figure class="iblock">
			<div id="qsort15"></div>
			<div id="qsort16"></div>
			<div id="qsort17"></div>
		</figure>
		<p>Each singleton is sorted, so we merge:</p>
		<div id="qsort18"></div>
		<p>Going back to our very first pivot, we now have:</p>
		<figure class="iblock">
			<div id="qsort19"></div>
			<div id="qsort20"></div>
			<div id="qsort21"></div>
		</figure>
		<p>Merging all of the sets together, we get:</p>
		<figure class="block">
			<div id="qsort22"></div>
			<figcaption>The sorted array <var>A</var></figcaption>
		</figure>
		<section id="implementation">
			<h4>Implementation</h4>

			<div class="tabs">
				<ul>
					<li>Pseudocode</li>
					<li>JavaScript</li>
				</ul>

				<div class="ps">
					<p>
						To implement quicksort, we first need a
						<var>partition()</var> function. This is the function we'll use
						to select a pivot and separate smaller elements to the pivot's
						left and larger elements to the pivot's right.
					</p>
					<ol class="alg">
						<li>
							pivot(TYPE[] array, uint start=0, uint end=array.length+1) ->
							array[]:
						</li>
						<ol>
							<li>TYPE let pivot = array[start]</li>
							<li>uint let swapIndex = start;</li>
							<li>for (let i = start + 1; i &lt; length(array); i++):</li>
							<ol>
								<li>if (pivot &gt; array[i]):</li>
								<ol>
									<li>swapIndex++</li>
									<li>swap(array[swapIndex], array[i])</li>
								</ol>
							</ol>
							<li>swap(array[start], array[swapIndex])</li>
							<li>return array</li>
						</ol>
					</ol>
					<p>
						To help clarify the code above, consider the following trace
						table:
					</p>
					<pre class="language-pseudo"><code>
						+----------------------------------------+
						| i = 1  | swapIndex = 0 | [5,9,4,3,1,7] |
						|        | 5 > 9?        | => false      |
						| i = 2  | swapIndex = 0 | [5,9,4,3,1,7] |
						|        | 5 > 4?        | => true       |
						| i = 2  | swapIndex = 1 | [5,9,4,3,1,7] | Swap: 9, 4
						| i = 3  | swapIndex = 1 | [5,4,9,3,1,7] |
						|        | 5 > 3?        | => true       |
						| i = 3  | swapIndex = 2 | [5,4,9,3,1,7] | Swap: 9, 3
						| i = 4  | swapIndex = 2 | [5,4,3,9,1,7] |
						|        | 5 > 1?        | => true       |
						| i = 4  | swapIndex = 3 | [5,4,3,9,1,7] | Swap: 9, 1
						| i = 5  | swapIndex = 3 | [5,4,3,1,9,7] |
						|        | 5 > 7?        | => false      |
						+----------------------------------------+
						|  breaking out of loop                  |
						+----------------------------------------+
						| start=0 | swapIndex = 3 |  Swap: 5, 1  |
						------------------------------------------
						|  Final  |         [1,4,3,5,9,7]        |
						+----------------------------------------+
					</code></pre>
				</div>
				<div class="js"></div>
			</div>
		</section>
	</section>
</section>

<section id="non_comparison_sorts">
	<h2>Non-Comparison Sorts</h2>
	<p>
		All of the algorithms we saw previously are examples of
		<i>comparison sorts</i> &mdash; sorting algorithms were compare one
		element against another.
	</p>
	<div id="radix0"></div>
</section>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script type="module" src="../../../static/numerc/csmd/csmd.mjs"></script>
<script
	type="module"
	src="../../../static/numerc/scripts/cpp_sorting.js"
></script>

{% endblock %}
