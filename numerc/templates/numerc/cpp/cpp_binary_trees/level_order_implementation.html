{% load static %}

<p>Consider the following tree (edge labels are pointer values):</p>
<div id="level_order_traversal_sample"></div>
<p>
	In level-order traversal, we traverse the tree's nodes level by level.
	Thus, for the tree above, we have the traversal:
</p>
<figure>$$ \lang 8, 3, 9, 7, 6, 4, 5, 2 \rang $$</figure>
<p>
	As with the other traversal methods, we can implement level-order
	traversal the tree by making use of queue.
</p>
<div class="pseudosource">
	<ol class="alg">
		<li>fn levelOrder(Node* root) -> void:</li>
		<ol>
			<li>Queue qeueue = newQueue();</li>
			<li>print((*root).data)</li>
			<li>enqueue(qeueue, root);</li>
			<li>while (!isEmpty(q)):</li>
			<ol>
				<li>root = dequeue(qeueue);</li>
				<li>if ((*root).leftChild):</li>
				<ol>
					<li>print((*(*root).leftChild).data);</li>
					<li>enqueue(queue, (*root).leftChild);</li>
				</ol>
				<li>if ((*root).rightChild):</li>
				<ol>
					<li>print((*(*root).rightChild).data);</li>
					<li>enqueue(queue, (*root).rightChild);</li>
				</ol>
			</ol>
		</ol>
	</ol>
	<ol class="algc">
		<li>Declare the function.</li>
		<li>Create a new empty queue.</li>
		<li>
			Print the <var>root</var>'s data. This is the first node in the
			tree, the root node.
		</li>
		<li>Enqueue <var>root</var> to the queue.</li>
		<li>
			As long as the queue is not empty, execute the following
			instructions. If the queue is empty, END.
		</li>
		<li>
			Dequeue the queue, and make <var>root</var> the dequeued value (a
			node).
		</li>
		<li>
			If the dequeued node has a left child, execute the instructions
			below. Otherwise, go to instruction 9.
		</li>
		<li>Print the dequeued node's data.</li>
		<li>Enqueue the left child of the dequeued node to the queue.</li>
		<li>
			If the dequeued node has a right child, execute the instructions
			below. Otherwise, go back to instruction 4.
		</li>
		<li>Print the dequeued node's data.</li>
		<li>Enqueue the right child of the dequeued node to the queue.</li>
	</ol>
</div>
