{% load static %}

<p>
	The postorder traversal algorithm is embodied in the following
	function:
</p>
<ol class="alg">
	<li>fn postorder(Node* root) -> void:</li>
	<ol>
		<li>postorder((*root).left_child)</li>
		<li>postorder((*root).right_child)</li>
		<li>print((*root).data)</li>
	</ol>
</ol>
<p>
	Notice that the algorithm looks similar to the other traversal methods,
	the only difference being: The <var>print()</var> call occurs only
	after the left- and right-subtrees of a given node have been traversed.
	Suppose we called <var>postorder()</var> on a tree called
	<var>cedar</var>, represented as follows:
</p>
<div id="postorder_sample"></div>
<p>
	We won't go over the call execution for postorder traversal in detail,
	as it is similar to the other traversals we've seen. The call trace is
	as follows:
</p>
<div id="postorder_trace_final"></div>
<p>
	As we saw with preorder and inorder traversal, postorder traversal
	results in ${2N + 1}$ function calls, where ${N}$ is the binary tree's
	order &mdash; i.e., the number of its nodes. Along the same lines, the
	resulting call stack size for a given invokation of
	<var>postorder()</var> is ${S_c = H + 2,}$ where ${H}$ is the tree's
	height.
</p>

