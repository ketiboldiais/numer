{% load static %}
<p>
	The <b>linked-list-implemented binary tree (LBT)</b> looks similar to
	a general linked list in implementation. Usually, there's a
	<i>root pointer</i>, a pointer in the stack whose pointee is the
	<i>root</i> of the binary tree. For the binary tree, each node has
	${2}$ <i>next fields</i> &mdash; one for a
	<var>leftChild</var> pointer and one for the
	<var>rightChild</var> pointer, and ${1}$ <i>data field</i>.
	Furthermore, each node in the tree, other than the root node, is the
	lone pointee of another node.
</p>
<figure>
	<img
		src="{% static 'images/binary_tree_implementation.svg' %}"
		alt="Binary tree implementation"
		loading="lazy"
		style="width: 370px"
	/>
</figure>
<p>For example, suppose we had the following binary tree:</p>
<div id="lbt1"></div>
<p>This tree would be implemented as:</p>
<figure>
	<img
		src="{% static 'images/lbt1_implementation.svg' %}"
		alt="Binary tree implementation"
		loading="lazy"
		style="width: 250px"
	/>
</figure>
<p>
	If we look at the representation, we see that there are ${7}$ nodes,
	corresponding to the ${7}$ elements we seek to store. Notice that
	with ${7}$ nodes, there are ${8}$ null pointers. If there are ${N}$
	nodes, then are ${N + 1}$ null pointers.
</p>
<p>
	To begin, we need to implement the basic <var>Node</var> data
	structure, as we saw with linked lists, along with its constructor:
</p>
<div class="tabs">
	<ul>
		<li>Pseudocode</li>
		<li>JavaScript</li>
	</ul>
	<div class="pseudo">
		<pre class="language-pseudo"><code>
			class Node {
				TYPE   data
				Node*  left
				Node*  right
			}

			class BinaryTree {
				Node* root = null
			}
		</code></pre>
	</div>
	<div class="js">
		<pre class="language-javascript"><code>
			export class Node {
				constructor(value) {
					this.value = value;
					this.left = null;
					this.right = null;
				}
			}
			
			export class BinarySearchTree {
				constructor() {
					this.root = null;
				}
			}
		</code></pre>
	</div>
</div>
