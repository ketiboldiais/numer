{% load static %}
<p>
	Recall that a <i>perfect binary tree</i> is a binary tree where every
	branch node has exactly ${2}$ children, and a
	<i>complete binary tree</i> is a binary tree where (a) every node
	with a height greater than ${0}$ has ${2}$ children, and (b) the last
	generation is filled from left to right.
</p>
<p>
	We might have wondered why the prong (b) is a condition for the
	complete binary tree. Now that we're discussing implementations, we
	can see a helpful rationale. Consider the following perfect binary
	tree:
</p>
<div id="perfect_abt1"></div>
<p>
	To implement this tree with an array, we go generation by generation,
	assigning nodes into the array from left to right:
</p>
<div id="perfect_abt1_array"></div>
<p>Next, consider the following complete binary tree.</p>
<div id="complete_abt1"></div>
<p>
	Using the same storage order &mdash; generation by generation, left
	to right &mdash; we get:
</p>
<div id="complete_abt1_array"></div>
<p>
	Here we see the first difference. With a perfect binary tree, we used
	all of the array's allocated spaces. With a complete binary tree,
	however, some of the spaces are unused. Now let's consider an
	<i>incomplete binary tree</i>:
</p>
<div id="incomplete_abt1"></div>
<p>Implementing this tree as an array, we see:</p>
<div id="incomplete_abt1_array"></div>
<p>
	Examinining the array, we observe that with an incomplete binary
	tree, some of the allocated spaces are unused, and there are gaps.
	This presents an additional problem. As we saw with the array data
	structure, when there are gaps in the array, we must perform shifting
	to fill the gaps. That shifting is costly, and negates the benefits
	we gain from using a binary tree in the first place. For this reason,
	if our solution allows or requires the use of incomplete binary
	trees, ABTs are more than likely an unsuitable implementation.
</p>

