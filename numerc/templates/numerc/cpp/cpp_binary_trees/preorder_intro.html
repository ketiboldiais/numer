{% load static %}

<p>Preorder traveral is defined as follows:</p>
<dfn>
	<small>Procedure: Preorder Traversal</small>
	<p>Let ${B}$ be a binary tree. To traverse ${B}$ in preorder:</p>
	<ol>
		<li>Visit some node ${n}$ in ${B.}$</li>
		<li>Traverse the left subtree of ${n}$ in preorder.</li>
		<li>Traverse the right subtree of ${n}$ in preorder.</li>
	</ol>
</dfn>
<p>In pseudocode, the procedure looks like:</p>
<figure>
	<pre class="language-pseudo"><code>
		preorder(tree):
			visit(node)
			preorder(left(tree))
			preorder(right(tree))
	</code></pre>
</figure>
<p>Let's illustrate with a few examples. Consider the following tree:</p>
<div id="_3node_preorder"></div>
<p>
	We start by executing <var>visit(node)</var>. This means visiting the
	root, ${n_a:}$
</p>
<div id="_3node_preorder_visit"></div>
<p>
	Then we execute <var>preorder_traverse(left_subtree)</var>. This is
	simply a recursive call of <var>preorder_traverse()</var>, with the left
	subtree of ${n_a}$ passed as an argument. Passing the left subtree of
	${n_a}$ as an argument, we again call <var>visit(node)</var>. This means
	visiting the root of the tree, ${n_b:}$
</p>
<div id="_3node_preorder_left_subtree"></div>
<p>
	Because ${n_b}$ has no subrees, we finish the call
	<var>preorder_traverse(left_subtree)</var> and go to the next call,
	<var>preorder_traverse(right_subtree)</var>. This is the right subtree of
	${n_a:}$
</p>
<div id="_3node_preorder_right_subtree"></div>
<p>
	Putting these calls all together, for binary tree of order ${3,}$ the
	traversal sequence is:
</p>
<figure>$$ (n_a, n_b, n_c) $$</figure>
<p>
	If we had a left-skewed binary tree, the sequence would be ${(n_a,
	n_b).}$
</p>
<div id="_2nodeleft_preorder"></div>
<p>
	The same goes for a right-skewed binary tree. Since there is no
	left-subtree, the next call is
	<var>preorder_traverse(right_subtree)</var>:
</p>
<div id="_2noderight_preorder"></div>
