{% extends '../layout.html' %} {% load static %} {% block content %}
<section id="functions">
	<h4>Functions</h4>
	<p>
		In <span class="monoText">C++</span>, the order in which we write functions
		matters. Any call to a function <span class="underlineText">must</span> be
		made <span class="underlineText">after</span> the function is implemented.
		For example, the following will not work:
	</p>
	<pre class="language-cpp"><code>
		int main() {
			double a = circleArea(2.0);
			return 0;
		}
		double circleArea(double r) {
			double pi = 3.14;
			double area = 2 * pi * r;
			return area;
		}
	</code></pre>
	<pre class="language-bash"><code>
		error: ‘circleArea’ was not declared in this scope
	</code></pre>
	<p>The correct syntax:</p>
	<pre class="language-cpp"><code>
		double circleArea(double r) {
			double pi = 3.14;
			double area = 2 * pi * r;
			return area;
		}
		int main() {
			double a = circleArea(2.0);
			return 0;
		}
	</code></pre>

	<p>
		Most programmers, however, do not like having these implementations before
		the <span class="monoText">main()</span> function. The
		<span class="monoText">main()</span> function is where all of the primary
		source code lies, so we usually want to see that as soon as possible. To do
		so, we include <span class="term">function prototypes</span> before
		<span class="monoText">main()</span>. This prototype serves as sort of a
		"heads up" to the compiler about an upcoming function. It takes the form:
	</p>

	<figure class="math-display">
		<ul class="syntax">
			<li>${t_r}$ ${f}$(${t_0 \space p_0, \ldots, t_n \space p_n}$)</li>
		</ul>
	</figure>

	<p>
		${t_r}$ represents the function's
		<span class="italicsText">return type</span> (the type of the function's
		output). ${f}$ is the function's <span class="italicsText">name</span>.
		${t_0, \ldots, t_n}$ are the types of the function's parameters. ${p_0,
		\ldots, p_n}$ are the parameter. Notice that just like variables, the
		parameters in a <span class="monoText">C++</span> function must have
		explicitly declared types.
	</p>
	<p>Thus, we can rewrite the erroneous example above as:</p>

	<pre class="language-cpp"><code>
		double circleArea(double r);

		int main() {
			double a = circleArea(2.0);
			return 0;
		}
		double circleArea(double r) {
			double pi = 3.14;
			double area = 2 * pi * r;
			return area;
		}
	</code></pre>

	<p>
		Obviously, a program can have numerous functions, in which case we might
		have hundreds, if not thousands, of function protoypes. This is when we
		start writing functions in separate files, and
		<span class="monoText">include</span> them in our primary source code file.
		These files are called <span class="term">header files</span>, and we
		discuss them in more detail in a later section.
	</p>

	<p>
		Some functions do not explicitly return a value. What is the return type for
		these functions? It is <span class="monoText">void</span>:
	</p>
	<figure class="math-display">
		<ul class="syntax">
			<li>void ${f}$(${t_0 \space p_0, \ldots, t_n \space p_n}$)</li>
		</ul>
	</figure>
	<p>
		The keyword <span class="monoText">void</span> only applies to return types.
		We cannot have a <span class="monoText">void</span> parameter, and we cannot
		have <span class="monoText">void</span> variables.
	</p>
	<p>
		The above syntax is for function protoypes. When we actually implement the
		function, we use the following syntax:
	</p>
	<figure class="math-display">
		<ul class="syntax">
			<li>${r_t}$ ${f}$(${t_0}$ ${p_0}$, ${\ldots}$, ${t_n}$ ${p_n}$) {</li>
			<ul>
				<li>${t_v}$ ${v}$</li>
				<li>${statements}$</li>
				<li>${\vdots}$</li>
				<li>return ${v}$</li>
			</ul>
			<li>}</li>
		</ul>
	</figure>
	<p>
		In the syntax above, ${r_t}$ is the return type of the function, ${f}$ is
		the name of the function, ${t_n}$ are the types for the parameters, ${p_n}$
		are the parameters, ${t_v}$ is the return type for the variable that will
		store the return, and ${v}$ is the variable that will store the return. For
		example:
	</p>
	<pre class="language-cpp"><code>
		double Average(double a, double b) {
			double sum = a + b;
			return sum / 2;
		}

		int main() {
			double mid = average(10.2, 11.8);
			cout << mid << endl;
			return 0;
		}
	</code></pre>
	<p>
		One quirk of <span class="monoText">C++</span> is that order absolutely
		matters. All of our actual source code is located in the
		<span class="monoText">main</span> function, so any function that is called
		inside <span class="monoText">main</span> must be defined before
		<span class="monoText">main</span>. More generally, a function must always
		be defined before it is called.
	</p>
	<p>
		In the code above, the <span class="monoText">average()</span> function is
		called the <span class="term">callee function</span> &mdash; it is the
		function that is called. The <span class="monoText">main()</span> function
		is called the <span class="term">caller function</span> &mdash; the function
		that calls.
	</p>
	<p>
		In the function <span class="monoText">average()</span>, we have
		<span class="monoText">double a</span> and
		<span class="monoText">double b</span>. These are the
		<span class="italicsText">parameters</span> of
		<span class="monoText">average()</span>. The variables
		<span class="monoText">a</span> and <span class="monoText">b</span> exist
		only inside the function <span class="monoText">average()</span>. They exist
		nowhere else but the <span class="monoText">average()</span> function.
		Likewise, the variable <span class="monoText">mid</span> exists only inside
		the <span class="monoText">main()</span> function. This means that
		<span class="monoText">average()</span> has no access to
		<span class="monoText">mid</span>, and
		<span class="monoText">main()</span> has no access to
		<span class="monoText">a</span> and <span class="monoText">b</span>.
	</p>
</section>
<section id="pass_by_value">
	<h4>Pass by Value</h4>
	<p>What is the output of the following code:</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;

		int doubleValue(int x) {
			x *= 2;
			return x
		}

		int main() {
			int myValue = 5;
			int result = doubleValue(myValue);
			
			cout << "myValue: " << myValue << " ";
			cout << "result: " << result << endl;
		}
	</code></pre>
	<p>
		The output is <span class="monoText">10</span>. This is because we passed a
		<span class="italicsText">copy</span> of
		<span class="monoText">myValue</span> into the function
		<span class="monoText">doubleValue</span>. We call this mode of operation
		<span class="term">pass-by-value</span>, and it is the default mode of
		operation in <span class="monoText">C++</span>.
	</p>

	<p>
		<span class="topic">Default Values.</span> In
		<span class="monoText">C++</span>, we can set default values for function
		parameters. For example:
	</p>

	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
			
		int increment(int a, int b=1) {
			int result = a + b;
			return result;
		}
		
		int main() {
			int a = increment(1);
			int b = increment(1, 2);
			cout&lt;&lt;a&lt;&lt;endl;
			cout&lt;&lt;b;
	
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		2
		3
	</code></pre>
</section>

<section id="value_of_functions">
	<h4>Why use functions?</h4>
	<p>
		Functions are more than just a way of reusing code. They are the building
		blocks for <span class="term">procedural decomposition</span> &mdash;
		breaking down a program into smaller and smaller pieces. In a good
		<span class="monoText">C++</span> program, the
		<span class="monoText">main()</span> function is the overarching function
		that calls <span class="term">helper functions</span>. We should think of
		<span class="monoText">main()</span> as a function akin to the conductor of
		a gargantuan orchestra; it simply drives, or directs, the order in which the
		helper functions are called.
	</p>
	<p>
		The helper functions should meet several criteria: (1) The helper function
		performs one, and only one, coherent task. (2) The function does not do too
		large a share of the work. (3) The function is not overly reliant on other
		functions. And (4) the function stores data in the narrowest scope possible.
	</p>
</section>
{% endblock %}
