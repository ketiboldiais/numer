{% extends '../layout.html' %} {% load static %} {% block description %}
<meta name="description" content="C++ functions" />
{% endblock %} {% block title %}
<title>C++ Functions</title>
{% endblock %} {% block content %}

<h1>Functions</h1>
<section id="functions">
	<div class="mainIdea">
		<span class="topic">Key Points</span>
		<ul>
			<li>
				Pass-by-value: The parameter copies a value, changes to the value only
				affect the local copy. Benefit: Avoids mutability and unexpected
				changes. Cost: Creating new copies, resulting in more memory and
				processing power usage.
			</li>
			<li>
				Pass-by-reference: The parameter passes a reference to the original
				value, changes to the value can affect the original value. Benefits:
				More efficient, since no copies are made. Cost: More difficult to reason
				about what the code is doing.
			</li>
		</ul>
	</div>
	<p>
		<span class="drop">I</span>n the simplest terms, a function is a piece of
		code that performs a specific task. It takes inputs, called
		<span class="term">arguments</span>, and returns an output, called a
		<span class="term">return value</span>. There are many ways to think about
		functions. For now, we can think of functions as ways to
		<span class="italicsText">modularize</span> our code. If we have a
		particular computation that must be performed over and over again, that
		computation would be best capsulated as a function. For example, consider
		this code that prints out an array:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		int main() {
			int arr[]{1, 2, 3, 4};
			int sizeOfArr = sizeof(arr) / sizeof(int);
			for (int i = 0; i < sizeOfArr; i++) {
				cout << arr[i] << " ";
			}
			cout << endl;
			return 0;
		}
	</code></pre>
	<p>
		If we had multiple arrays, we would have to write that
		<span class="monoText">for</span> loop multiple times.
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		int main() {
			int arr1[]{1, 2, 3, 4};
			int arr2[]{5, 6, 7, 8};
			int sizeOfArr1 = sizeof(arr1) / sizeof(int);
			int sizeOfArr2 = sizeof(arr2) / sizeof(int);
			for (int i = 0; i < sizeOfArr1; i++) {
				cout << arr1[i] << " ";
			}
			cout << endl;
			for (int i = 0; i < sizeOfArr2; i++) {
				cout << arr2[i] << " ";
			}
			cout << endl;
			return 0;
		}
	</code></pre>
	<p>It would be much cleaner if we just wrote a function:</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		void printIntArr(int arr[], int length);
		
		int main() {
			int arr1[]{1, 2, 3, 4};
			int arr2[]{5, 6, 7, 8};
			int sizeOf_arr1 = sizeof(arr1) / sizeof(int);
			int sizeOf_arr2 = sizeof(arr2) / sizeof(int);
			printIntArr(arr1, sizeOf_arr1);
			printIntArr(arr2, sizeOf_arr2);
			return 0;
		}
		
		void printIntArr(int arr[], int length) {
			for (int i = 0; i < length; i++) {
				cout << arr[i] << " ";
			}
			cout << endl;
		}
	</code></pre>
	<p>
		It may look like there's not much of a difference, but we have effectively
		modularized our code, allowing us to call it whenever we'd like, for however
		many arrays we want, without having to write
		<span class="monoText">for</span> loops over and over. To clean the code up
		a bit more, we can use a macro (don't worry about this for now, we will
		expore macros in later sections):
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		#define SIZEOF(a) sizeof(a)/sizeof(*a)
		
		void printIntArr(int arr[], int length);
		
		int main() {
			int arr1[]{1, 2, 3, 4};
			int arr2[]{5, 6, 7, 8};
			printIntArr(arr1, SIZEOF(arr1));
			printIntArr(arr2, SIZEOF(arr2));
			return 0;
		}
		
		void printIntArr(int arr[], int length) {
			for (int i = 0; i < length; i++) {
				cout << arr[i] << " ";
			}
			cout << endl;
		}
	</code></pre>
	<p>
		Erring on the side of functions when writing code is a hallmark of the
		programming paradigm <span class="term">functional programming</span>. The
		benefits of functional programming is modularized code, and it is the exact
		opposite of <span class="term">monolithic programming</span> &mdash; writing
		all of our code in a single area, such as
		<span class="monoText">main()</span>. If we wrote all of our code in
		<span class="monoText">main()</span>, then we take on several risks. First,
		suppose our program spanned several thousand lies (not at all unusual). If
		we so happen to encounter a bug, we would have to weave through several
		thousand lines trying to pinpoint the problem. With modularized code, we can
		more quickly find the source by examining each module separately. Moreover,
		modularized code avoids cross-contamination by isolating pieces of code.
	</p>
	<p>
		Second, our program required performing a computation in a for loop, or a
		computation in a function, or a computation in a function in a function
		(again, not at all unusual). Without using functions, we would have to copy
		and paste the computation's code everywhere it's needed. This is (1) not
		productive and (2) almost assuredly will cause bugs (think about how many
		times you've copied and pasted and missed a character; one character is all
		it takes in programming).
	</p>
	<blockquote>Order matters.</blockquote>
	<p>
		In <span class="monoText">C++</span>, the order in which we write functions
		matters. Any call to a function <span class="underlineText">must</span> be
		made <span class="underlineText">after</span> the function is implemented.
		For example, the following will not work:
	</p>
	<pre class="language-cpp"><code>
		int main() {
			double a = circleArea(2.0);
			return 0;
		}
		double circleArea(double r) {
			double pi = 3.14;
			double area = 2 * pi * r;
			return area;
		}
	</code></pre>
	<pre class="language-bash"><code>
		error: ‘circleArea’ was not declared in this scope
	</code></pre>
	<p>The correct syntax:</p>
	<pre class="language-cpp"><code>
		double circleArea(double r) {
			double pi = 3.14;
			double area = 2 * pi * r;
			return area;
		}
		int main() {
			double a = circleArea(2.0);
			return 0;
		}
	</code></pre>

	<p>
		Most programmers, however, do not like having these implementations before
		the <span class="monoText">main()</span> function. The
		<span class="monoText">main()</span> function is where all of the primary
		source code lies, so we usually want to see that as soon as possible. To do
		so, we include <span class="term">function prototypes</span> before
		<span class="monoText">main()</span>. This prototype serves as sort of a
		"heads up" to the compiler about an upcoming function. It takes the form:
	</p>

	<figure class="math-display">
		<ul class="syntax">
			<li>${t_r}$ ${f}$(${t_0 \space p_0, \ldots, t_n \space p_n}$)</li>
		</ul>
	</figure>

	<p>
		${t_r}$ represents the function's
		<span class="italicsText">return type</span> (the type of the function's
		output). ${f}$ is the function's <span class="italicsText">name</span>.
		${t_0, \ldots, t_n}$ are the types of the function's parameters. ${p_0,
		\ldots, p_n}$ are the parameter. Notice that just like variables, the
		parameters in a <span class="monoText">C++</span> function must have
		explicitly declared types.
	</p>
	<p>Thus, we can rewrite the erroneous example above as:</p>

	<pre class="language-cpp"><code>
		double circleArea(double r);

		int main() {
			double a = circleArea(2.0);
			return 0;
		}
		double circleArea(double r) {
			double pi = 3.14;
			double area = 2 * pi * r;
			return area;
		}
	</code></pre>

	<p>
		Obviously, a program can have numerous functions, in which case we might
		have hundreds, if not thousands, of function protoypes. This is when we
		start writing functions in separate files, and
		<span class="monoText">include</span> them in our primary source code file.
		These files are called <span class="term">header files</span>, and we
		discuss them in more detail in a later section.
	</p>

	<p>
		Some functions do not explicitly return a value. What is the return type for
		these functions? It is <span class="monoText">void</span>:
	</p>
	<figure class="math-display">
		<ul class="syntax">
			<li>void ${f}$(${t_0 \space p_0, \ldots, t_n \space p_n}$)</li>
		</ul>
	</figure>
	<p>
		The keyword <span class="monoText">void</span> only applies to return types.
		We cannot have a <span class="monoText">void</span> parameter, and we cannot
		have <span class="monoText">void</span> variables.
	</p>
	<p>
		The above syntax is for function protoypes. When we actually implement the
		function, we use the following syntax:
	</p>
	<figure class="math-display">
		<ul class="syntax">
			<li>${r_t}$ ${f}$(${t_0}$ ${p_0}$, ${\ldots}$, ${t_n}$ ${p_n}$) {</li>
			<ul>
				<li>${t_v}$ ${v}$</li>
				<li>${statements}$</li>
				<li>${\vdots}$</li>
				<li>return ${v}$</li>
			</ul>
			<li>}</li>
		</ul>
	</figure>
	<p>
		In the syntax above, ${r_t}$ is the return type of the function, ${f}$ is
		the name of the function, ${t_n}$ are the types for the parameters, ${p_n}$
		are the parameters, ${t_v}$ is the return type for the variable that will
		store the return, and ${v}$ is the variable that will store the return. For
		example:
	</p>
	<pre class="language-cpp"><code>
		double Average(double a, double b) {
			double sum = a + b;
			return sum / 2;
		}

		int main() {
			double mid = average(10.2, 11.8);
			cout << mid << endl;
			return 0;
		}
	</code></pre>
	<p>
		One quirk of <span class="monoText">C++</span> is that order absolutely
		matters. All of our actual source code is located in the
		<span class="monoText">main</span> function, so any function that is called
		inside <span class="monoText">main</span> must be defined before
		<span class="monoText">main</span>. More generally, a function must always
		be defined before it is called.
	</p>
	<p>
		In the code above, the <span class="monoText">average()</span> function is
		called the <span class="term">callee function</span> &mdash; it is the
		function that is called. The <span class="monoText">main()</span> function
		is called the <span class="term">caller function</span> &mdash; the function
		that calls.
	</p>
	<p>
		In the function <span class="monoText">average()</span>, we have
		<span class="monoText">double a</span> and
		<span class="monoText">double b</span>. These are the
		<span class="italicsText">parameters</span> of
		<span class="monoText">average()</span>. The variables
		<span class="monoText">a</span> and <span class="monoText">b</span> exist
		only inside the function <span class="monoText">average()</span>. They exist
		nowhere else but the <span class="monoText">average()</span> function.
		Likewise, the variable <span class="monoText">mid</span> exists only inside
		the <span class="monoText">main()</span> function. This means that
		<span class="monoText">average()</span> has no access to
		<span class="monoText">mid</span>, and
		<span class="monoText">main()</span> has no access to
		<span class="monoText">a</span> and <span class="monoText">b</span>.
	</p>
	<p>
		<span class="topic">Default Values.</span> In
		<span class="monoText">C++</span>, we can set default values for function
		parameters. For example:
	</p>

	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
			
		int increment(int a, int b=1) {
			int result = a + b;
			return result;
		}
		
		int main() {
			int a = increment(1);
			int b = increment(1, 2);
			cout&lt;&lt;a&lt;&lt;endl;
			cout&lt;&lt;b;
	
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		2
		3
	</code></pre>
</section>

<section id="function_overloading">
	<h2>Function Overloading</h2>
	<p>
		Notice that the three functions, <span class="monoText">print()</span>, have
		the same name, but they compile just fine:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		#define SIZEOF(a) sizeof(a)/sizeof(*a)
		
		void print(int arr[], int length);
		void print(char arr[], int length);
		void print(double arr[], int length);
		
		int main() {
			int intArr[]{1, 2, 3, 4};
			char charArr[]{'a', 'b', 'c', 'd'};
			double doubleArr[]{1.2, 2.9, 3.1, 3.10};
		
			print(intArr, SIZEOF(intArr));
			print(charArr, SIZEOF(charArr));
			print(doubleArr, SIZEOF(doubleArr));
			return 0;
		}
		
		void print(int arr[], int length) {
			for (int i = 0; i < length; i++) {
				cout << arr[i] << " ";
			}
			cout << endl;
		}

		void print(char arr[], int length) {
			for (int i = 0; i < length; i++) {
				cout << arr[i] << " ";
			}
			cout << endl;
		}

		void print(double arr[], int length) {
			for (int i = 0; i < length; i++) {
				cout << arr[i] << " ";
			}
			cout << endl;
		}
	</code></pre>
	<pre class="language-bash"><code>
		1 2 3 4 
		a b c d 
		1.2 2.9 3.1 3.1 
	</code></pre>
	<p>
		This is an example of <span class="term">function overloading</span> &mdash;
		the phenomenon of when different functions performing different tasks, have
		the same identifier. More abstractly, we can think of it as if the function
		&mdash; an operator &mdash; can perform multiple tasks. In C++, we can
		accomplish function overloading by either (a) having different type
		parameters, (b) having a different number of parameters. In general, to
		accomplish function overloading, we have to provide C++ a way to
		differentiate between the functions. In the example of
		<span class="monoText">print()</span>, this is done by providing different
		arguments.
	</p>
	<p>
		Things that will not work, on their own, for differentiating: Return type,
		the order the functions are written, and default parameters. Using these
		differences alone are insufficient to allowing C++ to differentiate the
		functions, resulting in a <span class="term">name conflict</span>.
	</p>
	<p>
		Function overloading is tremendously useful. One of the hardest tasks in
		programming is naming things, made all the more difficult when we have
		functions that perform something very similar &mdash; like printing an array
		to the console &mdash; but differ by just one or two things, such as
		argument type. However, as with all features, there are tradeoffs.
	</p>
	<p>
		Function overloading is a kind of
		<span class="italicsText">polymorphism</span>, a topic we will discuss
		further in later sections. In a nutshell, polymorphism is when we have an
		entity of a particular type behaving like something else of a particular
		type. For example, a person's dog can behave like a loving friend. Yet in
		other situations, a vicious guard. The same idea &mdash; and risk &mdash;
		applies to overloaded functions. We must always be cognizant of what our
		functions are capable of doing, just as a dog owner should be cognizant of
		when and where their dogs are a danger to others. If a function is
		overloaded with too many tasks, we risk losing track of what the function
		does when passed certain arguments. A similar risk occurs when we overload a
		function with tasks that don't intuitively correspond to the identifier. For
		example, it would be a poor choice to allow
		<span class="monoText">print()</span> to average the elements of an
		<span class="monoText">int</span> array &mdash; it's not clear how averaging
		something relates to <span class="monoText">print</span>.
	</p>
</section>

<section id="function_templates">
	<h2>Function Templates</h2>
	<p>
		Recall the <span class="monoText">print()</span> function we saw in the
		previous example:
	</p>
	<pre class="language-cpp"><code>
		void print(int arr[], int length) {
			for (int i = 0; i < length; i++) {
				cout << arr[i] << " ";
			}
			cout << endl;
		}
		void print(char arr[], int length) {
			for (int i = 0; i < length; i++) {
				cout << arr[i] << " ";
			}
			cout << endl;
		}
		void print(double arr[], int length) {
			for (int i = 0; i < length; i++) {
				cout << arr[i] << " ";
			}
			cout << endl;
		}
	</code></pre>
	<p>
		The only thing that differentiates this function is the argument type. When
		programming, it's not uncommon to have functions like this &mdash; the same
		computation, but different arguments. In these situations, it's best to use
		a <span class="term">function template</span>. We can think of a function
		template as simply a more general, or abstract form of the function. We can
		reduce the functions above into a single function:
	</p>
	<pre class="language-cpp"><code>
		template&lt;class T&gt;
		void print(T arr[], int length) {
			for (int i = 0; i < length; i++) {
				cout << arr[i] << " ";
			}
			cout << endl;
		}
	</code></pre>
	<p>
		The <span class="monoText">T</span> in the code above essentially acts like
		a placeholder. C++ will replace the <span class="monoText">T</span> with the
		appropriate data type. This results in
		<span class="monoText">print()</span> becoming a
		<span class="term">generic function</span>. Applying this feature, our code
		begins to look cleaner, while keeping the added functionality:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		#define SIZEOF(a) sizeof(a)/sizeof(*a)
		
		template&lt;class T&gt;
		void print(T arr[], int length);
		
		int main() {
			int intArr[]{1, 2, 3, 4};
			char charArr[]{'a', 'b', 'c', 'd'};
			double doubleArr[]{1.2, 2.9, 3.1, 3.10};
		
			print(intArr, SIZEOF(intArr));
			print(charArr, SIZEOF(charArr));
			print(doubleArr, SIZEOF(doubleArr));
			return 0;
		}
		
		template&lt;class T&gt;
		void print(T arr[], int length) {
			for (int i = 0; i < length; i++) {
				cout << arr[i] << " ";
			}
			cout << endl;
		}
	</code></pre>
	<pre class="language-bash"><code>
		1 2 3 4 
		a b c d 
		1.2 2.9 3.1 3.1 
	</code></pre>
	<p>
		Notice that because we must include function signatures, the template
		declaration must appear both before the function signature and before the
		function's definition. Of course, we can avoid this by simply placing our
		function definition before <span class="monoText">main()</span>:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		#define SIZEOF(a) sizeof(a)/sizeof(*a)
		
		template &lt;class T&gt;
		void print(T arr[], int length) {
			for (int i = 0; i < length; i++) {
				cout << arr[i] << " ";
			}
			cout << endl;
		}
		
		int main() {
			int intArr[]{1, 2, 3, 4};
			char charArr[]{'a', 'b', 'c', 'd'};
			double doubleArr[]{1.2, 2.9, 3.1, 3.10};
		
			print(intArr, SIZEOF(intArr));
			print(charArr, SIZEOF(charArr));
			print(doubleArr, SIZEOF(doubleArr));
			return 0;
		}
	</code></pre>
</section>

<section id="argument_passing">
	<h2>Argument Passing</h2>
	<p>
		When functions have parameters without default values, they must be passed
		arguments. In C++, passing arguments into functions can be done in three
		ways: (1) <span class="term">pass-by-value</span>, (2)
		<span class="term">pass-by-reference</span>, and (3)
		<span class="term">pass-by-address</span>.
	</p>

	<h3>Pass-by-value</h3>
	<p>
		To illustrate these differences, let's consider a canonical function in
		programming, <span class="monoText">swap()</span>. Before we write the
		function, let's recall how the function works. Say we have an
		<span class="monoText">int a = 0</span> and an
		<span class="monoText">int b = 1</span>. To swap the values assigned to the
		variables, we create a temporary variable, called
		<span class="monoText">temp</span>. Then, we assign to
		<span class="monoText">temp</span> the variable
		<span class="monoText">a.</span> Thus,
		<span class="monoText">temp = a = 0.</span> Then, we assign to
		<span class="monoText">a</span> the variable
		<span class="monoText">b.</span> Thus,
		<span class="monoText">a = b = 1.</span> Finally, we assign to
		<span class="monoText">b</span> the variable
		<span class="monoText">temp</span>:
		<span class="monoText">b = temp = 0</span>. The end result:
		<span class="monoText">a = 1</span> and <span class="monoText">b = 0</span>.
		Putting it all together:
	</p>

	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		int main() {
			int a = 0;
			int b = 1;
		
			cout << "Before the swap: " << endl;
			cout << "x = " << a << endl;
			cout << "y = " << b << endl;
		
			// The swap
			int temp;
			temp = a;
			a = b;
			b = temp;
		
			cout << "After the swap: " << endl;
			cout << "x = " << a << endl;
			cout << "y = " << b << endl;
		
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		Before the swap: 
		x = 0
		y = 1
		After the swap: 
		x = 1
		y = 0
	</code></pre>
	<p>
		Great, it works. Swapping variables, however, is a very common operation.
		Accordingly, we want to place this computation in a function, to be used
		whenever we'd like:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		void swap(int a, int b) {
			int temp;
			temp = a;
			a = b;
			b = temp;
		}
		
		int main() {
			int a = 0;
			int b = 1;
		
			cout << "Before the swap: " << endl;
			cout << "x = " << a << endl;
			cout << "y = " << b << endl;
		
			swap(a, b);
		
			cout << "After the swap: " << endl;
			cout << "x = " << a << endl;
			cout << "y = " << b << endl;
		
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		Before the swap: 
		x = 0
		y = 1
		After the swap: 
		x = 0
		y = 1
	</code></pre>
	<p>
		Strange. It didn't perform the swap. Why? Because calling functions the way
		we did above, <span class="monoText">swap(a, b)</span>, is by default
		<span class="term">pass-by-value</span>. In pass-by-value, the function only
		receives a <span class="underlineText">copy</span> of the values passed.
		They are not pass an original. To understand what this implies, recall what
		happens in main memory when we execute a function.
	</p>
	<p>
		When <span class="monoText">main()</span> is loaded, a stack in main memory
		is allocated for it. Let's call it
		<span class="italicsText">stack main</span>. Inside
		<span class="italicsText">stack main</span>, memory is allocated for
		<span class="monoText">int a = 0</span> and
		<span class="monoText">int b = 1</span>. Going down the code, we encounter
		<span class="monoText">swap(a, b)</span>. This is a new function, so a new
		stack is created to accomodate its variables. Call it
		<span class="italicsText">stack swap</span>. Inside
		<span class="italicsText">stack swap</span>, memory is allocated for
		<span class="monoText">int a</span>, <span class="monoText">int b</span>,
		and <span class="monoText">temp</span>. Now, arguments were passed into
		<span class="monoText">swap()</span>, so the memory allocated is for
		<span class="monoText">int a = 0</span>,
		<span class="monoText">int b = 1</span>, and
		<span class="monoText">temp</span>.
	</p>
	<p>
		Inside <span class="italicsText">swap stack</span>, the body of
		<span class="monoText">swap()</span> works as expected. The variables do in
		fact swap. We can see that's true by running the function without arguments:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		void swap(int a = 0, int b = 1) {
			cout << "Before swap: " << endl;
			cout << "\t a = " << a << endl;
			cout << "\t b = " << b << endl;
		
			// The swap
			int temp;
			temp = a;
			a = b;
			b = temp;
		
			cout << "After swap: " << endl;
			cout << "\t a = " << a << endl;
			cout << "\t b = " << b << endl;
		}
		
		int main() {
			swap();
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		Before swap: 
				a = 0
				b = 1
		After swap: 
				a = 1
				b = 0
	</code></pre>
	<p>
		So what does this all mean? It means that the swap never actually occurs in
		the <span class="monoText">main()</span> function. It only occurs in
		<span class="monoText">swap()</span>, and once
		<span class="monoText">swap()</span> is done,
		<span class="italicsText">stack swap</span> is destroyed. There was no
		effect whatsoever on the <span class="monoText">int a = 0</span> and
		<span class="monoText">int b = 1</span> in
		<span class="italicsText">stack main</span>.
	</p>
	<p>
		This embodies the concept of pass-by-value. When we simply pass regular
		variables into a function, we only pass copies of the values into the
		function. We never pass the originals.
	</p>
	<p>
		Call-by-value is what we use when we want the function to simply return a
		result based on the arguments passed. In fact, most of the functions we
		write are computations based on arguments. We generally do not want the
		original values changed &mdash; we want a new result. For example, suppose
		we had a function that computes acceleration:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		double acceleration(double velocity1, double velocity2, double time) {
			return (velocity2 - velocity1) / time;
		}
		
		int main() {
			double v1 = 12.4;
			double v2 = 14.6;
			double t = 3.48;
		
			cout << "Before function call:" << endl;
			cout << "v1 = " << v1 << endl;
			cout << "v2 = " << v2 << endl;
			cout << "t = " << t << endl;
			
			double a = acceleration(v1, v2, t);
		
			cout << "After function call:" << endl;
			cout << "v1 = " << v1 << endl;
			cout << "v2 = " << v2 << endl;
			cout << "t = " << t << endl;
			cout << "a = " << a << endl;
		
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		Before function call:
		v1 = 12.4
		v2 = 14.6
		t = 3.48
		After function call:
		v1 = 12.4
		v2 = 14.6
		t = 3.48
		a = 0.632184
	</code></pre>
	<p>
		We obtained a value, but we did not modify the actual arguments,
		<span class="monoText">v1</span>, <span class="monoText">v2</span>, and
		<span class="monoText">t</span>. In programming, we want to minimize
		mutation as much as possible. Pass-by-value is one means of ensuring that.
		But what if we do want mutation? I.e., what if we truly want to modify the
		actual arguments, like how we intended in
		<span class="monoText">swap()</span>?
	</p>

	<h3>Pass-by-address</h3>
	<p>
		One way to do so is with <span class="term">pass-by-address</span>.
		Pass-by-address is exactly what it sounds like. Instead of sending copies of
		the values to a function, we send the address of the values:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		void swap(int *a, int *b) {
			int temp;
			temp = *a;
			*a = *b;
			*b = temp;
		}
		
		int main() {
			int a = 0;
			int b = 1;
		
			cout << "Before the swap: " << endl;
			cout << "x = " << a << endl;
			cout << "y = " << b << endl;
		
			swap(&a, &b);
		
			cout << "After the swap: " << endl;
			cout << "x = " << a << endl;
			cout << "y = " << b << endl;
		
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		Before the swap: 
		x = 0
		y = 1
		After the swap: 
		x = 1
		y = 0
	</code></pre>
	<p>
		Now it works. But how? Notice that with the function call
		<span class="monoText">swap()</span>, we passed as arguments
		<span class="monoText">&a</span> and <span class="monoText">&b</span>. These
		are the addresses of <span class="monoText">a</span> and
		<span class="monoText">b</span> in <span class="monoText">main()</span>.
		Then, inside <span class="monoText">swap()</span>, the parameters are
		<span class="monoText">*a</span> and <span class="monoText">*b</span>. These
		are pointers. Why are they pointers? Because if we want to store memory
		addresses, we must use pointers. Accordingly, inside the body of
		<span class="monoText">swap()</span>, we use pointers to perform the swap.
		Those pointers always refer to the addresses of
		<span class="monoText">a</span> and <span class="monoText">b</span> in
		<span class="monoText">main()</span>.
	</p>

	<h3>Pass-by-reference</h3>
	<p>
		Recall that we can think of a <span class="italicsText">reference</span> as
		a nickname, or pseudonym, for a variable. That nickname, or pseudonym, can
		be passed as an argument to a function. Passing references as arguments to a
		function is called <span class="term">pass-by-reference</span>. For example,
		using our code above:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		void swap(int &a, int &b) {
			int temp;
			temp = a;
			a = b;
			b = temp;
		}
		
		int main() {
			int a = 0;
			int b = 1;
		
			cout << "Before the swap: " << endl;
			cout << "x = " << a << endl;
			cout << "y = " << b << endl;
		
			swap(a, b);
		
			cout << "After the swap: " << endl;
			cout << "x = " << a << endl;
			cout << "y = " << b << endl;
		
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		Before the swap: 
		x = 0
		y = 1
		After the swap: 
		x = 1
		y = 0
	</code></pre>
	<p>
		The same result from passing by address is obtained. This is because we
		employed <span class="term">pass-by-reference</span>. When
		<span class="monoText">main()</span> is memory is allocated for its
		variables, as usual. However, the distinction is when the loader encounters
		<span class="monoText">swap(a, b)</span>. The formal parameters of
		<span class="monoText">a</span> and <span class="monoText">b</span> are
		<span class="monoText">&a</span> and <span class="monoText">&b</span>.
	</p>
	<p>
		What happens when these parameters are used? The entire definition for
		<span class="monoText">swap()</span> is &#8220;copied-and-pasted&#8221; into
		the body of <span class="monoText">main()</span>. In other words,
		<span class="monoText">swap()</span> isn't loaded separately from
		<span class="monoText">main()</span>. It is loaded as a part of
		<span class="monoText">main()</span>. And because
		<span class="monoText">swap()</span> is a part of
		<span class="monoText">main()</span>,
		<span class="monoText">swap()</span> can effectively &#8220;see&#8221;, or
		has access, to the preceding variables inside
		<span class="monoText">main()</span>. In practice, pass-by-reference is used
		far more often than pass-by-address. Why? Because it's simpler to write and
		easier to read.
	</p>
</section>

<section id="returns">
	<h2>Function Returns</h2>
	<p>
		Just as functions can take different parameters, functions can also have
		different returns. The default return method is
		<span class="italicsText">return-by-value</span>. The function performs a
		computation, and returns the result. We can, however, also perform
		<span class="italicsText">return-by-address</span> and
		<span class="italicsText">return-by-reference</span>.
	</p>

	<h3>Return-by-address</h3>
	<p>
		Suppose we wanted a function to return an array, which we can then use and
		mutate elsewhere. One way to do so is to write a function with
		<span class="term">return-by-address</span> &mdash; a function that returns
		the address of stored data:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		int* natNumArray(int size) {
			int *p = new int[size];
			for (int i = 0; i < size; i++) {
				p[i] = i+1;
			}
			return p;
		}
		
		int main() {
			int *natNumPTR = natNumArray(5);
			return 0;
		}
	</code></pre>
	<p>
		In the code above, we allocated memory in the heap for an
		<span class="monoText">int</span> array, using the function
		<span class="monoText">natNumArray()</span>. The function returns the
		resulting array's address, and in <span class="monoText">main()</span>, that
		address is assigned to a pointer called
		<span class="monoText">*natNumPTR</span>. As a result, both
		<span class="monoText">p</span> in
		<span class="monoText">natNumArray()</span> and
		<span class="monoText">natNumPTR</span> point to the same address,
		effectively allowing us to modify the newly allocated array.
	</p>

	<h3>Return-by-reference</h3>
	<p>
		With return-by-address, we use an explicit pointer. We can instead use an
		implicit pointer with <span class="term">return-by-reference</span>. By
		writing a function as return-by-reference, we instruct C++ that the
		particular reference returns a pointer to its return value, rather than the
		value itself. The end result: We can use functions on the
		<span class="underlineText">left</span> side of an assignment statement,
		rather than the typical right side.
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
			
		double& setValues(double vals[], int i) {
			return vals[i];
		}
			
		int main () {
			double arr[] = {1.1, 9.8, 3.1, 2.1, 5.7};
			cout << "Value before change" << endl;
			for ( int i = 0; i < 5; i++ ) {
				cout << "\t arr[" << i << "] = ";
				cout << arr[i] << endl;
			}
			
			setValues(arr, 1) = 19.2;
			setValues(arr, 3) = 58.8;
			
			cout << "Value after change" << endl;
			for ( int i = 0; i < 5; i++ ) {
				cout << "\t arr[" << i << "] = ";
				cout << arr[i] << endl;
			}
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		Value before change
			arr[0] = 1.1
			arr[1] = 9.8
			arr[2] = 3.1
			arr[3] = 2.1
			arr[4] = 5.7
		Value after change
			arr[0] = 1.1
			arr[1] = 19.2
			arr[2] = 3.1
			arr[3] = 58.8
			arr[4] = 5.7
	</code></pre>
</section>

<section id="value_of_functions">
	<h2>Why use functions?</h2>
	<p>
		Functions are more than just a way of reusing code. They are the building
		blocks for <span class="term">procedural decomposition</span> &mdash;
		breaking down a program into smaller and smaller pieces. In a good
		<span class="monoText">C++</span> program, the
		<span class="monoText">main()</span> function is the overarching function
		that calls <span class="term">helper functions</span>. We should think of
		<span class="monoText">main()</span> as a function akin to the conductor of
		a gargantuan orchestra; it simply drives, or directs, the order in which the
		helper functions are called.
	</p>
	<p>
		The helper functions should meet several criteria: (1) The helper function
		performs one, and only one, coherent task. (2) The function does not do too
		large a share of the work. (3) The function is not overly reliant on other
		functions. And (4) the function stores data in the narrowest scope possible.
	</p>
</section>

<section id="variable_scope">
	<h2>Variable Scope</h2>
	<p>
		Functions are good point for us to switch gears and discuss
		<span class="term">variable scope</span>. Generally, there are kinds of
		scope: (1) the <span class="term">global scope</span> and (2) a
		<span class="term">local scope</span>. Consider the following code:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		int a = 1; 
		
		bool isEven(int n) {
			return (n % 2 == 0);
		}
		
		int main() {
			int x = 0;
			cout << x << endl;
			x += a;
			if (isEven(x)) {
				cout << x << " is even." << endl;
			} else {
				cout << x << " is not even." << endl;
			}
		
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		0
		1 is not even.
	</code></pre>
	<p>
		In the code above, we have two functions,
		<span class="monoText">main()</span> and
		<span class="monoText">isEven()</span>. Outside of these functions, we have
		<span class="monoText">int a = 1</span>. This is a
		<span class="italicsText">global variable</span>. Inside
		<span class="monoText">main()</span>, we have the variable
		<span class="monoText">int x = 0</span>. This is a
		<span class="italicsText">local variable</span> (more specifically, a
		variable <span class="italicsText">local to</span>
		<span class="monoText">main</span>). Inside both
		<span class="monoText">main()</span> and
		<span class="monoText">isEven()</span>, we have access to
		<span class="monoText">int a</span>. This is because
		<span class="monoText">int a</span> is a global variable &mdash; it's a
		variable that can be &#8220;seen&#8221; by all the functions following it.
	</p>
	<p>
		Recall that when we load a function in memory, each function's variables are
		allocated memory in a stack. Those stacks are popped off (i.e., the
		variables are destroyed) once the function finishes executing. This rule is
		true only for local variables (and function variables are local to the
		function). The rule is not true for global variables. Global variables exist
		in memory so long as the program continues running. Where do they exist? Not
		in the stack or the heap. Instead, they are allocated memory in the code
		section, where they stay as long as our program runs.
	</p>

	<h3>Block Level Scope</h3>
	<p>
		In addition to the global and local distinction, C++ also distinguishes
		scopes with block levels. A simple rule for block level scope: During
		compilation, C++ can see the variables to the left, but not variables to the
		right. For example:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		int x = 1;
		
		int main() {
			int x = 2;
			{
				int x = 3;
				cout << "x (from block): " << x << endl;
				cout << "Global x (from block): " << ::x << endl;
			}
			cout << "x (from main): " << x << endl;
			cout << "Global x (from main): " << ::x << endl;
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		x (from block): 3
		Global x (from block): 1
		x (from main): 2
		Global x (from main): 1
	</code></pre>
	<p>
		The <span class="monoText">::</span> operator is called the
		<span class="term">scope resolution operator</span>. It allows us to access
		a particular global variable when we have a variable with the same name
		locally.
	</p>
</section>

<section id="static_variables">
	<h2>Static Variables</h2>
	<p>
		Static variables are often a source of confusion for beginning programmers.
		In part, this is due to being overloaded with too many details all at once.
		Consider this issue, we study static variables by first considering a
		relatable problem. Consider the following code:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
			using namespace std;
			
			int x = 1;
			
			void func1() {
				x++;
				cout << x << endl;
			}
			
			int main() {
				func1();
				func1();
				func1();
				return 0;
			}
	</code></pre>
	<pre class="language-bash"><code>
		1
		2
		3
	</code></pre>
	<p>
		In the code above, we have a global variable,
		<span class="monoText">int x = 1</span>. We then have a function,
		<span class="monoText">func1()</span>, which increments the global variable,
		<span class="monoText">x</span> by <span class="monoText">1</span>. Thus,
		when we go into <span class="monoText">main()</span>, each call to
		<span class="monoText">func1()</span> results in an increment of
		<span class="monoText">x</span>.
	</p>
	<p>
		Now, suppose we don't want that <span class="monoText">x</span> to be a
		global variable. There are many reasons for why might not want
		<span class="monoText">x</span> to be a global variable (in fact, we
		generally do not want global variables). Perhaps
		<span class="monoText">x</span> is a variable that should only be mutated by
		<span class="monoText">func1()</span>; no other function or module should be
		able to touch it. How do we achieve this? Well, why not just place
		<span class="monoText">x</span> inside the body of
		<span class="monoText">func1()</span>? Let's try that:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		void func1() {
			int x = 0;
			x++;
			cout << x << endl;
		}
		
		int main() {
			func1();
			func1();
			func1();
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		1
		1
		1
	</code></pre>
	<p>
		Nope, that didn't work. Remember: After a function has finished executing,
		the stack where its variables are allocated is popped off. Thus, we never
		see <span class="monoText">1 2 3</span> because each function call starts
		with <span class="monoText">int x = 0</span>.
	</p>
	<p>Static variables are intended to address this problem:</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		void func1() {
			static int x = 0;
			x++;
			cout << x << endl;
		}
		
		int main() {
			func1();
			func1();
			func1();
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		1
		2
		3
	</code></pre>
	<p>
		By appending the <span class="monoText">static</span> keyword to
		<span class="monoText">int x = 0</span>, we've ensured that
		<span class="monoText">x</span> is treated as a static variable of the
		function <span class="monoText">func1()</span>. This effectively makes
		<span class="monoText">x</span> a variable akin to being
		&#8220;global&#8221; to <span class="monoText">func1()</span>. Thus, for
		every call to <span class="monoText">func1()</span>,
		<span class="monoText">func1()</span> uses the current value of
		<span class="monoText">x</span>.
	</p>
	<p>
		Like global variables, static variables exist in memory so long as our
		program runs. The different: Static variables are only accessible to their
		respective modules. In this case, <span class="monoText">x</span> is only
		accessible to <span class="monoText">func1()</span>; nowhere else.
	</p>
</section>

{% endblock %}
