{% extends '../layout.html' %} {% load static %} {% block description %}
<meta name="description" content="C++ functions" />
{% endblock %} {% block title %}
<title>C++ Functions</title>
{% endblock %} {% block content %}

<h1>Functions</h1>
<section id="functions">
	<p>
		In the simplest terms, a function is a piece of code that performs a
		specific task. It takes inputs, called <span class="term">arguments</span>,
		and returns an output, called a <span class="term">return value</span>.
		There are many ways to think about functions. For now, we can think of
		functions as ways to <span class="italicsText">modularize</span> our code.
		If we have a particular computation that must be performed over and over
		again, that computation would be best capsulated as a function. For example,
		consider this code that prints out an array:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		int main() {
			int arr[]{1, 2, 3, 4};
			int sizeOfArr = sizeof(arr) / sizeof(int);
			for (int i = 0; i < sizeOfArr; i++) {
				cout << arr[i] << " ";
			}
			cout << endl;
			return 0;
		}
	</code></pre>
	<p>
		If we had multiple arrays, we would have to write that
		<span class="monoText">for</span> loop multiple times.
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		int main() {
			int arr1[]{1, 2, 3, 4};
			int arr2[]{5, 6, 7, 8};
			int sizeOfArr1 = sizeof(arr1) / sizeof(int);
			int sizeOfArr2 = sizeof(arr2) / sizeof(int);
			for (int i = 0; i < sizeOfArr1; i++) {
				cout << arr1[i] << " ";
			}
			cout << endl;
			for (int i = 0; i < sizeOfArr2; i++) {
				cout << arr2[i] << " ";
			}
			cout << endl;
			return 0;
		}
	</code></pre>
	<p>It would be much cleaner if we just wrote a function:</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		void printIntArr(int arr[], int length);
		
		int main() {
			int arr1[]{1, 2, 3, 4};
			int arr2[]{5, 6, 7, 8};
			int sizeOf_arr1 = sizeof(arr1) / sizeof(int);
			int sizeOf_arr2 = sizeof(arr2) / sizeof(int);
			printIntArr(arr1, sizeOf_arr1);
			printIntArr(arr2, sizeOf_arr2);
			return 0;
		}
		
		void printIntArr(int arr[], int length) {
			for (int i = 0; i < length; i++) {
				cout << arr[i] << " ";
			}
			cout << endl;
		}
	</code></pre>
	<p>
		It may look like there's not much of a difference, but we have effectively
		modularized our code, allowing us to call it whenever we'd like, for however
		many arrays we want, without having to write
		<span class="monoText">for</span> loops over and over. To clean the code up
		a bit more, we can use a macro (don't worry about this for now, we will
		expore macros in later sections):
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		#define SIZEOF(a) sizeof(a)/sizeof(*a)
		
		void printIntArr(int arr[], int length);
		
		int main() {
			int arr1[]{1, 2, 3, 4};
			int arr2[]{5, 6, 7, 8};
			printIntArr(arr1, SIZEOF(arr1));
			printIntArr(arr2, SIZEOF(arr2));
			return 0;
		}
		
		void printIntArr(int arr[], int length) {
			for (int i = 0; i < length; i++) {
				cout << arr[i] << " ";
			}
			cout << endl;
		}
	</code></pre>
	<p>
		Erring on the side of functions when writing code is a hallmark of the
		programming paradigm <span class="term">functional programming</span>. The
		benefits of functional programming is modularized code, and it is the exact
		opposite of <span class="term">monolithic programming</span> &mdash; writing
		all of our code in a single area, such as
		<span class="monoText">main()</span>. If we wrote all of our code in
		<span class="monoText">main()</span>, then we take on several risks. First,
		suppose our program spanned several thousand lies (not at all unusual). If
		we so happen to encounter a bug, we would have to weave through several
		thousand lines trying to pinpoint the problem. With modularized code, we can
		more quickly find the source by examining each module separately. Moreover,
		modularized code avoids cross-contamination by isolating pieces of code.
	</p>
	<p>
		Second, our program required performing a computation in a for loop, or a
		computation in a function, or a computation in a function in a function
		(again, not at all unusual). Without using functions, we would have to copy
		and paste the computation's code everywhere it's needed. This is (1) not
		productive and (2) almost assuredly will cause bugs (think about how many
		times you've copied and pasted and missed a character; one character is all
		it takes in programming).
	</p>
	<blockquote>Order matters.</blockquote>
	<p>
		In <span class="monoText">C++</span>, the order in which we write functions
		matters. Any call to a function <span class="underlineText">must</span> be
		made <span class="underlineText">after</span> the function is implemented.
		For example, the following will not work:
	</p>
	<pre class="language-cpp"><code>
		int main() {
			double a = circleArea(2.0);
			return 0;
		}
		double circleArea(double r) {
			double pi = 3.14;
			double area = 2 * pi * r;
			return area;
		}
	</code></pre>
	<pre class="language-bash"><code>
		error: ‘circleArea’ was not declared in this scope
	</code></pre>
	<p>The correct syntax:</p>
	<pre class="language-cpp"><code>
		double circleArea(double r) {
			double pi = 3.14;
			double area = 2 * pi * r;
			return area;
		}
		int main() {
			double a = circleArea(2.0);
			return 0;
		}
	</code></pre>

	<p>
		Most programmers, however, do not like having these implementations before
		the <span class="monoText">main()</span> function. The
		<span class="monoText">main()</span> function is where all of the primary
		source code lies, so we usually want to see that as soon as possible. To do
		so, we include <span class="term">function prototypes</span> before
		<span class="monoText">main()</span>. This prototype serves as sort of a
		"heads up" to the compiler about an upcoming function. It takes the form:
	</p>

	<figure class="math-display">
		<ul class="syntax">
			<li>${t_r}$ ${f}$(${t_0 \space p_0, \ldots, t_n \space p_n}$)</li>
		</ul>
	</figure>

	<p>
		${t_r}$ represents the function's
		<span class="italicsText">return type</span> (the type of the function's
		output). ${f}$ is the function's <span class="italicsText">name</span>.
		${t_0, \ldots, t_n}$ are the types of the function's parameters. ${p_0,
		\ldots, p_n}$ are the parameter. Notice that just like variables, the
		parameters in a <span class="monoText">C++</span> function must have
		explicitly declared types.
	</p>
	<p>Thus, we can rewrite the erroneous example above as:</p>

	<pre class="language-cpp"><code>
		double circleArea(double r);

		int main() {
			double a = circleArea(2.0);
			return 0;
		}
		double circleArea(double r) {
			double pi = 3.14;
			double area = 2 * pi * r;
			return area;
		}
	</code></pre>

	<p>
		Obviously, a program can have numerous functions, in which case we might
		have hundreds, if not thousands, of function protoypes. This is when we
		start writing functions in separate files, and
		<span class="monoText">include</span> them in our primary source code file.
		These files are called <span class="term">header files</span>, and we
		discuss them in more detail in a later section.
	</p>

	<p>
		Some functions do not explicitly return a value. What is the return type for
		these functions? It is <span class="monoText">void</span>:
	</p>
	<figure class="math-display">
		<ul class="syntax">
			<li>void ${f}$(${t_0 \space p_0, \ldots, t_n \space p_n}$)</li>
		</ul>
	</figure>
	<p>
		The keyword <span class="monoText">void</span> only applies to return types.
		We cannot have a <span class="monoText">void</span> parameter, and we cannot
		have <span class="monoText">void</span> variables.
	</p>
	<p>
		The above syntax is for function protoypes. When we actually implement the
		function, we use the following syntax:
	</p>
	<figure class="math-display">
		<ul class="syntax">
			<li>${r_t}$ ${f}$(${t_0}$ ${p_0}$, ${\ldots}$, ${t_n}$ ${p_n}$) {</li>
			<ul>
				<li>${t_v}$ ${v}$</li>
				<li>${statements}$</li>
				<li>${\vdots}$</li>
				<li>return ${v}$</li>
			</ul>
			<li>}</li>
		</ul>
	</figure>
	<p>
		In the syntax above, ${r_t}$ is the return type of the function, ${f}$ is
		the name of the function, ${t_n}$ are the types for the parameters, ${p_n}$
		are the parameters, ${t_v}$ is the return type for the variable that will
		store the return, and ${v}$ is the variable that will store the return. For
		example:
	</p>
	<pre class="language-cpp"><code>
		double Average(double a, double b) {
			double sum = a + b;
			return sum / 2;
		}

		int main() {
			double mid = average(10.2, 11.8);
			cout << mid << endl;
			return 0;
		}
	</code></pre>
	<p>
		One quirk of <span class="monoText">C++</span> is that order absolutely
		matters. All of our actual source code is located in the
		<span class="monoText">main</span> function, so any function that is called
		inside <span class="monoText">main</span> must be defined before
		<span class="monoText">main</span>. More generally, a function must always
		be defined before it is called.
	</p>
	<p>
		In the code above, the <span class="monoText">average()</span> function is
		called the <span class="term">callee function</span> &mdash; it is the
		function that is called. The <span class="monoText">main()</span> function
		is called the <span class="term">caller function</span> &mdash; the function
		that calls.
	</p>
	<p>
		In the function <span class="monoText">average()</span>, we have
		<span class="monoText">double a</span> and
		<span class="monoText">double b</span>. These are the
		<span class="italicsText">parameters</span> of
		<span class="monoText">average()</span>. The variables
		<span class="monoText">a</span> and <span class="monoText">b</span> exist
		only inside the function <span class="monoText">average()</span>. They exist
		nowhere else but the <span class="monoText">average()</span> function.
		Likewise, the variable <span class="monoText">mid</span> exists only inside
		the <span class="monoText">main()</span> function. This means that
		<span class="monoText">average()</span> has no access to
		<span class="monoText">mid</span>, and
		<span class="monoText">main()</span> has no access to
		<span class="monoText">a</span> and <span class="monoText">b</span>.
	</p>
</section>

<section id="pass_by_value">
	<h2>Pass-by-value v. Pass-by-reference</h2>
	<p>What is the output of the following code:</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;

		int doubleValue(int x) {
			x *= 2;
			return x
		}

		int main() {
			int myValue = 5;
			int result = doubleValue(myValue);
			
			cout << "myValue: " << myValue << " ";
			cout << "result: " << result << endl;
		}
	</code></pre>
	<p>
		The output is <span class="monoText">10</span>. This is because we passed a
		<span class="italicsText">copy</span> of
		<span class="monoText">myValue</span> into the function
		<span class="monoText">doubleValue</span>. We call this mode of operation
		<span class="term">pass-by-value</span>, and it is the default mode of
		operation in <span class="monoText">C++</span>.
		<span class="marginnote"
			>One way to think about pass-by-value is a professor sending out his
			syllabus. Every student gets a copy of the syllabus, which they are free
			to mark, highlight, remove parts of, etc. However, the original syllabus
			&mdash; likely some Word or LaTeX document &mdash; exists only with the
			professor, and no student can modify it.</span
		>
		In pass-by-value, the arguments passed to a function are stored in a memory
		location other than the value passed into the parameter. This is why we say
		that functions receive a &#8220;copy,&#8221; rather than the original.
	</p>

	<p>
		Suppose, however, that we want the modify the original. In that situation,
		we use <span class="term">pass-by-reference</span> &mdash; the parameters
		and the arguments refer to the same memory location. To do so, we prepend
		the parameter name with an ampersand (<span class="monoText">&</span>).
	</p>

	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		void cube(int &x);
		
		int main(int argc, char *argv[]) {
			int num = 3;
			cout << num << endl;
			cube(num);
			cout << num << endl;
			return 0;
		}
		
		void cube(int &x) {
			x = x * x * x;
		}
	</code></pre>
	<pre class="language-bash"><code>
		3
		27
	</code></pre>
	<p>
		Notice how the value assigned to <span class="monoText">num</span> changed.
		This is because we passed a reference, rather than a copy. Accordingly, the
		value originally assigned to <span class="monoText">num</span> was modified.
	</p>

	<p>
		<span class="topic">Default Values.</span> In
		<span class="monoText">C++</span>, we can set default values for function
		parameters. For example:
	</p>

	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
			
		int increment(int a, int b=1) {
			int result = a + b;
			return result;
		}
		
		int main() {
			int a = increment(1);
			int b = increment(1, 2);
			cout&lt;&lt;a&lt;&lt;endl;
			cout&lt;&lt;b;
	
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		2
		3
	</code></pre>
</section>

<section id="variable_scope">
	<h2>Variable Scope</h2>
	<p>
		Functions are good point for us to switch gears and discuss
		<span class="term">scope</span>.
	</p>
</section>

<section id="value_of_functions">
	<h2>Why use functions?</h2>
	<p>
		Functions are more than just a way of reusing code. They are the building
		blocks for <span class="term">procedural decomposition</span> &mdash;
		breaking down a program into smaller and smaller pieces. In a good
		<span class="monoText">C++</span> program, the
		<span class="monoText">main()</span> function is the overarching function
		that calls <span class="term">helper functions</span>. We should think of
		<span class="monoText">main()</span> as a function akin to the conductor of
		a gargantuan orchestra; it simply drives, or directs, the order in which the
		helper functions are called.
	</p>
	<p>
		The helper functions should meet several criteria: (1) The helper function
		performs one, and only one, coherent task. (2) The function does not do too
		large a share of the work. (3) The function is not overly reliant on other
		functions. And (4) the function stores data in the narrowest scope possible.
	</p>
</section>
{% endblock %}
