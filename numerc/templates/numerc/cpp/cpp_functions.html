{% extends '../layout.html' %} {% load static %} {% block description %}
<meta name="description" content="C++ functions" />
{% endblock %} {% block title %}
<title>C++ Functions</title>
{% endblock %} {% block content %}

<h1>Functions</h1>
<section id="functions">
	<p>
		In the simplest terms, a function is a piece of code that performs a
		specific task. It takes inputs, called <span class="term">arguments</span>,
		and returns an output, called a <span class="term">return value</span>.
		There are many ways to think about functions. For now, we can think of
		functions as ways to <span class="italicsText">modularize</span> our code.
		If we have a particular computation that must be performed over and over
		again, that computation would be best capsulated as a function. For example,
		consider this code that prints out an array:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		int main() {
			int arr[]{1, 2, 3, 4};
			int sizeOfArr = sizeof(arr) / sizeof(int);
			for (int i = 0; i < sizeOfArr; i++) {
				cout << arr[i] << " ";
			}
			cout << endl;
			return 0;
		}
	</code></pre>
	<p>
		If we had multiple arrays, we would have to write that
		<span class="monoText">for</span> loop multiple times.
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		int main() {
			int arr1[]{1, 2, 3, 4};
			int arr2[]{5, 6, 7, 8};
			int sizeOfArr1 = sizeof(arr1) / sizeof(int);
			int sizeOfArr2 = sizeof(arr2) / sizeof(int);
			for (int i = 0; i < sizeOfArr1; i++) {
				cout << arr1[i] << " ";
			}
			cout << endl;
			for (int i = 0; i < sizeOfArr2; i++) {
				cout << arr2[i] << " ";
			}
			cout << endl;
			return 0;
		}
	</code></pre>
	<p>It would be much cleaner if we just wrote a function:</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		void printIntArr(int arr[], int length);
		
		int main() {
			int arr1[]{1, 2, 3, 4};
			int arr2[]{5, 6, 7, 8};
			int sizeOf_arr1 = sizeof(arr1) / sizeof(int);
			int sizeOf_arr2 = sizeof(arr2) / sizeof(int);
			printIntArr(arr1, sizeOf_arr1);
			printIntArr(arr2, sizeOf_arr2);
			return 0;
		}
		
		void printIntArr(int arr[], int length) {
			for (int i = 0; i < length; i++) {
				cout << arr[i] << " ";
			}
			cout << endl;
		}
	</code></pre>
	<p>
		It may look like there's not much of a difference, but we have effectively
		modularized our code, allowing us to call it whenever we'd like, for however
		many arrays we want, without having to write
		<span class="monoText">for</span> loops over and over. To clean the code up
		a bit more, we can use a macro (don't worry about this for now, we will
		expore macros in later sections):
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		#define SIZEOF(a) sizeof(a)/sizeof(*a)
		
		void printIntArr(int arr[], int length);
		
		int main() {
			int arr1[]{1, 2, 3, 4};
			int arr2[]{5, 6, 7, 8};
			printIntArr(arr1, SIZEOF(arr1));
			printIntArr(arr2, SIZEOF(arr2));
			return 0;
		}
		
		void printIntArr(int arr[], int length) {
			for (int i = 0; i < length; i++) {
				cout << arr[i] << " ";
			}
			cout << endl;
		}
	</code></pre>
	<p>
		Erring on the side of functions when writing code is a hallmark of the
		programming paradigm <span class="term">functional programming</span>. The
		benefits of functional programming is modularized code, and it is the exact
		opposite of <span class="term">monolithic programming</span> &mdash; writing
		all of our code in a single area, such as
		<span class="monoText">main()</span>. If we wrote all of our code in
		<span class="monoText">main()</span>, then we take on several risks. First,
		suppose our program spanned several thousand lies (not at all unusual). If
		we so happen to encounter a bug, we would have to weave through several
		thousand lines trying to pinpoint the problem. With modularized code, we can
		more quickly find the source by examining each module separately. Moreover,
		modularized code avoids cross-contamination by isolating pieces of code.
	</p>
	<p>
		Second, our program required performing a computation in a for loop, or a
		computation in a function, or a computation in a function in a function
		(again, not at all unusual). Without using functions, we would have to copy
		and paste the computation's code everywhere it's needed. This is (1) not
		productive and (2) almost assuredly will cause bugs (think about how many
		times you've copied and pasted and missed a character; one character is all
		it takes in programming).
	</p>
	<blockquote>Order matters.</blockquote>
	<p>
		In <span class="monoText">C++</span>, the order in which we write functions
		matters. Any call to a function <span class="underlineText">must</span> be
		made <span class="underlineText">after</span> the function is implemented.
		For example, the following will not work:
	</p>
	<pre class="language-cpp"><code>
		int main() {
			double a = circleArea(2.0);
			return 0;
		}
		double circleArea(double r) {
			double pi = 3.14;
			double area = 2 * pi * r;
			return area;
		}
	</code></pre>
	<pre class="language-bash"><code>
		error: ‘circleArea’ was not declared in this scope
	</code></pre>
	<p>The correct syntax:</p>
	<pre class="language-cpp"><code>
		double circleArea(double r) {
			double pi = 3.14;
			double area = 2 * pi * r;
			return area;
		}
		int main() {
			double a = circleArea(2.0);
			return 0;
		}
	</code></pre>

	<p>
		Most programmers, however, do not like having these implementations before
		the <span class="monoText">main()</span> function. The
		<span class="monoText">main()</span> function is where all of the primary
		source code lies, so we usually want to see that as soon as possible. To do
		so, we include <span class="term">function prototypes</span> before
		<span class="monoText">main()</span>. This prototype serves as sort of a
		"heads up" to the compiler about an upcoming function. It takes the form:
	</p>

	<figure class="math-display">
		<ul class="syntax">
			<li>${t_r}$ ${f}$(${t_0 \space p_0, \ldots, t_n \space p_n}$)</li>
		</ul>
	</figure>

	<p>
		${t_r}$ represents the function's
		<span class="italicsText">return type</span> (the type of the function's
		output). ${f}$ is the function's <span class="italicsText">name</span>.
		${t_0, \ldots, t_n}$ are the types of the function's parameters. ${p_0,
		\ldots, p_n}$ are the parameter. Notice that just like variables, the
		parameters in a <span class="monoText">C++</span> function must have
		explicitly declared types.
	</p>
	<p>Thus, we can rewrite the erroneous example above as:</p>

	<pre class="language-cpp"><code>
		double circleArea(double r);

		int main() {
			double a = circleArea(2.0);
			return 0;
		}
		double circleArea(double r) {
			double pi = 3.14;
			double area = 2 * pi * r;
			return area;
		}
	</code></pre>

	<p>
		Obviously, a program can have numerous functions, in which case we might
		have hundreds, if not thousands, of function protoypes. This is when we
		start writing functions in separate files, and
		<span class="monoText">include</span> them in our primary source code file.
		These files are called <span class="term">header files</span>, and we
		discuss them in more detail in a later section.
	</p>

	<p>
		Some functions do not explicitly return a value. What is the return type for
		these functions? It is <span class="monoText">void</span>:
	</p>
	<figure class="math-display">
		<ul class="syntax">
			<li>void ${f}$(${t_0 \space p_0, \ldots, t_n \space p_n}$)</li>
		</ul>
	</figure>
	<p>
		The keyword <span class="monoText">void</span> only applies to return types.
		We cannot have a <span class="monoText">void</span> parameter, and we cannot
		have <span class="monoText">void</span> variables.
	</p>
	<p>
		The above syntax is for function protoypes. When we actually implement the
		function, we use the following syntax:
	</p>
	<figure class="math-display">
		<ul class="syntax">
			<li>${r_t}$ ${f}$(${t_0}$ ${p_0}$, ${\ldots}$, ${t_n}$ ${p_n}$) {</li>
			<ul>
				<li>${t_v}$ ${v}$</li>
				<li>${statements}$</li>
				<li>${\vdots}$</li>
				<li>return ${v}$</li>
			</ul>
			<li>}</li>
		</ul>
	</figure>
	<p>
		In the syntax above, ${r_t}$ is the return type of the function, ${f}$ is
		the name of the function, ${t_n}$ are the types for the parameters, ${p_n}$
		are the parameters, ${t_v}$ is the return type for the variable that will
		store the return, and ${v}$ is the variable that will store the return. For
		example:
	</p>
	<pre class="language-cpp"><code>
		double Average(double a, double b) {
			double sum = a + b;
			return sum / 2;
		}

		int main() {
			double mid = average(10.2, 11.8);
			cout << mid << endl;
			return 0;
		}
	</code></pre>
	<p>
		One quirk of <span class="monoText">C++</span> is that order absolutely
		matters. All of our actual source code is located in the
		<span class="monoText">main</span> function, so any function that is called
		inside <span class="monoText">main</span> must be defined before
		<span class="monoText">main</span>. More generally, a function must always
		be defined before it is called.
	</p>
	<p>
		In the code above, the <span class="monoText">average()</span> function is
		called the <span class="term">callee function</span> &mdash; it is the
		function that is called. The <span class="monoText">main()</span> function
		is called the <span class="term">caller function</span> &mdash; the function
		that calls.
	</p>
	<p>
		In the function <span class="monoText">average()</span>, we have
		<span class="monoText">double a</span> and
		<span class="monoText">double b</span>. These are the
		<span class="italicsText">parameters</span> of
		<span class="monoText">average()</span>. The variables
		<span class="monoText">a</span> and <span class="monoText">b</span> exist
		only inside the function <span class="monoText">average()</span>. They exist
		nowhere else but the <span class="monoText">average()</span> function.
		Likewise, the variable <span class="monoText">mid</span> exists only inside
		the <span class="monoText">main()</span> function. This means that
		<span class="monoText">average()</span> has no access to
		<span class="monoText">mid</span>, and
		<span class="monoText">main()</span> has no access to
		<span class="monoText">a</span> and <span class="monoText">b</span>.
	</p>
	<p>
		<span class="topic">Default Values.</span> In
		<span class="monoText">C++</span>, we can set default values for function
		parameters. For example:
	</p>

	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
			
		int increment(int a, int b=1) {
			int result = a + b;
			return result;
		}
		
		int main() {
			int a = increment(1);
			int b = increment(1, 2);
			cout&lt;&lt;a&lt;&lt;endl;
			cout&lt;&lt;b;
	
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		2
		3
	</code></pre>
</section>

<section id="function_overloading">
	<h2>Function Overloading</h2>
	<p>
		Notice that the three functions, <span class="monoText">print()</span>, have
		the same name, but they compile just fine:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		#define SIZEOF(a) sizeof(a)/sizeof(*a)
		
		void print(int arr[], int length);
		void print(char arr[], int length);
		void print(double arr[], int length);
		
		int main() {
			int intArr[]{1, 2, 3, 4};
			char charArr[]{'a', 'b', 'c', 'd'};
			double doubleArr[]{1.2, 2.9, 3.1, 3.10};
		
			print(intArr, SIZEOF(intArr));
			print(charArr, SIZEOF(charArr));
			print(doubleArr, SIZEOF(doubleArr));
			return 0;
		}
		
		void print(int arr[], int length) {
			for (int i = 0; i < length; i++) {
				cout << arr[i] << " ";
			}
			cout << endl;
		}

		void print(char arr[], int length) {
			for (int i = 0; i < length; i++) {
				cout << arr[i] << " ";
			}
			cout << endl;
		}

		void print(double arr[], int length) {
			for (int i = 0; i < length; i++) {
				cout << arr[i] << " ";
			}
			cout << endl;
		}
	</code></pre>
	<pre class="language-bash"><code>
		1 2 3 4 
		a b c d 
		1.2 2.9 3.1 3.1 
	</code></pre>
	<p>
		This is an example of <span class="term">function overloading</span> &mdash;
		the phenomenon of when different functions performing different tasks, have
		the same identifier. More abstractly, we can think of it as if the function
		&mdash; an operator &mdash; can perform multiple tasks. In C++, we can
		accomplish function overloading by either (a) having different type
		parameters, (b) having a different number of parameters. In general, to
		accomplish function overloading, we have to provide C++ a way to
		differentiate between the functions. In the example of
		<span class="monoText">print()</span>, this is done by providing different
		arguments.
	</p>
	<p>
		Things that will not work, on their own, for differentiating: Return type,
		the order the functions are written, and default parameters. Using these
		differences alone are insufficient to allowing C++ to differentiate the
		functions, resulting in a <span class="term">name conflict</span>.
	</p>
	<p>
		Function overloading is tremendously useful. One of the hardest tasks in
		programming is naming things, made all the more difficult when we have
		functions that perform something very similar &mdash; like printing an array
		to the console &mdash; but differ by just one or two things, such as
		argument type. However, as with all features, there are tradeoffs.
	</p>
	<p>
		Function overloading is a kind of
		<span class="italicsText">polymorphism</span>, a topic we will discuss
		further in later sections. In a nutshell, polymorphism is when we have an
		entity of a particular type behaving like something else of a particular
		type. For example, a person's dog can behave like a loving friend. Yet in
		other situations, a vicious guard. The same idea &mdash; and risk &mdash;
		applies to overloaded functions. We must always be cognizant of what our
		functions are capable of doing, just as a dog owner should be cognizant of
		when and where their dogs are a danger to others. If a function is
		overloaded with too many tasks, we risk losing track of what the function
		does when passed certain arguments. A similar risk occurs when we overload a
		function with tasks that don't intuitively correspond to the identifier. For
		example, it would be a poor choice to allow
		<span class="monoText">print()</span> to average the elements of an
		<span class="monoText">int</span> array &mdash; it's not clear how averaging
		something relates to <span class="monoText">print</span>.
	</p>
</section>

<section id="function_templates">
	<h2>Function Templates</h2>
	<p>
		Recall the <span class="monoText">print()</span> function we saw in the
		previous example:
	</p>
	<pre class="language-cpp"><code>
		void print(int arr[], int length) {
			for (int i = 0; i < length; i++) {
				cout << arr[i] << " ";
			}
			cout << endl;
		}
		void print(char arr[], int length) {
			for (int i = 0; i < length; i++) {
				cout << arr[i] << " ";
			}
			cout << endl;
		}
		void print(double arr[], int length) {
			for (int i = 0; i < length; i++) {
				cout << arr[i] << " ";
			}
			cout << endl;
		}
	</code></pre>
	<p>
		The only thing that differentiates this function is the argument type. When
		programming, it's not uncommon to have functions like this &mdash; the same
		computation, but different arguments. In these situations, it's best to use
		a <span class="term">function template</span>. We can think of a function
		template as simply a more general, or abstract form of the function. We can
		reduce the functions above into a single function:
	</p>
	<pre class="language-cpp"><code>
		template&lt;class T&gt;
		void print(T arr[], int length) {
			for (int i = 0; i < length; i++) {
				cout << arr[i] << " ";
			}
			cout << endl;
		}
	</code></pre>
	<p>
		The <span class="monoText">T</span> in the code above essentially acts like
		a placeholder. C++ will replace the <span class="monoText">T</span> with the
		appropriate data type. This results in
		<span class="monoText">print()</span> becoming a
		<span class="term">generic function</span>. Applying this feature, our code
		begins to look cleaner, while keeping the added functionality:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		#define SIZEOF(a) sizeof(a)/sizeof(*a)
		
		template&lt;class T&gt;
		void print(T arr[], int length);
		
		int main() {
			int intArr[]{1, 2, 3, 4};
			char charArr[]{'a', 'b', 'c', 'd'};
			double doubleArr[]{1.2, 2.9, 3.1, 3.10};
		
			print(intArr, SIZEOF(intArr));
			print(charArr, SIZEOF(charArr));
			print(doubleArr, SIZEOF(doubleArr));
			return 0;
		}
		
		template&lt;class T&gt;
		void print(T arr[], int length) {
			for (int i = 0; i < length; i++) {
				cout << arr[i] << " ";
			}
			cout << endl;
		}
	</code></pre>
	<pre class="language-bash"><code>
		1 2 3 4 
		a b c d 
		1.2 2.9 3.1 3.1 
	</code></pre>
	<p>
		Notice that because we must include function signatures, the template
		declaration must appear both before the function signature and before the
		function's definition. Of course, we can avoid this by simply placing our
		function definition before <span class="monoText">main()</span>:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		#define SIZEOF(a) sizeof(a)/sizeof(*a)
		
		template &lt;class T&gt;
		void print(T arr[], int length) {
			for (int i = 0; i < length; i++) {
				cout << arr[i] << " ";
			}
			cout << endl;
		}
		
		int main() {
			int intArr[]{1, 2, 3, 4};
			char charArr[]{'a', 'b', 'c', 'd'};
			double doubleArr[]{1.2, 2.9, 3.1, 3.10};
		
			print(intArr, SIZEOF(intArr));
			print(charArr, SIZEOF(charArr));
			print(doubleArr, SIZEOF(doubleArr));
			return 0;
		}
	</code></pre>
</section>

<section id="argument_passing">
	<h2>Argument Passing</h2>
	<p>
		When functions have parameters without default values, they must be passed
		arguments. In C++, passing arguments into functions can be done in three
		ways: (1) <span class="term">pass-by-value</span>, (2)
		<span class="term">pass-by-reference</span>, and (3)
		<span class="term">pass-by-address</span>.
	</p>
	<p>
		To illustrate these differences, let's consider a canonical function in
		programming, <span class="monoText">swap()</span>. Before we write the
		function, let's recall how the function works. Say we have an
		<span class="monoText">int a = 0</span> and an
		<span class="monoText">int b = 1</span>. To swap the values assigned to the
		variables, we create a temporary variable, called
		<span class="monoText">temp</span>. Then, we assign to
		<span class="monoText">temp</span> the variable
		<span class="monoText">a.</span> Thus,
		<span class="monoText">temp = a = 0.</span> Then, we assign to
		<span class="monoText">a</span> the variable
		<span class="monoText">b.</span> Thus,
		<span class="monoText">a = b = 1.</span> Finally, we assign to
		<span class="monoText">b</span> the variable
		<span class="monoText">temp</span>:
		<span class="monoText">b = temp = 0</span>. The end result:
		<span class="monoText">a = 1</span> and <span class="monoText">b = 0</span>.
		Putting it all together:
	</p>

	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		int main() {
			int a = 0;
			int b = 1;
		
			cout << "Before the swap: " << endl;
			cout << "x = " << a << endl;
			cout << "y = " << b << endl;
		
			// The swap
			int temp;
			temp = a;
			a = b;
			b = temp;
		
			cout << "After the swap: " << endl;
			cout << "x = " << a << endl;
			cout << "y = " << b << endl;
		
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		Before the swap: 
		x = 0
		y = 1
		After the swap: 
		x = 1
		y = 0
	</code></pre>
	<p>
		Great, it works. Swapping variables, however, is a very common operation.
		Accordingly, we want to place this computation in a function, to be used
		whenever we'd like:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		void swap(int a, int b) {
			int temp;
			temp = a;
			a = b;
			b = temp;
		}
		
		int main() {
			int a = 0;
			int b = 1;
		
			cout << "Before the swap: " << endl;
			cout << "x = " << a << endl;
			cout << "y = " << b << endl;
		
			swap(a, b);
		
			cout << "After the swap: " << endl;
			cout << "x = " << a << endl;
			cout << "y = " << b << endl;
		
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		Before the swap: 
		x = 0
		y = 1
		After the swap: 
		x = 0
		y = 1
	</code></pre>
	<p>
		Strange. It didn't perform the swap. Why? Because calling functions the way
		we did above, <span class="monoText">swap(a, b)</span>, is by default
		<span class="term">pass-by-value</span>. In pass-by-value, the function only
		receives a <span class="underlineText">copy</span> of the values passed.
		They are not pass an original. To understand what this implies, recall what
		happens in main memory when we execute a function.
	</p>
	<p>
		When <span class="monoText">main()</span> is loaded, a stack in main memory
		is allocated for it. Let's call it
		<span class="italicsText">stack main</span>. Inside
		<span class="italicsText">stack main</span>, memory is allocated for
		<span class="monoText">int a = 0</span> and
		<span class="monoText">int b = 1</span>. Going down the code, we encounter
		<span class="monoText">swap(a, b)</span>. This is a new function, so a new
		stack is created to accomodate its variables. Call it
		<span class="italicsText">stack swap</span>. Inside
		<span class="italicsText">stack swap</span>, memory is allocated for
		<span class="monoText">int a</span>, <span class="monoText">int b</span>,
		and <span class="monoText">temp</span>. Now, arguments were passed into
		<span class="monoText">swap()</span>, so the memory allocated is for
		<span class="monoText">int a = 0</span>,
		<span class="monoText">int b = 1</span>, and
		<span class="monoText">temp</span>.
	</p>
	<p>
		Inside <span class="italicsText">swap stack</span>, the body of
		<span class="monoText">swap()</span> works as expected. The variables do in
		fact swap. We can see that's true by running the function without arguments:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		void swap(int a = 0, int b = 1) {
			cout << "Before swap: " << endl;
			cout << "\t a = " << a << endl;
			cout << "\t b = " << b << endl;
		
			// The swap
			int temp;
			temp = a;
			a = b;
			b = temp;
		
			cout << "After swap: " << endl;
			cout << "\t a = " << a << endl;
			cout << "\t b = " << b << endl;
		}
		
		int main() {
			swap();
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		Before swap: 
				a = 0
				b = 1
		After swap: 
				a = 1
				b = 0
	</code></pre>
	<p>
		So what does this all mean? It means that the swap never actually occurs in
		the <span class="monoText">main()</span> function. It only occurs in
		<span class="monoText">swap()</span>, and once
		<span class="monoText">swap()</span> is done,
		<span class="italicsText">stack swap</span> is destroyed. There was no
		effect whatsoever on the <span class="monoText">int a = 0</span> and
		<span class="monoText">int b = 1</span> in
		<span class="italicsText">stack main</span>.
	</p>
	<p>
		This embodies the concept of pass-by-value. When we simply pass regular
		variables into a function, we only pass copies of the values into the
		function. We never pass the originals.
	</p>
	<p>Call-by-value is what we use when we want the function to simply return a result based on the arguments passed. In fact, most of the functions we write are computations based on arguments. We generally do not want the original values changed &mdash; we want a new result. For example, suppose we had a function that computes acceleration:</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		double acceleration(double velocity1, double velocity2, double time) {
			return (velocity2 - velocity1) / time;
		}
		
		int main() {
			double v1 = 12.4;
			double v2 = 14.6;
			double t = 3.48;
		
			cout << "Before function call:" << endl;
			cout << "v1 = " << v1 << endl;
			cout << "v2 = " << v2 << endl;
			cout << "t = " << t << endl;
			
			double a = acceleration(v1, v2, t);
		
			cout << "After function call:" << endl;
			cout << "v1 = " << v1 << endl;
			cout << "v2 = " << v2 << endl;
			cout << "t = " << t << endl;
			cout << "a = " << a << endl;
		
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		Before function call:
		v1 = 12.4
		v2 = 14.6
		t = 3.48
		After function call:
		v1 = 12.4
		v2 = 14.6
		t = 3.48
		a = 0.632184
	</code></pre>
	<p>We obtained a value, but we did not modify the actual arguments, <span class="monoText">v1</span>, <span class="monoText">v2</span>, and <span class="monoText">t</span>. In programming, we want to minimize mutation as much as possible. Pass-by-value is one means of ensuring that. But what if we do want mutation? I.e., what if we truly want to modify the actual arguments?</p>
	<p>One way to do so is with <span class="term">pass-by-address</span>.</p>
</section>

<section id="variable_scope">
	<h2>Variable Scope</h2>
	<p>
		Functions are good point for us to switch gears and discuss
		<span class="term">scope</span>.
	</p>
</section>

<section id="value_of_functions">
	<h2>Why use functions?</h2>
	<p>
		Functions are more than just a way of reusing code. They are the building
		blocks for <span class="term">procedural decomposition</span> &mdash;
		breaking down a program into smaller and smaller pieces. In a good
		<span class="monoText">C++</span> program, the
		<span class="monoText">main()</span> function is the overarching function
		that calls <span class="term">helper functions</span>. We should think of
		<span class="monoText">main()</span> as a function akin to the conductor of
		a gargantuan orchestra; it simply drives, or directs, the order in which the
		helper functions are called.
	</p>
	<p>
		The helper functions should meet several criteria: (1) The helper function
		performs one, and only one, coherent task. (2) The function does not do too
		large a share of the work. (3) The function is not overly reliant on other
		functions. And (4) the function stores data in the narrowest scope possible.
	</p>
</section>
{% endblock %}
