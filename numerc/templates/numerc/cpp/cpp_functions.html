{% extends '../layout.html' %} {% load static %} {% block description %}
<meta name="description" content="C++ functions" />
{% endblock %} {% block title %}
<title>C++ Functions</title>
{% endblock %} {% block content %}

<h1>Functions</h1>
<section id="functions">
	<div class="mainIdea">
		<span class="topic">Key Points</span>
		<ul>
			<li>
				Pass-by-value: The parameter copies a value, changes to the value only
				affect the local copy. Benefit: Avoids mutability and unexpected
				changes. Cost: Creating new copies, resulting in more memory and
				processing power usage.
			</li>
			<li>
				Pass-by-reference: The parameter passes a reference to the original
				value, changes to the value can affect the original value. Benefits:
				More efficient, since no copies are made. Cost: More difficult to reason
				about what the code is doing.
			</li>
		</ul>
	</div>
	<p>
		<span class="drop">I</span>n the simplest terms, a function is a piece of
		code that performs a specific task. It takes inputs, called
		<span class="term">arguments</span>, and returns an output, called a
		<span class="term">return value</span>. There are many ways to think about
		functions. For now, we can think of functions as ways to
		<span class="italicsText">modularize</span> our code. If we have a
		particular computation that must be performed over and over again, that
		computation would be best capsulated as a function. For example, consider
		this code that prints out an array:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		int main() {
			int arr[]{1, 2, 3, 4};
			int sizeOfArr = sizeof(arr) / sizeof(int);
			for (int i = 0; i < sizeOfArr; i++) {
				cout << arr[i] << " ";
			}
			cout << endl;
			return 0;
		}
	</code></pre>
	<p>
		If we had multiple arrays, we would have to write that
		<span class="monoText">for</span> loop multiple times.
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		int main() {
			int arr1[]{1, 2, 3, 4};
			int arr2[]{5, 6, 7, 8};
			int sizeOfArr1 = sizeof(arr1) / sizeof(int);
			int sizeOfArr2 = sizeof(arr2) / sizeof(int);
			for (int i = 0; i < sizeOfArr1; i++) {
				cout << arr1[i] << " ";
			}
			cout << endl;
			for (int i = 0; i < sizeOfArr2; i++) {
				cout << arr2[i] << " ";
			}
			cout << endl;
			return 0;
		}
	</code></pre>
	<p>It would be much cleaner if we just wrote a function:</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		void printIntArr(int arr[], int length);
		
		int main() {
			int arr1[]{1, 2, 3, 4};
			int arr2[]{5, 6, 7, 8};
			int sizeOf_arr1 = sizeof(arr1) / sizeof(int);
			int sizeOf_arr2 = sizeof(arr2) / sizeof(int);
			printIntArr(arr1, sizeOf_arr1);
			printIntArr(arr2, sizeOf_arr2);
			return 0;
		}
		
		void printIntArr(int arr[], int length) {
			for (int i = 0; i < length; i++) {
				cout << arr[i] << " ";
			}
			cout << endl;
		}
	</code></pre>
	<p>
		It may look like there's not much of a difference, but we have effectively
		modularized our code, allowing us to call it whenever we'd like, for however
		many arrays we want, without having to write
		<span class="monoText">for</span> loops over and over. To clean the code up
		a bit more, we can use a macro (don't worry about this for now, we will
		expore macros in later sections):
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		#define SIZEOF(a) sizeof(a)/sizeof(*a)
		
		void printIntArr(int arr[], int length);
		
		int main() {
			int arr1[]{1, 2, 3, 4};
			int arr2[]{5, 6, 7, 8};
			printIntArr(arr1, SIZEOF(arr1));
			printIntArr(arr2, SIZEOF(arr2));
			return 0;
		}
		
		void printIntArr(int arr[], int length) {
			for (int i = 0; i < length; i++) {
				cout << arr[i] << " ";
			}
			cout << endl;
		}
	</code></pre>
	<p>
		Erring on the side of functions when writing code is a hallmark of the
		programming paradigm <span class="term">functional programming</span>. The
		benefits of functional programming is modularized code, and it is the exact
		opposite of <span class="term">monolithic programming</span> &mdash; writing
		all of our code in a single area, such as
		<span class="monoText">main()</span>. If we wrote all of our code in
		<span class="monoText">main()</span>, then we take on several risks. First,
		suppose our program spanned several thousand lies (not at all unusual). If
		we so happen to encounter a bug, we would have to weave through several
		thousand lines trying to pinpoint the problem. With modularized code, we can
		more quickly find the source by examining each module separately. Moreover,
		modularized code avoids cross-contamination by isolating pieces of code.
	</p>
	<p>
		Second, our program required performing a computation in a for loop, or a
		computation in a function, or a computation in a function in a function
		(again, not at all unusual). Without using functions, we would have to copy
		and paste the computation's code everywhere it's needed. This is (1) not
		productive and (2) almost assuredly will cause bugs (think about how many
		times you've copied and pasted and missed a character; one character is all
		it takes in programming).
	</p>
	<blockquote>Order matters.</blockquote>
	<p>
		In <span class="monoText">C++</span>, the order in which we write functions
		matters. Any call to a function <span class="underlineText">must</span> be
		made <span class="underlineText">after</span> the function is implemented.
		For example, the following will not work:
	</p>
	<pre class="language-cpp"><code>
		int main() {
			double a = circleArea(2.0);
			return 0;
		}
		double circleArea(double r) {
			double pi = 3.14;
			double area = 2 * pi * r;
			return area;
		}
	</code></pre>
	<pre class="language-bash"><code>
		error: ‘circleArea’ was not declared in this scope
	</code></pre>
	<p>The correct syntax:</p>
	<pre class="language-cpp"><code>
		double circleArea(double r) {
			double pi = 3.14;
			double area = 2 * pi * r;
			return area;
		}
		int main() {
			double a = circleArea(2.0);
			return 0;
		}
	</code></pre>

	<p>
		Most programmers, however, do not like having these implementations before
		the <span class="monoText">main()</span> function. The
		<span class="monoText">main()</span> function is where all of the primary
		source code lies, so we usually want to see that as soon as possible. To do
		so, we include <span class="term">function prototypes</span> before
		<span class="monoText">main()</span>. This prototype serves as sort of a
		"heads up" to the compiler about an upcoming function. It takes the form:
	</p>

	<figure class="math-display">
		<ul class="syntax">
			<li>${t_r}$ ${f}$(${t_0 \space p_0, \ldots, t_n \space p_n}$)</li>
		</ul>
	</figure>

	<p>
		${t_r}$ represents the function's
		<span class="italicsText">return type</span> (the type of the function's
		output). ${f}$ is the function's <span class="italicsText">name</span>.
		${t_0, \ldots, t_n}$ are the types of the function's parameters. ${p_0,
		\ldots, p_n}$ are the parameter. Notice that just like variables, the
		parameters in a <span class="monoText">C++</span> function must have
		explicitly declared types.
	</p>
	<p>Thus, we can rewrite the erroneous example above as:</p>

	<pre class="language-cpp"><code>
		double circleArea(double r);

		int main() {
			double a = circleArea(2.0);
			return 0;
		}
		double circleArea(double r) {
			double pi = 3.14;
			double area = 2 * pi * r;
			return area;
		}
	</code></pre>

	<p>
		Obviously, a program can have numerous functions, in which case we might
		have hundreds, if not thousands, of function protoypes. This is when we
		start writing functions in separate files, and
		<span class="monoText">include</span> them in our primary source code file.
		These files are called <span class="term">header files</span>, and we
		discuss them in more detail in a later section.
	</p>

	<p>
		Some functions do not explicitly return a value. What is the return type for
		these functions? It is <span class="monoText">void</span>:
	</p>
	<figure class="math-display">
		<ul class="syntax">
			<li>void ${f}$(${t_0 \space p_0, \ldots, t_n \space p_n}$)</li>
		</ul>
	</figure>
	<p>
		The keyword <span class="monoText">void</span> only applies to return types.
		We cannot have a <span class="monoText">void</span> parameter, and we cannot
		have <span class="monoText">void</span> variables.
	</p>
	<p>
		The above syntax is for function protoypes. When we actually implement the
		function, we use the following syntax:
	</p>
	<figure class="math-display">
		<ul class="syntax">
			<li>${r_t}$ ${f}$(${t_0}$ ${p_0}$, ${\ldots}$, ${t_n}$ ${p_n}$) {</li>
			<ul>
				<li>${t_v}$ ${v}$</li>
				<li>${statements}$</li>
				<li>${\vdots}$</li>
				<li>return ${v}$</li>
			</ul>
			<li>}</li>
		</ul>
	</figure>
	<p>
		In the syntax above, ${r_t}$ is the return type of the function, ${f}$ is
		the name of the function, ${t_n}$ are the types for the parameters, ${p_n}$
		are the parameters, ${t_v}$ is the return type for the variable that will
		store the return, and ${v}$ is the variable that will store the return. For
		example:
	</p>
	<pre class="language-cpp"><code>
		double Average(double a, double b) {
			double sum = a + b;
			return sum / 2;
		}

		int main() {
			double mid = average(10.2, 11.8);
			cout << mid << endl;
			return 0;
		}
	</code></pre>
	<p>
		One quirk of <span class="monoText">C++</span> is that order absolutely
		matters. All of our actual source code is located in the
		<span class="monoText">main</span> function, so any function that is called
		inside <span class="monoText">main</span> must be defined before
		<span class="monoText">main</span>. More generally, a function must always
		be defined before it is called.
	</p>
	<p>
		In the code above, the <span class="monoText">average()</span> function is
		called the <span class="term">callee function</span> &mdash; it is the
		function that is called. The <span class="monoText">main()</span> function
		is called the <span class="term">caller function</span> &mdash; the function
		that calls.
	</p>
	<p>
		In the function <span class="monoText">average()</span>, we have
		<span class="monoText">double a</span> and
		<span class="monoText">double b</span>. These are the
		<span class="italicsText">parameters</span> of
		<span class="monoText">average()</span>. The variables
		<span class="monoText">a</span> and <span class="monoText">b</span> exist
		only inside the function <span class="monoText">average()</span>. They exist
		nowhere else but the <span class="monoText">average()</span> function.
		Likewise, the variable <span class="monoText">mid</span> exists only inside
		the <span class="monoText">main()</span> function. This means that
		<span class="monoText">average()</span> has no access to
		<span class="monoText">mid</span>, and
		<span class="monoText">main()</span> has no access to
		<span class="monoText">a</span> and <span class="monoText">b</span>.
	</p>
	<p>
		<span class="topic">Default Values.</span> In
		<span class="monoText">C++</span>, we can set default values for function
		parameters. For example:
	</p>

	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
			
		int increment(int a, int b=1) {
			int result = a + b;
			return result;
		}
		
		int main() {
			int a = increment(1);
			int b = increment(1, 2);
			cout&lt;&lt;a&lt;&lt;endl;
			cout&lt;&lt;b;
	
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		2
		3
	</code></pre>
</section>

<section id="function_overloading">
	<h2>Function Overloading</h2>
	<p>
		Notice that the three functions, <span class="monoText">print()</span>, have
		the same name, but they compile just fine:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		#define SIZEOF(a) sizeof(a)/sizeof(*a)
		
		void print(int arr[], int length);
		void print(char arr[], int length);
		void print(double arr[], int length);
		
		int main() {
			int intArr[]{1, 2, 3, 4};
			char charArr[]{'a', 'b', 'c', 'd'};
			double doubleArr[]{1.2, 2.9, 3.1, 3.10};
		
			print(intArr, SIZEOF(intArr));
			print(charArr, SIZEOF(charArr));
			print(doubleArr, SIZEOF(doubleArr));
			return 0;
		}
		
		void print(int arr[], int length) {
			for (int i = 0; i < length; i++) {
				cout << arr[i] << " ";
			}
			cout << endl;
		}

		void print(char arr[], int length) {
			for (int i = 0; i < length; i++) {
				cout << arr[i] << " ";
			}
			cout << endl;
		}

		void print(double arr[], int length) {
			for (int i = 0; i < length; i++) {
				cout << arr[i] << " ";
			}
			cout << endl;
		}
	</code></pre>
	<pre class="language-bash"><code>
		1 2 3 4 
		a b c d 
		1.2 2.9 3.1 3.1 
	</code></pre>
	<p>
		This is an example of <span class="term">function overloading</span> &mdash;
		the phenomenon of when different functions performing different tasks, have
		the same identifier. More abstractly, we can think of it as if the function
		&mdash; an operator &mdash; can perform multiple tasks. In C++, we can
		accomplish function overloading by either (a) having different type
		parameters, (b) having a different number of parameters. In general, to
		accomplish function overloading, we have to provide C++ a way to
		differentiate between the functions. In the example of
		<span class="monoText">print()</span>, this is done by providing different
		arguments.
	</p>
	<p>
		Things that will not work, on their own, for differentiating: Return type,
		the order the functions are written, and default parameters. Using these
		differences alone are insufficient to allowing C++ to differentiate the
		functions, resulting in a <span class="term">name conflict</span>.
	</p>
	<p>
		Function overloading is tremendously useful. One of the hardest tasks in
		programming is naming things, made all the more difficult when we have
		functions that perform something very similar &mdash; like printing an array
		to the console &mdash; but differ by just one or two things, such as
		argument type. However, as with all features, there are tradeoffs.
	</p>
	<p>
		Function overloading is a kind of
		<span class="italicsText">polymorphism</span>, a topic we will discuss
		further in later sections. In a nutshell, polymorphism is when we have an
		entity of a particular type behaving like something else of a particular
		type. For example, a person's dog can behave like a loving friend. Yet in
		other situations, a vicious guard. The same idea &mdash; and risk &mdash;
		applies to overloaded functions. We must always be cognizant of what our
		functions are capable of doing, just as a dog owner should be cognizant of
		when and where their dogs are a danger to others. If a function is
		overloaded with too many tasks, we risk losing track of what the function
		does when passed certain arguments. A similar risk occurs when we overload a
		function with tasks that don't intuitively correspond to the identifier. For
		example, it would be a poor choice to allow
		<span class="monoText">print()</span> to average the elements of an
		<span class="monoText">int</span> array &mdash; it's not clear how averaging
		something relates to <span class="monoText">print</span>.
	</p>
</section>

<section id="function_templates">
	<h2>Function Templates</h2>
	<p>
		Recall the <span class="monoText">print()</span> function we saw in the
		previous example:
	</p>
	<pre class="language-cpp"><code>
		void print(int arr[], int length) {
			for (int i = 0; i < length; i++) {
				cout << arr[i] << " ";
			}
			cout << endl;
		}
		void print(char arr[], int length) {
			for (int i = 0; i < length; i++) {
				cout << arr[i] << " ";
			}
			cout << endl;
		}
		void print(double arr[], int length) {
			for (int i = 0; i < length; i++) {
				cout << arr[i] << " ";
			}
			cout << endl;
		}
	</code></pre>
	<p>
		The only thing that differentiates this function is the argument type. When
		programming, it's not uncommon to have functions like this &mdash; the same
		computation, but different arguments. In these situations, it's best to use
		a <span class="term">function template</span>. We can think of a function
		template as simply a more general, or abstract form of the function. We can
		reduce the functions above into a single function:
	</p>
	<pre class="language-cpp"><code>
		template&lt;class T&gt;
		void print(T arr[], int length) {
			for (int i = 0; i < length; i++) {
				cout << arr[i] << " ";
			}
			cout << endl;
		}
	</code></pre>
	<p>
		The <span class="monoText">T</span> in the code above essentially acts like
		a placeholder. C++ will replace the <span class="monoText">T</span> with the
		appropriate data type. This results in
		<span class="monoText">print()</span> becoming a
		<span class="term">generic function</span>. Applying this feature, our code
		begins to look cleaner, while keeping the added functionality:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		#define SIZEOF(a) sizeof(a)/sizeof(*a)
		
		template&lt;class T&gt;
		void print(T arr[], int length);
		
		int main() {
			int intArr[]{1, 2, 3, 4};
			char charArr[]{'a', 'b', 'c', 'd'};
			double doubleArr[]{1.2, 2.9, 3.1, 3.10};
		
			print(intArr, SIZEOF(intArr));
			print(charArr, SIZEOF(charArr));
			print(doubleArr, SIZEOF(doubleArr));
			return 0;
		}
		
		template&lt;class T&gt;
		void print(T arr[], int length) {
			for (int i = 0; i < length; i++) {
				cout << arr[i] << " ";
			}
			cout << endl;
		}
	</code></pre>
	<pre class="language-bash"><code>
		1 2 3 4 
		a b c d 
		1.2 2.9 3.1 3.1 
	</code></pre>
	<p>
		Notice that because we must include function signatures, the template
		declaration must appear both before the function signature and before the
		function's definition. Of course, we can avoid this by simply placing our
		function definition before <span class="monoText">main()</span>:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		#define SIZEOF(a) sizeof(a)/sizeof(*a)
		
		template &lt;class T&gt;
		void print(T arr[], int length) {
			for (int i = 0; i < length; i++) {
				cout << arr[i] << " ";
			}
			cout << endl;
		}
		
		int main() {
			int intArr[]{1, 2, 3, 4};
			char charArr[]{'a', 'b', 'c', 'd'};
			double doubleArr[]{1.2, 2.9, 3.1, 3.10};
		
			print(intArr, SIZEOF(intArr));
			print(charArr, SIZEOF(charArr));
			print(doubleArr, SIZEOF(doubleArr));
			return 0;
		}
	</code></pre>
</section>

<section id="argument_passing">
	<h2>Argument Passing</h2>
	<p>
		When functions have parameters without default values, they must be passed
		arguments. In C++, passing arguments into functions can be done in three
		ways: (1) <span class="term">pass-by-value</span>, (2)
		<span class="term">pass-by-reference</span>, and (3)
		<span class="term">pass-by-address</span>.
	</p>

	<section id="pass_by_value">
		<h3>Pass-by-value</h3>
		<p>
			To illustrate these differences, let's consider a canonical function in
			programming, <span class="monoText">swap()</span>. Before we write the
			function, let's recall how the function works. Say we have an
			<span class="monoText">int a = 0</span> and an
			<span class="monoText">int b = 1</span>. To swap the values assigned to
			the variables, we create a temporary variable, called
			<span class="monoText">temp</span>. Then, we assign to
			<span class="monoText">temp</span> the variable
			<span class="monoText">a.</span> Thus,
			<span class="monoText">temp = a = 0.</span> Then, we assign to
			<span class="monoText">a</span> the variable
			<span class="monoText">b.</span> Thus,
			<span class="monoText">a = b = 1.</span> Finally, we assign to
			<span class="monoText">b</span> the variable
			<span class="monoText">temp</span>:
			<span class="monoText">b = temp = 0</span>. The end result:
			<span class="monoText">a = 1</span> and
			<span class="monoText">b = 0</span>. Putting it all together:
		</p>

		<pre class="language-cpp"><code>
			#include &lt;iostream&gt;
			using namespace std;
			
			int main() {
				int a = 0;
				int b = 1;
			
				cout << "Before the swap: " << endl;
				cout << "x = " << a << endl;
				cout << "y = " << b << endl;
			
				// The swap
				int temp;
				temp = a;
				a = b;
				b = temp;
			
				cout << "After the swap: " << endl;
				cout << "x = " << a << endl;
				cout << "y = " << b << endl;
			
				return 0;
			}
		</code></pre>
		<pre class="language-bash"><code>
			Before the swap: 
			x = 0
			y = 1
			After the swap: 
			x = 1
			y = 0
		</code></pre>
		<p>
			Great, it works. Swapping variables, however, is a very common operation.
			Accordingly, we want to place this computation in a function, to be used
			whenever we'd like:
		</p>
		<pre class="language-cpp"><code>
			#include &lt;iostream&gt;
			using namespace std;
			
			void swap(int a, int b) {
				int temp;
				temp = a;
				a = b;
				b = temp;
			}
			
			int main() {
				int a = 0;
				int b = 1;
			
				cout << "Before the swap: " << endl;
				cout << "x = " << a << endl;
				cout << "y = " << b << endl;
			
				swap(a, b);
			
				cout << "After the swap: " << endl;
				cout << "x = " << a << endl;
				cout << "y = " << b << endl;
			
				return 0;
			}
		</code></pre>
		<pre class="language-bash"><code>
			Before the swap: 
			x = 0
			y = 1
			After the swap: 
			x = 0
			y = 1
		</code></pre>
		<p>
			Strange. It didn't perform the swap. Why? Because calling functions the
			way we did above, <span class="monoText">swap(a, b)</span>, is by default
			<span class="term">pass-by-value</span>. In pass-by-value, the function
			only receives a <span class="underlineText">copy</span> of the values
			passed. They are not pass an original. To understand what this implies,
			recall what happens in main memory when we execute a function.
		</p>
		<p>
			When <span class="monoText">main()</span> is loaded, a stack in main
			memory is allocated for it. Let's call it
			<span class="italicsText">stack main</span>. Inside
			<span class="italicsText">stack main</span>, memory is allocated for
			<span class="monoText">int a = 0</span> and
			<span class="monoText">int b = 1</span>. Going down the code, we encounter
			<span class="monoText">swap(a, b)</span>. This is a new function, so a new
			stack is created to accomodate its variables. Call it
			<span class="italicsText">stack swap</span>. Inside
			<span class="italicsText">stack swap</span>, memory is allocated for
			<span class="monoText">int a</span>, <span class="monoText">int b</span>,
			and <span class="monoText">temp</span>. Now, arguments were passed into
			<span class="monoText">swap()</span>, so the memory allocated is for
			<span class="monoText">int a = 0</span>,
			<span class="monoText">int b = 1</span>, and
			<span class="monoText">temp</span>.
		</p>
		<p>
			Inside <span class="italicsText">swap stack</span>, the body of
			<span class="monoText">swap()</span> works as expected. The variables do
			in fact swap. We can see that's true by running the function without
			arguments:
		</p>
		<pre class="language-cpp"><code>
			#include &lt;iostream&gt;
			using namespace std;
			
			void swap(int a = 0, int b = 1) {
				cout << "Before swap: " << endl;
				cout << "\t a = " << a << endl;
				cout << "\t b = " << b << endl;
			
				// The swap
				int temp;
				temp = a;
				a = b;
				b = temp;
			
				cout << "After swap: " << endl;
				cout << "\t a = " << a << endl;
				cout << "\t b = " << b << endl;
			}
			
			int main() {
				swap();
				return 0;
			}
		</code></pre>
		<pre class="language-bash"><code>
			Before swap: 
					a = 0
					b = 1
			After swap: 
					a = 1
					b = 0
		</code></pre>
		<p>
			So what does this all mean? It means that the swap never actually occurs
			in the <span class="monoText">main()</span> function. It only occurs in
			<span class="monoText">swap()</span>, and once
			<span class="monoText">swap()</span> is done,
			<span class="italicsText">stack swap</span> is destroyed. There was no
			effect whatsoever on the <span class="monoText">int a = 0</span> and
			<span class="monoText">int b = 1</span> in
			<span class="italicsText">stack main</span>.
		</p>
		<p>
			This embodies the concept of pass-by-value. When we simply pass regular
			variables into a function, we only pass copies of the values into the
			function. We never pass the originals.
		</p>
		<p>
			Call-by-value is what we use when we want the function to simply return a
			result based on the arguments passed. In fact, most of the functions we
			write are computations based on arguments. We generally do not want the
			original values changed &mdash; we want a new result. For example, suppose
			we had a function that computes acceleration:
		</p>
		<pre class="language-cpp"><code>
			#include &lt;iostream&gt;
			using namespace std;
			
			double acceleration(double velocity1, double velocity2, double time) {
				return (velocity2 - velocity1) / time;
			}
			
			int main() {
				double v1 = 12.4;
				double v2 = 14.6;
				double t = 3.48;
			
				cout << "Before function call:" << endl;
				cout << "v1 = " << v1 << endl;
				cout << "v2 = " << v2 << endl;
				cout << "t = " << t << endl;
				
				double a = acceleration(v1, v2, t);
			
				cout << "After function call:" << endl;
				cout << "v1 = " << v1 << endl;
				cout << "v2 = " << v2 << endl;
				cout << "t = " << t << endl;
				cout << "a = " << a << endl;
			
				return 0;
			}
		</code></pre>
		<pre class="language-bash"><code>
			Before function call:
			v1 = 12.4
			v2 = 14.6
			t = 3.48
			After function call:
			v1 = 12.4
			v2 = 14.6
			t = 3.48
			a = 0.632184
		</code></pre>
		<p>
			We obtained a value, but we did not modify the actual arguments,
			<span class="monoText">v1</span>, <span class="monoText">v2</span>, and
			<span class="monoText">t</span>. In programming, we want to minimize
			mutation as much as possible. Pass-by-value is one means of ensuring that.
			But what if we do want mutation? I.e., what if we truly want to modify the
			actual arguments, like how we intended in
			<span class="monoText">swap()</span>?
		</p>
	</section>

	<section id="pass_by_address">
		<h3>Pass-by-address</h3>
		<p>
			One way to do so is with <span class="term">pass-by-address</span>.
			Pass-by-address is exactly what it sounds like. Instead of sending copies
			of the values to a function, we send the address of the values:
		</p>
		<pre class="language-cpp"><code>
			#include &lt;iostream&gt;
			using namespace std;
			
			void swap(int *a, int *b) {
				int temp;
				temp = *a;
				*a = *b;
				*b = temp;
			}
			
			int main() {
				int a = 0;
				int b = 1;
			
				cout << "Before the swap: " << endl;
				cout << "x = " << a << endl;
				cout << "y = " << b << endl;
			
				swap(&a, &b);
			
				cout << "After the swap: " << endl;
				cout << "x = " << a << endl;
				cout << "y = " << b << endl;
			
				return 0;
			}
		</code></pre>
		<pre class="language-bash"><code>
			Before the swap: 
			x = 0
			y = 1
			After the swap: 
			x = 1
			y = 0
		</code></pre>
		<p>
			Now it works. But how? Notice that with the function call
			<span class="monoText">swap()</span>, we passed as arguments
			<span class="monoText">&a</span> and <span class="monoText">&b</span>.
			These are the addresses of <span class="monoText">a</span> and
			<span class="monoText">b</span> in <span class="monoText">main()</span>.
			Then, inside <span class="monoText">swap()</span>, the parameters are
			<span class="monoText">*a</span> and <span class="monoText">*b</span>.
			These are pointers. Why are they pointers? Because if we want to store
			memory addresses, we must use pointers. Accordingly, inside the body of
			<span class="monoText">swap()</span>, we use pointers to perform the swap.
			Those pointers always refer to the addresses of
			<span class="monoText">a</span> and <span class="monoText">b</span> in
			<span class="monoText">main()</span>.
		</p>
	</section>

	<section id="pass_by_reference">
		<h3>Pass-by-reference</h3>
		<p>
			Recall that we can think of a
			<span class="italicsText">reference</span> as a nickname, or pseudonym,
			for a variable. That nickname, or pseudonym, can be passed as an argument
			to a function. Passing references as arguments to a function is called
			<span class="term">pass-by-reference</span>. For example, using our code
			above:
		</p>
		<pre class="language-cpp"><code>
			#include &lt;iostream&gt;
			using namespace std;
			
			void swap(int &a, int &b) {
				int temp;
				temp = a;
				a = b;
				b = temp;
			}
			
			int main() {
				int a = 0;
				int b = 1;
			
				cout << "Before the swap: " << endl;
				cout << "x = " << a << endl;
				cout << "y = " << b << endl;
			
				swap(a, b);
			
				cout << "After the swap: " << endl;
				cout << "x = " << a << endl;
				cout << "y = " << b << endl;
			
				return 0;
			}
		</code></pre>
		<pre class="language-bash"><code>
			Before the swap: 
			x = 0
			y = 1
			After the swap: 
			x = 1
			y = 0
		</code></pre>
		<p>
			The same result from passing by address is obtained. This is because we
			employed <span class="term">pass-by-reference</span>. When
			<span class="monoText">main()</span> is memory is allocated for its
			variables, as usual. However, the distinction is when the loader
			encounters <span class="monoText">swap(a, b)</span>. The formal parameters
			of <span class="monoText">a</span> and <span class="monoText">b</span> are
			<span class="monoText">&a</span> and <span class="monoText">&b</span>.
		</p>
		<p>
			What happens when these parameters are used? The entire definition for
			<span class="monoText">swap()</span> is &#8220;copied-and-pasted&#8221;
			into the body of <span class="monoText">main()</span>. In other words,
			<span class="monoText">swap()</span> isn't loaded separately from
			<span class="monoText">main()</span>. It is loaded as a part of
			<span class="monoText">main()</span>. And because
			<span class="monoText">swap()</span> is a part of
			<span class="monoText">main()</span>,
			<span class="monoText">swap()</span> can effectively &#8220;see&#8221;, or
			has access, to the preceding variables inside
			<span class="monoText">main()</span>. In practice, pass-by-reference is
			used far more often than pass-by-address. Why? Because it's simpler to
			write and easier to read.
		</p>
	</section>

	<section id="comparison_reference_v_value">
		<h3>Pass-by-reference v. Pass-by-value</h3>
		<p>
			To repeat, the default approach for passing arguments into functions in
			C++ is pass-by-value. A fair question is when should we avoid the default
			approach; i.e., pass-by-reference. Answer: It depends.
		</p>
		<p>
			When we pass-by-value, we pass a copy of the value. This has the benefit
			of avoiding inadvertent mutability. It also leads to code that's easier to
			prove or reason about. The cost, however, is inefficiency. If a function
			takes a large data structure as an argument, it's worth considering
			whether we actually want to pass that argument by value. With
			pass-by-value, an entire copy of that data structure must be made, and
			this takes up both memory and processing power.
		</p>
		<p>
			If the data structure is particularly large, then it's like that case that
			we want to pass-by-reference. This avoids the computational expense of
			generating a copy of that data structure.
		</p>
		<p>
			Of course, we should also consider whether we should be passing the entire
			data structure in the first place. If only a part of that data structure
			is needed by a function, we should be passing only part of that data
			structure as an argument. If that part is particularly small, then we
			should err on the side of passing by value.
		</p>
		<p>
			In general, pass-by-reference is a convenient feature in C++, but it can
			be easily abused. From a big-picture perspective, references should only
			be used when there's some value in the program that every other module in
			the program depends on. Because of that dependancy, it's necessary to
			change that value for everyone else, because those changes impact what
			everyone else does.
		</p>
	</section>
</section>

<section id="returns">
	<h2>Function Returns</h2>
	<p>
		Just as functions can take different parameters, functions can also have
		different returns. The default return method is
		<span class="italicsText">return-by-value</span>. The function performs a
		computation, and returns the result. We can, however, also perform
		<span class="italicsText">return-by-address</span> and
		<span class="italicsText">return-by-reference</span>.
	</p>

	<h3>Return-by-address</h3>
	<p>
		Suppose we wanted a function to return an array, which we can then use and
		mutate elsewhere. One way to do so is to write a function with
		<span class="term">return-by-address</span> &mdash; a function that returns
		the address of stored data:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		int* natNumArray(int size) {
			int *p = new int[size];
			for (int i = 0; i < size; i++) {
				p[i] = i+1;
			}
			return p;
		}
		
		int main() {
			int *natNumPTR = natNumArray(5);
			return 0;
		}
	</code></pre>
	<p>
		In the code above, we allocated memory in the heap for an
		<span class="monoText">int</span> array, using the function
		<span class="monoText">natNumArray()</span>. The function returns the
		resulting array's address, and in <span class="monoText">main()</span>, that
		address is assigned to a pointer called
		<span class="monoText">*natNumPTR</span>. As a result, both
		<span class="monoText">p</span> in
		<span class="monoText">natNumArray()</span> and
		<span class="monoText">natNumPTR</span> point to the same address,
		effectively allowing us to modify the newly allocated array.
	</p>

	<h3>Return-by-reference</h3>
	<p>
		With return-by-address, we use an explicit pointer. We can instead use an
		implicit pointer with <span class="term">return-by-reference</span>. By
		writing a function as return-by-reference, we instruct C++ that the
		particular reference returns a pointer to its return value, rather than the
		value itself. The end result: We can use functions on the
		<span class="underlineText">left</span> side of an assignment statement,
		rather than the typical right side.
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
			
		double& setValues(double vals[], int i) {
			return vals[i];
		}
			
		int main () {
			double arr[] = {1.1, 9.8, 3.1, 2.1, 5.7};
			cout << "Value before change" << endl;
			for ( int i = 0; i < 5; i++ ) {
				cout << "\t arr[" << i << "] = ";
				cout << arr[i] << endl;
			}
			
			setValues(arr, 1) = 19.2;
			setValues(arr, 3) = 58.8;
			
			cout << "Value after change" << endl;
			for ( int i = 0; i < 5; i++ ) {
				cout << "\t arr[" << i << "] = ";
				cout << arr[i] << endl;
			}
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		Value before change
			arr[0] = 1.1
			arr[1] = 9.8
			arr[2] = 3.1
			arr[3] = 2.1
			arr[4] = 5.7
		Value after change
			arr[0] = 1.1
			arr[1] = 19.2
			arr[2] = 3.1
			arr[3] = 58.8
			arr[4] = 5.7
	</code></pre>
</section>

<section id="value_of_functions">
	<h2>Why use functions?</h2>
	<p>
		Functions are more than just a way of reusing code. They are the building
		blocks for <span class="term">procedural decomposition</span> &mdash;
		breaking down a program into smaller and smaller pieces. In a good
		<span class="monoText">C++</span> program, the
		<span class="monoText">main()</span> function is the overarching function
		that calls <span class="term">helper functions</span>. We should think of
		<span class="monoText">main()</span> as a function akin to the conductor of
		a gargantuan orchestra; it simply drives, or directs, the order in which the
		helper functions are called.
	</p>
	<p>
		The helper functions should meet several criteria: (1) The helper function
		performs one, and only one, coherent task. (2) The function does not do too
		large a share of the work. (3) The function is not overly reliant on other
		functions. And (4) the function stores data in the narrowest scope possible.
	</p>
</section>

<section id="variable_scope">
	<h2>Variable Scope</h2>
	<p>
		Functions are good point for us to switch gears and discuss
		<span class="term">variable scope</span>. Generally, there are kinds of
		scope: (1) the <span class="term">global scope</span> and (2) a
		<span class="term">local scope</span>. Consider the following code:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		int a = 1; 
		
		bool isEven(int n) {
			return (n % 2 == 0);
		}
		
		int main() {
			int x = 0;
			cout << x << endl;
			x += a;
			if (isEven(x)) {
				cout << x << " is even." << endl;
			} else {
				cout << x << " is not even." << endl;
			}
		
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		0
		1 is not even.
	</code></pre>
	<p>
		In the code above, we have two functions,
		<span class="monoText">main()</span> and
		<span class="monoText">isEven()</span>. Outside of these functions, we have
		<span class="monoText">int a = 1</span>. This is a
		<span class="italicsText">global variable</span>. Inside
		<span class="monoText">main()</span>, we have the variable
		<span class="monoText">int x = 0</span>. This is a
		<span class="italicsText">local variable</span> (more specifically, a
		variable <span class="italicsText">local to</span>
		<span class="monoText">main</span>). Inside both
		<span class="monoText">main()</span> and
		<span class="monoText">isEven()</span>, we have access to
		<span class="monoText">int a</span>. This is because
		<span class="monoText">int a</span> is a global variable &mdash; it's a
		variable that can be &#8220;seen&#8221; by all the functions following it.
	</p>
	<p>
		Recall that when we load a function in memory, each function's variables are
		allocated memory in a stack. Those stacks are popped off (i.e., the
		variables are destroyed) once the function finishes executing. This rule is
		true only for local variables (and function variables are local to the
		function). The rule is not true for global variables. Global variables exist
		in memory so long as the program continues running. Where do they exist? Not
		in the stack or the heap. Instead, they are allocated memory in the code
		section, where they stay as long as our program runs.
	</p>

	<h3>Block Level Scope</h3>
	<p>
		In addition to the global and local distinction, C++ also distinguishes
		scopes with block levels. A simple rule for block level scope: During
		compilation, C++ can see the variables to the left, but not variables to the
		right. For example:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		int x = 1;
		
		int main() {
			int x = 2;
			{
				int x = 3;
				cout << "x (from block): " << x << endl;
				cout << "Global x (from block): " << ::x << endl;
			}
			cout << "x (from main): " << x << endl;
			cout << "Global x (from main): " << ::x << endl;
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		x (from block): 3
		Global x (from block): 1
		x (from main): 2
		Global x (from main): 1
	</code></pre>
	<p>
		The <span class="monoText">::</span> operator is called the
		<span class="term">scope resolution operator</span>. It allows us to access
		a particular global variable when we have a variable with the same name
		locally.
	</p>
</section>

<section id="static_variables">
	<h2>Static Variables</h2>
	<p>
		Static variables are often a source of confusion for beginning programmers.
		In part, this is due to being overloaded with too many details all at once.
		Consider this issue, we study static variables by first considering a
		relatable problem. Consider the following code:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
			using namespace std;
			
			int x = 1;
			
			void func1() {
				x++;
				cout << x << endl;
			}
			
			int main() {
				func1();
				func1();
				func1();
				return 0;
			}
	</code></pre>
	<pre class="language-bash"><code>
		1
		2
		3
	</code></pre>
	<p>
		In the code above, we have a global variable,
		<span class="monoText">int x = 1</span>. We then have a function,
		<span class="monoText">func1()</span>, which increments the global variable,
		<span class="monoText">x</span> by <span class="monoText">1</span>. Thus,
		when we go into <span class="monoText">main()</span>, each call to
		<span class="monoText">func1()</span> results in an increment of
		<span class="monoText">x</span>.
	</p>
	<p>
		Now, suppose we don't want that <span class="monoText">x</span> to be a
		global variable. There are many reasons for why might not want
		<span class="monoText">x</span> to be a global variable (in fact, we
		generally do not want global variables). Perhaps
		<span class="monoText">x</span> is a variable that should only be mutated by
		<span class="monoText">func1()</span>; no other function or module should be
		able to touch it. How do we achieve this? Well, why not just place
		<span class="monoText">x</span> inside the body of
		<span class="monoText">func1()</span>? Let's try that:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		void func1() {
			int x = 0;
			x++;
			cout << x << endl;
		}
		
		int main() {
			func1();
			func1();
			func1();
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		1
		1
		1
	</code></pre>
	<p>
		Nope, that didn't work. Remember: After a function has finished executing,
		the stack where its variables are allocated is popped off. Thus, we never
		see <span class="monoText">1 2 3</span> because each function call starts
		with <span class="monoText">int x = 0</span>.
	</p>
	<p>Static variables are intended to address this problem:</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		void func1() {
			static int x = 0;
			x++;
			cout << x << endl;
		}
		
		int main() {
			func1();
			func1();
			func1();
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		1
		2
		3
	</code></pre>
	<p>
		By appending the <span class="monoText">static</span> keyword to
		<span class="monoText">int x = 0</span>, we've ensured that
		<span class="monoText">x</span> is treated as a static variable of the
		function <span class="monoText">func1()</span>. This effectively makes
		<span class="monoText">x</span> a variable akin to being
		&#8220;global&#8221; to <span class="monoText">func1()</span>. Thus, for
		every call to <span class="monoText">func1()</span>,
		<span class="monoText">func1()</span> uses the current value of
		<span class="monoText">x</span>.
	</p>
	<p>
		Like global variables, static variables exist in memory so long as our
		program runs. The different: Static variables are only accessible to their
		respective modules. In this case, <span class="monoText">x</span> is only
		accessible to <span class="monoText">func1()</span>; nowhere else.
	</p>
</section>

<section id="cpp_recursion">
	<h2>Recursion</h2>
	<p>Many problems can be solved with repetition by self-reference:</p>
	<div class="rule">
		<span class="header">Baize</span>
		<p>
			In the Republic of Palau, there's a semi-government agency called PPUC
			(Palau Public Utilities Corporation). This monolithic entity is the single
			electricity, water, and sewage provider for the entire nation. Our friend
			Brak recently bought a house and wants to open a utilities account. He
			fills the application and submits it to a representative.
		</p>
		<p>
			The representative says, &#8220;Oh, this is a new account. I can't sign
			off on it unless the clerk signs it.&#8221; The representative hands it to
			the clerk.
		</p>
		<p>
			The clerk says &#8220;Oh, this is a new account. I can't sight off on it
			unless the manager signs it.&#8221; The clerk hands it to the manager.
		</p>
		<p>
			The manager says, &#8220;Oh, this is a new account. I can't sign off on it
			unless the director signs it.&#8221; The manager hands it to the director.
		</p>
		<p>
			The director says, &#8220;Oh, a new account. Looks good. Signed.&#8221;
		</p>
		<p>
			The signed form goes back to the manager. &#8220;Director signed off.
			Sign.&#8221;
		</p>
		<p>
			The signed form goes back to the clerk. &#8220;Manager signed off.
			Signed.&#8221;
		</p>
		<p>
			The signed form goes back to the representative. &#8220;Clerk signed off.
			Signed. You'll have utilities by end of day.&#8221;
		</p>
	</div>
	<div class="rule">
		<span class="header">Cleaver</span>
		<p>
			Our friend Brak has a daughter, Kukau. After finishing her homework, Kukau
			wants to know if all her answers are correct before she submits her
			assignment.
		</p>
		<p>
			She goes to her teacher, Dort, and asks her, &#8220;Sensei, I want to know
			if all my answers on this list are correct. The list is ${[1, 4, 9,
			3].}$&#8221;
		</p>
		<p>
			Dort replies, &#8220;I can only check if the first answer in the list is
			incorrect.&#8221;
		</p>
		<p>
			Kukau thinks for a moment, then asks, &#8220;Ok. How about this list ${[1,
			4, 9, 3]?}$&#8221;
		</p>
		<p>
			Dort replies, &#8220;The first answer in that list is not
			incorrect.&#8221;
		</p>
		<p>Kukau then asks, &#8220;Now how about this list ${[4, 9, 3]?}$&#8221;</p>
		<p>
			Dort again replies, &#8220;The first answer in that list is not
			incorrect.&#8221;
		</p>
		<p>Now excited, &#8220;And how about this one ${[9, 3]?}$&#8221;</p>
		<p>
			Once more, &#8220;The first answer in that list is not incorrect.&#8221;
		</p>
		<p>Smirking, &#8220;And this one ${[3]?}$&#8221;</p>
		<p>&#8220;The first answer in that list is not incorrect.&#8221;</p>
		<p>Amused, Kukau asks, &#8220;[]?&#8221;</p>
		<p>
			&#8220;That is the empty list. There can be no incorrect answer because
			there's nothing there.&#8221;
		</p>
		<p>
			Gleefully, Kukau exlaims, &#8220;Aha, so my answers are all
			correct!&#8221;
		</p>
	</div>
	<p>
		<span class="term">Recursion</span> is the programming technique of solving
		a problem whose solution depends on solutions to smaller instances of the
		same problem. This is done by calling a function that calls itself from
		within itself. To understand how this works, it's worth recalling the
		control flow with function calls. Say we executed this code:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;

		void func(int n) {
			int x = n * n;
			std::cout << x << std::endl;
		}
		
		int main() {
			int a = 2;
			int b = 3;
			std::cout << a << std::endl;
			func(a);
			std::cout << b << std::endl;
			return 0;
		}
	</code></pre>
	<p>In the code above, we can trace control in the program as such:</p>
	<figure class="math-display">
		<div>
			<pre class="language-pseudo"><code>
				main()				
				|
				int a = 2;
				|
				int b = 3;
				|
				std::cout << a << std::endl;
				|
				func(a);--------+
												|
											int n = a;
											int x = n * n;
											std::cout << x << std::endl;
												|
				main()----------+
				|
				std::cout << a << std::endl;
				|
				return 0;
			</code></pre>
		</div>
	</figure>
	<p>
		In the diagram above, <span class="monoText">main()</span> executes as
		expected, but once it encounters <span class="monoText">func(a)</span>,
		control transfers to <span class="monoText">func(a)</span>. Then, once
		<span class="monoText">func(a)</span> has finished its computation, control
		returns to <span class="monoText">main()</span>.
	</p>
	<p>
		Writing recursive functions is essentially writing instructions for the
		journey from (a) the call to the recursive function to (b) a known fact
		about the problem. Keeping this perspective in mind, whenever we write
		recursive functions, there are three key rules to follow: (1) We must state
		when to stop the journey. (2) We must state how to take one step in the
		journey. (3) We must know how to break the journey down into a single step
		plus a smaller journey.
	</p>
	<p>
		The point where we stop (i.e., a known fact about the problem), is called
		the <span class="term">base case</span>. We must always have this base case,
		lest we embark on an infinite journey. When we state how to take one step in
		the journey, we are simply moving along the journey. When we break the
		journey down into a single step plus a smaller journey, we are performing
		<span class="term">induction</span>.
	</p>
	<p>All this said, let's consider an example:</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;

		void f(int n, int& count) {
			if (n > 0) {
				std::cout<<"run before f(n: "<< n <<", count: "<< count <<")\n";
				count++;
				f(n - 1, count);
			} else {
				std::cout << "end\n";
			}
		}
		
		int main() {
			int i = 0;
			f(4, i);
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		run before f(n: 4, count: 0)
		run before f(n: 3, count: 1)
		run before f(n: 2, count: 2)
		run before f(n: 1, count: 3)
		end
	</code></pre>
	<p>
		Inside <span class="monoText">main()</span>, we called
		<span class="monoText">f(4, i)</span>, where
		<span class="monoText">i = 0</span>. This transfers control to
		<span class="monoText">f()</span>. In <span class="monoText">f()</span>, we
		have a condition, <span class="monoText">n > 0</span>. If this condition is
		<span class="monoText">true</span>, we execute the following statements: (1)
		output a statement, (2) increment <span class="monoText">count</span> (which
		is initially <span class="monoText">0</span>); and (3) call
		<span class="monoText">f(n-1, count)</span>. If the condition is false,
		output <span class="monoText">end</span>. Reasoning through this process,
		the program's output is as expected. We can visualize the flow as such
		(assume we just printed the value of <span class="monoText">n</span>):
	</p>

	<figure class="math-display">
		<div>
			<pre class="language-pseudo"><code>
				func(4, 0)
					/  \
				4   func(3, 1)
							/  \
						3   func(2, 2)
									/  \
								2   func(1, 3)
											/  \
										1   func(0, 4)
													|
													end
			</code></pre>
		</div>
	</figure>
	<p>
		Let's see what happens when we move the console output line to
		<span class="underlineText">after</span> the recursive call:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;

		void f(int n, int& count) {
			if (n > 0) {
				count++;
				f(n - 1, count);
				std::cout<<"run after f(n: " << n <<", count: " << count << ")\n";
			} else {
				std::cout << "end\n";
			}
		}
		
		int main() {
			int i = 0;
			f(4, i);
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		end
		run after f(n: 1, count: 4)
		run after f(n: 2, count: 4)
		run after f(n: 3, count: 4)
		run after f(n: 4, count: 4)
	</code></pre>
	<p>
		Interesting, notice how it outputs <span class="monoText">end</span> first.
		Why is this output different? Well, notice that the output value of
		<span class="monoText">count</span> is
		<span class="monoText">4</span> rather than the incrementing we saw earlier.
		This is because when we run <span class="monoText">f()</span>, it never
		actually finishes executing until we get to
		<span class="monoText">f(0, 4)</span>. At that point, we run the else-block,
		<span class="monoText">"end"</span>. Additionally at that point,
		<span class="monoText">count</span> has incremented to
		<span class="monoText">4</span>. As such, when
		<span class="monoText">f(0, 4)</span> has finished executing,
		<span class="monoText">f(1, 4)</span> is exeuted, then
		<span class="monoText">f(2, 4)</span>, and so on, all way back up to
		<span class="monoText">f(4, 4)</span>. Visually:
	</p>
	<figure class="math-display">
		<div>
			<pre class="language-pseudo"><code>
				f(4, 0)
				    \
						f(3, 1)
						  \
							f(2, 2)
							  \
								f(1, 3)
								  \
									f(0, 4)
									 |
									 print end
								  /
							f(1,3) &rarr; print f(1,4)
							  /
						f(2,2) &rarr; print f(2,4)
						  /
					f(3,1) &rarr; print f(3,4)
					 /
				f(4,0) &rarr; print f(4,4)
			</code></pre>
		</div>
	</figure>
	<p>
		The above is an example of a
		<span class="term">classical recursion</span> or
		<span class="term">simple recursion</span>. It's the kind of recursion most
		commonly used in programming. There are, however, other types of recursion:
		tail recursion, head recursion, tree recursion, mutual recursion, and nested
		recursion. We will explore each type in turn.
	</p>

	<section id="recursion_and_memory">
		<p>
			<span class="topic">Recursion & Memory.</span> Unlike loops, the system
			stack will provide separate areas of memory for each recursive call. For
			example, consider this recursive function for summing the elements of an
			array:
		</p>
		<pre class="language-cpp"><code>
			#include &lt;iostream&gt;

			int summate(int array[], int arrayLength) {
				if (arrayLength == 1) {
					return array[0];
				} else {
					int sum = summate(array, arrayLength - 1);
					return sum + array[arrayLength - 1];
				}
			}
			
			int main() {
				int list[4] = {1, 0, 3, 2};
				int listSum = summate(list, 4);
				std::cout << listSum << std::endl;
				return 0;
			}
		</code></pre>
		<pre class="language-bash"><code>
			6
		</code></pre>
		<p>
			Each time we call <span class="monoText">summate()</span>, we create a new
			stack, where each local variable and argument of the recursive call is
			isolated from the other recursive call stacks. In this case, there four
			stacks total: <span class="monoText">summate(list, 4)</span>,
			<span class="monoText">summate(list, 3)</span>,
			<span class="monoText">summate(list, 2)</span>, and
			<span class="monoText">summate(list, 1)</span>.
		</p>

		<pre class="language-pseudo"><code style="font-size: 0.62rem;">
				main()
				===================================
				[ int list = {1, 0, 3, 2};        ]
				[ int listSum = summate(list, 4); ]
				===================================
												|
												|
												summate(list, 4)
												===============================
												[ int array = {1, 0, 3, 2};   ]
												[ int arrayLength = 4;        ]
												[ int sum = summate(list, 3); ]
												===============================
																		|
																		|
																		summate(list, 3)
																		===============================
																		[ int array = {1, 0, 3, 2};   ]
																		[ int arrayLength = 3;        ]
																		[ int sum = summate(list, 2); ]
																		===============================
																								|
																								|
																								summate(list, 2)
																								==============================
																								[ int array = {1, 0, 3, 2};  ]
																								[ int arrayLength = 2;       ]
																								[ int sum = summate(list, 1);]
																								==============================
																														|
																														|
																														summate(list, 1)
																														==============================
																														[ int array = {1, 0, 3, 2};  ]
																														[ int arrayLength = 1;       ]
																														{ return 1                   }
																														==============================
																														|
																														|
																							summate(list, 2)
																							~~~~~~~~~~~~~~~~
																							{ return 1 + 0 }
																							~~~~~~~~~~~~~~~~
																							|
																							|
																summate(list, 3)
																~~~~~~~~~~~~~~~~
																{ return 1 + 3 }
																~~~~~~~~~~~~~~~~
																|
																|
									summate(list, 4)
									~~~~~~~~~~~~~~~~
									{ return 4 + 2 }
									~~~~~~~~~~~~~~~~
									|
									|
						 main()
						 ~~~~~~~~~~~~~~~~~~~~
						 [ int list sum = 6 ]
						 ~~~~~~~~~~~~~~~~~~~~
			</code></pre>
	</section>

	<section id="time_complexity_linear_recursion">
		<p>
			<span class="topic">Time Complexity of Classical Recursion</span> Consider
			this linear-recursive approach to the factorial function:
		</p>
		<pre class="language-cpp"><code>
			#include &lt;iostream&gt;

			int factorial(int n) {
				if (n == 0) {
					return 1;
				} else {
					return n * factorial(n - 1);
				}
			}
			
			int main() {
				int a = 4;
				int b = factorial(a);
				std::cout << a << "! = " << b << std::endl;
				return 0;
			}
		</code></pre>
		<pre class="language-bash"><code>
			4! = 24
		</code></pre>
		<p>
			What is the time complexity for this function? Well, each call to
			<span class="monoText">factorial()</span> results in several computational
			steps: (1) Checking whether <span class="monoText">n == 0</span>, (2) If
			<span class="monoText">n != 0</span>, executing
			<span class="monoText">n</span> times the result of
			<span class="monoText">factorial(n - 1)</span>; (3) the evaluation of
			<span class="monoText">n - 1</span>. We can think of this roughly as
			${3n,}$ where ${n}$ is the number of calls to
			<span class="monoText">factorial()</span> (which corresponds to argument
			for <span class="monoText">n</span>). Accordingly, we say that the linear
			recursion function above has a time complexity of
			<span class="monoText">O(n)</span>. This is linear time.
		</p>
		<p>
			Alternatively, we can determine the time complexity of
			<span class="monoText">factorial()</span> with a
			<span class="italicsText">recurrence relation</span>. To do so, we first
			recognize that there are two discrete cases for
			<span class="monoText">factorial()</span>'s evaluation. If
			<span class="monoText">n == 0</span>, we perform a single step,
			<span class="monoText">return 1</span>. If
			<span class="monoText">n != 0</span> (i.e.,
			<span class="monoText">n > 0</span>), we perform the computational step
			<span class="monoText">n * factorial(n - 1)</span>. Next, whenever we call
			<span class="monoText">factorial()</span>, we have roughly 3 separate
			computations: Checking if <span class="monoText">n == 0</span>,
			multiplying <span class="monoText">n</span>, and evaluating
			<span class="monoText">n - 1</span>. Thus, we can express
			<span class="monoText">factorial(n - 1)</span> as the relation ${T(n -
			1).}$ Accordingly, we can express
			<span class="monoText">factorial(n)</span> as the relation ${T(n) = T(n -
			1) + 3.}$ It follows then that:
		</p>
		<figure class="math-display">
			<div>
				$$ T(n) = \begin{cases} 1 &n = 0 \\ T(n-1) + 3 &n > 0 \end{cases} $$
			</div>
		</figure>
		<p>
			From this recurrence relation, we can then compute the time complexity.
			Since ${T(n) = T(n - 1) + 3,}$ it follows that ${T(n - 1) = T(n - 2) +
			3.}$ As such, ${T(n) = T(n - 2) + 3 + 3 = T(n) = T(n - 2) + 6.}$ If we
			continued this substitution ${k}$ times, we would have ${T(n) = T(n - k) +
			2k.}$ Now, if we assume that ${n - k = 0,}$ we can infer that ${n = k.}$
			And given that ${n = k,}$ we have ${T(n) = T(n - n) + 2n;}$ i.e., ${T(n) =
			T(0) + 2n.}$ But we that ${T(0)}$ is ${1,}$ so ${T(n) = 1 + 2n.}$ Applying
			complexity analysis, we have the time complexity of ${O(n).}$
		</p>
	</section>

	<section id="tail_recursion">
		<h3>Tail Recursion</h3>
		<p>
			The first example in the previous section was an example of
			<span class="term">tail recursion</span> &mdash; a recursive function
			where the recursive call is the
			<span class="underlineText">last</span> expression to be evaluated. We
			call this a <span class="term">tail call</span>. Roughly, a tail recursive
			function takes the form:
		</p>
		<figure class="math-display">
			<ul class="syntax">
				<li>${f(n)}$ {</li>
				<ul>
					<li>${\vdots}$</li>
					<li>${f(\Delta n)}$</li>
				</ul>
				<li>}</li>
			</ul>
		</figure>
		<p>
			For example, the previous
			<span class="monoText">factorial()</span> function is not a tail
			recursive. This is because <span class="monoText">factorial()</span> is
			not the last computation to perform. It's multiplication. To rewrite
			<span class="monoText">factorial()</span> as a tail recursive function,
			the multiplication must occur
			<span class="underlineText">before</span> the tail call. We can do so by
			passing the result of the multiplication as a parameter:
		</p>
		<pre class="language-cpp"><code>
			#include &lt;iostream&gt;

			int factorial(int n, int m = 1) {
				if (n == 0) {
					return m;
				}
				return factorial(n - 1, m * n);
			}
			
			int main() {
				int x = 5;
				int y = factorial(x);
				std::cout << "5! = " << y << std::endl;
				return 0;
			}
		</code></pre>
		<pre class="language-bash"><code>
			5! = 120
		</code></pre>
		<p>
			Notice that with this implementation, the last line to execute is a call
			to <span class="monoText">factorial()</span>.
		</p>
		<p>
			Note that every tail recursive function can be written as a loop, and
			every loop can be written as a tail recursive function. For example, we
			could have written the same function above as such:
		</p>
		<pre class="language-cpp"><code>
			#include &lt;iostream&gt;

			int factorial(int n) {
				int product = 1;
				if (n == 0) {
					return product;
				} else {
					for (int i = 1; i <= n; i++) {
						product *= i;
					}
				}
				return product;
			}
			
			int main() {
				int x = 7;
				int y = factorial(x);
				std::cout << "7! = " << y << std::endl;
				return 0;
			}
		</code></pre>
		<pre class="language-bash"><code>
			7! = 5040
		</code></pre>
		<p>
			Both these implementations work the same way. There is no difference
			between these two implementations, at least in terms of time complexity.
			Both have a time complexity of ${O(n).}$ Where they may differ is in terms
			of space complexity. With each call to
			<span class="monoText">factorial()</span>, we generate a new stack frame.
			And with enough tail calls, we can run into
			<span class="italicsText">stack overflow</span>. Fortunately, most modern
			C++ compilers have implemented
			<span class="term">tail call optimization</span> (TCO). With TCO, the
			compiler recognizes tail calls, and optimizes space allocation.
		</p>
	</section>

	<section id="head_recursion">
		<h2>Head Recursion</h2>
		<p>
			The opposite of tail recursion is
			<span class="term">head recursion</span>. With head recursion, the
			recursive call <span class="underlineText">before</span> other statements
			are executed. Visually:
		</p>
		<figure class="math-display">
			<ul class="syntax">
				<li>${f(n)}$ {</li>
				<ul>
					<li>${f(\Delta n)}$;</li>
					<li>${\vdots}$</li>
					<li>${\textit{return }\ldots}$</li>
				</ul>
				<li>}</li>
			</ul>
		</figure>
		<p>
			Using the <span class="monoText">factorial()</span> example again, here is
			a head-recursive implementation:
		</p>
		<pre class="language-cpp"><code>
			#include &lt;iostream&gt;

			int factorial(int n, int m = 1) {
				if (n > 0) {
					return factorial(n - 1, n * m);
				} else {
					return m;
				}
			}
			
			int main() {
				int x = 7;
				int y = factorial(x);
				std::cout << "7! = " << y << std::endl;
				return 0;
			}
		</code></pre>
		<pre class="language-bash"><code>
			7! = 5040
		</code></pre>
		<p>
			As can be seen, both tail and head recursion have a time complexity of
			${O(n)}$ and a space complexity of ${O(n).}$ The difference, however, is
			that head recursion tends to be much more difficult to implement as a
			loop.
		</p>
	</section>

	<section id="tree_recursion">
		<h2>Tree Recursion</h2>
		<p>
			All of the examples we've used above are instances of
			<span class="term">linear recursion</span>. In linear recursion, the
			recursive function is defined with only one call to itself. If the
			recursive function is defined with either multiple calls to itself, then
			we have an instance of <span class="term">tree recursion</span>. Roughly,
			this looks like the following:
		</p>
		<figure class="math-display">
			<ul class="syntax">
				<li>${f(n)}$ {</li>
				<ul>
					<li>${f(\Delta n)}$</li>
					<li>${f(\Delta n)}$</li>
				</ul>
				<li>}</li>
			</ul>
		</figure>
		<p>
			Many problems are best solved with tree recursion. Consider a few examples
			below.
		</p>
		<section id="fibonacci">
			<p>
				<span class="topic"
					>Compute the ${n^{\text{\scriptsize{th}}}}$ Fibonnaci Number.</span
				>
				In the Fibonacci sequence, each element of the sequence is the sum of
				the preceding two elements: ${\lang 0, 1, 1, 2, 3, 5, 8, \ldots \rang.}$
				Mathematically, this sequence is defined with the recurrence relation:
			</p>
			<figure class="math-display">
				<div>
					$$ Fib(n) = \begin{cases} 0 &\textit{if } \space n = 0 \\ 1
					&\textit{if } \space n = 1 \\ Fib(n - 1) + Fib(n - 2) &\textit{else}
					\end{cases} $$
				</div>
			</figure>
			<p>This definition lends itself to tree recursion:</p>
			<pre class="language-cpp"><code>
				#include &lt;iostream&gt;

				int fib(int n) {
					int result = 0;
					if (n == 0) { return 0; } 
					else if (n == 1) { return 1; } 
					else {
						result = fib(n - 1) + fib(n - 2);
					}
					return result;
				}
				
				int main() {
					int index = 6;
					int fib6 = fib(6);
					std::cout << fib6 << std::endl;
					return 0;
				}
			</code></pre>
			<pre class="language-bash"><code>
				8
			</code></pre>
			<p>Visualizing the tree:</p>
			<figure>
				<img
					src="{% static 'images/fibonacciTreeRecursion1.svg' %}"
					alt="Fibonacci tree"
					loading="lazy"
				/>
			</figure>
		</section>
		<section id="number_of_permutations">
			<p>
				<span class="topic">Number of Permutations.</span> Suppose we played a
				game where we could score either a 1 point or 2 points. Given ${n}$
				number of maximum points, how many possible arrangements of 1 point and
				2 points are there to reach ${n?}$ Again, this problem lends itself to
				tree recursion. What we're really being asked to do is: How many
				different ways can you add 1 and 2 such that you get ${n?}$
			</p>
			<pre class="language-cpp"><code>
				#include &lt;iostream&gt;

				int permute(int n) {
					int permutations;
					if (n == 1) { return 1; }
					else if (n == 2) { return 2; }
					else {
						permutations = permute(n - 1) + permute(n - 2);
					}
					return permutations;
				}
				
				int main() {
					int maxPoints = 35;
					int numberOfPossibleArrangements = permute(maxPoints);
					std::cout << numberOfPossibleArrangements << std::endl;
					return 0;
				}
			</code></pre>
			<pre class="language-bash"><code>
				14930352
			</code></pre>
		</section>

		<section id="tree_recursion_memory">
			<p>
				<span class="topic">Complexity of Tree Recursion.</span> Tree recursion
				alone does not lend itself well to time complexity. To understand the
				tree recursion complexity, let's consider a simple example:
			</p>
			<pre class="language-cpp"><code>
				#include &lt;iostream&gt;

				void fun(int n) {
					if (n > 0) {
						std::cout << "fun(" << n << ")" << std::endl;
						fun(n - 1);
						fun(n - 1);
					}
				}
				
				int main() {
					int n = 3;
					fun(3);
					return 0;
				}
			</code></pre>
			<pre class="language-bash"><code>
				fun(3)
				fun(2)
				fun(1)
				fun(1)
				fun(2)
				fun(1)
				fun(1)
			</code></pre>
			<p>
				Let's parse how <span class="monoText">fun(3)</span> is executed. First,
				<span class="monoText">fun(3)</span> results in the console output
				<span class="monoText">fun(3)</span>, as expected. Then, there is the
				call to <span class="monoText">fun(n - 1)</span>, which is
				<span class="monoText">fun(2)</span>. Then, when
				<span class="monoText">fun(2)</span> is executed, we output to the
				console, and call <span class="monoText">fun(1)</span> and
				<span class="monoText">fun(1)</span> again. Only after
				<span class="monoText">fun(2)</span> has finished executing do we get to
				the <span class="monoText">fun(1)</span> from
				<span class="monoText">fun(3)</span>. Visualizing these calls, we see a
				tree:
			</p>

			<figure style="margin: 0">
				<img
					src="{% static 'images/treeRecursion1.svg' %}"
					alt="A diagram of the tree call"
					loading="lazy"
				/>
			</figure>

			<p>
				For each call, once we reach <span class="monoText">fun(0)</span>, the
				call has finished, so the stack allocated to
				<span class="monoText">fun(0)</span> is removed. But because there's
				another call <span class="monoText">fun(n - 1)</span>, another
				activation record <span class="monoText">fun(0)</span> is created. This
				is why see the output pattern above. Counting the number of calls in the
				diagram, we get 15. Thus, activation records are created and destroyed
				15 times.
			</p>
			<p>
				Thus, where ${n = 3,}$ ${fun(n)}$ is called 15 times. Examining the tree
				above, there are 4 levels. On the first level, there is only one call
				&mdash; <span class="monoText">fun(3)</span>. On the second level, there
				are 2 calls &mdash; <span class="monoText">fun(2)</span> and
				<span class="monoText">fun(2)</span>. On the third level, there are 4
				calls, and on the fourth level, there are 8 calls. This corresponds to a
				<span class="italicsText">geometric sequence</span>:
			</p>
			<figure class="math-display">
				<div>
					<p>${\lang 1, 2, 4, 8, 16, 32, 64, 128, 256, \ldots \rang}$</p>
				</div>
			</figure>
			<p>
				Accordingly, the sum of this sequence is the geometric series ${\sum_{i
				= 0}^{n} 2^n = 2^{n + 1} - 1.}$ It follows then that the tree recursive
				function ${f(n)}$ will result in ${2^{n + 1} - 1}$ total calls. Applying
				complexity analysis, this means the ${f(n)}$ has a time complexity of
				${O(2^n).}$
			</p>
			<p>
				Now, what is the space complexity? To determine space complexity, we ask
				ourselves, &#8220;What is the maximum height of the stack?&#8221; Well,
				we can just look at the tree above. With tree recursive functions, each
				stack generated is destroyed because once a call has finished it is
				destroyed. This in turn means that number of levels in the recursive
				tree corresponds to the height of the stack. For
				<span class="monoText">fun(0)</span> the number of levels is 1. For
				<span class="monoText">fun(1)</span>, the number of levels is 2. For
				<span class="monoText">fun(2)</span>, the number of levels is 3, and so
				on. As such, the height of the tree is given by ${n + 1.}$ Applying
				complexity analysis, we have a space complexity of ${O(n).}$
			</p>
			<p>
				From this discussion, we can see that tree recursion doesn't perform
				very well in terms of time &mdash; it runs on exponential time. Tree
				recursion, however, has its place. Some problems are just too difficult
				to solve with loops. Other problems are so difficult that exponential
				time is the best we can do. We will see some of these problems in later
				sections.
			</p>
		</section>
	</section>

	<section id="mutual_recursion">
		<h2>Mutual Recursion</h2>
		<p>
			In <span class="term">mutual recursion</span>, the recursive function
			${f}$ calls a recursive function ${g,}$ and the recursive function ${g}$
			calls the recursive function ${f.}$ Generally:
		</p>
		<figure class="math-display">
			<ul class="syntax">
				<li>${f(n)}$ { ${g(\Delta n)}$ }</li>
				<li>${g(n)}$ { ${f(\Delta n)}$ }</li>
			</ul>
		</figure>
		<p>For example:</p>
		<pre class="language-cpp"><code>
			#include &lt;iostream&gt;

			void g(int n);
			
			void f(int n) {
				if (n > 0) {
					std::cout << "f(" << n << ")" << std::endl;
					g(n - 1);
				}
			}
			
			void g(int n) {
				if (n > 1) {
					std::cout << "g(" << n << ")" << std::endl;
					f(n - 1);
				}
			}
			
			int main() {
				int x = 5;
				f(x);
				return 0;
			}
		</code></pre>
		<pre class="language-bash"><code>
			f(5)
			g(4)
			f(3)
			g(2)
			f(1)
		</code></pre>
		<p>
			Observe the output. When we call <span class="monoText">f()</span>, we
			call <span class="monoText">g()</span>, and when we cal
			<span class="monoText">g()</span>, we call
			<span class="monoText">f()</span>. Under normal circumstances, such a
			circular control flow immediately alerts us to an infinite process. But,
			as with all recursive functions, the approach works because each call is
			given a smaller and smaller input, and each call has a base case.
			Visualizing the call as a tree:
		</p>
		<figure>
			<img
				src="{% static 'images/mutualRecursion1.svg' %}"
				alt="A mutual recursion tree"
				loading="lazy"
				class="forty-p"
			/>
		</figure>
	</section>

	<section id="nested_recursion">
		<h2>Nested Recursion</h2>
		<p>
			Because functions are expressions, they can be passed as arguments to
			functions. Accordingly, given a recursive function ${f,}$ we can pass a
			call to ${f}$ as an argument for ${f.}$ This is an example of
			<span class="term">nested recursion</span>.
		</p>
		<figure class="math-display">
			<div>
				<ul class="syntax">
					<li>${f(f(\Delta n))}$ { }</li>
				</ul>
			</div>
		</figure>
		<p>For example:</p>
		<pre class="language-cpp"><code>
			#include &lt;iostream&gt;

			int n(int x) {
				if (x > 20) {
					return x - 5;
				} 
				else { 
					return n(n(x + 6)); 
				}
			}
			
			int main() {
				int x = 17;
				n(x); // returns 21
				return 0;
			}
		</code></pre>
		<p>
			In the function above, the call to
			<span class="monoText">n(x)</span> results in a call to
			<span class="monoText">n(n(x + 6))</span>. This is a nested-recursive
			function. We can visualized the evaluation as such:
		</p>
		<figure class="math-display">
			<ul class="syntax">
				<li>${n(x)}$</li>
				<li>${n(17)}$</li>
				<li>${n(n(x + 6))}$</li>
				<li>${n(n(17 + 6))}$</li>
				<li>${n(n(23))}$</li>
				<li>${n(x - 5)}$</li>
				<li>${n(23 - 5)}$</li>
				<li>${n(18)}$</li>
				<li>${n(n(x + 6))}$</li>
				<li>${n(n(18 + 6))}$</li>
				<li>${n(n(24))}$</li>
				<li>${n(x - 5)}$</li>
				<li>${n(24 - 5)}$</li>
				<li>${n(19)}$</li>
				<li>${n(n(x + 6))}$</li>
				<li>${n(n(19 + 6))}$</li>
				<li>${n(n(25))}$</li>
				<li>${n(x - 5)}$</li>
				<li>${n(25 - 5)}$</li>
				<li>${n(20)}$</li>
				<li>${n(n(x + 6))}$</li>
				<li>${n(n(20 + 6))}$</li>
				<li>${n(n(26))}$</li>
				<li>${n(x - 5)}$</li>
				<li>${n(26 - 5)}$</li>
				<li>${n(21 - 5)}$</li>
				<li>${21 - 5}$</li>
				<li>${16}$</li>
			</ul>
		</figure>
	</section>
	<p>To confirm:</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;

		int n(int x) {
			if (x > 20) {
				std::cout << "x > 20 " << std::endl;
				std::cout << "n(" << x << ")" << std::endl;
				std::cout << "return " << x << " - 5\n" << std::endl;
				return x - 5;
			} 
			else { 
				std::cout << "x = " << x << "\n" << std::endl;
				std::cout << "x <= 20" << std::endl;
				std::cout << "n(n(" << x << " + 6))\n" << std::endl;
				std::cout << "x = " << x + 6 << "\n" << std::endl;
				return n(n(x + 6)); 
			}
		}
		
		int main() {
			int x = 17;
			n(x);
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		x = 17

		x <= 20
		n(n(17 + 6))
		
		x = 23
		
		x > 20 
		n(23)
		return 23 - 5
		
		x = 18
		
		x <= 20
		n(n(18 + 6))
		
		x = 24
		
		x > 20 
		n(24)
		return 24 - 5
		
		x = 19
		
		x <= 20
		n(n(19 + 6))
		
		x = 25
		
		x > 20 
		n(25)
		return 25 - 5
		
		x = 20
		
		x <= 20
		n(n(20 + 6))
		
		x = 26
		
		x > 20 
		n(26)
		return 26 - 5
		
		x > 20 
		n(21)
		return 21 - 5
	</code></pre>
</section>
{% endblock %}
