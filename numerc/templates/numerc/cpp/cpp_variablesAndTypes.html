{% extends '../layout.html' %} {% load static %} {% block description %}
<meta
	name="description"
	content="An overview of variables and primitive types in C++: int, float, boolean, char, string, variable declarations, variable initialization, pass by value, pass by reference."
/>
{% endblock %} {% block title %}
<title>C++: Variables and Data Types</title>
{% endblock %} {% block content %}
<h1>Variables &amp; Types</h1>
<section id="variables_and_types">
	<p>
		In a computer, data is stored inside a memory location. We can think of
		computer memory as a large grid of small squares with unique addresses.
		These small squares, or cells, are arranged in a logical order. Each cell
		can store <span class="underlineText">1 byte</span>, or
		<span class="underlineText">8 bits</span> of data. A bit is either a 0 or a
		1. With 8 bits, we have 256 different combinations (${2^8 = 256.}$) Those
		combinations can be used to represent the numbers 0 to 255. In statically
		typed languages, we must explicitly state variable's type during
		declaration. This tells the compiler what type of data the variable will
		store. Given that information, the compiler can determine how much memory to
		allocate. To use that data, we must reference that particular location. In
		languages like Assembly, this is in fact how we access that data. Now, these
		memory locations are fairly cryptic and difficult to read (they're in
		hexadecimal). Instead of referencing these memory locations, we can
		associate a <span class="italicsText">name</span> to that particular
		location, and reference that name instead. This is called a
		<span class="term">binding</span>.
	</p>

	<p>
		Variables are essentialy &#8220;cabinets&#8221; where we can place data.
		Those cabinets, however, have specific labels called
		<span class="italicsText">types</span>. The data we place in a cabinet must
		have a type that matches the label. However, we can change the contents of
		the cabinets. More formally, variables are locations in memory where we can
		store data. Instead of referring to that location with its memory address,
		we give that location a name called an
		<span class="italicsText">identifier</span>. In source code, the identifier
		is the name we give a variable. Identifiers should be descriptive and
		meaningful, so as to make later recall easier. Identifiers can only consist
		of (a) upper-case alphabets, (b) lower-case alphabets (c) numbers, and (d)
		underscores. Additionally, the first character in the identifier must be
		either an alphabet or an underscore. Thus, identifiers cannot contain
		special characters (&, !, #, ;, etc.) nor can it contain whitespace.
		Upper-case alphabets and lower-case alphabets are distinct. Thus, the
		identifier <span class="monoText">foo</span> is different from the
		identifier <span class="monoText">Foo</span>. A
		<span class="term">variable</span> is a programming construct that allows us
		to associate a <span class="italicsText">value</span> with a
		<span class="italicsText">name</span>. More formally, a variable is a named
		piece of memory that a programmer uses to store specific types of data. In
		other words, it is an abstraction for the process described previously.
		Examples of variables in <span class="monoText">C++</span>:
	</p>

	<pre class="language-cpp"><code>
		int x; // value is undefined
		char grade = 'A';
		double pi = 3.14;
	</code></pre>

	<p>
		The value <span class="monoText">'A'</span> and
		<span class="monoText">3.14</span> are called
		<span class="term">literals</span>. A literal is a value directly
		represented inside the program executable (as opposed to a value that must
		be accessed through a variable stored somewhere in memory). For example, the
		variable <span class="monoText">pi</span> will be stored somewhere in
		memory. The literal <span class="monoText">3.14</span>, however, will be
		directly represented as binary in the executable.
		<span class="marginnote">
			A <span class="italicsText">variable declaration</span> is an instruction
			to the compiler to <span class="underlineText">reserve</span> space in
			memory for data. Because C++ is a
			<span class="italicsText">statically typed</span> language, variable
			declarations must explicitly include the variable's type. A
			<span class="italicsText">variable initialization</span> is an instruction
			to the compiler to <span class="underlineText">store</span> data in the
			reserved space.
		</span>
		For example, suppose we wrote the following:
	</p>

	<pre class="language-cpp"><code>
		int a = 1
		int b = 2
	</code></pre>

	<p>
		When we actually compile the program, the code above looks something like:
	</p>

	<figure class="table">
		<table class="monotable">
			<tbody>
				<tr>
					<td>001</td>
					<td>a = 1 (int)</td>
				</tr>
				<tr>
					<td>002</td>
					<td>b = 2 (int)</td>
				</tr>
				<tr>
					<td>${\vdots}$</td>
					<td>${\vdots}$</td>
				</tr>
				<tr>
					<td>0040</td>
					<td>1</td>
				</tr>
				<tr>
					<td>0041</td>
					<td>2</td>
				</tr>
			</tbody>
		</table>
	</figure>

	<p>
		The values are called literals because they are
		<span class="italicsText">literally</span> inside the source code. They do
		not need to be represented in memory. Because the values bound to
		<span class="monoText">a</span> and <span class="monoText">b</span> are
		literals, we can use <span class="monoText">a</span> and
		<span class="monoText">b</span> throughout our program (this is true because
		the variables above are presumed to be declared in the global scope; more on
		this later).
	</p>

	<p>
		Note that literals with modifiers, like
		<span class="monoText">long</span> and
		<span class="monoText">unsigned</span>, should have a suffix appended at the
		end, indicating that the value is a literal:
	</p>

	<pre class="language-cpp"><code>
		unsigned int ceoBonus {2'000'000u};
		unsigned int errorCode = 0xBAD; // evaluates to 2989 
		int myOctal {0777u} // evaluates to 511
		float myFloat {1.2f}
	</code></pre>

	<p>
		Notice the use of single quotes as separators. This is particularly helpful
		when we have large value literals. Notice also that we can represent hex
		numbers in C++.
		<span class="marginnote"
			>Hex numbers are used amusingly (and usefully) in many programs as
			<span class="italicsText">hex speak.</span> For example, the hex number
			<span class="monoText">0xBAAAAAAD</span> is used as an iOS exception
			report (it evaluates to the integer
			<span class="monoText">3131746989</span>.) Similarly,
			<span class="monoText">0xDEADBEEF</span> is almost ubiquitously used in
			embedded systems to indicate a software crash or a deadlock. These are all
			examples of <span class="term">magic numbers</span>; numbers used to
			indicate a particular value.</span
		>
		Hex numbers are also used to indicate colors. Above, we also see an example
		of using octal numbers as literals. Notice that octal numbers are prefaced
		with a <span class="monoText">0</span>. Because of this use of
		<span class="monoText">0</span>, be very careful not to preface
		<span class="monoText">int</span> values with a
		<span class="monoText">0</span> if an <span class="monoText">int</span> is
		intended.
	</p>
	<p>
		In the last line, we see a <span class="monoText">float</span> literal.
		Notice the suffix <span class="monoText">f</span>. This suffix must be
		included if we want to ensure the value is treated as a
		<span class="monoText">float</span> literal. If we fail to include the
		suffix, we risk C++ treating the value as a
		<span class="monoText">double</span>.
	</p>

	<h3>Data Types</h3>
	<p>
		C++ has three kinds of data types: (1)
		<span class="italicsText">primitive types</span>; (2)
		<span class="italicsText">derived types</span>; and (3)
		<span class="italicsText">user-defined types</span>.
		<span class="marginnote"
			>Mathematically, a data type is really just a
			<span class="italicsText">set</span>. It is the set of all the possible
			values that belong to that type, alongside the operations that can be
			performed on those values.</span
		>
		The primitive types are types provided by default in C++. They include:
		<span class="monoText">int</span>, <span class="monoText">float</span>,
		<span class="monoText">double</span>, <span class="monoText">char</span>,
		<span class="monoText">boolean</span>, and
		<span class="monoText">void</span>. The derived types are types derived from
		the primitive data types. They include:
		<span class="monoText">Function</span>, <span class="monoText">Array</span>,
		<span class="monoText">Pointer</span>, and
		<span class="monoText">Reference</span>. The user-defined types are types
		defined by the user. They include: <span class="monoText">Structure</span>,
		<span class="monoText">Union</span>, <span class="monoText">Enum</span>,
		<span class="monoText">Class</span>, and
		<span class="monoText">Typedef</span>.
	</p>

	<p>
		A variable of type <span class="monoText">float</span>, as well as a
		variable of type <span class="monoText">double</span>, stores floating point
		values (i.e., numbers with a decimal point).
		<span class="monoText">double</span> is allocated 8 bytes of memory. Thus,
		it can store values ranging from ${-2^{63}}$ to ${2^{63} - 1.}$ How precise
		floating-point value is depends on how many numbers follow the decimal
		point. A <span class="monoText">float</span> can store up to 7 digits.
	</p>

	<p>
		A variable of type <span class="monoText">int</span> takes up 4 bytes of
		memory. It can store any value from ${-2^{31}}$ to ${2^{31} - 1.}$ If we
		store a floating point value (e.g., ${2.32}$) in an
		<span class="monoText">int</span> variable, C++ will truncate the value to
		2. A <span class="monoText">double</span> can store up to 15 digits A
		variable of type <span class="monoText">char</span> stores a character from
		the ASCII table. In reality, <span class="monoText">char</span> represents
		the character's numeric ASCII value. <span class="monoText">char</span> is
		allocated 1 byte of memory. It can store any Unicode value from ${-2^7}$ to
		${2^7 - 1.}$
	</p>

	<p>
		A variable of type <span class="monoText">bool</span> stores one of two
		values &mdash; <span class="monoText">true</span> or
		<span class="monoText">false</span>. A variable of type
		<span class="monoText">bool</span> is allocated 1 byte of memory. The
		<span class="monoText">void</span> data type represents &#8220;no
		value.&#8221; This is a specific instruction to the compiler not to allocate
		any memory.
	</p>

	<p>
		<span class="italicsText">Data type modifiers</span> are special symbols we
		can prepend to a data type to modify the data type's instructions. The
		modifier <span class="monoText">long</span> will instruct the compiler to
		allocate 4 more bytes. We can use <span class="monoText">long</span> with
		<span class="monoText">int</span> and <span class="monoText">double</span>.
		The modifier <span class="monoText">short</span> instructs the compiler to
		only allocate 2 bytes. <span class="monoText">short</span> applies only to
		<span class="monoText">int</span>. We
		<span class="underlineText">cannot</span> use modifiers with the
		<span class="monoText">float</span> type. The
		<span class="monoText">unsigned</span> modifier allows us to store only
		positive values (i.e., values without the signed bit). The
		<span class="monoText">signed</span> modifier allows us to store both
		positive and negative values. <span class="monoText">signed</span> is the
		default declaration for <span class="monoText">int</span> and
		<span class="monoText">char</span>.
	</p>

	<p>
		<span class="italicsText">Type-casting</span> is when we instruct the
		compiler to convert a value of one type to another. There are two types of
		type-casting: <span class="italicsText">implicit casting</span> and
		<span class="monoText">explicit casting</span>. In implicit-casting, the
		compiler automatically converts one data type to another. In
		explicit-casting, we, the programmers, explicitly instruct the compiler to
		convert.
	</p>

	<p>
		The value of <span class="monoText">x</span> above is
		<span class="monoText">undefined</span>, which is itself a value. It will
		display to the console some value, but it could be any value. All of the
		types above are <span class="term">primitive types</span> in
		<span class="monoText">C++</span>. There are several others:
	</p>

	<figure class="table">
		<table class="truth_table">
			<thead>
				<th>Data Type</th>
				<th>Size</th>
				<th>Represents</th>
			</thead>
			<tbody>
				<tr>
					<td>char</td>
					<td>${1}$ byte, ${\geq 8}$ bits</td>
					<td rowspan="4">character</td>
				</tr>
				<tr>
					<td>char16_t</td>
					<td>${\geq 16}$ bits</td>
				</tr>
				<tr>
					<td>char32_t</td>
					<td>${\geq 32}$ bits</td>
				</tr>
				<tr>
					<td>wchar_t</td>
					<td>largest available character set</td>
				</tr>
				<tr>
					<td>short</td>
					<td>${\geq 16}$ bits</td>
					<td rowspan="5">signed integer values</td>
				</tr>
				<tr>
					<td>short</td>
					<td>${\geq 16}$ bits</td>
				</tr>
				<tr>
					<td>int</td>
					<td>${\geq 16}$ bits</td>
				</tr>
				<tr>
					<td>long</td>
					<td>${\geq 32}$ bits</td>
				</tr>
				<tr>
					<td>long long</td>
					<td>${\geq 64}$ bits</td>
				</tr>
				<tr>
					<td>unsigned short</td>
					<td>${\geq 16}$ bits</td>
					<td rowspan="4">unsigned integer values</td>
				</tr>
				<tr>
					<td>unsigned</td>
					<td>${\geq 16}$ bits</td>
				</tr>
				<tr>
					<td>unsigned long</td>
					<td>${\geq 32}$ bits</td>
				</tr>
				<tr>
					<td>unsigned long long</td>
					<td>${\geq 64}$ bits</td>
				</tr>
				<tr>
					<td>float</td>
					<td>${\approx}$ ${7}$ decimal places</td>
					<td rowspan="3">non-integer reals</td>
				</tr>
				<tr>
					<td>double</td>
					<td>${\approx}$ ${15}$ decimal places</td>
				</tr>
				<tr>
					<td>long double</td>
					<td>${\approx}$ ${19}$ decimal places</td>
				</tr>
				<tr>
					<td>bool</td>
					<td>usually ${8}$ bits</td>
					<td>true; false</td>
				</tr>
				<tr>
					<td>void</td>
					<td>represents "typelessness"</td>
					<td></td>
				</tr>
				<tr>
					<td>auto</td>
					<td>used to deduce types</td>
					<td></td>
				</tr>
			</tbody>
		</table>
	</figure>

	<p>
		What data type we use depends on the program we're writing and whether we're
		particularly concerned about memory use. If we attempt to assign too large
		of a value into a variable type that does not accomodate for that value's
		size, we will get an <span class="term">overflow</span>.
	</p>

	<p>
		<span class="topic">Constants.</span> Constants are variables whose bound
		values are immutable &mdash; the value cannot be changed. We can initialize
		constants in C++ as such:
		<span class="marginnote">
			A <span class="italicsText">constant</span> is a variable whose constants
			<span class="underlineText">cannot</span> be changed. We can think of it
			as a locked cabinet. Because they are locked cabinets, constants must be
			initialized and declared at the same time.
		</span>
	</p>

	<pre class="language-cpp"><code>
		const double accelerationGravity { 9.807 }; // meters per second^2
	</code></pre>

	<p>
		The <span class="monoText">const</span> qualifier does not actually apply to
		the data in memory. In other words, it's not like the data in memory
		permanently stays in some location, never moving, never changing. Instead,
		the qualifier applies to the variable name. What this means is, in the
		variable above, <span class="monoText">accelerationGravity</span>, we cannot
		change the value bound to it, <span class="monoText">9.807</span>, using
		<span class="monoText">accelerationGravity</span>. This is a crucial
		distinction to understand, because there is more than one way to modify a
		value bound to a variable. As we will see on the section with pointers,
		there are situations where we can accidentally cause a
		<span class="monoText">const</span> to change.
	</p>
	<p>
		Question: What if the <span class="monoText">const</span> value depends on
		the computation of a non-constant value? Will subsequent changes to the
		non-constant value cause changes to the
		<span class="monoText">const</span> value? Fortunately in C++, no. Once a
		variable is initialized as a constant, that value will remain bound to the
		identifier:
	</p>

	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;

		int main() {
			int a = 3;
			const int b = 4 + a;
			std::cout << b << std::endl;
			a += 1;
			std::cout << b << std::endl;
		
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		7
		7
	</code></pre>

	<p>
		Constants are what allow us to ensure that a value bound to a particular
		identifier is never changed throughout its existence. If we, or any part of
		our code, attempt to modify that constant, we will get a compiler error. In
		general, we should err on the side of constants. While mutability is a
		useful tool, erring on mutability only increases the amount of values we
		must keep track of. Some of those values will be things that should never
		change, and should not be included in our personal list of tracked values.
		Some C++ programmers follow the habit of declaring every variable as a
		<span class="monoText">const</span>, then deciding after seeing compiler
		errors whether to remove the
		<span class="monoText">const</span> declaration. This is great habit, as it
		forces us to more carefully consider whether we want mutability.
	</p>

	<p>
		<span class="term">Constant Expressions.</span> Constant expressions are
		expressions that are evaluated at compile time rather than runtime. The
		default behavior is to perform these computations at runtime. The problem,
		however, is that some computations can be enormous. This means that whenever
		a user loads an executable (i.e., runs the program,) the computation may
		need to be performed again. This redundancy can amount to large costs in
		runtime. To declare constant expressions, we use the
		<span class="monoText">constexpr</span> keyword:
	</p>
	<pre class="language-cpp"><code>
		constexpr double pi {3.14};
	</code></pre>
	<p>
		We cannot use non-constant expressions (i.e.,
		<span class="term">runtime values</span>) inside constant expressions (<span
			class="term"
			>compile-time values</span
		>). This is because the compiler cannot perform computations on or with
		runtime values. Those computations must be done at runtime.
	</p>
	<pre class="language-cpp"><code>
		const double e {2.718};
		constexpr double myNum { e * 2.2 };  // returns an error
	</code></pre>
	<p>
		The code above returns an error because <span class="monoText">e</span> is a
		non-constant expression. To actually perform the computation,
		<span class="monoText">e</span> must also be a constant expression:
	</p>
	<pre class="language-cpp"><code>
		constexpr double e {2.718};
		constexpr double myNum { e * 2.2 };  // returns 5.9796
	</code></pre>
	<p>
		Constant expressions are enormously useful in ensuring that we do not waste
		valuable runtime. In particular, we almost always want to perform large,
		heavy computations at compile time. By doing so, we do not have to waste
		valuable runtime performing the large computation. Instead, the computer's
		loader will simply retrieve the result from the compiler's computation.
	</p>
	<p>
		We can think of constant expressions as a cost-shifting mechanism. Rather
		than the user paying the price for the large computation, we, as the
		programmers, pay the price at computation. Erring on constant expressions,
		executables can load much, much faster.
		<span class="marginnote"
			>As evidence of how valuable constant expressions are, one of the most
			competitive games in the programming languages market is moving as many
			computations as possible to compile time. With each new standard of C++
			(and other languages like Java), there have been increases in the number
			of movable computations. Given how fast compilers are getting, the game is
			only growing more heated.</span
		>
	</p>
	<p>
		Constant expressions are very useful for checks For example, suppose our
		program should not proceed any further &mdash; in compilation &mdash; unless
		some condition is met. We can do so with
		<span class="monoText">static_assert(${b}$)</span>, where ${b}$ is the
		condition we want met.
	</p>

	<pre class="language-cpp"><code>
		int main() {
			constexpr int a = 2;
			static_assert(a == 3);
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		main.cpp:5:2: error: static_assert failed due to requirement 'a == 3'
        static_assert(a == 3);
        ^             ~~~~~~
		1 error generated.
	</code></pre>

	<p>
		Above, our program never actually compiles &mdash; and never gets to runtime
		&mdash; because the condition <span class="monoText">a == 3</span> is not
		met. Separately, constant expressions are effectively constants, so the
		expressions cannot be mutated.
		<span class="monoText">static_assert()</span> can be a very valuable tool
		when we are moving large amounts of computations to compile time, as it
		reduces the costs we've shifted to ourselves as programmers.
	</p>

	<p>
		<span class="topic"><span class="monoText">sizeof.</span></span> The
		<span class="monoText">sizeof()</span> operator returns the size, in bytes,
		of a type or variable. The operator is often used to determine size of
		arrays, structures, and objects. We address it here because it is
		particularly useful for variables, and will revisit it when we discuss
		arrays.
	</p>

	<p>
		<span class="monoText">C++</span> provides several ways to declare and
		initialize variables:
	</p>

	<pre class="language-cpp"><code>
		int foo; // declaration; likely contains garbage value
		int baz = 17; // assignment initialization
		int kwa (43); // constructor initialization; initializes to 43
		int xyz {13}; // C++ list initialization; initializes to 13
		int bar {}; // initializes to 0
		
		// we can also uses expressions as initializers
		int bop {14 + 2}; // initializes to 16
		int x {2};
		int y {5};
		int z {x + y}; // initializes to 7
		int g {x + y + i}; // won't compile, i is undeclared
	</code></pre>

	<p>
		Note that if we declare a variable but do not initialize it, that variable
		will have some <span class="term">garbage value</span> stored, and we have
		no control over what that value is. As such, it is crucial that we
		initialize variables once declared.
		<span class="marginnote"
			>This is a stark contrast to other languages like Java, where there are
			default values for uninitialized variables. If you're coming from one of
			those languages, beware!</span
		>
	</p>

	<p>
		<span class="topic">More on Numeric Types.</span> Numeric types are so
		important in programming that it's worth exploring them more deeply. To
		begin, <span class="monoText">C++</span> has no problem handling positive
		and negative numbers:
	</p>

	<pre class="language-cpp"><code>
		int val1 {1} // a positive integer
		int val2 {-1} // a negative integer
	</code></pre>

	<p>The code above is a form of syntactic sugar for the following:</p>

	<pre class="language-cpp"><code>
		signed int val1 {1}
		signed int val2 {-1}
	</code></pre>

	<p>
		The keyword <span class="monoText">signed</span> is called a
		<span class="term">modifier</span>. A modifier does what it says &mdash; it
		modifies what a variable can and cannot do. In this case,
		<span class="monoText">signed</span> indicates that the subsequent variable
		can store positive or negative numbers. If we want to ensure that a variable
		can only store positive numbers, we use the
		<span class="monoText">unsigned</span> modifier. Whether or not an
		<span class="monoText">int</span> is signed or unsigned, the
		<span class="monoText">int</span> will still occupy 4 bytes in memory.
	</p>

	<p>
		Signage, however, impacts how many values a given numeric type can
		represent. Roughly, where ${n}$ is the number of bits for a type in memory,
		unsigned numeric types can represent numbers in the interval ${[0, 2^n-1].}$
		Signed integers can store numbers in the interval ${[-2^{n-1}, 2^{n-1} -
		1].}$ For example, with integers, the
		<span class="monoText">unsigned</span> modifier allows us to represent
		numbers from 0 to about 4.2 billion. With
		<span class="monoText">signed</span>, we can represent numbers from about
		-2.1 billion to 2.1 billion.
	</p>

	<p>
		There are additional modifiers we can use for numeric types,
		<span class="monoText">short</span> and <span class="monoText">long</span>.
		The <span class="monoText">short</span> and
		<span class="monoText">long</span> modifiers will modify the number of bytes
		a type requires. With <span class="monoText">short</span>, we reduce the
		range of values we can represent, but save memory. With
		<span class="monoText">long</span>, we increase the range of values can
		represent, but use up more memory. We can use
		<span class="monoText">short</span> and
		<span class="monoText">long</span> with
		<span class="monoText">signed</span> and
		<span class="monoText">unsigned</span> to balance the tradeoffs:
	</p>

	<pre class="language-cpp"><code>
		// these variables take up 2 bytes
		short foo {};
		short int bar {};
		signed short bang {};
		signed short int zing {};
		unsigned short int blob {};

		// these variables take up 4 bytes
		int vroom {};
		signed hoho {};
		signed int gaga {};
		unsigned int didi {};

		// these variables take up 4 or 8 bytes
		long wawa {};
		long int pepe {};
		signed long toto {};
		signed long int shibi {};
		unsigned long int grob {};

		// these variables take up 8 bytes
		long long jam {};
		long long int jip {};
		signed long long doop {};
		signed long long int coco {};
		unsigned long long lulu {};
		unsigned long long int momo {};
	</code></pre>

	<p>
		Note that the modifiers <span class="monoText">signed</span>,
		<span class="monoText">unsigned</span>, <span class="monoText">long</span>,
		and <span class="monoText">short</span> only work for
		<span class="term">integral types</span> &mdash; types representing
		integers. They will not work for
		<span class="term">floating types</span> &mdash; types representing
		fractional numbers.
	</p>

	<p>
		Furthermore, we should be careful when using the
		<span class="monoText">short</span> and
		<span class="monoText">unsigned</span> modifiers with integral types like
		<span class="monoText">short int</span>. Arithmetic may not work as expected
		for an integral type that can take no more than 4 bytes of memory (e.g.,
		<span class="monoText">short int</span>, which only takes 2 bytes). If the
		result requires more than 4 bytes of memory, C++ will return a result in
		type other than the operands'. For example, in the case of
		<span class="monoText">short int</span>, if the result requires more than 2
		bytes of memory, C++ will return a result of type
		<span class="monoText">int</span>.
	</p>

	<p>
		<span class="topic">Floating Types.</span> C++ has three base floating
		types: <span class="monoText">float</span>,
		<span class="monoText">double</span>, and
		<span class="monoText">long double</span>. The base type
		<span class="monoText">float</span> takes up 4 bytes of memory,
		<span class="monoText">double</span> takes up 8 bytes, and
		<span class="monoText">long double</span> takes up 12 bytes. With floating
		types, the primary concern for memory usage is more focused on precision.
		With 4 bytes of memory, precision is ensured for up to 7 decimal places
		(including the integral part). For <span class="monoText">double</span>,
		it's 15. With <span class="monoText">long double</span>, it depends on the
		compiler implementation; it can range anywhere from 15, 18, to 33. For the
		most part, <span class="monoText">double</span> is the recommended type to
		use, and it suffices for most programming tasks.
	</p>

	<p>
		<span class="topic">Scientific Notation.</span> C++ supports scientific
		notation natively:
	</p>

	<pre class="language-cpp"><code>
		// x and y are equivalent
		double x { 732400023 };  
		double y { 7.32400023e8 };

		// v and w are equivalent
		double v { 0.00000000002313 };
		double w { 2.313e-11 };
	</code></pre>

	<p>
		<span class="topic">Infinity and NaN.</span> For those familiar with
		JavaScript, C++ has representations for Infinity and
		<span class="monoText">NaN</span>:
	</p>

	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;

		int main() {
			float a { 1.0 };
			float b {};
			float c { a / b }; // evaluates to Infinity
		
			float u { 0.0 };
			float v { 0.0 };
			float w { u / v };; // evaluates to NaN
		
			std::cout << "valueOf c: " << c << std::endl;
			std::cout << "valueOf w: " << w << std::endl;
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		valueOf c: inf
		valueOf w: nan
	</code></pre>

	<p>
		<span class="topic">Division.</span> The arithmetic operations covered are
		fairly straightforward. Special attention, however, should be given to
		division.
		<span class="marginnote"
			>As an aside, the <span class="monoText">*</span> (asterisk) operator's
			use for multiplication dates back to John Backus and his team's
			development of Fortran. At the time (1954), the available character set
			for computers was limited, and <span class="monoText">*</span> was the
			closest symbol to ${\times.}$</span
		>
	</p>

	<p>Dividing integers can yield unusual results:</p>

	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;

		int main() {
			int c = 21 / 10; // expected: 2.1
			std::cout << c << std::endl;
		}
	</code></pre>
	<pre class="language-bash"><code>
		2
	</code></pre>

	<p>
		Notice that the output is 2. Why is this? What's actually happening is that
		C++ is trying to figure out how many times it can fit 10 inside 21. In this
		case, 2. This is what happens when we divide an
		<span class="monoText">int</span> value by a non-multiple of that value. We
		won't get back a fractional number. For that, we need to use float types:
	</p>

	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;

		int main() {
			double c = 21.0 / 10.0; // expected: 2.1
			std::cout << c << std::endl;
		}
	</code></pre>
	<pre class="language-bash"><code>
		2.1
	</code></pre>

	<!-- Booleans -->

	<p>
		<span class="topic">Booleans.</span> Boolean data types represent just two
		states &mdash; true or false. Accordingly the data type
		<span class="monoText">bool</span> in C++ consists of only two values:
		<span class="monoText">true</span> and <span class="monoText">false</span>.
		A Boolean value takes up 8 bits of memory (an entire byte). This may seem
		extremely wasteful, particularly from the perspective of embedded systems,
		where memory is very scarce. With advances in memory capacity, however, most
		programs aren't impacted by the consumption. We will see in later sections
		various ways of bundling more data into a byte.
	</p>

	<!-- characters -->

	<span class="topic">Characters.</span> In C++, single-character data is
	represented with <span class="monoText">char</span> type. A
	<span class="monoText">char</span> value is represented with single quotes in
	C++:
	<pre class="language-cpp"><code>
			char foo = 'a';
		</code></pre>
	<p>
		Note that we must use single quotes. Any other symbol will return an error.
	</p>
	<p>
		The <span class="monoText">char</span> type takes up 1 byte, or 8 bits, of
		memory. Characters in C++ map to the ASCII table. Thus, each ASCII character
		has an integer ASCII encoding.
	</p>

	<!-- auto -->

	<p>
		<span class="topic"><span class="monoText">auto</span>.</span> The keyword
		<span class="monoText">auto</span> is C++'s take on type inference. By
		appending the keyword to a variable name, we instruct C++ to infer the bound
		value's type. This is particulary useful for when we have particularly long
		type names. We can't really appreciate how useful type inference is at the
		moment, but we mention it here for completeness.
	</p>

	<pre class="language-cpp"><code>
		auto val1 {19}; // type inferred: int
		auto val2 {38.3}; // type inferred: double
		auto val3 {'e'}; // type inferred: char
		auto val4 {2.0f}; // type inferred: float
		auto val5 {290.3l}; // type inferred: long
		auto val6 {923u}; // type inferred: unsigned
		auto val7 {197ul}; // type inferred: unsigned long
		auto val9 {9291ll}; // type inferred: long long
	</code></pre>

	<!-- User Input -->
	<p>
		<span class="topic">User Input.</span> In the examples above, we used
		<span class="monoText">cout</span> to output data.
		<span class="monoText">cout</span> has sibling,
		<span class="monoText">cin</span>, which
		<span class="italicsText">inputs</span> data:
	</p>

	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		int main(int argc, char *argv[]) {
			int userNumber;
			cout << "Pick a number:" << endl;
			cin >> userNumber;
			cout << "You picked: " << userNumber << endl;
		
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		Pick a number: 
		27
		You picked: 27
	</code></pre>

	<!-- global v. local variables -->

	<p>
		<span class="topic">Global v. Local Variables.</span> Variables declared
		inside the <span class="monoText">main()</span> function are said to be
		<span class="term">local variables</span>:
	</p>

	<pre class="language-cpp"><code>
		int zob {1};

		int main() {
			int fen {25};
			int jib {12};
		}
	</code></pre>

	<p>
		In the code above, <span class="monoText">fen</span> and
		<span class="monoText">jib</span> are local variables. We say they are local
		variables because their scope (visibility) is within the
		<span class="monoText">main()</span> function. Put differently, the
		variables <span class="monoText">fen</span> and
		<span class="monoText">gib</span> only exist inside the
		<span class="monoText">main()</span> function. Outside of the
		<span class="monoText">main()</span> function, they effectively do not
		exist.
	</p>

	<p>
		In contrast, the variable <span class="monoText">zob</span> is a
		<span class="term">global variable</span>. This means they are visible to
		everything in the program. Which in turn means they can be changed from
		anywhere and by anything in the program.
	</p>

	<p>
		<span class="topic">Naming Rules.</span>
		<span class="monoText">C++</span> has a few naming rules we must follow: (1)
		Variables can contain letters, numbers, and underscores; (2) Variables must
		begin with a letter or underscore; (3) Cannot use reserved symbols; and (4)
		cannot <span class="italicsText">redeclare</span> a name in the same scope.
	</p>

	<p>
		<span class="topic">Enapsulation.</span> The idea of
		<span class="term">eancapsulation</span> is that user defined types have two
		layers: (1) an <span class="italicsText">interface</span> and (2) an
		<span class="italicsText">implementation</span>. The interface is how the
		world accesses the type, and the implementation is how the type operates or
		works. These two layers are defined in separate files. For example, suppose
		we have a user-defined type called <span class="monoText">cube</span>. The
		interface is kept in a file called <span class="monoText">cube.h</span> (a
		<span class="italicsText">header file</span>), and the implementation in a
		file called <span class="monoText">cube.cpp</span> (a
		<span class="italicsText">code file</span>).
	</p>

	<p>Inside <span class="monoText">cube.h</span>, we have the following:</p>

	<pre class="language-cpp"><code>
		// The Cube.h file

		#pragma once

		class Cube {
			public: 
			// These are the functions we can use with this type
				double getVolume();
				double getSurfaceArea();
				double getSize();

			private:
			// This is the data stored by this type
				double side_;

		};
	</code></pre>

	<p>
		The line <span class="monoText">#pragma once</span> tells the compiler that
		the following code should be used once during compilation. We include this
		line because our code might have a header file that relies on another header
		file that relies on another header file. This raises the danger of a
		possibly never-ending loop of searching for header files.
		<span class="monoText">#pragma once</span> ensures that loop terminates. We
		call statements like <span class="monoText">#pragma once</span>
		<span class="term">include guards</span>.
	</p>

	<p>
		Because these materials assume some knowledge of object-oriented
		programming, we address <span class="monoText">public</span> and
		<span class="monoText">private</span> in brief. The symbols
		<span class="monoText">public</span> and
		<span class="monoText">private</span> operate the same way as they would in
		other OOP languages like Java &mdash; <span class="monoText">public</span>,
		anyone and anything has access to the variable or method;
		<span class="monoText">private</span>, the particular variable or method is
		accessible only to the class. In <span class="monoText">C++</span>, if no
		access modifier is explicitly stated, the variable or method is
		<span class="monoText">private</span> by default.
	</p>

	<p>
		With the functions and data above, we now need to actually define them in
		our <span class="monoText">Cube.cpp</span> file:
	</p>

	<pre class="language-cpp"><code>
		// The Cube.cpp file

		#include "Cube.h"

		double Cube::getVolume() {

		}
	</code></pre>

	<p>
		The line <span class="monoText">#include "Cube.h"</span> tells the compiler,
		"Find the file called <span class="monoText">Cube.h</span>, and copy it to
		this file." This is because the compiler must know how the interface works
		to compile <span class="monoText">Cube.cpp</span>. It can only do so if we
		insert <span class="monoText">#include "Cube.h"</span> into the file. Notice
		how the code in the header file corresponds to the code in source code file:
	</p>

	<div class="compare">
		<pre class="language-cpp"><code>
			// The Cube.h file

			class Cube {
				public:
					double getVolume();
			}
		</code></pre>
		<pre class="language-cpp"><code>
			// The Cube.cpp file
			#include "Cube.h"

			double Cube::getVolume() {

			}
		</code></pre>
	</div>

	<p>
		Notice the <span class="monoText">::</span>. This is called the
		<span class="term">scope resolution operator</span>. This operator says,
		place <span class="monoText">Cube</span> in front of
		<span class="monoText">getVolume()</span>. Because
		<span class="monoText">getVolume()</span> is a
		<span class="italicsText">member function</span> &mdash; i.e., a
		<span class="term">method</span> &mdash; we must inform the compiler what
		class <span class="monoText">getVolume()</span> belongs to. This is done
		with the scope resolution operator, <span class="monoText">::</span>(two
		colons).
	</p>

	<p>
		Why do we have to tell the compiler which class this method belongs to?
		Because in <span class="monoText">Cube.h</span>, we might have a function
		called <span class="monoText">getVolume()</span> in other classes that are
		not <span class="monoText">Cube</span>.
	</p>

	<div class="compare">
		<pre class="language-cpp"><code>
			// The Cube.h file

			class Cube {
				public:
					double getVolume();
			}
			
			class Sphere {
				public:
					double getVolum();
			}
		</code></pre>
		<pre class="language-cpp"><code>
			// The Cube.cpp file

			#include "Cube.h"

			double Cube::getVolume() {

			}

			double Sphere::getVolume() {

			}
		</code></pre>
	</div>

	<p>
		Let's write some <span class="monoText">return</span> statements for
		<span class="monoText">Cube::getVolume()</span> method.
	</p>

	<pre class="language-cpp"><code>
		#include "Cube.h"

		double Cube::getVolume() {
			return side_ * side_ * side_;
		}
	</code></pre>
</section>

<section id="overflow">
	<h2>Overflow</h2>
	<p>
		A value of type <span class="monoText">char</span> takes 1 byte of memory.
		Consider the output for the following code:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		int main() {
			char x = 127;
			cout << (int)x << endl;
			x++;
			cout << (int)x << endl;
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		127
		-128
	</code></pre>
	<p>
		Strange. By incrementing <span class="monoText">x</span> by 1, the value
		went from 127 to 128. This demonstrates the concept of
		<span class="term">overflow</span>. A character can store only 1 byte. This
		means a value of type <span class="monoText">char</span> can only represent
		numeric values in the range ${[127, -128].}$ So what happens when we go
		beyond 127 or -128? We move to the beginning or the end of the range.
	</p>
	<p>
		We can think of this like a clock. We start at 0, then go up to 127. After
		127 is -128, then -127, then -126, all the way up to 0 and all way up to
		127. It's cyclical. But why is it cyclical?
	</p>
	<p>
		Because the numbers are represented as bits. The number 127 is represented
		as <span class="monoText">01111111</span>. When we increment by 1, we get:
		<span class="monoText">10000000</span>,
		<span class="monoText">-128</span> in the decimal system. This is just
		binary addition. The first bit is the sign, 0 for positive, and 1 for
		negative.
	</p>
</section>

<section id="bitwise_operators">
	<h2>Bitwise Operators</h2>
	<p>
		The bitwise operators are interesting, but not often used operators in C++.
		They are operators that allow us to manipulate data at the bit-level, rather
		than one the entire value. The operators are the following:
	</p>
	<figure class="table">
		<table class="truth_table">
			<thead>
				<th>Operator</th>
				<th>Description</th>
			</thead>
			<tbody>
				<tr>
					<td><span class="monoText">&</span></td>
					<td>
						Bitwise AND; given <span class="monoText">bit1</span> and
						<span class="monoText">bit2</span>,
						<span class="monoText">bit1 & bit2</span> are 1 if, and only if,
						both bits are 1. Otherwise,
						<span class="monoText">bit1 & bit2</span> are 0.
					</td>
				</tr>
				<tr>
					<td><span class="monoText">|</span></td>
					<td>
						Bitwise OR; if either <span class="monoText">bit1</span> or
						<span class="monoText">bit2</span> is 1, then
						<span class="monoText">bit1 | bit2</span> is 1.
					</td>
				</tr>
				<tr>
					<td><span class="monoText">^</span></td>
					<td>
						Bitwise XOR; if <span class="monoText">bit1</span> or
						<span class="monoText">bit2</span> is 1, but not both
						<span class="monoText">bit1</span> and
						<span class="monoText">bit2</span> are 1, then
						<span class="monoText">bit1 ^ bit2</span> is 1. If both
						<span class="monoText">bit1</span> and
						<span class="monoText">bit2</span> is 0, then
						<span class="monoText">bit1 | bit2</span> is 1. If both
						<span class="monoText">bit1</span> and
						<span class="monoText">bit2</span> is 1, then
						<span class="monoText">bit1 | bit2</span> is 0.
					</td>
				</tr>
				<tr>
					<td><span class="monoText">~</span></td>
					<td>
						Bitwise NOT; if <span class="monoText">bit1</span> is 1, then
						<span class="monoText">~bit1</span> is 0, and vice versa.
					</td>
				</tr>
				<tr>
					<td><span class="monoText">&lt;&lt;</span></td>
					<td>left shift</td>
				</tr>
				<tr>
					<td><span class="monoText">&gt;&gt;</span></td>
					<td>right shift</td>
				</tr>
			</tbody>
		</table>
	</figure>
	<p>
		Here is an example using the bitwise operator
		<span class="monoText">&</span>:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		int main() {
			int x = 1;
			int y = 2;
			int z = x & y;
			cout << z << endl;
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		0
	</code></pre>
	<p>Why is it 0? Because of the following:</p>
	<figure class="math-display">$$ 0 1 \\ 1 0 $$</figure>
	<p>
		The <span class="monoText">&</span> operator will pair each bit in
		<span class="monoText">x</span> with each bit in
		<span class="monoText">y</span>. In this case,
		<span class="monoText">1 & 0</span> and <span class="monoText">0 & 1</span>.
		Now, recall the rule: <span class="monoText">bit1 & bit2</span> are 1 if,
		and only if, both values are 1. Otherwise,
		<span class="monoText">bit1 & bit2</span> are 0. Thus,
		<span class="monoText">x & y</span> evaluates to
		<span class="monoText">00</span>, the integer 0 in the decimal system.
	</p>
</section>

<section id="value_reference_semantics">
	<h2>Value v. Reference Semantics</h2>
	<p>
		In languages like <span class="monoText">C++</span> and Java, when variables
		are passed as parameters, the values bound to those values are copied. For
		example:
	</p>
	<pre class="language-cpp"><code>
		void swap(int a, int b) {
			int temp = a;
			a = b;
			b = temp;
		}
		int main() {
			int x = 17;
			int y = 35; 
			cout << "x = " << x << ", y = " << y << endl;
			swap(x, y);
			cout << "x = " << x << ", y = " << y << endl;
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		x = 17, y = 35
		x = 17, y = 35
	</code></pre>
	<p>
		No swap occurs because we are passing
		<span class="italicsText">copies</span> of values into the variables. In
		other words, <span class="monoText">x</span> and
		<span class="monoText">y</span> always remain
		<span class="monoText">17</span> and
		<span class="monoText">35</span> respectively because only copies of those
		values were passed into the function. Any computation done in
		<span class="monoText">swap()</span> was done on copies of those values, so
		there no effect on <span class="monoText">x</span> and
		<span class="monoText">y</span>, the originals.
	</p>
	<p>
		This phenomenon, called <span class="italicsText">pass-by-value</span>, is
		not the only behavior in <span class="monoText">C++</span>. There is also
		<span class="italicsText">pass-by-reference</span>, which relies on
		<span class="term">reference semantics</span>. Here is an example using
		reference semantics:
	</p>
	<pre class="language-cpp"><code>
		void swap(int& a, int& b) {
			int temp = a;
			a = b;
			b = temp;
		}
		int main() {
			int x = 17;
			int y = 35
			cout << "x = " << x << ", y = " << y << endl;
			swap(x, y);
			cout << "x = " << x << ", y = " << y << endl;
		}
	</code></pre>
	<pre class="language-bash"><code>
		x = 17, y = 35
		x = 35, y = 17
	</code></pre>
	<p>
		Notice the use of the ampersand, <span class="monoText">&</span>. This tells
		<span class="monoText">C++</span> that we want a
		<span class="italicsText">reference</span> to the value. Because we are
		using a reference rather than a copy, changes to the parameter
		<span class="underlineText">will</span> affect the variable passed in.
		<span class="marginnote"
			>Passing by reference is usually best to avoid. With more reference
			values, it becomes more difficult to reason about code, and when that
			difficulty increases, the more difficult it is to debug. In some languages
			like Ruby, there are naming conventions in place to ensure reference or
			mutable values are physically visible. Although
			<span class="monoText">C++</span> has no such conventions, it is
			recommended to follow some sort of convention denoting which variables
			employ reference semantics. Or better yet, avoid using reference semantics
			as much as possible. There are situations of course where referance
			semantics are necessary. I.e., very large objects (e.g., massive data
			structures), should likely be passed as references. There is a balance,
			but for run-of-the-mill code, we generally want to avoid passing by
			reference.</span
		>
	</p>
	<p>
		Another point for concern with reference values is when we use reference
		variables as parameters to functions. In <span class="monoText">C++</span>,
		reference parameters can only take variables as arguments. In other words,
		we can never pass a literal to a reference parameter (after all, the whole
		point of reference semantics is to <span class="italicsText">refer</span> to
		something). Having said all these negatives, we should acknowledge the
		benefits of reference parameters: (1) We have a way of
		&#8220;returning&#8221; more than one value with functions, and (2) we have
		a way of avoiding making bulky copies of large objects when passing them as
		arguments.
	</p>
</section>

<section id="strings">
	<h2>Strings in <span class="monoText">C++</span></h2>
	<p>
		In C++, there are two approaches to represent strings: (1) as an array of
		<span class="monoText">char</span> values; or (2) as an instance of the
		class <span class="monoText">string</span>. In C++, the second approach is
		preferred.
		<span class="marginnote"
			>The first approach, representing strings as an array of character values,
			originates in the C language. It is how strings are represented in C, and
			because C++ is a superset of C, the same approach can be applied in
			C++.</span
		>
	</p>
</section>

<section id="character_arrays">
	<h3>Character Arrays</h3>
	<p>Applying the first approach:</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		void printString(char arr[], int n);
		int main() {
			char greet[] = "Hello world!";
			cout << greet << endl;
		
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		Hello world!
	</code></pre>
	<p>
		Notice the use of square bracket syntax to denote an array of
		<span class="monoText">char</span>. An important point to notice about
		character arrays is their size. Recalling the fact that a
		<span class="monoText">char</span> type takes 1 byte, consider this output:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		void printString(char arr[], int n);
		int main() {
			char greet[] = "Hello world!";
			int sizeOf_greet = sizeof(greet);
			cout << "size of greet = " << sizeOf_greet << " bytes" << endl;

			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		size of greet = 13 bytes
	</code></pre>
	<p>
		The array <span class="monoText">greet</span> consists of 12 elements (there
		are 12 characters in &#8220;Hello world!&#8221;). Why are we seeing 13 bytes
		as the size of <span class="monoText">greet</span>? Because every character
		array, denoted as a string, takes one extra byte, reserved for
		<span class="monoText">\0</span>. This value,
		<span class="monoText">\0</span>, is called the
		<span class="term">null byte</span>, or more specifically, the
		<span class="term">string delimiter</span>. It is the byte at the very end
		of the array, placed there to indicate the end of an array of characters, a
		string.
		<span class="marginnote"
			>Note that not every character array is a string. The array
			<span class="monoText">{'b', 'y', 'e'}</span> is a
			<span class="monoText">char</span> array, but it is not a string. However,
			once we include the string delimiter, it is considered a string:
			<span class="monoText">{'b', 'y', 'e', '\0'}</span>.</span
		>
	</p>
	<p>
		<span class="topic">Reading & Writing Character Arrays.</span> We can read
		and write <span class="monoText">char</span> arrays with
		<span class="monoText">cin</span> and <span class="monoText">cout</span>.
		The catch, however, is that we must indicate the size of the character
		array. This can lead to wasted space, but we will address this problem
		later.
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		void printString(char arr[], int n);
		int main() {
			char name[20];
			cout << "What's your name?" << endl;
			cin >> name;
			cout << "Hello, " << name << "." << endl;
		
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		What's your name?
		Dorian
		Hello, Dorian.
	</code></pre>
	<p>
		The problem with the approach above, however, is that it will not read
		anything after a whitespace:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		void printString(char arr[], int n);
		int main() {
			char name[20];
			cout << "What's your name?" << endl;
			cin >> name;
			cout << "Hello, " << name << "." << endl;
		
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		What's your name?
		Dorian Gray
		Hello, Dorian.
	</code></pre>
	<p>To fix this, we need to use <span class="monoText">cin.get</span>:</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		void printString(char arr[], int n);
		int main() {
			char name[20];
			cout << "What's your name?" << endl;
			cin.get(name, 20);
			cout << "Hello, " << name << "." << endl;
		
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		What's your name?
		Dorian Gray
		Hello, Dorian Gray.
	</code></pre>
	<p>
		Notice the syntax for <span class="monoText">cin.get()</span>. We must pass
		into it the variable we want to store the input in, and the number of
		characters to be read. With <span class="monoText">cin.get()</span>, if we
		pass in 20 for the number of characters, the number of characters to be read
		is actually 19, with 1 for the null byte.
	</p>
	<p>
		If we want multiple string inputs from the user, we use
		<span class="monoText">cin.getline()</span>. This is a separate function for
		reading strings because <span class="monoText">cin.get()</span> does not
		differentiate between different <span class="monoText">enter</span> key
		inputs. If we do want to use <span class="monoText">cin.get()</span>, we
		should separate the different <span class="monoText">cin.get()</span> calls
		with a <span class="monoText">cin.ignore()</span>. Of course, it is much
		easier to just use <span class="monoText">cin.getline()</span> whenever we
		seek multiple inputs from the user.
	</p>

	<h3>Functions on Strings</h3>
	<p>
		C++ provides several string functions through
		<span class="monoText">string.h</span>, a header file, or alternatively,
		through <span class="monoText">cstring</span>. These are both libraries
		providing various operations we can perform on strings.
	</p>
	<p>
		<span class="topic">Finding a String's Length.</span> Without the
		aforementioned libraries, one way to find a string's length is with the
		<span class="monoText">sizeof()</span> operator:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		int main() {
			char greet[] = "Foo bar baz bang";
			int sizeOfGreet = sizeof(greet) - 1;
			cout << "size of greet = " << sizeOfGreet << endl;
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		size of greet = 16
	</code></pre>
	<p>
		We subtract 1 because there is 1 extra element in the array, reserved for
		the null byte. Alternatively, we can simply use the
		<span class="monoText">strlen()</span> method provided by
		<span class="monoText">cstring</span>:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		#include &lt;cstring&gt;
		using namespace std;
		
		int main() {
			char greet[] = "Foo bar baz bang";
			int sizeOfGreet = strlen(greet);
			cout << "size of greet = " << sizeOfGreet << endl;
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		size of greet = 16
	</code></pre>
	<p>
		Notice the syntax for <span class="monoText">strlen()</span>. We simply pass
		in the variable storing the string, or the string itself, we seek the length
		for.
	</p>
	<p>
		<span class="topic">Concatenating Strings.</span> When we
		<span class="term">concatenate</span> two strings, we merge the strings
		together. We can concatenate strings with the
		<span class="monoText">strcat()</span> method:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		#include &lt;cstring&gt;
		using namespace std;
		
		int main() {
			char foo[] = "John ";
			char bar[] = "Kim";
			strcat(foo, bar);
			cout << foo << endl;
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		John Kim
	</code></pre>
	<p>The syntax for <span class="monoText">strcat()</span> is as follows:</p>
	<figure class="math-display">
		<ul class="syntax">
			<li>strcat(${destination}$, ${source}$)</li>
		</ul>
		<figcaption>
			where ${destination}$ is the string to be merged on to (here
			<span class="monoText">foo</span>), and ${source}$ is the string to merge
			(here <span class="monoText">bar</span>).
		</figcaption>
	</figure>
	<p>To understand how concatenation works, examine the array of characters:</p>
	<figure class="math-display">
		<div>
			<p><span class="monoText">['J', 'o', 'h', 'n', ' ', '\0']</span></p>
			<p><span class="monoText">['K', 'i', 'm', '\0']</span></p>
		</div>
	</figure>
	<p>
		When we concatenate <span class="monoText">Kim</span> onto
		<span class="monoText">John</span>, we take the first character of
		<span class="monoText">Kim</span> &mdash;
		<span class="monoText">K</span> &mdash; and use it to replace the null byte
		of <span class="monoText">John</span>. If we want to concatenate only some
		characters in the source string, we use
		<span class="monoText">strncat()</span>:
	</p>

	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		#include &lt;cstring&gt;
		using namespace std;
		
		int main() {
			char x[] = "Big ";
			char y[] = "Apple";
			strncat(x, y, 3);
			cout << x << endl;
		
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		Big App
	</code></pre>

	<p>
		<span class="topic">Copying Strings.</span> With the functions above, we
		mutated an existing string. What if we do not want to mutate an existing
		string? For that, we need the ability to copy strings. We can do so with
		<span class="monoText">strcpy()</span>. The general syntax:
	</p>
	<figure class="math-display">
		<ul class="syntax">
			<li>strcpy(${destination}$, ${source}$)</li>
		</ul>
	</figure>
	<p>For example:</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		#include &lt;cstring&gt;
		using namespace std;
		
		int main() {
			char x[] = "Hello";
			int sizeOfx = sizeof(x);
			char z[sizeOfx];
			char y[] = " world!";
			strcpy(z, x);
			strcat(z, y);
			cout << "x: " << x << endl;
			cout << "z: " << z << endl;
		
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		x: Hello
		z: Hello world!
	</code></pre>
	<p>
		Notice that we did not mutate <span class="monoText">x</span>. This is
		because we made a copy of the string stored in
		<span class="monoText">x</span>, and stored that copy in
		<span class="monoText">z</span>.
	</p>

	<p>
		<span class="topic">Substrings.</span> Another useful feature to have when
		working with strings is determining whether a given string is a
		<span class="italicsText">substring</span> of another string. For example,
		the string &#8220;corn&#8221; is a substring of the string
		&#8220;acorn.&#8221; We can make this determination with
		<span class="monoText">strstr()</span>. The general syntax:
	</p>
	<figure class="math-display">
		<ul class="syntax">
			<li>strstr(${main}$, ${substring}$)</li>
		</ul>
	</figure>
	<p>
		In the syntax above, ${main}$ is the existing string, and ${substring}$ is
		the substring we want to check for. An example:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		#include &lt;cstring&gt;
		using namespace std;
		
		int main() {
			char x[] = "Apple pie";
			bool result = strstr(x, "Apple");
			cout << result << endl;
		
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		1
	</code></pre>
	<p>
		We get back <span class="monoText">1</span>, indicating
		<span class="monoText">"Apple"</span> is a substring of the string
		<span class="monoText">"Apple pie"</span>. Remember that upper and lowercase
		characters are different. Checking for the substring
		<span class="monoText">"apple"</span> will return
		<span class="monoText">0</span>.
	</p>
	<p>
		If we want to find an instance of a <span class="monoText">char</span>, we
		use <span class="monoText">strchar()</span>. The general syntax:
	</p>
	<figure class="math-display">
		<ul class="syntax">
			<li>strchr(${string}$, ${char}$)</li>
		</ul>
	</figure>
	<p>
		The function <span class="monoText">strchr()</span> will search for a given
		character starting from the left. If we want to find a given character from
		the right, we use <span class="monoText">strrchar()</span>.
	</p>
	<p>
		<span class="topic">Comparing Strings.</span> In some languages, we can
		compare strings with the <span class="monoText">&lt;</span> or
		<span class="monoText">&gt;</span> operators. These operations output which
		of the given strings appears first in the alphabet. C++ provides a similar
		function, <span class="monoText">strcmp()</span>.
		<span class="marginnote"
			>&#8220;strcmp&#8221; is a clipping of &#8220;string compare.&#8221;</span
		>
		The general syntax:
	</p>
	<figure class="math-display">
		<div>
			<ul class="syntax">
				<li>strcmp(${s_1}$, ${s_2}$)</li>
			</ul>
		</div>
		<figcaption>
			Where ${s_1}$ and ${s_2}$ are the strings to be compared
		</figcaption>
	</figure>
	<p>For example:</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		#include &lt;cstring&gt;
		using namespace std;
		
		int main() {
			char apple[] = "apple";
			char kiwi[] = "kiwi";
			char peach[] = "peach";
		
			int result1 = strcmp(apple, kiwi);
			int result2 = strcmp(peach, apple);
			int result3 = strcmp(peach, peach);
		
			cout << "result1 = " << result1 << endl;
			cout << "result2 = " << result2 << endl;
			cout << "result3 = " << result3 << endl;
		
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		result1 = -10
		result2 = 15
		result3 = 0
	</code></pre>
	<p>
		Let's examine this output. First,
		<span class="monoText">strcmp(${s_1}$, ${s_2}$)</span> returns either a
		negative, 0, or positive value. If ${s_1}$ comes before ${s_2}$ in the
		alphabet, the value returned is negative. If ${s_1}$ comes after ${s_2}$ in
		the alphabet, the value returns positive. Finally, if both ${s_1}$ and
		${s_2}$ are the same, the value returned is 0.
	</p>
	<p>
		How does <span class="monoText">strcmp()</span> work? It compares the ACII
		integer values of the first non-matching character. For example, with
		<span class="monoText">apple</span> and <span class="monoText">kiwi</span>,
		the first non-matching characters are <span class="monoText">a</span> and
		<span class="monoText">k</span>. The character
		<span class="monoText">a</span> has an ASCII value of 97, and the character
		<span class="monoText">k</span> has an ASCII value of
		<span class="monoText">107</span>. Thus,
		<span class="monoText">apple</span> is different from
		<span class="monoText">kiwi</span> by -10 in terms in ASCII value.
	</p>
	<p>
		<span class="topic">String to Number.</span> Suppose we have the following
		strings:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		#include &lt;cstring&gt;
		using namespace std;
		
		int main() {
			char num1[] = "157";
			char num2[] = "2.49";
		
			return 0;
		}
	</code></pre>
	<p>
		Strings containing numbers are common in programming. So much so that C++
		provides functions for converting a string of numbers into a numeric type.
		These functions are <span class="monoText">strtol()</span> and
		<span class="monoText">strtof()</span>.
		<span class="marginnote"
			><span class="monoText">strtol()</span> is a clipping of &#8220;string to
			long&#8221; and <span class="monoText">strtof()</span> is a clipping of
			&#8220;string to float.&#8221;</span
		>
		The function <span class="monoText">strtolong()</span> will convert a number
		string into a <span class="monoText">long int</span>, and
		<span class="monoText">strtof()</span> will convert a number string into a
		<span class="monoText">float</span>.
	</p>

	<pre class="language-cpp"><code>
			#include &lt;iostream&gt;
			#include &lt;cstring&gt;
			#include &lt;typeinfo&gt;
			using namespace std;
			
			int main() {
				char num1[] = "157";
				char num2[] = "2.49";
				long int x = strtol(num1, NULL, 10);
				float y = strtof(num2, NULL);
			
				cout << typeid(num1).name() << " num1 : " << num1 << endl;
				cout << typeid(num2).name() << " num2 : " << num2 << endl;
				cout << typeid(x).name() << " x : " << x << endl;
				cout << typeid(y).name() << " y : " << y << endl;
			
				return 0;
			}
		</code></pre>
	<pre class="language-bash"><code>
			A4_c num1 : 157
			A5_c num2 : 2.49
			l x : 157
			f y : 2.49
		</code></pre>
	<p>
		Notice how the types have changed. The function
		<span class="monoText">strtol()</span> takes three arguments: (1) the string
		we wish to convert; (2) <span class="monoText">NULL</span>; and (3) the base
		for the relevant number system (e.g., 10 for the decimal systemm; 2 for the
		binary system; 16 for hexadecimalese; etc.). The
		<span class="monoText">strtof()</span> function takes the same arguments,
		but without the need for a number system parameter.
	</p>

	<p><span class="topic">Tokenizing.</span> Consider the following string:</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		#include &lt;cstring&gt;
		using namespace std;
		
		int main() {
			char userInput[] = "Hello world";
		
			return 0;
		}
	</code></pre>

	<p>
		Can we separate the string <span class="monoText">userInput</span> into the
		smaller strings <span class="monoText">"Hello"</span> and
		<span class="monoText">"world"</span>? Yes, we can. The process of breaking
		down a string into smaller pieces is called
		<span class="term">tokenizing</span>. The term &#8220;tokenizing&#8221;
		comes from the fact that every string consists of discrete parts. For
		example, the string <span class="monoText">"Hello world"</span> consists of
		the tokens <span class="monoText">"Hello"</span> and
		<span class="monoText">"world"</span>. Tokens are defined according to some
		common separator. For example, in
		<span class="monoText">"Hello world"</span> the separator is a whitespace.
	</p>
	<p>
		To tokenize a string in C++, we use the
		<span class="monoText">strtok()</span> function. The general syntax:
	</p>
	<figure class="math-display">
		<div>
			<ul class="syntax">
				<li>strtok(${s_1}$, "${d}$")</li>
			</ul>
		</div>
		<figcaption>
			where ${s_1}$ is the string to tokenize, and ${d}$ is the delimiter, or
			separator
		</figcaption>
	</figure>
	<p>
		For example, let's tokenize the string
		<span class="monoText">userInput</span>:
	</p>

	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		#include &lt;cstring&gt;
		using namespace std;
		
		int main() {
			char userInput[] = "Hello world";
			char *substr = strtok(userInput, " ");
			cout << substr << endl;
		
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		Hello
	</code></pre>
	<p>
		We managed to extract <span class="monoText">Hello</span>, but what about
		<span class="monoText">world</span>? This is the expected behavior for
		<span class="monoText">strtok()</span>. With only the arguments we passed
		into <span class="monoText">strtok()</span>, C++ will only extract the first
		token. To extract all the tokens, we will need to run
		<span class="monoText">strtok()</span> repeatedly. In other words, we must
		use a loop. Let's use a while loop, and store the respective tokens into a
		string array:
	</p>

	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		#include &lt;cstring&gt;
		using namespace std;
		
		void printStringArray(char *arr[], int n);
		
		int main() {
			char str[] = "Hello world";
			char *token = strtok(str, " ");
			char *tokenArr[2];
			int i = 0;
			while (token != NULL) {
				tokenArr[i] = token;
				token = strtok(NULL, " ");
				i++;
			}
		
			printStringArray(tokenArr, 2);
			// we can then index into the array
			cout << tokenArr[0] << endl;
			cout << tokenArr[1] << endl;
		
			return 0;
		}
		
		void printStringArray(char *arr[], int n) {
			cout << "[ ";
			for (int i = 0; i < n; i++) {
				cout << arr[i] << "  ";
			}
			cout << "]" << endl;
		}
	</code></pre>
	<pre class="language-bash"><code>
		[ Hello  world ]
		Hello
		world
	</code></pre>
</section>

<section id="string_class">
	<h3>String Class</h3>
	<p>
		As we saw, in <span class="monoText">C++</span>, strings are not a primitive
		type in C++. We have to either use a
		<span class="monoText">char</span> array &mdash; the historic and
		traditional way of creating strings &mdash; or, we can use the class
		<span class="monoText">String</span>. The
		<span class="monoText">String</span> class is defined in a separate header
		file, <span class="monoText">string.h</span>. When using the
		<span class="monoText">String</span> class to create a string, we are
		creating a <span class="italicsText">string object</span>. These differences
		are made more apparent after a discussion on classes.
	</p>
	<p>
		To use the <span class="monoText">String</span> class, we must include the
		<span class="monoText">String</span> library:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		#include &lt;string&gt;
		using namespace std;
		
		int main() {
			string greet = "Good morning";
			cout << greet << endl;
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		Good morning
	</code></pre>
	<p>
		Notice that unlike the <span class="monoText">char</span> array method, we
		simply used the word <span class="monoText">string</span>. The advantage to
		using the <span class="monoText">String</span> class is that it cuts down on
		the amount of code we have to write, and we don't have worry so much about
		arrays. The underlying mechanism behind
		<span class="monoText">string</span>, however, is the same. We are still
		creating an array of <span class="monoText">char</span>, with a null byte at
		the end. The <span class="monoText">string</span> class simply abstracts
		away the implementation.
	</p>
	<p>
		The one catch to a <span class="monoText">string</span> object is that the
		<span class="monoText">char</span> array allocated in memory isn't
		necessarily the length of the string plus 1 for the null byte:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		#include &lt;string&gt;
		using namespace std;
		
		int main() {
			char foo1[] = "foo";
			string foo2 = "foo";
			int foo1Size = sizeof(foo1);
			int foo2Size = sizeof(foo2);
			cout << "size of foo1: " << foo1Size << endl;
			cout << "size of foo2: " << foo2Size << endl;
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		size of foo1: 4
		size of foo2: 24
	</code></pre>
	<p>
		Notice the size difference between <span class="monoText">foo1</span>,
		created with the traditional method, and <span class="monoText">foo2</span>,
		created using the <span class="monoText">string</span> class.
		<span class="monoText">string</span> will allocate a larger array in memory
		for the string. This is to ensure that the
		<span class="monoText">string</span> can grow as needed. We call this extra
		memory the string's <span class="term">capacity</span>. C++ implements this
		string capacity in response to the fact that it can get somewhat unwieldy
		concatenating strings with the traditional method.
	</p>
	<p>
		Again, strings in
		<span class="monoText">C++</span> are a (potentially empty) sequence of
		characters. And as a sequence of characters, instances of
		<span class="monoText">String</span> are indexed from
		<span class="monoText">0</span> to ${n,}$ where ${n}$ is some positive
		integer. We can access the individual characters of a string using
		<span class="monoText">[${i}$]</span> where ${i}$ is some nonnegative
		integer, or with <span class="monoText">at</span>. For example:
	</p>
	<pre class="language-cpp"><code>
		string foo = "hello";
		char c1 = s[0]; // "h"
		char c2 = s.at(1); // "e"
	</code></pre>
	<p>
		Characters in <span class="monoText">C++</span> have
		<span class="term">ASCII encodings</span>. These encodings effectively map
		each character to an integer. Thus, when we cast a character into an
		<span class="monoText">int</span>, we will get back character's
		corresponding ASCII encoding.
	</p>
	<p>
		<span class="topic">Basic Operators.</span> We can concatenate strings in
		<span class="monoText">C++</span> as we would most other languages:
	</p>
	<pre class="language-cpp"><code>
		string s1 = "Hello ";
		s1 += "World!" // "Hello world!"
	</code></pre>
	<p>
		We can also use the comparison operators on strings, as we did with
		<span class="monoText">char</span> arrays. The comparison operators will
		compare the ASCII encodings of the strings. Thus, the character
		<span class="monoText">a</span> is "less than"
		<span class="monoText">b</span> becomes it has a smaller ASCII enscoding.
		Below are some other useful methods we can use with the
		<span class="monoText">string</span> class:
	</p>
	<figure class="table">
		<table class="truth_table">
			<thead>
				<th>Member Function</th>
				<th>Description</th>
			</thead>
			<tbody>
				<tr>
					<td><span class="monoText">${v}$.append(${s}$)</span></td>
					<td>add ${s}$ to end of ${v.}$</td>
				</tr>
				<tr>
					<td><span class="monoText">${v}$.erase(${i, \ell}$)</span></td>
					<td>
						delete ${\ell}$ characters in ${v}$ starting from index ${i.}$
					</td>
				</tr>
				<tr>
					<td><span class="monoText">${v}$.insert(${i, m}$)</span></td>
					<td>add text ${m}$ into string ${v}$ at index ${i.}$</td>
				</tr>
				<tr>
					<td><span class="monoText">${v}$.length()</span></td>
					<td>return the number of characters in the string ${v}$</td>
				</tr>
				<tr>
					<td><span class="monoText">${v}$.size()</span></td>
					<td>return the size of the string ${v}$</td>
				</tr>
				<tr>
					<td><span class="monoText">${v}$.capacity()</span></td>
					<td>return the capacity of the string ${v}$</td>
				</tr>
				<tr>
					<td><span class="monoText">${v}$.resize(${n}$, ${c}$)</span></td>
					<td>
						increases the length of the string ${v}$ by ${n}$ characters; pass
						the <span class="monoText">char</span> parameter ${c}$, which will
						occupy the new spaces
					</td>
				</tr>
				<tr>
					<td><span class="monoText">${v}$.max_size()</span></td>
					<td>
						returns the maximum size the string ${v}$ can grow to given current
						system limitations
					</td>
				</tr>
				<tr>
					<td><span class="monoText">${v}$.clear()</span></td>
					<td>
						erase the contents of the string ${v}$; results in an empty string
					</td>
				</tr>
				<tr>
					<td><span class="monoText">${v}$.empty()</span></td>
					<td>determines whether the string ${v}$ is the empty string</td>
				</tr>
				<tr>
					<td>
						<span class="monoText">${v}$.replace(${i}$, ${n}$, "${s}$")</span>
					</td>
					<td>
						replaces the characters in ${i}$ up to ${i + (n - 1)}$ with the
						character ${s.}$ For example:
						<pre class="language-cpp"><code>
							#include &lt;iostream&gt;
							#include &lt;string&gt;
							using namespace std;
							
							int main() {
								string foo = "foo";
								cout << foo << endl;
								foo.replace(0, 1, "b");
								cout << foo << endl;
								return 0;
							}
						</code></pre>
						<pre class="language-bash"><code>
							foo
							boo
						</code></pre>
					</td>
				</tr>
				<tr>
					<td><span class="monoText">${v}$.push_back('${c}$')</span></td>
					<td>
						Given a string ${v}$ containing the character ${c,}$ pushes the
						character ${c}$ back by one space; the opposite operation is
						<span class="monoText">.pop_back()</span>
					</td>
				</tr>
				<tr>
					<td><span class="monoText">${v}$.swap(w)</span></td>
					<td>Given strings ${v}$ and ${w,}$ swap the strings.</td>
				</tr>
			</tbody>
		</table>
	</figure>
	<p>
		However, there are differences. Strings in
		<span class="monoText">C++</span> are
		<span class="underlineText">mutable</span>. Additionally, there are
		<span class="underlineText">two</span> types of strings in
		<span class="monoText">C++</span>.
	</p>
</section>
{% endblock %}
