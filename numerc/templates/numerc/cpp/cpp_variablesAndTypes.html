{% extends '../layout.html' %} {% load static %} {% block description %}
<meta
	name="description"
	content="An overview of variables and primitive types in C++: int, float, boolean, char, string, variable declarations, variable initialization, pass by value, pass by reference."
/>
{% endblock %} {% block title %}
<title>C++: Variables and Data Types</title>
{% endblock %} {% block content %}
<h1>Variables &amp; Types</h1>
<section id="variables_and_types">
	<p>
		In a computer, data is stored inside a memory location. We can think of
		computer memory as a large grid of small squares with unique addresses.
		These small squares, or cells, are arranged in a logical order. Each cell
		can store <em>1 byte</em>, or <em>8 bits</em> of data. A bit is either a 0
		or a 1. With 8 bits, we have 256 different combinations (${2^8 = 256.}$)
		Those combinations can be used to represent the numbers 0 to 255. In
		statically typed languages, we must explicitly state variable's type during
		declaration. This tells the compiler what type of data the variable will
		store. Given that information, the compiler can determine how much memory to
		allocate. To use that data, we must reference that particular location. In
		languages like Assembly, this is in fact how we access that data. Now, these
		memory locations are fairly cryptic and difficult to read (they're in
		hexadecimal). Instead of referencing these memory locations, we can
		associate a <i>name</i> to that particular location, and reference that name
		instead. This is called a <b>binding</b>.
	</p>

	<p>
		Variables are essentialy &#8220;cabinets&#8221; where we can place data.
		Those cabinets, however, have specific labels called
		<i>types</i>. The data we place in a cabinet must have a type that matches
		the label. However, we can change the contents of the cabinets. More
		formally, variables are locations in memory where we can store data. Instead
		of referring to that location with its memory address, we give that location
		a name called an <i>identifier</i>. In source code, the identifier is the
		name we give a variable. Identifiers should be descriptive and meaningful,
		so as to make later recall easier. Identifiers can only consist of (a)
		upper-case alphabets, (b) lower-case alphabets (c) numbers, and (d)
		underscores. Additionally, the first character in the identifier must be
		either an alphabet or an underscore. Thus, identifiers cannot contain
		special characters (&, !, #, ;, etc.) nor can it contain whitespace.
		Upper-case alphabets and lower-case alphabets are distinct. Thus, the
		identifier <var>foo</var> is different from the identifier <var>Foo</var>. A
		<b>variable</b> is a programming construct that allows us to associate a
		<i>value</i> with a <i>name</i>. More formally, a variable is a named piece
		of memory that a programmer uses to store specific types of data. In other
		words, it is an abstraction for the process described previously. Examples
		of variables in <var>C++</var>:
	</p>

	<pre class="language-cpp"><code>
		int x; // value is undefined
		char grade = 'A';
		double pi = 3.14;
	</code></pre>

	<p>
		The value <var>'A'</var> and <var>3.14</var> are called <b>literals</b>. A
		literal is a value directly represented inside the program executable (as
		opposed to a value that must be accessed through a variable stored somewhere
		in memory). For example, the variable <var>pi</var> will be stored somewhere
		in memory. The literal <var>3.14</var>, however, will be directly
		represented as binary in the executable.<sup></sup>
		For example, suppose we wrote the following:
	</p>
	<div class="note">
		<p>
			A <i>variable declaration</i> is an instruction to the compiler to
			<em>reserve</em> space in memory for data. Because C++ is a
			<i>statically typed</i> language, variable declarations must explicitly
			include the variable's type. A <i>variable initialization</i> is an
			instruction to the compiler to <em>store</em> data in the reserved space.
		</p>
	</div>

	<pre class="language-cpp"><code>
		int a = 1
		int b = 2
	</code></pre>

	<p>
		When we actually compile the program, the code above looks something like:
	</p>

	<figure class="table">
		<table class="monotable">
			<tbody>
				<tr>
					<td>001</td>
					<td>a = 1 (int)</td>
				</tr>
				<tr>
					<td>002</td>
					<td>b = 2 (int)</td>
				</tr>
				<tr>
					<td>${\vdots}$</td>
					<td>${\vdots}$</td>
				</tr>
				<tr>
					<td>0040</td>
					<td>1</td>
				</tr>
				<tr>
					<td>0041</td>
					<td>2</td>
				</tr>
			</tbody>
		</table>
	</figure>

	<p>
		The values are called literals because they are
		<i>literally</i> inside the source code. They do not need to be represented
		in memory. Because the values bound to <var>a</var> and <var>b</var> are
		literals, we can use <var>a</var> and <var>b</var> throughout our program
		(this is true because the variables above are presumed to be declared in the
		global scope; more on this later).
	</p>

	<p>
		Note that literals with modifiers, like
		<var>long</var> and <var>unsigned</var>, should have a suffix appended at
		the end, indicating that the value is a literal:
	</p>

	<pre class="language-cpp"><code>
		unsigned int ceoBonus {2'000'000u};
		unsigned int errorCode = 0xBAD; // evaluates to 2989 
		int myOctal {0777u} // evaluates to 511
		float myFloat {1.2f}
	</code></pre>

	<p>
		Notice the use of single quotes as separators. This is particularly helpful
		when we have large value literals. Notice also that we can represent hex
		numbers in C++.<sup></sup> Hex numbers are also used to indicate colors.
		Above, we also see an example of using octal numbers as literals. Notice
		that octal numbers are prefaced with a <var>0</var>. Because of this use of
		<var>0</var>, be very careful not to preface <var>int</var> values with a
		<var>0</var> if an <var>int</var> is intended.
	</p>
	<div class="note">
		<p>
			Hex numbers are used amusingly (and usefully) in many programs as
			<i>hex speak.</i> For example, the hex number <var>0xBAAAAAAD</var> is
			used as an iOS exception report (it evaluates to the integer
			<var>3131746989</var>.) Similarly, <var>0xDEADBEEF</var> is almost
			ubiquitously used in embedded systems to indicate a software crash or a
			deadlock. These are all examples of <b>magic numbers</b>; numbers used to
			indicate a particular value.
		</p>
	</div>
	<p>
		In the last line, we see a <var>float</var> literal. Notice the suffix
		<var>f</var>. This suffix must be included if we want to ensure the value is
		treated as a <var>float</var> literal. If we fail to include the suffix, we
		risk C++ treating the value as a <var>double</var>.
	</p>

	<h3>Data Types</h3>
	<p>
		C++ has three kinds of data types: (1)
		<i>primitive types</i>; (2) <i>derived types</i>; and (3)
		<i>user-defined types</i>.<sup></sup>
		The primitive types are types provided by default in C++. They include:
		<var>int</var>, <var>float</var>, <var>double</var>, <var>char</var>,
		<var>boolean</var>, and <var>void</var>. The derived types are types derived
		from the primitive data types. They include: <var>Function</var>,
		<var>Array</var>, <var>Pointer</var>, and <var>Reference</var>. The
		user-defined types are types defined by the user. They include:
		<var>Structure</var>, <var>Union</var>, <var>Enum</var>, <var>Class</var>,
		and <var>Typedef</var>.
	</p>
	<div class="note">
		<p>
			Mathematically, a data type is really just a
			<i>set</i>. It is the set of all the possible values that belong to that
			type, alongside the operations that can be performed on those values.
		</p>
	</div>

	<p>
		A variable of type <var>float</var>, as well as a variable of type
		<var>double</var>, stores floating point values (i.e., numbers with a
		decimal point). <var>double</var> is allocated 8 bytes of memory. Thus, it
		can store values ranging from ${-2^{63}}$ to ${2^{63} - 1.}$ How precise
		floating-point value is depends on how many numbers follow the decimal
		point. A <var>float</var> can store up to 7 digits.
	</p>

	<p>
		A variable of type <var>int</var> takes up 4 bytes of memory. It can store
		any value from ${-2^{31}}$ to ${2^{31} - 1.}$ If we store a floating point
		value (e.g., ${2.32}$) in an <var>int</var> variable, C++ will truncate the
		value to 2. A <var>double</var> can store up to 15 digits A variable of type
		<var>char</var> stores a character from the ASCII table. In reality,
		<var>char</var> represents the character's numeric ASCII value.
		<var>char</var> is allocated 1 byte of memory. It can store any Unicode
		value from ${-2^7}$ to ${2^7 - 1.}$
	</p>

	<p>
		A variable of type <var>bool</var> stores one of two values &mdash;
		<var>true</var> or <var>false</var>. A variable of type <var>bool</var> is
		allocated 1 byte of memory. The <var>void</var> data type represents
		&#8220;no value.&#8221; This is a specific instruction to the compiler not
		to allocate any memory.
	</p>

	<p>
		<i>Data type modifiers</i> are special symbols we can prepend to a data type
		to modify the data type's instructions. The modifier <var>long</var> will
		instruct the compiler to allocate 4 more bytes. We can use
		<var>long</var> with <var>int</var> and <var>double</var>. The modifier
		<var>short</var> instructs the compiler to only allocate 2 bytes.
		<var>short</var> applies only to <var>int</var>. We <em>cannot</em> use
		modifiers with the <var>float</var> type. The <var>unsigned</var> modifier
		allows us to store only positive values (i.e., values without the signed
		bit). The <var>signed</var> modifier allows us to store both positive and
		negative values. <var>signed</var> is the default declaration for
		<var>int</var> and <var>char</var>.
	</p>

	<p>
		<i>Type-casting</i> is when we instruct the compiler to convert a value of
		one type to another. There are two types of type-casting:
		<i>implicit casting</i> and <var>explicit casting</var>. In
		implicit-casting, the compiler automatically converts one data type to
		another. In explicit-casting, we, the programmers, explicitly instruct the
		compiler to convert.
	</p>

	<p>
		The value of <var>x</var> above is <var>undefined</var>, which is itself a
		value. It will display to the console some value, but it could be any value.
		All of the types above are <b>primitive types</b> in <var>C++</var>. There
		are several others:
	</p>

	<figure class="table">
		<table class="truth_table">
			<thead>
				<th>Data Type</th>
				<th>Size</th>
				<th>Represents</th>
			</thead>
			<tbody>
				<tr>
					<td>char</td>
					<td>${1}$ byte, ${\geq 8}$ bits</td>
					<td rowspan="4">character</td>
				</tr>
				<tr>
					<td>char16_t</td>
					<td>${\geq 16}$ bits</td>
				</tr>
				<tr>
					<td>char32_t</td>
					<td>${\geq 32}$ bits</td>
				</tr>
				<tr>
					<td>wchar_t</td>
					<td>largest available character set</td>
				</tr>
				<tr>
					<td>short</td>
					<td>${\geq 16}$ bits</td>
					<td rowspan="5">signed integer values</td>
				</tr>
				<tr>
					<td>short</td>
					<td>${\geq 16}$ bits</td>
				</tr>
				<tr>
					<td>int</td>
					<td>${\geq 16}$ bits</td>
				</tr>
				<tr>
					<td>long</td>
					<td>${\geq 32}$ bits</td>
				</tr>
				<tr>
					<td>long long</td>
					<td>${\geq 64}$ bits</td>
				</tr>
				<tr>
					<td>unsigned short</td>
					<td>${\geq 16}$ bits</td>
					<td rowspan="4">unsigned integer values</td>
				</tr>
				<tr>
					<td>unsigned</td>
					<td>${\geq 16}$ bits</td>
				</tr>
				<tr>
					<td>unsigned long</td>
					<td>${\geq 32}$ bits</td>
				</tr>
				<tr>
					<td>unsigned long long</td>
					<td>${\geq 64}$ bits</td>
				</tr>
				<tr>
					<td>float</td>
					<td>${\approx}$ ${7}$ decimal places</td>
					<td rowspan="3">non-integer reals</td>
				</tr>
				<tr>
					<td>double</td>
					<td>${\approx}$ ${15}$ decimal places</td>
				</tr>
				<tr>
					<td>long double</td>
					<td>${\approx}$ ${19}$ decimal places</td>
				</tr>
				<tr>
					<td>bool</td>
					<td>usually ${8}$ bits</td>
					<td>true; false</td>
				</tr>
				<tr>
					<td>void</td>
					<td>represents "typelessness"</td>
					<td></td>
				</tr>
				<tr>
					<td>auto</td>
					<td>used to deduce types</td>
					<td></td>
				</tr>
			</tbody>
		</table>
	</figure>

	<p>
		What data type we use depends on the program we're writing and whether we're
		particularly concerned about memory use. If we attempt to assign too large
		of a value into a variable type that does not accomodate for that value's
		size, we will get an <b>overflow</b>.
	</p>

	<section id="constants">
		<h3>Constants</h3>
		<p>
			Constants are variables whose bound values are immutable &mdash; the value
			cannot be changed. We can initialize constants in C++ as such:<sup></sup>
		</p>
		<div class="note">
			<p>
				A <i>constant</i> is a variable whose constants <em>cannot</em> be
				changed. We can think of it as a locked cabinet. Because they are locked
				cabinets, constants must be initialized and declared at the same time.
			</p>
		</div>

		<pre class="language-cpp"><code>
			const double accelerationGravity { 9.807 }; // meters per second^2
		</code></pre>

		<p>
			The <var>const</var> qualifier does not actually apply to the data in
			memory. In other words, it's not like the data in memory permanently stays
			in some location, never moving, never changing. Instead, the qualifier
			applies to the variable name. What this means is, in the variable above,
			<var>accelerationGravity</var>, we cannot change the value bound to it,
			<var>9.807</var>, using <var>accelerationGravity</var>. This is a crucial
			distinction to understand, because there is more than one way to modify a
			value bound to a variable. As we will see on the section with pointers,
			there are situations where we can accidentally cause a <var>const</var> to
			change.
		</p>
		<p>
			Question: What if the <var>const</var> value depends on the computation of
			a non-constant value? Will subsequent changes to the non-constant value
			cause changes to the <var>const</var> value? Fortunately in C++, no. Once
			a variable is initialized as a constant, that value will remain bound to
			the identifier:
		</p>

		<pre class="language-cpp"><code>
			#include &lt;iostream&gt;
	
			int main() {
				int a = 3;
				const int b = 4 + a;
				std::cout << b << std::endl;
				a += 1;
				std::cout << b << std::endl;
			
				return 0;
			}
		</code></pre>
		<pre class="language-bash"><code>
			7
			7
		</code></pre>

		<p>
			Constants are what allow us to ensure that a value bound to a particular
			identifier is never changed through that identifier. If we, or any part of
			our code, attempt to modify that constant through the identifier, we will
			get a compiler error.
		</p>
		<p>
			In general, we should err on the side of using constants. While mutability
			is a useful tool, erring on mutability only increases the amount of values
			we must keep track of. Some of those values will be things that should
			never change, and should not be included in our personal list of tracked
			values. Some C++ programmers follow the habit of declaring every variable
			as a <var>const</var>, then deciding after seeing compiler errors whether
			to remove the <var>const</var> declaration. This is great habit, as it
			forces us to more carefully consider whether we want mutability.
		</p>
	</section>

	<section id="constant_expressions">
		<h3>Constant Expressions</h3>
		<p>
			Constant expressions are expressions that are evaluated at compile time
			rather than runtime. The default behavior is to perform these computations
			at runtime. The problem, however, is that some computations can be
			enormous. This means that whenever a user loads an executable (i.e., runs
			the program,) the computation may need to be performed again. This
			redundancy can amount to large costs in runtime. To declare constant
			expressions, we use the
			<var>constexpr</var> keyword:
		</p>
		<pre class="language-cpp"><code>
			constexpr double pi {3.14};
		</code></pre>
		<p>
			We cannot use non-constant expressions (i.e.,
			<b>runtime values</b>) inside constant expressions (<b
				>compile-time values</b
			>). This is because the compiler cannot perform computations on or with
			runtime values. Those computations must be done at runtime.
		</p>
		<pre class="language-cpp"><code>
			const double e {2.718};
			constexpr double myNum { e * 2.2 };  // returns an error
		</code></pre>
		<p>
			The code above returns an error because <var>e</var> is a non-constant
			expression. To actually perform the computation, <var>e</var> must also be
			a constant expression:
		</p>
		<pre class="language-cpp"><code>
			constexpr double e {2.718};
			constexpr double myNum { e * 2.2 };  // returns 5.9796
		</code></pre>
		<p>
			Constant expressions are enormously useful in ensuring that we do not
			waste valuable runtime. In particular, we almost always want to perform
			large, heavy computations at compile time. By doing so, we do not have to
			waste valuable runtime performing the large computation. Instead, the
			computer's loader will simply retrieve the result from the compiler's
			computation.
		</p>
		<p>
			We can think of constant expressions as a cost-shifting mechanism. Rather
			than the user paying the price for the large computation, we, as the
			programmers, pay the price at computation. Erring on constant expressions,
			executables can load much, much faster.<sup></sup>
		</p>
		<div class="note">
			<p>
				As evidence of how valuable constant expressions are, one of the most
				competitive games in the programming languages market is moving as many
				computations as possible to compile time. With each new standard of C++
				(and other languages like Java), there have been increases in the number
				of movable computations. Given how fast compilers are getting, the game
				is only growing more heated.
			</p>
		</div>
		<p>
			Constant expressions are very useful for checks For example, suppose our
			program should not proceed any further &mdash; in compilation &mdash;
			unless some condition is met. We can do so with
			<var>static_assert(${b}$)</var>, where ${b}$ is the condition we want met.
		</p>

		<pre class="language-cpp"><code>
			int main() {
				constexpr int a = 2;
				static_assert(a == 3);
				return 0;
			}
		</code></pre>
		<pre class="language-bash"><code>
			main.cpp:5:2: error: static_assert failed due to requirement 'a == 3'
					static_assert(a == 3);
					^             ~~~~~~
			1 error generated.
		</code></pre>

		<p>
			Above, our program never actually compiles &mdash; and never gets to
			runtime &mdash; because the condition
			<var>a == 3</var> is not met. Separately, constant expressions are
			effectively constants, so the expressions cannot be mutated.
			<var>static_assert()</var> can be a very valuable tool when we are moving
			large amounts of computations to compile time, as it reduces the costs
			we've shifted to ourselves as programmers.
		</p>
	</section>

	<section id="size_of">
		<h3>The Size Of Operator</h3>
		<p>
			The
			<var>sizeof()</var> operator returns the size, in bytes, of a type or
			variable. The operator is often used to determine size of arrays,
			structures, and objects. We address it here because it is particularly
			useful for variables, and will revisit it when we discuss arrays.
		</p>

		<p>
			<var>C++</var> provides several ways to declare and initialize variables:
		</p>

		<pre class="language-cpp"><code>
			int foo; // declaration; likely contains garbage value
			int baz = 17; // assignment initialization
			int kwa (43); // constructor initialization; initializes to 43
			int xyz {13}; // C++ list initialization; initializes to 13
			int bar {}; // initializes to 0
			
			// we can also uses expressions as initializers
			int bop {14 + 2}; // initializes to 16
			int x {2};
			int y {5};
			int z {x + y}; // initializes to 7
			int g {x + y + i}; // won't compile, i is undeclared
		</code></pre>

		<p>
			Note that if we declare a variable but do not initialize it, that variable
			will have some <b>garbage value</b> stored, and we have no control over
			what that value is. As such, it is crucial that we initialize variables
			once declared.<sup></sup>
		</p>

		<div class="note">
			<p>
				This is a stark contrast to other languages like Java, where there are
				default values for uninitialized variables. If you're coming from one of
				those languages, beware!
			</p>
		</div>
	</section>

	<section id="more_on_numeric_types">
		<h3>More on Numeric Types</h3>
		<p>
			Numeric types are so important in programming that it's worth exploring
			them more deeply. To begin, <var>C++</var> has no problem handling
			positive and negative numbers:
		</p>

		<pre class="language-cpp"><code>
			int val1 {1} // a positive integer
			int val2 {-1} // a negative integer
		</code></pre>

		<p>The code above is a form of syntactic sugar for the following:</p>

		<pre class="language-cpp"><code>
			signed int val1 {1}
			signed int val2 {-1}
		</code></pre>

		<p>
			The keyword <var>signed</var> is called a <b>modifier</b>. A modifier does
			what it says &mdash; it modifies what a variable can and cannot do. In
			this case, <var>signed</var> indicates that the subsequent variable can
			store positive or negative numbers. If we want to ensure that a variable
			can only store positive numbers, we use the <var>unsigned</var> modifier.
			Whether or not an <var>int</var> is signed or unsigned, the
			<var>int</var> will still occupy 4 bytes in memory.
		</p>

		<p>
			Signage, however, impacts how many values a given numeric type can
			represent. Roughly, where ${n}$ is the number of bits for a type in
			memory, unsigned numeric types can represent numbers in the interval ${[0,
			2^n-1].}$ Signed integers can store numbers in the interval ${[-2^{n-1},
			2^{n-1} - 1].}$ For example, with integers, the
			<var>unsigned</var> modifier allows us to represent numbers from 0 to
			about 4.2 billion. With <var>signed</var>, we can represent numbers from
			about -2.1 billion to 2.1 billion.
		</p>

		<p>
			There are additional modifiers we can use for numeric types,
			<var>short</var> and <var>long</var>. The <var>short</var> and
			<var>long</var> modifiers will modify the number of bytes a type requires.
			With <var>short</var>, we reduce the range of values we can represent, but
			save memory. With <var>long</var>, we increase the range of values can
			represent, but use up more memory. We can use <var>short</var> and
			<var>long</var> with <var>signed</var> and <var>unsigned</var> to balance
			the tradeoffs:
		</p>

		<pre class="language-cpp"><code>
			// these variables take up 2 bytes
			short foo {};
			short int bar {};
			signed short bang {};
			signed short int zing {};
			unsigned short int blob {};
	
			// these variables take up 4 bytes
			int vroom {};
			signed hoho {};
			signed int gaga {};
			unsigned int didi {};
	
			// these variables take up 4 or 8 bytes
			long wawa {};
			long int pepe {};
			signed long toto {};
			signed long int shibi {};
			unsigned long int grob {};
	
			// these variables take up 8 bytes
			long long jam {};
			long long int jip {};
			signed long long doop {};
			signed long long int coco {};
			unsigned long long lulu {};
			unsigned long long int momo {};
		</code></pre>

		<p>
			Note that the modifiers <var>signed</var>, <var>unsigned</var>,
			<var>long</var>, and <var>short</var> only work for
			<b>integral types</b> &mdash; types representing integers. They will not
			work for <b>floating types</b> &mdash; types representing fractional
			numbers.
		</p>

		<p>
			Furthermore, we should be careful when using the
			<var>short</var> and <var>unsigned</var> modifiers with integral types
			like <var>short int</var>. Arithmetic may not work as expected for an
			integral type that can take no more than 4 bytes of memory (e.g.,
			<var>short int</var>, which only takes 2 bytes). If the result requires
			more than 4 bytes of memory, C++ will return a result in type other than
			the operands'. For example, in the case of <var>short int</var>, if the
			result requires more than 2 bytes of memory, C++ will return a result of
			type <var>int</var>.
		</p>
	</section>

	<section id="floating_types">
		<h3>Floats</h3>
		<p>
			C++ has three base floating types: <var>float</var>, <var>double</var>,
			and <var>long double</var>. The base type <var>float</var> takes up 4
			bytes of memory, <var>double</var> takes up 8 bytes, and
			<var>long double</var> takes up 12 bytes. With floating types, the primary
			concern for memory usage is more focused on precision. With 4 bytes of
			memory, precision is ensured for up to 7 decimal places (including the
			integral part). For <var>double</var>, it's 15. With
			<var>long double</var>, it depends on the compiler implementation; it can
			range anywhere from 15, 18, to 33. For the most part, <var>double</var> is
			the recommended type to use, and it suffices for most programming tasks.
		</p>
		<p>
			<span class="topic">Scientific Notation.</span> C++ supports scientific
			notation natively:
		</p>

		<pre class="language-cpp"><code>
			// x and y are equivalent
			double x { 732400023 };  
			double y { 7.32400023e8 };
	
			// v and w are equivalent
			double v { 0.00000000002313 };
			double w { 2.313e-11 };
		</code></pre>

		<p>
			<span class="topic">Infinity and NaN.</span> For those familiar with
			JavaScript, C++ has representations for Infinity and <var>NaN</var>:
		</p>

		<pre class="language-cpp"><code>
			#include &lt;iostream&gt;
	
			int main() {
				float a { 1.0 };
				float b {};
				float c { a / b }; // evaluates to Infinity
			
				float u { 0.0 };
				float v { 0.0 };
				float w { u / v };; // evaluates to NaN
			
				std::cout << "valueOf c: " << c << std::endl;
				std::cout << "valueOf w: " << w << std::endl;
				return 0;
			}
		</code></pre>
		<pre class="language-bash"><code>
			valueOf c: inf
			valueOf w: nan
		</code></pre>

		<p>
			<span class="topic">Division.</span> The arithmetic operations covered are
			fairly straightforward. Special attention, however, should be given to
			division.<sup></sup>
		</p>
		<div class="note">
			<p>
				As an aside, the <var>*</var> (asterisk) operator's use for
				multiplication dates back to John Backus and his team's development of
				Fortran. At the time (1954), the available character set for computers
				was limited, and <var>*</var> was the closest symbol to ${\times.}$
			</p>
		</div>

		<p>Dividing integers can yield unusual results:</p>

		<pre class="language-cpp"><code>
			#include &lt;iostream&gt;
	
			int main() {
				int c = 21 / 10; // expected: 2.1
				std::cout << c << std::endl;
			}
		</code></pre>
		<pre class="language-bash"><code>
			2
		</code></pre>

		<p>
			Notice that the output is 2. Why is this? What's actually happening is
			that C++ is trying to figure out how many times it can fit 10 inside 21.
			In this case, 2. This is what happens when we divide an
			<var>int</var> value by a non-multiple of that value. We won't get back a
			fractional number. For that, we need to use float types:
		</p>

		<pre class="language-cpp"><code>
			#include &lt;iostream&gt;
	
			int main() {
				double c = 21.0 / 10.0; // expected: 2.1
				std::cout << c << std::endl;
			}
		</code></pre>
		<pre class="language-bash"><code>
			2.1
		</code></pre>
	</section>

	<section id="booleans">
		<h3>Booleans</h3>
		<p>
			Boolean data types represent just two states &mdash; true or false.
			Accordingly the data type
			<var>bool</var> in C++ consists of only two values: <var>true</var> and
			<var>false</var>. A Boolean value takes up 8 bits of memory (an entire
			byte). This may seem extremely wasteful, particularly from the perspective
			of embedded systems, where memory is very scarce. With advances in memory
			capacity, however, most programs aren't impacted by the consumption. We
			will see in later sections various ways of bundling more data into a byte.
		</p>
	</section>

	<section id="characters">
		<h3>Characters</h3>
		<p>
			In C++, single-character data is represented with <var>char</var> type. A
			<var>char</var> value is represented with single quotes in C++:
		</p>

		<pre class="language-cpp"><code>
				char foo = 'a';
			</code></pre>
		<p>
			Note that we must use single quotes. Any other symbol will return an
			error.
		</p>
		<p>
			The <var>char</var> type takes up 1 byte, or 8 bits, of memory. Characters
			in C++ map to the ASCII table. Thus, each ASCII character has an integer
			ASCII encoding.
		</p>
	</section>

	<section id="auto">
		<h3>The Keyword Auto</h3>
		<p>
			The keyword
			<var>auto</var> is C++'s take on type inference. By appending the keyword
			to a variable name, we instruct C++ to infer the bound value's type. This
			is particulary useful for when we have particularly long type names. We
			can't really appreciate how useful type inference is at the moment, but we
			mention it here for completeness.
		</p>

		<pre class="language-cpp"><code>
			auto val1 {19}; // type inferred: int
			auto val2 {38.3}; // type inferred: double
			auto val3 {'e'}; // type inferred: char
			auto val4 {2.0f}; // type inferred: float
			auto val5 {290.3l}; // type inferred: long
			auto val6 {923u}; // type inferred: unsigned
			auto val7 {197ul}; // type inferred: unsigned long
			auto val9 {9291ll}; // type inferred: long long
		</code></pre>
	</section>

	<section id="user_input">
		<h3>User Input</h3>
		<p>
			In the examples above, we used
			<var>cout</var> to output data. <var>cout</var> has sibling,
			<var>cin</var>, which <i>inputs</i> data:
		</p>

		<pre class="language-cpp"><code>
			#include &lt;iostream&gt;
			using namespace std;
			
			int main(int argc, char *argv[]) {
				int userNumber;
				cout << "Pick a number:" << endl;
				cin >> userNumber;
				cout << "You picked: " << userNumber << endl;
			
				return 0;
			}
		</code></pre>
		<pre class="language-bash"><code>
			Pick a number: 
			27
			You picked: 27
		</code></pre>
	</section>

	<section id="global_v_local">
		<h3>Global v. Local</h3>
		<p>
			Variables declared inside the <var>main()</var> function are said to be
			<b>local variables</b>:
		</p>

		<pre class="language-cpp"><code>
			int zob {1};
	
			int main() {
				int fen {25};
				int jib {12};
			}
		</code></pre>

		<p>
			In the code above, <var>fen</var> and <var>jib</var> are local variables.
			We say they are local variables because their scope (visibility) is within
			the <var>main()</var> function. Put differently, the variables
			<var>fen</var> and <var>gib</var> only exist inside the
			<var>main()</var> function. Outside of the <var>main()</var> function,
			they effectively do not exist.
		</p>

		<p>
			In contrast, the variable <var>zob</var> is a <b>global variable</b>. This
			means they are visible to everything in the program. Which in turn means
			they can be changed from anywhere and by anything in the program.
		</p>
	</section>

	<section id="on_naming">
		<h3>Naming</h3>
		<p>
			<var>C++</var> has a few naming rules we must follow: (1) Variables can
			contain letters, numbers, and underscores; (2) Variables must begin with a
			letter or underscore; (3) Cannot use reserved symbols; and (4) cannot
			<i>redeclare</i> a name in the same scope.
		</p>
	</section>
</section>

<section id="header_files">
	<p>
		<span class="topic">Enapsulation.</span> The idea of
		<b>eancapsulation</b> is that user defined types have two layers: (1) an
		<i>interface</i> and (2) an <i>implementation</i>. The interface is how the
		world accesses the type, and the implementation is how the type operates or
		works. These two layers are defined in separate files. For example, suppose
		we have a user-defined type called <var>cube</var>. The interface is kept in
		a file called <var>cube.h</var> (a <i>header file</i>), and the
		implementation in a file called <var>cube.cpp</var> (a <i>code file</i>).
	</p>

	<p>Inside <var>cube.h</var>, we have the following:</p>

	<pre class="language-cpp"><code>
		// The Cube.h file

		#pragma once

		class Cube {
			public: 
			// These are the functions we can use with this type
				double getVolume();
				double getSurfaceArea();
				double getSize();

			private:
			// This is the data stored by this type
				double side_;

		};
	</code></pre>

	<p>
		The line <var>#pragma once</var> tells the compiler that the following code
		should be used once during compilation. We include this line because our
		code might have a header file that relies on another header file that relies
		on another header file. This raises the danger of a possibly never-ending
		loop of searching for header files. <var>#pragma once</var> ensures that
		loop terminates. We call statements like <var>#pragma once</var>
		<b>include guards</b>.
	</p>

	<p>
		Because these materials assume some knowledge of object-oriented
		programming, we address <var>public</var> and <var>private</var> in brief.
		The symbols <var>public</var> and <var>private</var> operate the same way as
		they would in other OOP languages like Java &mdash; <var>public</var>,
		anyone and anything has access to the variable or method;
		<var>private</var>, the particular variable or method is accessible only to
		the class. In <var>C++</var>, if no access modifier is explicitly stated,
		the variable or method is <var>private</var> by default.
	</p>

	<p>
		With the functions and data above, we now need to actually define them in
		our <var>Cube.cpp</var> file:
	</p>

	<pre class="language-cpp"><code>
		// The Cube.cpp file

		#include "Cube.h"

		double Cube::getVolume() {

		}
	</code></pre>

	<p>
		The line <var>#include "Cube.h"</var> tells the compiler, "Find the file
		called <var>Cube.h</var>, and copy it to this file." This is because the
		compiler must know how the interface works to compile <var>Cube.cpp</var>.
		It can only do so if we insert <var>#include "Cube.h"</var> into the file.
		Notice how the code in the header file corresponds to the code in source
		code file:
	</p>

	<div class="compare">
		<pre class="language-cpp"><code>
			// The Cube.h file

			class Cube {
				public:
					double getVolume();
			}
		</code></pre>
		<pre class="language-cpp"><code>
			// The Cube.cpp file
			#include "Cube.h"

			double Cube::getVolume() {

			}
		</code></pre>
	</div>

	<p>
		Notice the <var>::</var>. This is called the
		<b>scope resolution operator</b>. This operator says, place
		<var>Cube</var> in front of <var>getVolume()</var>. Because
		<var>getVolume()</var> is a <i>member function</i> &mdash; i.e., a
		<b>method</b> &mdash; we must inform the compiler what class
		<var>getVolume()</var> belongs to. This is done with the scope resolution
		operator, <var>::</var>(two colons).
	</p>

	<p>
		Why do we have to tell the compiler which class this method belongs to?
		Because in <var>Cube.h</var>, we might have a function called
		<var>getVolume()</var> in other classes that are not <var>Cube</var>.
	</p>

	<div class="compare">
		<pre class="language-cpp"><code>
			// The Cube.h file

			class Cube {
				public:
					double getVolume();
			}
			
			class Sphere {
				public:
					double getVolum();
			}
		</code></pre>
		<pre class="language-cpp"><code>
			// The Cube.cpp file

			#include "Cube.h"

			double Cube::getVolume() {

			}

			double Sphere::getVolume() {

			}
		</code></pre>
	</div>

	<p>
		Let's write some <var>return</var> statements for
		<var>Cube::getVolume()</var> method.
	</p>

	<pre class="language-cpp"><code>
		#include "Cube.h"

		double Cube::getVolume() {
			return side_ * side_ * side_;
		}
	</code></pre>
</section>

<section id="overflow">
	<h2>Overflow</h2>
	<p>
		A value of type <var>char</var> takes 1 byte of memory. Consider the output
		for the following code:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		int main() {
			char x = 127;
			cout << (int)x << endl;
			x++;
			cout << (int)x << endl;
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		127
		-128
	</code></pre>
	<p>
		Strange. By incrementing <var>x</var> by 1, the value went from 127 to 128.
		This demonstrates the concept of <b>overflow</b>. A character can store only
		1 byte. This means a value of type <var>char</var> can only represent
		numeric values in the range ${[127, -128].}$ So what happens when we go
		beyond 127 or -128? We move to the beginning or the end of the range.
	</p>
	<p>
		We can think of this like a clock. We start at 0, then go up to 127. After
		127 is -128, then -127, then -126, all the way up to 0 and all way up to
		127. It's cyclical. But why is it cyclical?
	</p>
	<p>
		Because the numbers are represented as bits. The number 127 is represented
		as <var>01111111</var>. When we increment by 1, we get: <var>10000000</var>,
		<var>-128</var> in the decimal system. This is just binary addition. The
		first bit is the sign, 0 for positive, and 1 for negative.
	</p>
</section>

<section id="bitwise_operators">
	<h2>Bitwise Operators</h2>
	<p>
		The bitwise operators are interesting, but not often used operators in C++.
		They are operators that allow us to manipulate data at the bit-level, rather
		than one the entire value. The operators are the following:
	</p>
	<figure class="table">
		<table class="truth_table">
			<thead>
				<th>Operator</th>
				<th>Description</th>
			</thead>
			<tbody>
				<tr>
					<td><var>&</var></td>
					<td>
						Bitwise AND; given <var>bit1</var> and <var>bit2</var>,
						<var>bit1 & bit2</var> are 1 if, and only if, both bits are 1.
						Otherwise, <var>bit1 & bit2</var> are 0.
					</td>
				</tr>
				<tr>
					<td><var>|</var></td>
					<td>
						Bitwise OR; if either <var>bit1</var> or <var>bit2</var> is 1, then
						<var>bit1 | bit2</var> is 1.
					</td>
				</tr>
				<tr>
					<td><var>^</var></td>
					<td>
						Bitwise XOR; if <var>bit1</var> or <var>bit2</var> is 1, but not
						both <var>bit1</var> and <var>bit2</var> are 1, then
						<var>bit1 ^ bit2</var> is 1. If both <var>bit1</var> and
						<var>bit2</var> is 0, then <var>bit1 | bit2</var> is 1. If both
						<var>bit1</var> and <var>bit2</var> is 1, then
						<var>bit1 | bit2</var> is 0.
					</td>
				</tr>
				<tr>
					<td><var>~</var></td>
					<td>
						Bitwise NOT; if <var>bit1</var> is 1, then <var>~bit1</var> is 0,
						and vice versa.
					</td>
				</tr>
				<tr>
					<td><var>&lt;&lt;</var></td>
					<td>left shift</td>
				</tr>
				<tr>
					<td><var>&gt;&gt;</var></td>
					<td>right shift</td>
				</tr>
			</tbody>
		</table>
	</figure>
	<p>
		Here is an example using the bitwise operator
		<var>&</var>:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		int main() {
			int x = 1;
			int y = 2;
			int z = x & y;
			cout << z << endl;
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		0
	</code></pre>
	<p>Why is it 0? Because of the following:</p>
	<figure class="math-display">$$ 0 1 \\ 1 0 $$</figure>
	<p>
		The <var>&</var> operator will pair each bit in <var>x</var> with each bit
		in <var>y</var>. In this case, <var>1 & 0</var> and <var>0 & 1</var>. Now,
		recall the rule: <var>bit1 & bit2</var> are 1 if, and only if, both values
		are 1. Otherwise, <var>bit1 & bit2</var> are 0. Thus,
		<var>x & y</var> evaluates to <var>00</var>, the integer 0 in the decimal
		system.
	</p>
</section>

<section id="value_reference_semantics">
	<h2>Value v. Reference Semantics</h2>
	<p>
		In languages like <var>C++</var> and Java, when variables are passed as
		parameters, the values bound to those values are copied. For example:
	</p>
	<pre class="language-cpp"><code>
		void swap(int a, int b) {
			int temp = a;
			a = b;
			b = temp;
		}
		int main() {
			int x = 17;
			int y = 35; 
			cout << "x = " << x << ", y = " << y << endl;
			swap(x, y);
			cout << "x = " << x << ", y = " << y << endl;
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		x = 17, y = 35
		x = 17, y = 35
	</code></pre>
	<p>
		No swap occurs because we are passing
		<i>copies</i> of values into the variables. In other words, <var>x</var> and
		<var>y</var> always remain <var>17</var> and <var>35</var> respectively
		because only copies of those values were passed into the function. Any
		computation done in <var>swap()</var> was done on copies of those values, so
		there no effect on <var>x</var> and <var>y</var>, the originals.
	</p>
	<p>
		This phenomenon, called <i>pass-by-value</i>, is not the only behavior in
		<var>C++</var>. There is also <i>pass-by-reference</i>, which relies on
		<b>reference semantics</b>. Here is an example using reference semantics:
	</p>
	<pre class="language-cpp"><code>
		void swap(int& a, int& b) {
			int temp = a;
			a = b;
			b = temp;
		}
		int main() {
			int x = 17;
			int y = 35
			cout << "x = " << x << ", y = " << y << endl;
			swap(x, y);
			cout << "x = " << x << ", y = " << y << endl;
		}
	</code></pre>
	<pre class="language-bash"><code>
		x = 17, y = 35
		x = 35, y = 17
	</code></pre>
	<p>
		Notice the use of the ampersand, <var>&</var>. This tells
		<var>C++</var> that we want a <i>reference</i> to the value. Because we are
		using a reference rather than a copy, changes to the parameter
		<em>will</em> affect the variable passed in.<sup></sup>
	</p>
	<div class="note">
		<p>
			Passing by reference is usually best to avoid. With more reference values,
			it becomes more difficult to reason about code, and when that difficulty
			increases, the more difficult it is to debug. In some languages like Ruby,
			there are naming conventions in place to ensure reference or mutable
			values are physically visible. Although
			<var>C++</var> has no such conventions, it is recommended to follow some
			sort of convention denoting which variables employ reference semantics. Or
			better yet, avoid using reference semantics as much as possible. There are
			situations of course where referance semantics are necessary. I.e., very
			large objects (e.g., massive data structures), should likely be passed as
			references. There is a balance, but for run-of-the-mill code, we generally
			want to avoid passing by reference.
		</p>
	</div>
	<p>
		Another point for concern with reference values is when we use reference
		variables as parameters to functions. In <var>C++</var>, reference
		parameters can only take variables as arguments. In other words, we can
		never pass a literal to a reference parameter (after all, the whole point of
		reference semantics is to <i>refer</i> to something). Having said all these
		negatives, we should acknowledge the benefits of reference parameters: (1)
		We have a way of &#8220;returning&#8221; more than one value with functions,
		and (2) we have a way of avoiding making bulky copies of large objects when
		passing them as arguments.
	</p>
</section>

<section id="strings">
	<h2>Strings in <var>C++</var></h2>
	<p>
		In C++, there are two approaches to represent strings: (1) as an array of
		<var>char</var> values; or (2) as an instance of the class
		<var>string</var>. In C++, the second approach is preferred.<sup></sup>
	</p>
	<div class="note">
		<p>
			The first approach, representing strings as an array of character values,
			originates in the C language. It is how strings are represented in C, and
			because C++ is a superset of C, the same approach can be applied in C++.
		</p>
	</div>
</section>

<section id="character_arrays">
	<h3>Character Arrays</h3>
	<p>Applying the first approach:</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		void printString(char arr[], int n);
		int main() {
			char greet[] = "Hello world!";
			cout << greet << endl;
		
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		Hello world!
	</code></pre>
	<p>
		Notice the use of square bracket syntax to denote an array of
		<var>char</var>. An important point to notice about character arrays is
		their size. Recalling the fact that a <var>char</var> type takes 1 byte,
		consider this output:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		void printString(char arr[], int n);
		int main() {
			char greet[] = "Hello world!";
			int sizeOf_greet = sizeof(greet);
			cout << "size of greet = " << sizeOf_greet << " bytes" << endl;

			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		size of greet = 13 bytes
	</code></pre>
	<p>
		The array <var>greet</var> consists of 12 elements (there are 12 characters
		in &#8220;Hello world!&#8221;). Why are we seeing 13 bytes as the size of
		<var>greet</var>? Because every character array, denoted as a string, takes
		one extra byte, reserved for <var>\0</var>. This value, <var>\0</var>, is
		called the <b>null byte</b>, or more specifically, the
		<b>string delimiter</b>. It is the byte at the very end of the array, placed
		there to indicate the end of an array of characters, a string.<sup></sup>
	</p>
	<div class="note">
		<p>
			Note that not every character array is a string. The array
			<var>{'b', 'y', 'e'}</var> is a <var>char</var> array, but it is not a
			string. However, once we include the string delimiter, it is considered a
			string: <var>{'b', 'y', 'e', '\0'}</var>.
		</p>
	</div>
	<p>
		<span class="topic">Reading & Writing Character Arrays.</span> We can read
		and write <var>char</var> arrays with <var>cin</var> and <var>cout</var>.
		The catch, however, is that we must indicate the size of the character
		array. This can lead to wasted space, but we will address this problem
		later.
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		void printString(char arr[], int n);
		int main() {
			char name[20];
			cout << "What's your name?" << endl;
			cin >> name;
			cout << "Hello, " << name << "." << endl;
		
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		What's your name?
		Dorian
		Hello, Dorian.
	</code></pre>
	<p>
		The problem with the approach above, however, is that it will not read
		anything after a whitespace:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		void printString(char arr[], int n);
		int main() {
			char name[20];
			cout << "What's your name?" << endl;
			cin >> name;
			cout << "Hello, " << name << "." << endl;
		
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		What's your name?
		Dorian Gray
		Hello, Dorian.
	</code></pre>
	<p>To fix this, we need to use <var>cin.get</var>:</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		void printString(char arr[], int n);
		int main() {
			char name[20];
			cout << "What's your name?" << endl;
			cin.get(name, 20);
			cout << "Hello, " << name << "." << endl;
		
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		What's your name?
		Dorian Gray
		Hello, Dorian Gray.
	</code></pre>
	<p>
		Notice the syntax for <var>cin.get()</var>. We must pass into it the
		variable we want to store the input in, and the number of characters to be
		read. With <var>cin.get()</var>, if we pass in 20 for the number of
		characters, the number of characters to be read is actually 19, with 1 for
		the null byte.
	</p>
	<p>
		If we want multiple string inputs from the user, we use
		<var>cin.getline()</var>. This is a separate function for reading strings
		because <var>cin.get()</var> does not differentiate between different
		<var>enter</var> key inputs. If we do want to use <var>cin.get()</var>, we
		should separate the different <var>cin.get()</var> calls with a
		<var>cin.ignore()</var>. Of course, it is much easier to just use
		<var>cin.getline()</var> whenever we seek multiple inputs from the user.
	</p>

	<h3>Functions on Strings</h3>
	<p>
		C++ provides several string functions through
		<var>string.h</var>, a header file, or alternatively, through
		<var>cstring</var>. These are both libraries providing various operations we
		can perform on strings.
	</p>
	<p>
		<span class="topic">Finding a String's Length.</span> Without the
		aforementioned libraries, one way to find a string's length is with the
		<var>sizeof()</var> operator:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;
		
		int main() {
			char greet[] = "Foo bar baz bang";
			int sizeOfGreet = sizeof(greet) - 1;
			cout << "size of greet = " << sizeOfGreet << endl;
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		size of greet = 16
	</code></pre>
	<p>
		We subtract 1 because there is 1 extra element in the array, reserved for
		the null byte. Alternatively, we can simply use the
		<var>strlen()</var> method provided by <var>cstring</var>:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		#include &lt;cstring&gt;
		using namespace std;
		
		int main() {
			char greet[] = "Foo bar baz bang";
			int sizeOfGreet = strlen(greet);
			cout << "size of greet = " << sizeOfGreet << endl;
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		size of greet = 16
	</code></pre>
	<p>
		Notice the syntax for <var>strlen()</var>. We simply pass in the variable
		storing the string, or the string itself, we seek the length for.
	</p>
	<p>
		<span class="topic">Concatenating Strings.</span> When we
		<b>concatenate</b> two strings, we merge the strings together. We can
		concatenate strings with the <var>strcat()</var> method:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		#include &lt;cstring&gt;
		using namespace std;
		
		int main() {
			char foo[] = "John ";
			char bar[] = "Kim";
			strcat(foo, bar);
			cout << foo << endl;
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		John Kim
	</code></pre>
	<p>The syntax for <var>strcat()</var> is as follows:</p>
	<figure class="math-display">
		<ul class="syntax">
			<li>strcat(${destination}$, ${source}$)</li>
		</ul>
		<figcaption>
			where ${destination}$ is the string to be merged on to (here
			<var>foo</var>), and ${source}$ is the string to merge (here
			<var>bar</var>).
		</figcaption>
	</figure>
	<p>To understand how concatenation works, examine the array of characters:</p>
	<figure class="math-display">
		<div>
			<p><var>['J', 'o', 'h', 'n', ' ', '\0']</var></p>
			<p><var>['K', 'i', 'm', '\0']</var></p>
		</div>
	</figure>
	<p>
		When we concatenate <var>Kim</var> onto <var>John</var>, we take the first
		character of <var>Kim</var> &mdash; <var>K</var> &mdash; and use it to
		replace the null byte of <var>John</var>. If we want to concatenate only
		some characters in the source string, we use <var>strncat()</var>:
	</p>

	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		#include &lt;cstring&gt;
		using namespace std;
		
		int main() {
			char x[] = "Big ";
			char y[] = "Apple";
			strncat(x, y, 3);
			cout << x << endl;
		
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		Big App
	</code></pre>

	<p>
		<span class="topic">Copying Strings.</span> With the functions above, we
		mutated an existing string. What if we do not want to mutate an existing
		string? For that, we need the ability to copy strings. We can do so with
		<var>strcpy()</var>. The general syntax:
	</p>
	<figure class="math-display">
		<ul class="syntax">
			<li>strcpy(${destination}$, ${source}$)</li>
		</ul>
	</figure>
	<p>For example:</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		#include &lt;cstring&gt;
		using namespace std;
		
		int main() {
			char x[] = "Hello";
			int sizeOfx = sizeof(x);
			char z[sizeOfx];
			char y[] = " world!";
			strcpy(z, x);
			strcat(z, y);
			cout << "x: " << x << endl;
			cout << "z: " << z << endl;
		
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		x: Hello
		z: Hello world!
	</code></pre>
	<p>
		Notice that we did not mutate <var>x</var>. This is because we made a copy
		of the string stored in <var>x</var>, and stored that copy in <var>z</var>.
	</p>

	<p>
		<span class="topic">Substrings.</span> Another useful feature to have when
		working with strings is determining whether a given string is a
		<i>substring</i> of another string. For example, the string
		&#8220;corn&#8221; is a substring of the string &#8220;acorn.&#8221; We can
		make this determination with <var>strstr()</var>. The general syntax:
	</p>
	<figure class="math-display">
		<ul class="syntax">
			<li>strstr(${main}$, ${substring}$)</li>
		</ul>
	</figure>
	<p>
		In the syntax above, ${main}$ is the existing string, and ${substring}$ is
		the substring we want to check for. An example:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		#include &lt;cstring&gt;
		using namespace std;
		
		int main() {
			char x[] = "Apple pie";
			bool result = strstr(x, "Apple");
			cout << result << endl;
		
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		1
	</code></pre>
	<p>
		We get back <var>1</var>, indicating <var>"Apple"</var> is a substring of
		the string <var>"Apple pie"</var>. Remember that upper and lowercase
		characters are different. Checking for the substring <var>"apple"</var> will
		return <var>0</var>.
	</p>
	<p>
		If we want to find an instance of a <var>char</var>, we use
		<var>strchar()</var>. The general syntax:
	</p>
	<figure class="math-display">
		<ul class="syntax">
			<li>strchr(${string}$, ${char}$)</li>
		</ul>
	</figure>
	<p>
		The function <var>strchr()</var> will search for a given character starting
		from the left. If we want to find a given character from the right, we use
		<var>strrchar()</var>.
	</p>
	<p>
		<span class="topic">Comparing Strings.</span> In some languages, we can
		compare strings with the <var>&lt;</var> or <var>&gt;</var> operators. These
		operations output which of the given strings appears first in the alphabet.
		C++ provides a similar function, <var>strcmp()</var>.<sup></sup>
		The general syntax:
	</p>
	<div class="note">
		<p>&#8220;strcmp&#8221; is a clipping of &#8220;string compare.&#8221;</p>
	</div>
	<figure class="math-display">
		<div>
			<ul class="syntax">
				<li>strcmp(${s_1}$, ${s_2}$)</li>
			</ul>
		</div>
		<figcaption>
			Where ${s_1}$ and ${s_2}$ are the strings to be compared
		</figcaption>
	</figure>
	<p>For example:</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		#include &lt;cstring&gt;
		using namespace std;
		
		int main() {
			char apple[] = "apple";
			char kiwi[] = "kiwi";
			char peach[] = "peach";
		
			int result1 = strcmp(apple, kiwi);
			int result2 = strcmp(peach, apple);
			int result3 = strcmp(peach, peach);
		
			cout << "result1 = " << result1 << endl;
			cout << "result2 = " << result2 << endl;
			cout << "result3 = " << result3 << endl;
		
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		result1 = -10
		result2 = 15
		result3 = 0
	</code></pre>
	<p>
		Let's examine this output. First,
		<var>strcmp(${s_1}$, ${s_2}$)</var> returns either a negative, 0, or
		positive value. If ${s_1}$ comes before ${s_2}$ in the alphabet, the value
		returned is negative. If ${s_1}$ comes after ${s_2}$ in the alphabet, the
		value returns positive. Finally, if both ${s_1}$ and ${s_2}$ are the same,
		the value returned is 0.
	</p>
	<p>
		How does <var>strcmp()</var> work? It compares the ACII integer values of
		the first non-matching character. For example, with <var>apple</var> and
		<var>kiwi</var>, the first non-matching characters are <var>a</var> and
		<var>k</var>. The character <var>a</var> has an ASCII value of 97, and the
		character <var>k</var> has an ASCII value of <var>107</var>. Thus,
		<var>apple</var> is different from <var>kiwi</var> by -10 in terms in ASCII
		value.
	</p>
	<p>
		<span class="topic">String to Number.</span> Suppose we have the following
		strings:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		#include &lt;cstring&gt;
		using namespace std;
		
		int main() {
			char num1[] = "157";
			char num2[] = "2.49";
		
			return 0;
		}
	</code></pre>
	<p>
		Strings containing numbers are common in programming. So much so that C++
		provides functions for converting a string of numbers into a numeric type.
		These functions are <var>strtol()</var> and <var>strtof()</var>.<sup
		></sup> The function <var>strtolong()</var> will convert a number string
		into a <var>long int</var>, and <var>strtof()</var> will convert a number
		string into a <var>float</var>.
	</p>
	<div class="note">
		<p>
			<var>strtol()</var> is a clipping of &#8220;string to long&#8221; and
			<var>strtof()</var> is a clipping of &#8220;string to float.&#8221;
		</p>
	</div>

	<pre class="language-cpp"><code>
			#include &lt;iostream&gt;
			#include &lt;cstring&gt;
			#include &lt;typeinfo&gt;
			using namespace std;
			
			int main() {
				char num1[] = "157";
				char num2[] = "2.49";
				long int x = strtol(num1, NULL, 10);
				float y = strtof(num2, NULL);
			
				cout << typeid(num1).name() << " num1 : " << num1 << endl;
				cout << typeid(num2).name() << " num2 : " << num2 << endl;
				cout << typeid(x).name() << " x : " << x << endl;
				cout << typeid(y).name() << " y : " << y << endl;
			
				return 0;
			}
		</code></pre>
	<pre class="language-bash"><code>
			A4_c num1 : 157
			A5_c num2 : 2.49
			l x : 157
			f y : 2.49
		</code></pre>
	<p>
		Notice how the types have changed. The function
		<var>strtol()</var> takes three arguments: (1) the string we wish to
		convert; (2) <var>NULL</var>; and (3) the base for the relevant number
		system (e.g., 10 for the decimal systemm; 2 for the binary system; 16 for
		hexadecimalese; etc.). The <var>strtof()</var> function takes the same
		arguments, but without the need for a number system parameter.
	</p>

	<p><span class="topic">Tokenizing.</span> Consider the following string:</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		#include &lt;cstring&gt;
		using namespace std;
		
		int main() {
			char userInput[] = "Hello world";
		
			return 0;
		}
	</code></pre>

	<p>
		Can we separate the string <var>userInput</var> into the smaller strings
		<var>"Hello"</var> and <var>"world"</var>? Yes, we can. The process of
		breaking down a string into smaller pieces is called <b>tokenizing</b>. The
		term &#8220;tokenizing&#8221; comes from the fact that every string consists
		of discrete parts. For example, the string <var>"Hello world"</var> consists
		of the tokens <var>"Hello"</var> and <var>"world"</var>. Tokens are defined
		according to some common separator. For example, in
		<var>"Hello world"</var> the separator is a whitespace.
	</p>
	<p>
		To tokenize a string in C++, we use the
		<var>strtok()</var> function. The general syntax:
	</p>
	<figure class="math-display">
		<div>
			<ul class="syntax">
				<li>strtok(${s_1}$, "${d}$")</li>
			</ul>
		</div>
		<figcaption>
			where ${s_1}$ is the string to tokenize, and ${d}$ is the delimiter, or
			separator
		</figcaption>
	</figure>
	<p>
		For example, let's tokenize the string
		<var>userInput</var>:
	</p>

	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		#include &lt;cstring&gt;
		using namespace std;
		
		int main() {
			char userInput[] = "Hello world";
			char *substr = strtok(userInput, " ");
			cout << substr << endl;
		
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		Hello
	</code></pre>
	<p>
		We managed to extract <var>Hello</var>, but what about <var>world</var>?
		This is the expected behavior for <var>strtok()</var>. With only the
		arguments we passed into <var>strtok()</var>, C++ will only extract the
		first token. To extract all the tokens, we will need to run
		<var>strtok()</var> repeatedly. In other words, we must use a loop. Let's
		use a while loop, and store the respective tokens into a string array:
	</p>

	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		#include &lt;cstring&gt;
		using namespace std;
		
		void printStringArray(char *arr[], int n);
		
		int main() {
			char str[] = "Hello world";
			char *token = strtok(str, " ");
			char *tokenArr[2];
			int i = 0;
			while (token != NULL) {
				tokenArr[i] = token;
				token = strtok(NULL, " ");
				i++;
			}
		
			printStringArray(tokenArr, 2);
			// we can then index into the array
			cout << tokenArr[0] << endl;
			cout << tokenArr[1] << endl;
		
			return 0;
		}
		
		void printStringArray(char *arr[], int n) {
			cout << "[ ";
			for (int i = 0; i < n; i++) {
				cout << arr[i] << "  ";
			}
			cout << "]" << endl;
		}
	</code></pre>
	<pre class="language-bash"><code>
		[ Hello  world ]
		Hello
		world
	</code></pre>
</section>

<section id="string_class">
	<h3>String Class</h3>
	<p>
		As we saw, in <var>C++</var>, strings are not a primitive type in C++. We
		have to either use a <var>char</var> array &mdash; the historic and
		traditional way of creating strings &mdash; or, we can use the class
		<var>String</var>. The <var>String</var> class is defined in a separate
		header file, <var>string.h</var>. When using the <var>String</var> class to
		create a string, we are creating a <i>string object</i>. These differences
		are made more apparent after a discussion on classes.
	</p>
	<p>
		To use the <var>String</var> class, we must include the
		<var>String</var> library:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		#include &lt;string&gt;
		using namespace std;
		
		int main() {
			string greet = "Good morning";
			cout << greet << endl;
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		Good morning
	</code></pre>
	<p>
		Notice that unlike the <var>char</var> array method, we simply used the word
		<var>string</var>. The advantage to using the <var>String</var> class is
		that it cuts down on the amount of code we have to write, and we don't have
		worry so much about arrays. The underlying mechanism behind
		<var>string</var>, however, is the same. We are still creating an array of
		<var>char</var>, with a null byte at the end. The <var>string</var> class
		simply abstracts away the implementation.
	</p>
	<p>
		The one catch to a <var>string</var> object is that the
		<var>char</var> array allocated in memory isn't necessarily the length of
		the string plus 1 for the null byte:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		#include &lt;string&gt;
		using namespace std;
		
		int main() {
			char foo1[] = "foo";
			string foo2 = "foo";
			int foo1Size = sizeof(foo1);
			int foo2Size = sizeof(foo2);
			cout << "size of foo1: " << foo1Size << endl;
			cout << "size of foo2: " << foo2Size << endl;
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		size of foo1: 4
		size of foo2: 24
	</code></pre>
	<p>
		Notice the size difference between <var>foo1</var>, created with the
		traditional method, and <var>foo2</var>, created using the
		<var>string</var> class. <var>string</var> will allocate a larger array in
		memory for the string. This is to ensure that the <var>string</var> can grow
		as needed. We call this extra memory the string's <b>capacity</b>. C++
		implements this string capacity in response to the fact that it can get
		somewhat unwieldy concatenating strings with the traditional method.
	</p>
	<p>
		Again, strings in
		<var>C++</var> are a (potentially empty) sequence of characters. And as a
		sequence of characters, instances of <var>String</var> are indexed from
		<var>0</var> to ${n,}$ where ${n}$ is some positive integer. We can access
		the individual characters of a string using <var>[${i}$]</var> where ${i}$
		is some nonnegative integer, or with <var>at</var>. For example:
	</p>
	<pre class="language-cpp"><code>
		string foo = "hello";
		char c1 = s[0]; // "h"
		char c2 = s.at(1); // "e"
	</code></pre>
	<p>
		Characters in <var>C++</var> have <b>ASCII encodings</b>. These encodings
		effectively map each character to an integer. Thus, when we cast a character
		into an <var>int</var>, we will get back character's corresponding ASCII
		encoding.
	</p>
	<p>
		<span class="topic">Basic Operators.</span> We can concatenate strings in
		<var>C++</var> as we would most other languages:
	</p>
	<pre class="language-cpp"><code>
		string s1 = "Hello ";
		s1 += "World!" // "Hello world!"
	</code></pre>
	<p>
		We can also use the comparison operators on strings, as we did with
		<var>char</var> arrays. The comparison operators will compare the ASCII
		encodings of the strings. Thus, the character <var>a</var> is "less than"
		<var>b</var> becomes it has a smaller ASCII enscoding. Below are some other
		useful methods we can use with the <var>string</var> class:
	</p>
	<figure class="table">
		<table class="truth_table">
			<thead>
				<th>Member Function</th>
				<th>Description</th>
			</thead>
			<tbody>
				<tr>
					<td><var>${v}$.append(${s}$)</var></td>
					<td>add ${s}$ to end of ${v.}$</td>
				</tr>
				<tr>
					<td><var>${v}$.erase(${i, \ell}$)</var></td>
					<td>
						delete ${\ell}$ characters in ${v}$ starting from index ${i.}$
					</td>
				</tr>
				<tr>
					<td><var>${v}$.insert(${i, m}$)</var></td>
					<td>add text ${m}$ into string ${v}$ at index ${i.}$</td>
				</tr>
				<tr>
					<td><var>${v}$.length()</var></td>
					<td>return the number of characters in the string ${v}$</td>
				</tr>
				<tr>
					<td><var>${v}$.size()</var></td>
					<td>return the size of the string ${v}$</td>
				</tr>
				<tr>
					<td><var>${v}$.capacity()</var></td>
					<td>return the capacity of the string ${v}$</td>
				</tr>
				<tr>
					<td><var>${v}$.resize(${n}$, ${c}$)</var></td>
					<td>
						increases the length of the string ${v}$ by ${n}$ characters; pass
						the <var>char</var> parameter ${c}$, which will occupy the new
						spaces
					</td>
				</tr>
				<tr>
					<td><var>${v}$.max_size()</var></td>
					<td>
						returns the maximum size the string ${v}$ can grow to given current
						system limitations
					</td>
				</tr>
				<tr>
					<td><var>${v}$.clear()</var></td>
					<td>
						erase the contents of the string ${v}$; results in an empty string
					</td>
				</tr>
				<tr>
					<td><var>${v}$.empty()</var></td>
					<td>determines whether the string ${v}$ is the empty string</td>
				</tr>
				<tr>
					<td>
						<var>${v}$.replace(${i}$, ${n}$, "${s}$")</var>
					</td>
					<td>
						replaces the characters in ${i}$ up to ${i + (n - 1)}$ with the
						character ${s.}$ For example:
						<pre class="language-cpp"><code>
							#include &lt;iostream&gt;
							#include &lt;string&gt;
							using namespace std;
							
							int main() {
								string foo = "foo";
								cout << foo << endl;
								foo.replace(0, 1, "b");
								cout << foo << endl;
								return 0;
							}
						</code></pre>
						<pre class="language-bash"><code>
							foo
							boo
						</code></pre>
					</td>
				</tr>
				<tr>
					<td><var>${v}$.push_back('${c}$')</var></td>
					<td>
						Given a string ${v}$ containing the character ${c,}$ pushes the
						character ${c}$ back by one space; the opposite operation is
						<var>.pop_back()</var>
					</td>
				</tr>
				<tr>
					<td><var>${v}$.swap(w)</var></td>
					<td>Given strings ${v}$ and ${w,}$ swap the strings.</td>
				</tr>
			</tbody>
		</table>
	</figure>
	<p>
		However, there are differences. Strings in
		<var>C++</var> are <em>mutable</em>. Additionally, there are
		<em>two</em> types of strings in <var>C++</var>.
	</p>
</section>
{% endblock %}
