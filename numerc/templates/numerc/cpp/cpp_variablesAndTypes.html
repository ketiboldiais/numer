{% extends '../layout.html' %} {% load static %} {% block content %}
<section id="variables_and_types">
	<h4>Variables &amp; Types</h4>
	<p>
		In a computer, data is stored inside a memory location. To use that data, we
		must reference that particular location. In very low-level languages, this
		is in fact the case. Now, these memory locations are fairly cryptic and
		difficult to read (e.g., in hex). Instead of referencing these memory
		locations, we can associate a
		<span class="italicsText">name</span> to that particular location, and
		reference that name instead. This is called a
		<span class="term">binding</span>.
	</p>

	<p>
		A <span class="term">variable</span> is a programming construct that allows
		us to associate a <span class="italicsText">value</span> with a
		<span class="italicsText">name</span>. In other words, it is an abstraction
		for the process described previously. Examples of variables in
		<span class="monoText">C++</span>:
	</p>

	<pre class="language-cpp"><code>
		int x; // value is undefined
		char grade = 'A';
		double pi = 3.14;
	</code></pre>

	<p>
		The value of <span class="monoText">x</span> above is
		<span class="monoText">undefined</span>, which is itself a value. It will
		display to the console some value, but it could be any value. All of the
		types above are <span class="term">primitive types</span> in
		<span class="monoText">C++</span>. There are several others:
	</p>

	<figure class="table">
		<table class="truth_table">
			<thead>
				<th>Data Type</th>
				<th>Size</th>
				<th>Represents</th>
			</thead>
			<tbody>
				<tr>
					<td>char</td>
					<td>${1}$ byte, ${\geq 8}$ bits</td>
					<td rowspan="4">character</td>
				</tr>
				<tr>
					<td>char16_t</td>
					<td>${\geq 16}$ bits</td>
				</tr>
				<tr>
					<td>char32_t</td>
					<td>${\geq 32}$ bits</td>
				</tr>
				<tr>
					<td>wchar_t</td>
					<td>largest available character set</td>
				</tr>
				<tr>
					<td>short</td>
					<td>${\geq 16}$ bits</td>
					<td rowspan="5">signed integer values</td>
				</tr>
				<tr>
					<td>short</td>
					<td>${\geq 16}$ bits</td>
				</tr>
				<tr>
					<td>int</td>
					<td>${\geq 16}$ bits</td>
				</tr>
				<tr>
					<td>long</td>
					<td>${\geq 32}$ bits</td>
				</tr>
				<tr>
					<td>long long</td>
					<td>${\geq 64}$ bits</td>
				</tr>
				<tr>
					<td>unsigned short</td>
					<td>${\geq 16}$ bits</td>
					<td rowspan="4">unsigned integer values</td>
				</tr>
				<tr>
					<td>unsigned</td>
					<td>${\geq 16}$ bits</td>
				</tr>
				<tr>
					<td>unsigned long</td>
					<td>${\geq 32}$ bits</td>
				</tr>
				<tr>
					<td>unsigned long long</td>
					<td>${\geq 64}$ bits</td>
				</tr>
				<tr>
					<td>float</td>
					<td>${\approx}$ ${7}$ decimal places</td>
					<td rowspan="3">non-integer reals</td>
				</tr>
				<tr>
					<td>double</td>
					<td>${\approx}$ ${15}$ decimal places</td>
				</tr>
				<tr>
					<td>long double</td>
					<td>${\approx}$ ${19}$ decimal places</td>
				</tr>
				<tr>
					<td>bool</td>
					<td>usually ${8}$ bits</td>
					<td>true; false</td>
				</tr>
			</tbody>
		</table>
	</figure>

	<p>
		What data type we use depends on the program we're writing and whether we're
		particularly concerned about memory use. If we attempt to assign too large
		of a value into a variable type that does not accomodate for that value's
		size, we will get an <span class="term">overflow</span>.
	</p>

	<p>
		<span class="topic"><span class="monoText">sizeof.</span></span> The
		<span class="monoText">sizeof()</span> operator returns the size, in bytes,
		of a type or variable. The operator is often used to determine size of
		arrays, structures, and objects. We address it here because it is
		particularly useful for variables, and will revisit it when we discuss
		arrays.
	</p>

	<p>
		<span class="monoText">C++</span> provides several ways to declare and
		initialize variables:
	</p>

	<pre class="language-cpp"><code>
		int foo; // declaration
		int baz = 17; // initialization
		int quo (43); // constructor initialization 
		int xyz {13}; // C++ list initialization
	</code></pre>

	<p>
		Note that if we declare a variable but do not initialize it, that variable
		will have some <span class="term">garbage value</span> stored, and we have
		no control over what that value is. As such, it is crucial that we
		initialize variables once declared.
		<span class="marginnote"
			>This is a stark contrast to other languages like Java, where there are
			default values for uninitialized variables. If you're coming from one of
			those languages, beware!</span
		>
	</p>

	<p>
		<span class="topic">Global v. Local Variables.</span> Variables declared
		inside the <span class="monoText">main()</span> function are said to be
		<span class="term">local variables</span>:
	</p>

	<pre class="language-cpp"><code>
		int zob {1};

		int main() {
			int fen {25};
			int jib {12};
		}
	</code></pre>

	<p>
		In the code above, <span class="monoText">fen</span> and
		<span class="monoText">jib</span> are local variables. We say they are local
		variables because their scope (visibility) is within the
		<span class="monoText">main()</span> function. Put differently, the
		variables <span class="monoText">fen</span> and
		<span class="monoText">gib</span> only exist inside the
		<span class="monoText">main()</span> function. Outside of the
		<span class="monoText">main()</span> function, they effectively do not
		exist.
	</p>

	<p>
		In contrast, the variable <span class="monoText">zob</span> is a
		<span class="term">global variable</span>. This means they are visible to
		everything in the program. Which in turn means they can be changed from
		anywhere and by anything in the program.
	</p>

	<p>
		<span class="topic">Naming Rules.</span>
		<span class="monoText">C++</span> has a few naming rules we must follow: (1)
		Variables can contain letters, numbers, and underscores; (2) Variables must
		begin with a letter or underscore; (3) Cannot use reserved symbols; and (4)
		cannot <span class="italicsText">redeclare</span> a name in the same scope.
	</p>

	<p>
		<span class="topic">Enapsulation.</span> The idea of
		<span class="term">eancapsulation</span> is that user defined types have two
		layers: (1) an <span class="italicsText">interface</span> and (2) an
		<span class="italicsText">implementation</span>. The interface is how the
		world accesses the type, and the implementation is how the type operates or
		works. These two layers are defined in separate files. For example, suppose
		we have a user-defined type called <span class="monoText">cube</span>. The
		interface is kept in a file called <span class="monoText">cube.h</span> (a
		<span class="italicsText">header file</span>), and the implementation in a
		file called <span class="monoText">cube.cpp</span> (a
		<span class="italicsText">code file</span>).
	</p>

	<p>Inside <span class="monoText">cube.h</span>, we have the following:</p>

	<pre class="language-cpp"><code>
		// The Cube.h file

		#pragma once

		class Cube {
			public: 
			// These are the functions we can use with this type
				double getVolume();
				double getSurfaceArea();
				double getSize();

			private:
			// This is the data stored by this type
				double side_;

		};
	</code></pre>

	<p>
		The line <span class="monoText">#pragma once</span> tells the compiler that
		the following code should be used once during compilation. We include this
		line because our code might have a header file that relies on another header
		file that relies on another header file. This raises the danger of a
		possibly never-ending loop of searching for header files.
		<span class="monoText">#pragma once</span> ensures that loop terminates. We
		call statements like <span class="monoText">#pragma once</span>
		<span class="term">include guards</span>.
	</p>

	<p>
		Because these materials assume some knowledge of object-oriented
		programming, we address <span class="monoText">public</span> and
		<span class="monoText">private</span> in brief. The symbols
		<span class="monoText">public</span> and
		<span class="monoText">private</span> operate the same way as they would in
		other OOP languages like Java &mdash; <span class="monoText">public</span>,
		anyone and anything has access to the variable or method;
		<span class="monoText">private</span>, the particular variable or method is
		accessible only to the class. In <span class="monoText">C++</span>, if no
		access modifier is explicitly stated, the variable or method is
		<span class="monoText">private</span> by default.
	</p>

	<p>
		With the functions and data above, we now need to actually define them in
		our <span class="monoText">Cube.cpp</span> file:
	</p>

	<pre class="language-cpp"><code>
		// The Cube.cpp file

		#include "Cube.h"

		double Cube::getVolume() {

		}
	</code></pre>

	<p>
		The line <span class="monoText">#include "Cube.h"</span> tells the compiler,
		"Find the file called <span class="monoText">Cube.h</span>, and copy it to
		this file." This is because the compiler must know how the interface works
		to compile <span class="monoText">Cube.cpp</span>. It can only do so if we
		insert <span class="monoText">#include "Cube.h"</span> into the file. Notice
		how the code in the header file corresponds to the code in source code file:
	</p>

	<div class="compare">
		<pre class="language-cpp"><code>
			// The Cube.h file

			class Cube {
				public:
					double getVolume();
			}
		</code></pre>
		<pre class="language-cpp"><code>
			// The Cube.cpp file
			#include "Cube.h"

			double Cube::getVolume() {

			}
		</code></pre>
	</div>

	<p>
		Notice the <span class="monoText">::</span>. This is called the
		<span class="term">scope resolution operator</span>. This operator says,
		place <span class="monoText">Cube</span> in front of
		<span class="monoText">getVolume()</span>. Because
		<span class="monoText">getVolume()</span> is a
		<span class="italicsText">member function</span> &mdash; i.e., a
		<span class="term">method</span> &mdash; we must inform the compiler what
		class <span class="monoText">getVolume()</span> belongs to. This is done
		with the scope resolution operator, <span class="monoText">::</span>(two
		colons).
	</p>

	<p>
		Why do we have to tell the compiler which class this method belongs to?
		Because in <span class="monoText">Cube.h</span>, we might have a function
		called <span class="monoText">getVolume()</span> in other classes that are
		not <span class="monoText">Cube</span>.
	</p>

	<div class="compare">
		<pre class="language-cpp"><code>
			// The Cube.h file

			class Cube {
				public:
					double getVolume();
			}
			
			class Sphere {
				public:
					double getVolum();
			}
		</code></pre>
		<pre class="language-cpp"><code>
			// The Cube.cpp file

			#include "Cube.h"

			double Cube::getVolume() {

			}

			double Sphere::getVolume() {

			}
		</code></pre>
	</div>

	<p>
		Let's write some <span class="monoText">return</span> statements for
		<span class="monoText">Cube::getVolume()</span> method.
	</p>

	<pre class="language-cpp"><code>
		#include "Cube.h"

		double Cube::getVolume() {
			return side_ * side_ * side_;
		}
	</code></pre>
</section>

<section id="value_reference_semantics">
	<h5>Value v. Reference Semantics</h5>
	<p>
		In languages like <span class="monoText">C++</span> and Java, when variables
		are passed as parameters, the values bound to those values are copied. For
		example:
	</p>
	<pre class="language-cpp"><code>
		void swap(int a, int b) {
			int temp = a;
			a = b;
			b = temp;
		}
		int main() {
			int x = 17;
			int y = 35; 
			cout << "x = " << x << ", y = " << y << endl;
			swap(x, y);
			cout << "x = " << x << ", y = " << y << endl;
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		x = 17, y = 35
		x = 17, y = 35
	</code></pre>
	<p>
		No swap occurs because we are passing
		<span class="italicsText">copies</span> of values into the variables. In
		other words, <span class="monoText">x</span> and
		<span class="monoText">y</span> always remain
		<span class="monoText">17</span> and
		<span class="monoText">35</span> respectively because only copies of those
		values were passed into the function. Any computation done in
		<span class="monoText">swap()</span> was done on copies of those values, so
		there no effect on <span class="monoText">x</span> and
		<span class="monoText">y</span>, the originals.
	</p>
	<p>
		This phenomenon, called <span class="italicsText">pass-by-value</span>, is
		not the only behavior in <span class="monoText">C++</span>. There is also
		<span class="italicsText">pass-by-reference</span>, which relies on
		<span class="term">reference semantics</span>. Here is an example using
		reference semantics:
	</p>
	<pre class="language-cpp"><code>
		void swap(int& a, int& b) {
			int temp = a;
			a = b;
			b = temp;
		}
		int main() {
			int x = 17;
			int y = 35
			cout << "x = " << x << ", y = " << y << endl;
			swap(x, y);
			cout << "x = " << x << ", y = " << y << endl;
		}
	</code></pre>
	<pre class="language-bash"><code>
		x = 17, y = 35
		x = 35, y = 17
	</code></pre>
	<p>
		Notice the use of the ampersand, <span class="monoText">&</span>. This tells
		<span class="monoText">C++</span> that we want a
		<span class="italicsText">reference</span> to the value. Because we are
		using a reference rather than a copy, changes to the parameter
		<span class="underlineText">will</span> affect the variable passed in.
		<span class="marginnote"
			>Passing by reference is usually best to avoid. With more reference
			values, it becomes more difficult to reason about code, and when that
			difficulty increases, the more difficult it is to debug. In some languages
			like Ruby, there are naming conventions in place to ensure reference or
			mutable values are physically visible. Although
			<span class="monoText">C++</span> has no such conventions, it is
			recommended to follow some sort of convention denoting which variables
			employ reference semantics. Or better yet, avoid using reference semantics
			as much as possible. There are situations of course where referance
			semantics are necessary. I.e., very large objects (e.g., massive data
			structures), should likely be passed as references. There is a balance,
			but for run-of-the-mill code, we generally want to avoid passing by
			reference.</span
		>
	</p>
	<p>
		Another point for concern with reference values is when we use reference
		variables as parameters to functions. In <span class="monoText">C++</span>,
		reference parameters can only take variables as arguments. In other words,
		we can never pass a literal to a reference parameter (after all, the whole
		point of reference semantics is to <span class="italicsText">refer</span> to
		something). Having said all these negatives, we should acknowledge the
		benefits of reference parameters: (1) We have a way of
		&#8220;returning&#8221; more than one value with functions, and (2) we have
		a way of avoiding making bulky copies of large objects when passing them as
		arguments.
	</p>
</section>

<section id="strings">
	<h4>Strings in <span class="monoText">C++</span></h4>
	<p>
		In <span class="monoText">C++</span>, strings are not a primitive type. We
		must include a system library:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;string&gt;
		...
		string foo = "hello";
	</code></pre>
	<p>
		Like Java and other languages, strings in
		<span class="monoText">C++</span> are a (potentially empty) sequence of
		characters. And as a sequence of characters, they are indexed from
		<span class="monoText">0</span> to ${n,}$ where ${n}$ is some positive
		integer. We can access the individual characters of a string using
		<span class="monoText">[${i}$]</span> where ${i}$ is some nonnegative
		integer, or with <span class="monoText">at</span>. For example:
	</p>
	<pre class="language-cpp"><code>
		string foo = "hello";
		char c1 = s[0]; // "h"
		char c2 = s.at(1); // "e"
	</code></pre>
	<p>
		Characters in <span class="monoText">C++</span> have
		<span class="term">ASCII encodings</span>. These encodings effectively map
		each character to an integer. Thus, when we cast a character into an
		<span class="monoText">int</span>, we will get back character's
		corresponding ASCII encoding.
	</p>
	<p>
		<span class="topic">Basic Operators.</span> We can
		<span class="term">concatenate</span> strings in
		<span class="monoText">C++</span> as we would most other languages:
	</p>
	<pre class="language-cpp"><code>
		string s1 = "Hello ";
		s1 += "World!" // "Hello world!"
	</code></pre>
	<p>
		One thing we can do with strings in <span class="monoText">C++</span> that
		we cannot do in other languages is use the comparison operators. The comparison operators will compare the ASCII encodings of the strings. Thus, the character <span class="monoText">a</span> is "less than" <span class="monoText">b</span> becomes it has a smaller ASCII enscoding.
	</p>
	<figure class="table">
		<table class="truth_table">
			<thead>
				<th>Member Function</th>
				<th>Description</th>
			</thead>
			<tbody>
				<tr>
					<td><span class="monoText">${v}$.append(${s}$)</span></td>
					<td>add ${s}$ to end of ${v.}$</td>
				</tr>
				<tr>
					<td><span class="monoText">${v}$.erase(${i, \ell}$)</span></td>
					<td>delete ${\ell}$ characters in ${v}$ starting from index ${i.}$</td>
				</tr>
				<tr>
					<td><span class="monoText">${v}$.insert(${i, m}$)</span></td>
					<td>add text ${m}$ into string ${v}$ at index ${i.}$</td>
				</tr>
				<tr>
					<td><span class="monoText">${v}$.length()</span></td>
					<td>return the number of characters in the string</td>
				</tr>
			</tbody>
		</table>
	</figure>
	<p>
		However, there are differences. Strings in
		<span class="monoText">C++</span> are
		<span class="underlineText">mutable</span>. Additionally, there are
		<span class="underlineText">two</span> types of strings in
		<span class="monoText">C++</span>.
	</p>
</section>
{% endblock %}
