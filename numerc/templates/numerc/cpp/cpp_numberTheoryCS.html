{% extends '../layout.html' %} {% load static %} {% block description %}
<meta
	name="description"
	content="Notes on number representation in CS: binary, hexadecimal, octal, decimal representation, and complements."
/>
{% endblock %} {% block title %}
<title>Number Theory for CS</title>
{% endblock %} {% block content %}
<h1>Algorithms from Number Theory</h1>
<section id="intro">
	<p>
		<span class="drop">N</span>umber theory will play a recurring role in our
		later investigations of data structures and algorithms. Accordingly, we
		present some recurring number theory related concepts in this section.
		Namely: Number representation, complementing, and issues related to prime
		numbers.
	</p>
</section>

<section id="number_representation">
	<h2>Number Representation</h2>
	<p>Consider this image:</p>
	<figure>
		<div>
			<p>${\huge 7}$</p>
		</div>
	</figure>
	<p>
		Our immediate response is to recognize this as the number
		&#8220;seven.&#8221; In reality, however, the image above is just a symbol
		for the number seven. In some alternate universe, the majority of the world
		could have used one of the following:
	</p>
	<figure>
		<div>
			$$ \huge \begin{matrix} \text{VII} & \text{ז} & \text{七} \\ \text{७} &
			\text{፯} & \text{৭} \\ \text{٧} & \text{౭} & \text{៧} \\ \text{๗} &
			\text{௭} & \text{൭} \end{matrix} $$
		</div>
		<figcaption>
			From top right to bottom left: Roman, Hebrew, Chinese, Devanagari,
			Amharic, Bengali, Arabic, Telugu, Khmer, Thai, Tamil, and Kannada
			numerals.
		</figcaption>
	</figure>
	<p>Or, it could have used tally marks, but here too there is variety:</p>
	<figure>
		<img
			src="{% static 'images/tallies.svg' %}"
			alt="tally system"
			loading="lazy"
			class="eighty-p"
		/>
		<figcaption>
			From top to bottom: The tally system often used in the Western world, the
			tally system used France, Brazil, and former French colonies, and the
			dot-dash tally, commonly used in forestry.
		</figcaption>
	</figure>
	<p>
		The number seven is a conception in the mind &mdash; a quantification of
		something we perceive in the real world. What that quantification is could
		be many things: Seven positions from a starting point, seven units from
		zero, seven apples, a lucky number, etc. Regardless, we use the symbol ${7}$
		to communicate this idea, and provide other symbols to refine the idea.
		${7~\text{cm},}$ ${7~\text{gallons},}$ ${7~\text{points},}$ ${i = 7,}$
		${+7,}$ ${-7,}$ ${\lvert 7 \rvert,}$ ${7x,}$ and so on.
	</p>
	<p>
		Question: How many symbols do we need to represent
		<span class="underlineText">any</span> number? There are infinitely many
		numbers, and clearly, we cannot have infinitely many symbols. Thus, we need
		a finite number of symbols that allows us to represent every conceivable
		number. For most of the world, that number is ${10:}$
	</p>
	<figure>
		<div>
			<p>${\huge 0~1~2~3~4~5~6~7~8~9}$</p>
		</div>
		<figcaption>The Hindu-Arabic numerals</figcaption>
	</figure>
	<p>
		Number systems that use ${10}$ symbols to represent all numbers are called
		<span class="term">decimal number systems</span>, or
		<span class="term">base-10 systems</span>. In the Western decimal number
		system, we need only ${10}$ symbols (called the
		<span class="term">Hindu-Arabic</span> numerals) to represent every
		conceivable number. The number of unique symbols used in a numbering system
		to represent a number in that system is called the
		<span class="term">base</span> or <span class="term">radix</span> of the
		numbering system. For Hindu-Arabic numerals, the radix is ${10.}$ For the
		ancient Mayans, the radix was ${20}$ (called a
		<span class="italicsText">vigesimal system</span>). For the Babylonians, the
		radix was ${60}$ (called a <span class="italicsText">base-60 system</span>).
	</p>
	<p>
		To understand how the base works, we'll consider the decimal system. First,
		we have enough symbols to represent the numbers zero through nine:
	</p>
	<figure>
		<div>
			<p>${\huge 0~1~2~3~4~5~6~7~8~9}$</p>
		</div>
	</figure>
	<p>
		The symbols above, however, hide a critical fact: They all have an infinite
		amount of &#8220;slots&#8221; or &#8220;places&#8221;, occupied by zero,
		immediately to the left:
	</p>
	<figure>
		<div>
			<p>
				$$ \large \begin{aligned} & \ldots 01 \\ & \ldots 02 \\ & \ldots 03 \\ &
				\ldots 04 \\ & \ldots 05 \\ & \ldots 06 \\ & \ldots 07 \\ & \ldots 08 \\
				& \ldots 09 \\ \end{aligned} $$
			</p>
		</div>
	</figure>
	<p>
		When we reach the number nine, we've run out of unique symbols. So to
		represent the number ten, we start again from the first symbol, and place
		the symbol to the zero immediately to the left, and continue:
	</p>
	<figure>
		<div>
			<p>
				$$ \begin{aligned} & \ldots 01 \\ & \ldots 02 \\ & \ldots 03 \\ & \ldots
				04 \\ & \ldots 05 \\ & \ldots 06 \\ & \ldots 07 \\ & \ldots 08 \\ &
				\ldots 09 \\ & \ldots 10 \\ & \ldots 11 \\ & \vdots \\ & \ldots 19
				\end{aligned} $$
			</p>
		</div>
	</figure>
	<p>Once we get to nineteen, we use the next symbol:</p>
	<figure>
		<div>
			<p>
				$$ \begin{aligned} & \ldots 10 \\ & \ldots 11 \\ & \ldots 12 \\ & \ldots
				13 \\ & \ldots 14 \\ & \ldots 15 \\ & \ldots 16 \\ & \ldots 17 \\ &
				\ldots 18 \\ & \ldots 19 \\ & \ldots 20 \end{aligned} $$
			</p>
		</div>
	</figure>
	<p>
		Because there are ten symbols, and for each of these ten we can assign one
		of the ten symbols immediately to its left, we have ${10 \times 10 = 10^2 =
		100}$ unique symbols. This allows us to represent numbers from zero (${0}$)
		to ninety-nine (${99}$).
	</p>
	<p>
		Once we get past ${99,}$ we introduce a third symbol immediately to the left
		of the second symbol, applying the same procedure: ${100.}$ Now we have ${10
		\times 10 \times 10 = 10^3 = 1000}$ unique symbols. This allows us to count
		from zero to nine hundred and ninety-nine (${999}$). Once we've reached
		${999,}$ the process continues, and we have ${10^4}$ unique symbols,
		${10^5}$ unique symbols, ${10^6}$ unique symbols,
		<span class="italicsText">ad infinitum</span>.
	</p>
	<p>
		So, we have a way to generate unique symbols. But using this approach, we
		have a problem: How do we ensure that someone seeing ${67}$ doesn't
		interpret it as ${6}$ and ${7?}$ This is accomplished by everyone agreeing
		to intrepret the second position as indicating how many times we've used up
		symbols for the first position. For example, in the case of ${67,}$ we
		interpet the ${6}$ as: "We've run through the symbols
		${0~1~2~3~4~5~6~7~8~9}$ six times in the first position." With the ${7}$
		included, the number ${67}$ translates to &#8220;Six of the ten symbols and
		seven of the symbols&#8221;:
	</p>
	<figure>
		<div>
			<p>${(6 \times 10) + 7}$</p>
		</div>
	</figure>
	<p>
		When we see ${816,}$ we think: &#8220;Eight of ten of the ten symbols, ten
		of the symbols, and six of the symbols:&#8221;
	</p>
	<figure>
		<div>
			<p>${(8 \times 10 \times 10) + (1 \times 10) + 6}$</p>
		</div>
	</figure>
	<p>This process continues over and over, embodying the following pattern:</p>
	<figure>
		<div>
			<p>
				${(s_i \times 10^k) \ldots (s_3 \times 10^3) + (s_2 \times 10^2) + (s_1
				\times 10^1) + s_0}$
			</p>
		</div>
	</figure>
	<p>
		where ${k}$ and ${s_i}$ are positive integers. Each of the terms above is
		called a place, and they are multiples of ten. For example, ${s_2 \times
		10^2}$ is the tenth's place, ${s_3 \times 10^3}$ is the hundredth's place,
		and so on. The term ${s_0}$ is often called the one's place, and it is
		mathematically denoted ${s_0 \times 10^0:}$
	</p>
	<figure>
		<div>
			<p>
				${(s_i \times 10^k) \ldots (s_3 \times 10^3) + (s_2 \times 10^2) + (s_1
				\times 10^1) + (s_0 \times 10^0)}$
			</p>
		</div>
	</figure>

	<section id="octal_numbers">
		<h3>Octal Number System</h3>
		<p>
			Although the decimal system allows us to write large numbers with fewer
			symbols, the more symbols we use, the more computations we must perform
			and the more likely we are to commit computational errors. Inversely, the
			fewer symbols we need, the less computations we must perform, and the less
			likely we are to commit computational errors. The tradeoff, however, is
			readability. With fewer digits, larger numbers are long and difficult to
			decipher. Nevertheless, some problems (as we'll later see) do not require
			humans to directly read the numbers, so we've gone ahead and used number
			systems with fewer symbols. One such system is the
			<span class="term">octal number system</span>.
		</p>
		<p>
			To understand the octal number system, it's worth mentioning a bit of its
			history. Before the French Revolution, most of Europe used a dizzying
			array of inconsistent measurement systems. As international trade
			increased, it grew costly to transact with so many different units. The
			French merchant would argue that he received less than the agreed upon
			amount, ${1}$
			<span class="italicsText">pied du roi</span> (the length of the King's
			foot, about ${32.48}$ cm), but the German merchant would argue he gave the
			correct amount, ${1}$ Fuß (possibly ${23.6}$ cm; there were competing
			values of Fuß).
		</p>
		<p>
			In 1799, the Académie des sciences, a learned society known for solving
			scientific and mathematical problems, tasked a panel of French scholars to
			remedy these problems.<label for="panel" class="margin-toggle"
				><sup></sup
			></label>
			<input type="checkbox" id="panel" class="margin-toggle sidenote-number" />
			<span class="marginnote"
				>Among the panelists were the mathematicians Joseph-Louis Lagrange,
				Pierre-Simon Laplace, and Nicolas de Condorcet.</span
			>
			Their solution: a decimal system of measurement relying on ten symbols,
			using prefixes like deci, centi, milli, deca, hecto, kilo, and several
			others. As we can guess, we know this system today as the
			<span class="italicsText">metric system</span>.
		</p>
		<p>
			Across the Channel, the English had their own system and its proponents.
			One such defender was the Scottish economist James Anderson. Weary of the
			costs of changing a centuries-old measurement system, Anderson advocated
			for an alternative more closely aligned with the English system. Instead
			of relying on ten symbols, Anderson's system relied on eight:
		</p>
		<figure>
			<div>
				<p>${\huge 0 ~ 1 ~ 2 ~ 3 ~ 4 ~ 5 ~ 6 ~ 7}$</p>
			</div>
		</figure>
		<p>
			Likely inspired by the Latin <span class="italicsText">octo</span>,
			meaning &#8220;eight&#8221; Anderson called his alternative the
			<span class="italicsText">octal system</span>.
		</p>
		<p>
			Knowing the basics of number systems, we see that in the octal number
			system, the radix is eight &mdash; a base-8 number system. And with eight
			symbols, we can represent the numbers zero through seven. Like what we saw
			with the decimal system, we run out of symbols once we reach ${7.}$ To
			represent the number eight, we add a new symbol to the left, and start the
			symbol to the right back at ${0:}$
		</p>
		<figure>
			<div>
				<p>${\huge 10}$</p>
			</div>
		</figure>
		<p>
			Thus, in the octal number system, the number eight is represented as
			${10.}$ Nine is ${11,}$ ten is ${12,}$ eleven is ${13,}$ and so on. Once
			we reach ${17,}$ the number fifteen, we increment the number to the right
			and start at zero on the left: The number sixteen is ${20.}$
		</p>
		<p>
			Similar to what we saw with the decimal system, going from right to left,
			the first position indicates the one's, and the second position indicates
			how many times we've gone through the first position. The third position
			indicates how many times we've gone through the second, the fourth the
			third, the third the fourth, and so on. The difference, however, is that
			instead of using a base of ten, we use a base of eight:
		</p>
		<figure>
			<div>
				<p>
					${(s_i \times 8^k) \ldots (s_3 \times 8^3) + (s_2 \times 8^2) + (s_1
					\times 8^1) + (s_0 \times 8^0)}$
				</p>
			</div>
		</figure>
		<p>Thus, the octal number ${117}$ is actually:</p>
		<figure>
			<div>
				<p>${(1 \times 8^2) + (1 \times 8^1) + (7 \times 8^0) = 79}$</p>
			</div>
		</figure>
		<p>
			Because octal numbers use the same symbols as the decimal numbers, we
			indicate them with subscripted brackets containing the base. For example,
			the octal number ${117}$ is formally written as:
		</p>
		<figure>
			<div>
				<p>${\Large 117_{[8]}}$</p>
			</div>
		</figure>
		<p>
			Alternatively (and in some computer languages), the number ${117}$ would
			be indicated as:
		</p>
		<figure>
			<div>
				<p>${\Large \texttt{0o117} }$</p>
			</div>
		</figure>
		<p>
			Following standard practice, we will use the former syntax in exposition,
			but the latter when referring to code.
		</p>
		<p>
			To convert quickly from decimal to octal, it's helpful to know the first
			ten powers of eight by heart:
		</p>
		<figure>
			<div>
				$$ \begin{aligned} &8^1 = 8 \\ &8^2 = 64 \\ &8^3 = 512 \\ &8^4 = 4096 \\
				&8^5 = 32~768 \\ &8^6 = 262~144 \\ &8^7 = 2~097~152 \\ &8^8 = 16~777~216
				\\ &8^9 = 134~217~728 \\ &8^{10} = 1~073~741~824 \end{aligned} $$
			</div>
		</figure>
	</section>
</section>

<section id="prime_numbers">
	<h2>Primality Tests</h2>
	<p>
		Suppose we're given a number ${n.}$ We want to answer the following
		question:
	</p>
	<figure>
		<div>
			<p>Is ${n}$ a prime number?</p>
		</div>
	</figure>
	<p>
		Recall the definition for a prime number. ${n}$ is a prime number only if it
		satisfies the following propositions:
	</p>
	<figure>
		<ol class="checklist">
			<li>${n}$ is a natural number,</li>
			<li>${n}$ is greater than ${1,}$ and</li>
			<li>${n}$ consists of only two divisors: ${n}$ and ${1.}$</li>
		</ol>
	</figure>
	<p>
		We denote the set of primes with the symbol ${\mathbb{P}.}$ The set below
		illustrates this, listing the first twenty-four prime numbers, with ellipses
		to indicate more:
	</p>
	<figure>
		<div>
			$$ \mathbb{P} = \left\{ \begin{matrix} 2 & 3 & 5 & 7 \\ 11 & 13 & 17 & 19
			\\ 23 & 29 & 31 & 37 \\ 41 & 43 & 47 & 53 \\ 59 & 61 & 67 & 71 \\ 73 & 79
			& 83 & 89 \\ \vdots & \vdots & \vdots & \vdots \end{matrix} \right\} $$
		</div>
	</figure>
	<p>
		Algorithms that determine whether a given number ${n}$ is a prime number are
		called <span class="term">primality tests</span>. These algorithms are
		immensely important in cryptography. Cryptography itself is what ensures
		sensitive data like passwords, text messages, emails, and credit card
		numbers stay secure as they are transmitted across networks.
	</p>
	<section id="brute_force_primality">
		<h3>Brute-force Primality Test</h3>
		<p>
			There are a variety of ways to implement a primality test, but we start
			with the simplest algorithm: a
			<span class="term">brute-force primality test</span>. This algorithm is
			part of a family of algorithms called
			<span class="term">brute-force algorithms</span>. These algorithms solve
			problems in the most simple, direct, or obvious way. For the prime number
			testing, the brute-force primality test is closely related to
			<span class="term">proof-by-exhaustion</span>, a method of proof in
			mathematics. We exhaust all of the possibilities before we exhaust
			ourselves (or more accurately, our machine's RAM).
		</p>
		<p>
			To implement the brute-force primality test, we study the mathematical
			definition:
		</p>
		<figure>
			<div class="rule">
				<p>
					If a natural number ${n}$ is prime, then ${n}$ is greater than ${1}$
					and is not divisible by any positive integer other than ${1}$ and
					${n.}$
				</p>
			</div>
		</figure>
		<p>
			When implementing algorithms based on mathematical definitions, it's
			helpful to read the definitions in all directions. In this case, let's
			read the definition in terms of its contrapositive:
		</p>
		<figure>
			<div class="rule">
				<p>
					If ${n}$ is less than or equal to ${1}$ or is divisible by a positive
					integer other than ${1}$ and ${n,}$ then ${n}$ is
					<span class="underlineText">not</span> prime.
				</p>
			</div>
		</figure>
		<p>
			The contrapositive essentially lays out the brute-force algorithm. The
			implementation is simple: Using a for-loop, we go through all of the
			integers from ${1}$ to ${n - 1,}$ verifying no number divides ${n}$
			without a remainder. If there is such a number, that would imply that
			${n}$ has a divisor other than ${1}$ and itself. This violates the last
			requirement above, and ${n}$ is not a prime number. Otherwise, ${n}$ is a
			prime number. Implementing in pseudocode:
		</p>
		<figure>
			<ol class="alg">
				<li>${f}$ brute_force_primality_test(int n):</li>
				<ol>
					<li>if (n < 2):</li>
					<ol>
						<li>return "n is not prime";</li>
					</ol>
					<li>else:</li>
					<ol>
						<li>for (int i = 2; i < n - 1; i++):</li>
						<ol>
							<li>if (n % i == 0):</li>
							<ol>
								<li>return "n is not prime";</li>
							</ol>
						</ol>
						<li>return "n is prime";</li>
					</ol>
				</ol>
			</ol>
		</figure>
		<p>
			With brute-force primality test, we must iterate through ${n - 1}$
			elements. As such, the running time function for this algorithm can be
			expressed as ${f(n) = n - 1.}$ Applying asymptotic analysis, the
			brute-force primality test, in the worst-case scenario, has a running time
			of order ${O(n).}$ This is linear time. Can we do better? Let's consider
			another algorithm.
		</p>
	</section>
	<section id="trial_division">
		<h3>Trial Division</h3>
		<p>
			The second primality test we investigate is
			<span class="term">trial division</span>. This algorithm relies on the
			same definition above, but the key insight lies in honing in on what
			constitutes a composite number &mdash; a number that is not prime.
		</p>
		<p>If ${n}$ is composite, then the following proposition is true:</p>
		<figure>
			<div class="rule">
				<p>${\Large n = a \cdot b}$</p>
				<ul class="def">
					<li class="where">${a, b \in \N,}$</li>
					<li>${a \geq 2,}$ and</li>
					<li>${b \leq n - 1}$</li>
				</ul>
			</div>
		</figure>
		<p>
			With the brute-force primality test, we attempted to find the divisor
			${a.}$ The index ${i}$ represents the divisor ${a,}$ and we iterated up to
			${n-1}$ checking to see if ${\dfrac{n}{a} = b.}$ Now, given any two
			numbers ${p}$ and ${q,}$ or in our case, ${a}$ and ${b,}$ one will be less
			than or equal to the other. This proposition originates in the
			<a
				href="{% url 'numerm:balg_realProperties'%}#inequalities"
				target="_blank"
				>Trichotomy and closure laws</a
			>
			in real analysis. Suppose ${a \leq b.}$ This is a perfectly reasonable
			assumption to start with; we don't lose any generality in doing so.
		</p>
		<p>
			So, what's next? This is where we get creative. We look at the facts we
			have so far and try to draw further facts. We assumed that ${a \leq b.}$
			And before that, we saw that the composite number ${n}$ has the form ${a
			\cdot b.}$ Our inequality looks like ${a \leq b,}$ so what if we tried
			getting it to look like ${n = a \cdot b?}$ To do so, we multiply ${a}$ to
			both sides:
		</p>
		<figure>
			<div>
				$$ \begin{aligned} a \cdot a &\leq a \cdot b \\ a^2 &\leq a \cdot b
				\end{aligned} $$
			</div>
		</figure>
		<p>
			That's an interesting result. If ${n = a \cdot b}$ and ${a \leq b,}$ we
			have:
		</p>
		<figure>
			<div>
				<p>${a^2 \leq n}$</p>
			</div>
		</figure>
		<p>Now if we took the square root of both sides:</p>
		<figure>
			<div>
				$$ \begin{aligned} \sqrt{a^2} &\leq \sqrt{n} \\ a &\leq \sqrt{n}
				\end{aligned} $$
			</div>
		</figure>
		<p>
			This is another big insight. If ${n = a \cdot b}$ and ${a \leq b,}$ then
			${a \leq \sqrt{n}.}$ Given that ${a}$ must be less than ${\sqrt{n,}}$ we
			don't have to search up to ${n - 1.}$ Instead, we only have to search up
			to ${\sqrt{n}.}$ The implementation is thus:
		</p>
		<figure>
			<ol class="alg">
				<li>${f}$ trial_division_primality(int n):</li>
				<ol>
					<li>if (n < 2): return "n is not prime";</li>
					<li>else:</li>
					<ol>
						<li>for (int i = 2; i < (sqrt(n)); i++):</li>
						<ol>
							<li>if n % i == 0:</li>
							<ol>
								<li>return "n is not prime";</li>
							</ol>
						</ol>
						<li>return "n is prime";</li>
					</ol>
				</ol>
			</ol>
		</figure>
		<p>
			With trial-division, the algorithm only takes ${\sqrt{n} - 1}$ operations
			to execute. Hence, this algorithm has a time complexity of
			${O(\sqrt{n}),}$ or ${O(n^{1/2}).}$ This is fractional power time, which
			is faster than linear time. Note that the time complexity for this
			algorithm may vary depending on how
			<span class="monoText">sqrt(n)</span> is implemented. To avoid these
			issues, we can instead establish the test condition as
			<span class="monoText">i*i < n</span> rather than
			<span class="monoText">i < sqrt(n)</span>:
		</p>
		<figure>
			<ol class="alg">
				<li>${f}$ trial_division_primality(int n):</li>
				<ol>
					<li>if (n < 2): return "n is not prime";</li>
					<li>else:</li>
					<ol>
						<li>for (int i = 2; i*i < n; i++):</li>
						<ol>
							<li>if n % i == 0:</li>
							<ol>
								<li>return "n is not prime";</li>
							</ol>
						</ol>
						<li>return "n is prime";</li>
					</ol>
				</ol>
			</ol>
		</figure>
	</section>

	<section id="prime_factorization">
		<h2>Prime Factorization</h2>
	</section>
</section>
{% endblock %}
