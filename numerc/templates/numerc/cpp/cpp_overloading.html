{% extends '../layout.html' %} {% load static %} {% block description %}
<meta
	name="description"
	content="What is overloading? An overview of operator overloading in C++."
/>
{% endblock %} {% block title %}
<title>Overloading</title>
{% endblock %} {% block content %}
<h1>Operator Overloading & Friends</h1>
<section id="prelude">
	<p>
		In mathematics, we often have symbols that can apply to different values.
		For example, ${1 + 2}$ and ${1.4 + 4.2}$ both mean addition, regardless of
		the fact that ${1,2 \in \Z^{+}}$ and ${1.4 + 4.2 \in \mathbb{Q}.}$ The
		values belong to different sets, but the ${+}$ works nevertheless.
		Mathematics could have gone a different route, using different symbols for
		addition, depending on which set the terms belonged to.
	</p>
	<p>
		Other symbols, however, can have different meanings depending on the terms
		used. For example, most people would recognize the ${\times}$ symbol in ${A
		\times B}$ as indicating multiplication. However, if ${A}$ and ${B}$ were
		vectors &mdash; an object with magnitude and direction &mdash; then the ${A
		\times B}$ is a cross product. This yields two very different computations:
		${A \times B = AB,}$ and ${A \times B = ||A|| \space ||B|| \sin \theta n.}$
	</p>
	<p>
		The same phenomon occurs in programming. The operators
		<span class="monoText">+</span>, <span class="monoText">-</span>,
		<span class="monoText">*</span>, and <span class="monoText">/</span> perform
		on both <span class="monoText">int</span> and
		<span class="monoText">double</span>.
	</p>
	<p>
		C++ allows us to extend this overloading by permitting us to define what a
		symbol like <span class="monoText">+</span> does in a given set of
		conditions. Maybe we want <span class="monoText">"tiger" + "lion"</span> to
		evaluate to <span class="monoText">"liger"</span>. This would be an example
		of we, the programmers, overloading an operator in C++. Let's consider an
		example.
	</p>
	<p>
		In mathematics, ${\sqrt{-1} = i.}$ We call ${i}$ the
		<span class="italicsText">imaginary unit</span>, which is defined by the
		property ${i^2 = -1.}$ Every real number can be written as a complex number
		of the form ${a + bi,}$ where ${a}$ is the real component and ${bi}$ is the
		complex component. For example, the real number ${4}$ can be written as ${4
		+ bi,}$ where ${b = 0.}$ Complex numbers can be added and subtracted,
		performing the computations on each part separately. For example, ${(4 + 3i)
		+ (2 + 8i) = 6 + 11i.}$
	</p>
	<p>Suppose we had the following class:</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		class ComplexNumber {
			private: 
				int real_component;
				int imaginary_component;
			public:
				ComplexNumber(int r = 0, int i = 0) {
					real_component = r;
					imaginary_component = i;
				}
		};
	</code></pre>
	<p>
		With the class above, we can create instances of
		<span class="monoText">ComplexNumber</span>. Next, let's include a method
		for adding complex numbers:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		class ComplexNumber {
			private: 
				int realPart;
				int imaginaryPart;
			public:
				ComplexNumber(int r = 0, int i = 0) {
					realPart = r;
					imaginaryPart = i;
				}
				ComplexNumber add(ComplexNumber val) {
					ComplexNumber temp;
					temp.realPart = realPart + val.realPart;
					temp.imaginaryPart = imaginaryPart + val.imaginaryPart;
					return temp;
				}
		};
	</code></pre>
	<p>Let's add a print method to the class and test:</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		class ComplexNumber {
			private: 
				int realPart;
				int imaginaryPart;
			public:
				ComplexNumber(int r = 0, int i = 0) {
					realPart = r;
					imaginaryPart = i;
				}
				ComplexNumber add(ComplexNumber val) {
					ComplexNumber temp;
					temp.realPart = realPart + val.realPart;
					temp.imaginaryPart = imaginaryPart + val.imaginaryPart;
					return temp;
				}
				void print() {
					std::cout << realPart << " + " << imaginaryPart << "i" << std::endl;
				}
		};
		
		int main() {
			ComplexNumber x = ComplexNumber(2, 3);
			ComplexNumber y = ComplexNumber(5, 8);
			ComplexNumber z = x.add(y);
			z.print();
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		7 + 11i
	</code></pre>
	<p>
		Although the code above works, it would be much more accurate if we could
		just use the <span class="monoText">+</span> symbol. This is where operator
		overloading comes in:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		class ComplexNumber {
			private: 
				int realPart;
				int imaginaryPart;
			public:
				ComplexNumber(int r = 0, int i = 0) {
					realPart = r;
					imaginaryPart = i;
				}
				ComplexNumber operator+(ComplexNumber val) {
					ComplexNumber temp;
					temp.realPart = realPart + val.realPart;
					temp.imaginaryPart = imaginaryPart + val.imaginaryPart;
					return temp;
				}
				void print() {
					std::cout << realPart << " + " << imaginaryPart << "i" << std::endl;
				}
		};
		
		int main() {
			ComplexNumber x = ComplexNumber(3, 8);
			ComplexNumber y = ComplexNumber(9, 5);
			ComplexNumber z = x + y;
			z.print();
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		12 + 13i
	</code></pre>
	<p>
		Notice the use of <span class="monoText">operator+</span>. This is the
		syntax for overloading operators in C++. C++ allows us to overload the
		following operators:
	</p>
	<figure class="table">
		<table class="mono">
			<tbody>
				<tr>
					<td>+</td>
					<td>-</td>
					<td>*</td>
					<td>/</td>
					<td>%</td>
					<td>^</td>
				</tr>
				<tr>
					<td>&</td>
					<td>|</td>
					<td>~</td>
					<td>!</td>
					<td>,</td>
					<td>=</td>
				</tr>
				<tr>
					<td><</td>
					<td>></td>
					<td><=</td>
					<td>>=</td>
					<td>++</td>
					<td>--</td>
				</tr>
				<tr>
					<td><<</td>
					<td>>></td>
					<td>==</td>
					<td>!=</td>
					<td>&&</td>
					<td>||</td>
				</tr>
				<tr>
					<td>+=</td>
					<td>-=</td>
					<td>/=</td>
					<td>%=</td>
					<td>^=</td>
					<td>&=</td>
				</tr>
				<tr>
					<td>|=</td>
					<td>*=</td>
					<td><<=</td>
					<td>>>=</td>
					<td>[]</td>
					<td>()</td>
				</tr>
				<tr>
					<td>_></td>
					<td>_>*</td>
					<td>new</td>
					<td>new[]</td>
					<td>delete</td>
					<td>delete[]</td>
				</tr>
			</tbody>
		</table>
	</figure>
	<p>
		The following operators <span class="underlineText">cannot</span> be
		overloaded:
	</p>
	<figure class="table">
		<table class="mono">
			<tbody>
				<tr>
					<td>::</td>
					<td>.*</td>
				</tr>
				<tr>
					<td>.</td>
					<td>?:</td>
				</tr>
			</tbody>
		</table>
	</figure>
</section>

<section id="friends">
	<h2>Friends</h2>
	<p>
		Recall that with classes, the class's properties and methods are
		<span class="monoText">private</span> by default. And if those properties
		and methods are private, they cannot be accessed outside the class.<label
			for="privateProperties"
			class="margin-toggle"
			><sup></sup
		></label>
		<input
			type="checkbox"
			id="privateProperties"
			class="margin-toggle sidenote-number"
		/>
		<span class="marginnote"
			><span class="italicsText">See</span>
			<a href="{% url 'numerc:cpp_oop'%}#classes"><em>Classes: The Class</em></a
			>.</span
		>
		To avoid complicating the subject, we omitted a detail: We can access those
		properties and methods outside the class with
		<span class="term">friends</span>. In this section, we'll focus on
		<span class="term">friend functions</span> &mdash; functions defined outside
		some class ${x,}$ but can access ${x}$'s private and protected data inside
		that class, provided our permission.
	</p>
	<p></p>
</section>
{% endblock %}
