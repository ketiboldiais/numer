{% extends '../layout.html' %} {% load static %} {% block description %}
<meta name="description" content="Dynamic arrays, sets, and sequences." />
{% endblock %} {% block title %}
<title>Dynamic Arrays</title>
{% endblock %} {% block content %}

<h1>Lists</h1>
<section id="intro">
	<p>
		<span class="drop">T</span>he first set of abstract data types we explore is
		the <span class="term">list</span>. Lists allow us to store ${n}$ things in
		a specific order. Those things could be strings, integers, floating point
		values, or even other abstract data type objects.
	</p>
	<p>
		The list data type consists of two subtypes: (a) the
		<span class="term">static list</span> and (b) the
		<span class="term">dynamic list</span>. The static list type is a sequence
		with a fixed size. I.e., the number of elements in the sequence does not
		change. The dynamic list type is a sequence with a dynamic size; the
		sequence can grow or shrink by inserting or removing elmeents in the
		sequence.
	</p>
</section>

<section id="static_lists">
	<h2>Static Lists</h2>
	<p>
		Focusing on just the static list, what are some operations we might want to
		include with the interface? Bearing in mind that the static list has a fixed
		size, we have several:
		<span class="monoText">.build(x)</span> operator, which creates the sequence
		<span class="monoText">x</span>;
		<span class="monoText">.length()</span> operator, which returns the length
		of the sequence; <span class="monoText">.iterSeq()</span> operator, which
		iterates through the elements in the sequence;
		<span class="monoText">.get(i)</span> operator, which returns the element at
		index <span class="monoText">i.</span> And a
		<span class="monoText">.set(i, x)</span> operator, which replaces the
		element at index <span class="monoText">i</span> with the element
		<span class="monoText">x</span>.
	</p>

	<section id="static_arrays">
		<p>
			<span class="topic">Static Arrays.</span>
			We can implement the static sequence described with a
			<span class="term">static array</span>. A static array is a data structure
			that occupies a contiguous and consecutive chunk of memory. In C++, the
			static array is implemented as such:
		</p>
		<pre class="language-cpp"><code>
			int main() {
				int A[5];
			}
		</code></pre>
		<p>
			The above creates an array of with a
			<span class="monoText">length</span> of 5. This array is created in the
			<span class="italicsText">stack</span>. In C, the static array's size is
			determined at compile time. However, in C++, the size can be determined at
			runtime with the following:
		</p>
		<pre class="language-cpp"><code>
			#include &lt;iostream&gt;

			int main() {
				int n;
				std::cin >> n;
				int A[n];
			}
		</code></pre>
		<p>
			We can access an element inside the static array with square bracket
			syntax. E.g., <span class="monoText">A[0]</span>.
		</p>
		<p>
			Because the static array is a consecutive block of memory, the operations
			<span class="monoText">.get(i)</span>,
			<span class="monoText">.set(i, x)</span>, and
			<span class="monoText">.length()</span> take ${O(1),}$ constant time, to
			execute.
		</p>
		<p>
			In contrast, <span class="monoText">.build(x)</span> and
			<span class="monoText">.iterSeq()</span> will take ${O(n),}$ linear time,
			to execute, since they require processing ${n}$ elements.
		</p>
		<p>
			Additionally, we might also want the operations:
			<span class="monoText">.getFirst()</span> for returning the first element
			in the sequence; <span class="monoText">.getLast()</span> for returning
			the last element in the sequence;
			<span class="monoText">.setFirst(x)</span> which replaces the first
			element in the sequence with the element <span class="monoText">x</span>;
			and <span class="monoText">.setLast(x)</span>, which replaces the last
			element in the sequence with the element <span class="monoText">x</span>.
		</p>
	</section>

	<section id="dynamic_arrays">
		<p>
			<span class="topic">Dynamic Arrays.</span> The alternative implementation
			of a static list is with a <span class="term">dynamic array</span>. In
			other words, an array created in the
			<span class="italicsText">heap</span>. In C++, the implementation appears
			as such:
		</p>
		<pre class="language-cpp"><code>
			int main() {
				int *p;
				p = new int[5];
				return 0;
			}
		</code></pre>
		<p>Alternatively, in C:</p>
		<pre class="language-c"><code>
			#include &lt;stdlib.h&gt;

			int main() {
				int *p;
				p = (int*)malloc(5 * sizeof(int));
				return 0;
			}
		</code></pre>
		<p>
			Note that whenever we work with the heap, we
			<span class="underlineText">must</span> deallocate the memory we requested
			once we're done using it. Otherwise, we're subject to memory leaks. In
			C++, this is done with the following:
		</p>
		<pre class="language-cpp"><code>
			int main() {
				int *p;
				p = new int[5];
				delete []p; // deallocation
			}
		</code></pre>
		<p>In C:</p>
		<pre class="language-c"><code>
			#include &lt;stdlib.h&gt;

			int main() {
				int *p;
				p = (int*)malloc(5 * sizeof(int));
				free(p); // deallocation
			}
		</code></pre>
		<p>
			Importantly, for both the static array and dynamic array, the array's size
			cannot be resized. Hence its representation of a
			<span class="italicsText">static list</span>. However, we will see shortly
			how a dynamic array can be used to implement a non-fixed size list, i.e.,
			a dynamic list.
		</p>
	</section>
</section>

<section id="dynamic_lists">
	<h2>Dynamic Lists</h2>
	<p>
		Now let's consider the dynamic sequence. For the dynamic sequence, we want
		all of the operations available to static sequences, a few more: (1)
		<span class="monoText">insertAt(i, x)</span>, which inserts at index
		<span class="monoText">i</span> the element <span class="monoText">x</span>;
		and (2) <span class="monoText">deleteAt(i)</span>, which removes the element
		at index <span class="monoText">i</span>. Both of these operations change
		the size of the sequence. In the case of
		<span class="monoText">.insertAt()</span>, we shift all of the elements
		after <span class="monoText">i</span> to the right by one. And for
		<span class="monoText">.deleteAt()</span>, we shift all the elements after
		<span class="monoText">i</span> to the left by one.
	</p>
	<p>
		We also want a few more operations pertaining to the sequence's endpoints:
		(1)
		<span class="monoText">insertFirst(x)</span>, which inserts at index ${i =
		0}$ the element <span class="monoText">x</span>;
		<span class="monoText">deleteFirst()</span> which removes the first element
		in the sequence; <span class="monoText">insertLast(x)</span> which inserts
		at the last index the element <span class="monoText">x</span>; and
		<span class="monoText">deleteLast()</span>, which deletes the last element
		in the sequence.
	</p>

	<section id="dynamic_lists_as_dynamic_arrays">
		<p>
			<span class="topic">Dynamic Arrays as Dynamic Lists.</span> Earlier, we
			mentioned that dynamic arrays have a fixed size. This is true, but we can
			use pointers to &#8220;increase&#8221; the list's size. We say
			&#8220;increase&#8221; because we aren't changing the array's size
			necessarily. Instead, we are merely changing which array a given pointer,
			identifying a list, points to. This change is done with the following
			code. First, we declare initialize a pointer with the value of some array
			created in the heap:
		</p>
		<pre class="language-cpp"><code>
			#include &lt;iostream&gt;

			int main() {
				int *p = new int[5];
				p[0] = 1, p[1] = 2, p[2] = 3, p[3] = 4, p[4] = 5; 
				return 0;
			}
		</code></pre>
		<p>Next, we create a new array of a larger size:</p>
		<pre class="language-cpp"><code>
			#include &lt;iostream&gt;

			int main() {
				int *p = new int[5];
				p[0] = 1, p[1] = 2, p[2] = 3, p[3] = 4, p[4] = 5; 
				int *q = new int[10];
				return 0;
			}
		</code></pre>
		<p>
			Next, we want to transfer all of the elements in the
			<span class="monoText">p</span> array to the
			<span class="monoText">q</span> array. We can do so with a for-loop:
		</p>
		<pre class="language-cpp"><code>
			#include &lt;iostream&gt;

			int main() {
				int *p = new int[5];
				p[0] = 1, p[1] = 2, p[2] = 3, p[3] = 4, p[4] = 5; 
				int *q = new int[10];
				for (int i = 0; i < 5; i++) {
					q[i] = p[i];
				}
				return 0;
			}
		</code></pre>
		<p>
			Now we want <span class="monoText">p</span> to point to the
			<span class="monoText">q</span> array. But, before doing so, we ought to
			deallocate the memory allocated for the
			<span class="monoText">p</span> array to avoid memory leaks.
		</p>
		<pre class="language-cpp"><code>
			#include &lt;iostream&gt;

			int main() {
				int *p = new int[5];
				p[0] = 1, p[1] = 2, p[2] = 3, p[3] = 4, p[4] = 5; 
				int *q = new int[10];
				for (int i = 0; i < 5; i++) {
					q[i] = p[i];
				}
				delete []p;
				return 0;
			}
		</code></pre>
		<p>
			Finally, we make <span class="monoText">p</span> point to the
			<span class="monoText">q</span> array:
		</p>
		<pre class="language-cpp"><code>
			#include &lt;iostream&gt;

			int main() {
				int *p = new int[5];
				p[0] = 1, p[1] = 2, p[2] = 3, p[3] = 4, p[4] = 5; 
				int *q = new int[10];
				for (int i = 0; i < 5; i++) {
					q[i] = p[i];
				}
				delete []p;
				p = q;
				return 0;
			}
		</code></pre>
		<p>
			And the very last step: We now have two pointers
			<span class="monoText">p</span> and <span class="monoText">q</span>,
			pointing to the same array. We do not need this feature, so we assign to
			<span class="monoText">q</span> the value
			<span class="monoText">NULL</span>:
		</p>
		<pre class="language-cpp"><code>
			#include &lt;iostream&gt;

			int main() {
				int *p = new int[5];
				p[0] = 1, p[1] = 2, p[2] = 3, p[3] = 4, p[4] = 5; 
				int *q = new int[10];
				for (int i = 0; i < 5; i++) {
					q[i] = p[i];
				}
				delete []p;
				p = q;
				q = NULL;
				return 0;
			}
		</code></pre>
	</section>

	<section id="linked_lists">
		<p>
			<span class="topic">Linked Lists.</span> We can implement the dynamic
			sequence type above with a <span class="term">linked list</span>. In a
			linked list, elements in the sequence are stored in
			<span class="italicsText">nodes</span>. Each node consists of: (1) the
			sequence element and (2) a pointer to the next node.
		</p>
		<p>
			With linked lists, there are two points of particular interest: the
			<span class="italicsText">head</span> of the linked list (the first node
			in the linked list) and the <span class="italicsText">tail</span> of the
			list (the last node in the linked list). Importantly, the tail consists of
			a node whose pointer points to nothing (i.e., a
			<span class="italicsText">null pointer</span>).
		</p>
	</section>
</section>

{% endblock %}
