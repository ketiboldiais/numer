{% extends '../layout.html' %} {% load static %} {% block description %}
<meta name="description" content="History of C++" />
{% endblock %} {% block title %}
<title>C++ Introduction</title>
{% endblock %} {% block content %}

<h1>Data Structures & Algorithms: C++</h1>
<section id="data_models">
	<p>
		<span class="drop">T</span>his volume explores data structures and
		algorithms, a core topic in computer science. In our investigation, our
		primary language of choice for implementation will be C++. Accordingly, as
		with the other volumes, the first few sections focus on syntax, idioms, and
		how key programming concepts are represented in the language.
	</p>
	<p>
		Importantly, the focus of this volume is not on learning C++, but on data
		structures and algorithms. As such, a fair amount of pseudocode is used for
		clarity. Usually, these pseudocode demonstrations will be implemented in
		C++. Occassionally, however, we will deviate and use a language other than
		C++ for implementation. For example, with simple and low level data
		structures and algorithms, C is often has easier and clearer
		implementations. For much more abstract approaches, Python is a better
		choice. For functional data structures and algorithms, we use either Racket,
		Scala, ML, or JavaScript. For everything else (the vast majority), we will
		use C++. Hence the &#8220;primary language of choice&#8221;.
	</p>
	<p>
		It may seem odd to use a myriad of languages, but the intent is not to make
		data structures and algorithms confusing or difficult. Instead, we use
		different languages because we want to use the right tool for the job. We
		also want to avoid mooring ourselves to a specific language. Data structures
		and algorithms appear everywhere in programming &mdash; not just C++.
		Moreover, the user can freely ignore the implementations. They are not the
		focus. Instead, the reader should hone in on the text, the mathematics, and
		the pseudocode demonstrations. That's the cake. The language-specific
		implementations are just icing.
	</p>
	<p>
		<span class="topic">Data Models.</span>
		To begin, we review some computer science fundamentals, but now with a more
		detailed view. The earlier volumes omitted several details, for the sake of
		expediency and keeping the exposition as simple as possible. Having grounded
		the most basic concepts, we now examine the same fundamentals with a
		magnifying glass.
	</p>
	<p>
		In programming, there are three tools we always use: (1) data models; (2)
		data structures; and (3) algorithms. These are the three ongoing themes in
		this volume.
	</p>
	<p>
		In all of the languages we've seen thus far, there are rules as to what we
		can and cannot do with particular pieces of data. These are called the
		language's
		<span class="term">syntax</span>. A language's syntax stems directly from
		the language's <span class="term">data model</span> &mdash; a set of rules,
		or a standard, dictating how data is organized, how they relate to one
		another, and how the data relates to the real-world entities. Every
		programming language has a data model, and data models vary across
		languages.
	</p>
	<p>
		Every data model answers two questions: (1) What values can a given object
		assume in the language? (2) What operations can be performed on a given
		object? The data model's answer to the first question embodies the
		<span class="term">static</span> aspect of the language. It tells us what
		values a particular object can have. This static aspect is called the
		language's <span class="term">type system</span>.
	</p>
	<p>
		The answer to the second question is embodies the
		<span class="term">dynamic</span> aspect of the language. It provides the
		ways in which we can change and create new values in the language.
	</p>
</section>
<section id="why_cpp">
	<h2 class="topic">Why C++?</h2>
	<p>
		C++ is one of the most popular languages at the moment. As a popular
		language, it has a large and active community. And with a large and active
		community, there's plenty of source code to examine and libraries to use.
	</p>

	<p>
		Moreover, C++ is a particularly relevant language. It used in implementing
		numerous applications, ranging from operating systems like Windows and Mac
		OS X, to database languages like MySQL, to consumer-facing services like
		Google, Amazon, PayPal, Facebook, and many more. C++ is built for systems
		programming, where high speed and efficiency is prioritized.
	</p>

	<p>
		Finally, C++ is well-suited to learning both lower-level and high-level
		abstractions, ranging from memory management to complex algorithms and data
		structures. This partly due to how powerful C++ is &mdash; it's a compiled,
		highly-scalable, procedural, and object-oriented language. It is also partly
		due to how large its community is. Numerous papers, blog posts, and other
		commentaries on algorithms and data structure analysis are done through a
		C++ lens. All that said, much of what's covered below can be done in other
		languages, so the focus in the following materials is not so much in
		learning C++ programming, but rather on the inter-relationships between
		<span class="italicsText">data structures</span> and
		<span class="italicsText">algorithms</span>.
	</p>
</section>
<section id="history">
	<h2 class="topic">Brief History of C++</h2>
	<p>
		The C++ languages traces its origins to another language, C. C is a very old
		language, developed in early 1970s by Dennis Ritchie at Bell Labs. C
		continues to be used today in embedded systems programming (in very rough
		terms, programming for machines like digital watches, washing machines,
		stoves, fridges, avionics, hybrid vehicles, HVAC systems, etc.).
	</p>

	<p>
		In 1979, computer scientist Bjarne Stroustrup invented C++, a programming
		language aimed at extending C to handle classes (.e., object-oriented
		programming). Of note, C++ is a different language from Objective-C, a
		language that extends C to the OOP sphere, but through a different approach.
		For example, Objective-C is premised on the message-passing approach to
		object instances (i.e., an object does not call a method, it sends a
		message), while C++ is premised on the
		<span class="monoText">Simula</span> approach (objects
		<span class="italicsText">call</span> methods).
	</p>

	<p>
		Therein lies the biggest differences between Objective-C and C++.
		Objective-C, created primarily by computer scientists Brad Cox and Tom Love
		in the early 1980s, was driven largely by the features of another language,
		<span class="monoText">Smalltalk</span>. C++, in contrast, was inspired in
		part by the features of <span class="monoText">Simula</span>, yet another
		language. Both <span class="monoText">Smalltalk</span> and
		<span class="monoText">Simula</span> took very different approaches to
		object-oriented programming.
	</p>

	<p>
		By 1989, C++ was released to the public by the C++ standards committee (a
		committee that continues to this day). Several standards have been released
		since the first commercial release: C++98 in 1998, C++03 in 2003, C++11 in
		2011, C++14 in 2014, C++17 in 2017, and C++20 in 2020. The most drastic
		changes made to the language were C++11, C++14, C++17, and C++20. Modern C++
		is based almost entirely on these standards, and they are the standards we
		will apply. We call all the standards before C++11
		<span class="term">classical C++</span>, and everything from C++11 onwards
		<span class="term">modern C++</span>. The changes are so drastic that Bjarne
		Stroustrup has described modern C++ as effectively an entirely new language.
	</p>
</section>

<section id="execution">
	<h2>Executing a Program</h2>
	<p>
		As mentioned, C++ is a compiled language. Our source code goes into a
		<span class="monoText">.cpp</span> file. To run the source code in that
		<span class="monoText">.cpp</span> file, we must compile the source code. On
		compilation, the <span class="monoText">.cpp</span> file is transformed into
		an <span class="term">object file</span>, with the extension
		<span class="monoText">.o</span> or <span class="monoText">.obj</span>. If
		our program requires multiple <span class="monoText">.cpp</span> files,
		those files are all compiled separately. This results in multiple object
		files, which must all be linked together for the program to execute. That
		linking is done by the <span class="term">linker</span>. We can think of the
		linker as gluing, or stitching all of the separate
		<span class="monoText">.o</span> files together.
	</p>
	<p>
		The denouement: an
		<span class="term">executable</span>. Of note, in contrast to Java programs
		&mdash; which compile to a <span class="monoText">.class</span> file &mdash;
		C++ objects and executables are
		<span class="term">platform-dependent</span>. This means that the files will
		not run on an operating system other than the operating system we compiled
		in.
		<span class="marginnote"
			>Those familiar with C might notice that the object files in C++ have the
			same <span class="monoText">.o</span> extension as the object files in C.
			This is no coincidence. C++ was created with the intent of being
			backwards-compatible with C.</span
		>
	</p>

	<p>
		Of note, there is no such thing as a &#8220;file&#8221; in C++. At the end
		of the day, C++ doesn't impose requirements on what files you must include.
		A file is purely a vessel for feeding code to the compiler. Unlike languages
		like Java, where there are file requirements, the onus is placed on the
		programmer to decide what files will be fed to the compiler. This is an
		important point to understand, because it implies that files have no meaning
		in C++. The extensions <span class="monoText">.cpp</span> and
		<span class="monoText">.h</span> are purely implemented conventions. If our
		file has the extension <span class="monoText">.cpp</span>, then C++, by
		default, will treat it as a C++ file. If it's
		<span class="monoText">.h</span>, a header file, and
		<span class="monoText">.c</span>, a C file. We can always override these
		defaults, or even create our own extensions. We might save source code to
		some file with a <span class="monoText">.math</span> extension, and instruct
		C++ to treat it as a <span class="monoText">C++</span> file. We bear that
		responsibility, not C++.
	</p>

	<p>
		All the programs that follow are executed via the command line. Suppose we
		have a program written in a file called
		<span class="monoText">main.cpp</span>, containing the following code:
	</p>

	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;

		int main() {
			std::cout << "Hello, world!" << std::endl;
			return 0
		}
	</code></pre>

	<p>
		The <span class="monoText">int</span> is a return type for
		<span class="monoText">main()</span>. By convention, we include a
		<span class="monoText">return 0</span> inside
		<span class="monoText">main()</span>. All of our program's primary source
		code &mdash; i.e., the source code that actually runs our program &mdash; is
		included in <span class="monoText">main()</span>. We can think of
		<span class="monoText">main()</span> as the master conductor for a massive
		orchestra. There are numerous different sections, musicians, and
		instruments, but there is one thing that keeps them all together and in
		sync.
	</p>

	<p>
		The <span class="monoText">#include &lt;iostream&gt;</span> is an
		<span class="italicsText">include statement</span>. It is more generally
		called a <span class="term">preprocessor</span>. In other languages like
		Python, it is referred to as an
		<span class="italicsText">import statement</span>. In other words, the
		<span class="monoText">#include</span> is a way of including source code in
		files other than the file containing <span class="monoText">main()</span>.
		Before C++ executes our program it &#8220;copies-and-pastes&#8221; the code
		inside <span class="monoText">&lt;iostream&gt;</span> into the file
		containing <span class="monoText">main()</span>. This is the preprocessing
		stage.
		<span class="marginnote"
			>Importantly, header files are
			<span class="underlineText">not</span> compiled or executed separately.
			They are &#8220;copied-and-pasted&#8221; into the relevant
			<span class="monoText">.cpp</span> file, and that
			<span class="monoText">.cpp</span> file is compiled.</span
		>
	</p>
	<p>
		In the code above, <span class="monoText">cout</span> and
		<span class="monoText">endl</span> objects come from the
		<span class="monoText">iostream</span>
		<span class="italicsText">header file</span>, a library. The
		<span class="monoText">std::</span> is called a
		<span class="italicsText">scope resolution</span>, and it tells the compiler
		that <span class="monoText">cout</span> and
		<span class="monoText">endl</span> are entities found in the
		<span class="monoText">iostream</span> header file. We can shorten the code
		above with a <span class="italicsText">namespace</span>:
	</p>

	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namspace std;

		int main() {
			cout << "Hello, world!" << endl;
			return 0
		}
	</code></pre>

	<p>
		The <span class="monoText">using namespace std</span> essentially tells the
		compiler that for all of the following code, keep in mind that we're using
		<span class="monoText">std</span>. Thus, when the compiler encounters
		<span class="monoText">cout</span> and <span class="monoText">endl</span>,
		it knows that these are entities from <span class="monoText">std</span>.
	</p>

	<p>
		To execute the code above, we open a terminal session in the directory
		containing <span class="monoText">main.cpp</span>, and execute the following
		line to compile:
	</p>

	<pre class="language-bash"><code>
		make main
	</code></pre>

	<p>
		Running the command above, we should see that there are now two files in the
		directory: <span class="monoText">a.out</span> and
		<span class="monoText">main.cpp</span>. To execute the source code in
		<span class="monoText">main.cpp</span>, we run:
	</p>

	<pre class="language-bash"><code>
		./main
		
		Hello, world!
	</code></pre>

	<p>
		For the rest of the source code examples following, we will omit these shell
		commands when displaying the output to the console. Note that whenever we
		make changes to a source code file, that source code must be compiled again
		to see the changes take effect.
	</p>

	<p>
		All code in a C++ program is written in the curly braces following
		<span class="monoText">main</span>:
	</p>

	<pre class="language-cpp"><code>
		int main() {
			// statements
			return 0;
		}
	</code></pre>

	<p>
		<span class="monoText">main()</span> is a function, and the brunt of our
		source code is placed inside the function
		<span class="monoText">main()</span> because
		<span class="monoText">main()</span> is what the operating system calls when
		it executes a C++ program. Given this role,
		<span class="monoText">main()</span> is called our program's
		<span class="term">entry point</span>. The
		<span class="monoText">int</span> prefacing
		<span class="monoText">main()</span> is the function's
		<span class="term">return type</span>, <span class="monoText">main</span> is
		the function's <span class="term">name</span>, the
		<span class="monoText">()</span> enclose the function's
		<span class="term">parameters</span>, and everything inside the curly braces
		<span class="monoText">{}</span> is the
		<span class="term">function body</span>. By convention, we will
		<span class="monoText">return 0</span> to indicate the program ran
		successfully. For example:
	</p>

	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;

		int main() {
			cout << "Hello, world!" << endl;
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		Hello, world!
	</code></pre>

	<p>Another example, gathering user input:</p>

	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;

		int main() {
			int user_num;
			std::cout << "Enter your favorite integer: ";
			std::cin >> user_num;
			std::cout << "Great choice!";
			
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		Enter your favorite number: 10
		Great choice!
	</code></pre>

	<p>
		Notice the differences between the code above. The symbol
		<span class="monoText">std</span> is called a
		<span class="italicsText">namespace</span>. We will explore what a namespace
		is in later sections. The symbol <span class="monoText">cout</span> is a
		method inside the namespace <span class="monoText">std</span>, and it allows
		us to output things to the console. Notice the direction of the
		<span class="italicsText">arrow-arrows</span> (formally called
		<span class="italicsText">chevrons</span>). The symbol
		<span class="monoText">cin</span> is also a method inside the namespace
		<span class="monoText">std</span>, and it allows us to collect user input
		via the console. Again note the direction of the arrow-arrows. In this case,
		we are storing the user's console input to a variable called
		<span class="monoText">user_num</span>.
	</p>

	<p>
		C++ is a compiled language. This separates it from languages like Python,
		which are interpreted. In very broad terms, a compiled language is one whose
		programs must be first entirely translated into machine code by a compiler
		before execution. An interpreted language, however, translates each
		statement into machine code and executes, one by one (these days, most
		interpreted languages translate source code into an intermediate format,
		called <span class="italicsText">byte code</span>). Examples of compiled
		languages include C++, C, <span class="monoText">Go</span>,
		<span class="monoText">Haskell</span>, and
		<span class="monoText">Rust</span>. Examples of interpreted languages
		include <span class="monoText">Python</span>,
		<span class="monoText">JavaScript</span>,
		<span class="monoText">Scheme</span>, <span class="monoText">Ruby</span>,
		etc. Some languages fall somewhere in the middle, like
		<span class="monoText">Java</span>, which first compiles source code to
		bytecode before compiling or interpreting to machine code.
	</p>

	<p>
		The supposed distinction between interpreted and compiled languages is not
		all that meaningful; what is more important is
		<span class="italicsText">how</span> the particular language is understood
		by the computer. The real benefit to languages like C++ is that it takes us
		very close to the metal &mdash; we have access to very low-level computing
		resources, such as direct control over computer memory. We could, of course,
		do the same using C, but it would be too cumbersome to create and handle
		large, complex data structures. Moreover, C++ is a superset of C.
	</p>

	<p>
		From these facts, all of our C++ source code must be
		<span class="italicsText">compiled</span> and
		<span class="italicsText">linked</span> before it
		<span class="italicsText">executes</span>. The processes of compiling and
		linking are collectively called <span class="term">building</span> &mdash;
		our code must first <span class="italicsText">build</span> before it is
		<span class="italicsText">executed</span>.
	</p>

	<p>
		We raise this point because the programs in the following sections are all
		compiled via the command line. Accordingly, we must always be sure we
		perform a <span class="term">clean build</span> with our C++ programs.
		Useful C++ programs tend to contain many
		<span class="monoText">.cpp</span> and
		<span class="monoText">.h</span> files. And when we compile a program, we
		are compiling just that program. Most IDEs either build cleanly by default
		or provide an option to clean before compiling. This is not the case with
		compiling via the terminal, and we must ensure that all of our files are
		compiled again before execution. We can do so either listing all of our
		relevant files when executing <span class="monoText">g++</span> separated by
		a space, or using some other shell command to ensure all the relevant files
		are included when executing <span class="monoText">g++</span>.
	</p>

	<!-- comments -->
	<p>
		<span class="topic">Comments.</span> Comments in C++ take the following
		form:
	</p>
	<pre class="language-cpp"><code>
		// This is a single line comment

		/* 
			* This is
			* a multiline
			* comment
		*/
	</code></pre>

	<!-- includes -->
	<p>
		<span class="topic"><span class="monoText">includes</span>.</span> We can
		utilize code written by other programmers by
		<span class="italicsText">including</span> a header file. There are two ways
		to do so:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		#include "console.h"
	</code></pre>
	<p>
		By convention, angle brackets are used for code from the C++ standard
		library. All other external code, use quotes.
	</p>

	<!-- Console output -->
	<p>
		<span class="topic">Console Output.</span> We will be using a console for
		many of the programs in the following discussions. The console provides a
		means of communicating information from a program to the user of the
		program. To output information to the console, we use the keyword
		<span class="monoText">cout</span>:
	</p>

	<pre class="language-cpp"><code>
		cout << "Hello, world" << endl;
	</code></pre>

	<p>
		We can think of the <span class="monoText">&lt;&lt;</span> operator as
		saying, Send <span class="monoText">"Hello, world!"</span> to the console.
		Those coming from other languages might ask, isn't the
		<span class="monoText">&lt;&lt;</span> a bit-shift operator? In C++, yes, it
		is also a bit-shift operator. <span class="monoText">&lt;&lt;</span> is an
		overloaded operators (and since operators are really just functions, an
		overload function). The keyword <span class="monoText">endl</span> ensures
		that the cursor in the console is placed on a new line. This allows multiple
		console outputs to display on different lines.
	</p>

	<p>
		Notice further the use of semicolons after each statement. Like
		<span class="monoText">Java</span> and C, C++ is a
		<span class="term">semicolon-delimited</span> language, meaning statements
		are indicated as complete with semicolons. Of course, not all all languages
		are semicolon-delimited, or delimited.
		<span class="monoText">Prolog</span> is a
		<span class="italicsText">full-stop delimited</span> language (periods mark
		the end of statements), and <span class="monoText">Python</span> depends
		only on tabbing.
	</p>
</section>

<section id="compiler_v_interpreter">
	<h2>Compiler v. Interpreter</h2>
	<p>
		Some programming languages are
		<span class="term">interpreted languages</span>, others are
		<span class="term">compiled languages</span>, and yet others are somewhere
		in the middle, a sort of hybrid. What is the difference between an
		interpreted language and a compiled language?
	</p>
	<p>
		The most obvious difference is that a compiled language employs a
		<span class="term">compiler</span>, while an interpreted language employs an
		<span class="term">interpreter</span>. Both interpreters and compilers are
		computer programs. The most common task for these programs is to check for
		errors. What errors a compiler or interpreter checks depends on its
		implementation. Some will only check for syntax issues. Others go a step
		further, and check for errors that would normally only be caught at runtime.
		Others will raise <span class="italicsText">warnings</span> &mdash; a
		potential error.
	</p>
	<p>
		The second task both programs perform is translating source code into
		machine code. That machine code consists of either (a)
		<span class="italicsText">constant data</span> or (b)
		<span class="italicsText">instructions</span>. Interpreted and compiled
		languages are necessarily non-machine code languages, and as such, the
		computer has no way of understanding them. Thus, the particular language's
		source code must be translated into machine code before they can be
		<span class="italicsText">executed</span>.
	</p>
	<p>
		It is the third task that distinguishes compilers from interpreters.
		Compilers <span class="underlineText">do not</span> handle execution. They
		perform the preliminary step of checking for errors before runtime is used.
		Interpreters, however, take on the task of error-checking, translation, and
		execution all at once.
	</p>
</section>
{% endblock %}
