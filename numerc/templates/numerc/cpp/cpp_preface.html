{% extends '../layout.html' %} {% load static %} {% block description %}
<meta name="description" content="History of C++" />
{% endblock %} {% block title %}
<title>C++ Introduction</title>
{% endblock %} {% block content %}

<h1>Data Structures & Algorithms: C and C++</h1>
<section id="why_cpp">
	<p>
		<span class="topic">Why C++?</span>
		C++ is one of the most popular languages at the moment. As a popular
		language, it has a large and active community. And with a large and active
		community, there's plenty of source code to examine and libraries to use.
	</p>

	<p>
		Moreover, C++ is a particularly relevant language. It used in implementing
		numerous applications, ranging from operating systems like Windows and Mac
		OS X, to database languages like MySQL, to consumer-facing services like
		Google, Amazon, PayPal, Facebook, and many more. C++ is built for systems
		programming, where high speed and efficiency is prioritized.
	</p>

	<p>
		Finally, C++ is well-suited to learning both lower-level and high-level
		abstractions, ranging from memory management to complex algorithms and data
		structures. This partly due to how powerful C++ is &mdash; it's a compiled,
		highly-scalable, procedural, and object-oriented language. It is also partly
		due to how large its community is. Numerous papers, blog posts, and other
		commentaries on algorithms and data structure analysis are done through a
		C++ lens. All that said, much of what's covered below can be done in other
		languages, so the focus in the following materials is not so much in
		learning C++ programming, but rather on the inter-relationships between
		<span class="italicsText">data structures</span> and
		<span class="italicsText">algorithms</span>.
	</p>

	<p>
		<span class="topic">Brief History of C++.</span>
		The C++ languages traces its origins to another language, C. C is a very old
		language, developed in early 1970s by Dennis Ritchie at Bell Labs. C
		continues to be used today in embedded systems programming (in very rough
		terms, programming for machines like digital watches, washing machines,
		stoves, fridges, avionics, hybrid vehicles, HVAC systems, etc.).
	</p>

	<p>
		In 1979, computer scientist Bjarne Stroustrup invented C++, a programming
		language aimed at extending C to handle classes (.e., object-oriented
		programming). Of note, C++ is a different language from Objective-C, a
		language that extends C to the OOP sphere, but through a different approach.
		For example, Objective-C is premised on the message-passing approach to
		object instances (i.e., an object does not call a method, it sends a
		message), while C++ is premised on the
		<span class="monoText">Simula</span> approach (objects
		<span class="italicsText">call</span> methods).
	</p>

	<p>
		Therein lies the biggest differences between Objective-C and C++.
		Objective-C, created primarily by computer scientists Brad Cox and Tom Love
		in the early 1980s, was driven largely by the features of another language,
		<span class="monoText">Smalltalk</span>. C++, in contrast, was inspired in
		part by the features of <span class="monoText">Simula</span>, yet another
		language. Both <span class="monoText">Smalltalk</span> and
		<span class="monoText">Simula</span> took very different approaches to
		object-oriented programming.
	</p>

	<p>
		By 1989, C++ was released to the public by the C++ standards committee (a
		committee that continues to this day). Several standards have been released
		since the first commercial release: C++98 in 1998, C++03 in 2003, C++11 in
		2011, C++14 in 2014, C++17 in 2017, and C++20 in 2020. The most drastic
		changes made to the language were C++11, C++14, C++17, and C++20. Modern C++
		is based almost entirely on these standards, and they are the standards we
		will apply. We call all the standards before C++11
		<span class="term">classical C++</span>, and everything from C++11 onwards
		<span class="term">modern C++</span>. The changes are so drastic that Bjarne
		Stroustrup has described modern C++ as effectively an entirely new language.
	</p>

	<p>
		<span class="topic">Compilation.</span> As mentioned, C++ is a compiled
		language. Our source code goes into a
		<span class="monoText">.cpp</span> file. To run the source code in that
		<span class="monoText">.cpp</span> file, we must compile the source code. On
		compilation, the <span class="monoText">.cpp</span> file is compiled into an
		<span class="term">object file</span>, with the extension
		<span class="monoText">.o</span>. Furthermore, if we have any linked
		libraries, those libraries are all linked to the
		<span class="monoText">.o</span> files. The end result of this entire
		process is an <span class="term">executable</span>. Of note, in contrast to
		Java programs &mdash; which compile to a
		<span class="monoText">.class</span> file &mdash; C++ objects and
		executables are <span class="term">platform-dependent</span>. This means
		that the files will not run on an operating system other than the operating
		system we compiled in.
		<span class="marginnote"
			>Those familiar with C might notice that the object files in C++ have the
			same <span class="monoText">.o</span> extension as the object files in C.
			This is no coincidence. C++ was created with the intent of being
			backwards-compatible with C.</span
		>
	</p>

	<p>
		<span class="topic">Executing a Program.</span> All the programs that follow
		are executed via the command line. Suppose we have a program written in a
		file called <span class="monoText">main.cpp</span>, containing the following
		code:
	</p>

	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;

		int main() {
			std::cout << "Hello, world!" << std::endl;
			return 0
		}
	</code></pre>

	<p>
		The <span class="monoText">int</span> is a return type for
		<span class="monoText">main()</span>. By convention, we include a
		<span class="monoText">return 0</span> inside
		<span class="monoText">main()</span>. All of our program's primary source
		code &mdash; i.e., the source code that actually runs our program &mdash; is
		included in <span class="monoText">main()</span>. We can think of
		<span class="monoText">main()</span> as the master conductor for a massive
		orchestra. There are numerous different sections, musicians, and
		instruments, but there is one thing that keeps them all together and in
		sync.
	</p>

	<p>
		The <span class="monoText">#include &lt;iostream&gt;</span> is an
		<span class="italicsText">include statement</span>. This is like an
		<span class="italicsText">import statement</span> in other languages. In
		other words, the <span class="monoText">#include</span> is a way of
		including source code in files other than the file containing
		<span class="monoText">main()</span>. In the code above,
		<span class="monoText">cout</span> and
		<span class="monoText">endl</span> objects come from the
		<span class="monoText">iostream</span>
		<span class="italicsText">header file</span>, a library. The
		<span class="monoText">std::</span> is called a
		<span class="italicsText">scope resolution</span>, and it tells the compiler
		that <span class="monoText">cout</span> and
		<span class="monoText">endl</span> are entities found in the
		<span class="monoText">iostream</span> header file. We can shorten the code
		above with a <span class="italicsText">namespace</span>:
	</p>

	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namspace std;

		int main() {
			cout << "Hello, world!" << endl;
			return 0
		}
	</code></pre>

	<p>
		The <span class="monoText">using namespace std</span> essentially tells the
		compiler that for all of the following code, keep in mind that we're using
		<span class="monoText">std</span>. Thus, when the compiler encounters <span class="monoText">cout</span> and <span class="monoText">endl</span>, it knows that these are entities from <span class="monoText">std</span>.
	</p>

	<p>
		To execute the code above, we open a terminal session in the directory
		containing <span class="monoText">main.cpp</span>, and execute the following
		line to compile:
	</p>

	<pre class="language-bash"><code>
		make main
	</code></pre>

	<p>
		Running the command above, we should see that there are now two files in the
		directory: <span class="monoText">a.out</span> and
		<span class="monoText">main.cpp</span>. To execute the source code in
		<span class="monoText">main.cpp</span>, we run:
	</p>

	<pre class="language-bash"><code>
		./main
		
		Hello, world!
	</code></pre>

	<p>
		For the rest of the source code examples following, we will omit these shell
		commands when displaying the output to the console. Note that whenever we
		make changes to a source code file, that source code must be compiled again
		to see the changes take effect.
	</p>

	<p>
		<span class="topic">Preliminaries.</span> For all the programs below, all
		code is written in the curly braces following
		<span class="monoText">main</span>:
	</p>

	<pre class="language-cpp"><code>
		using namespace std;
		int main() {
			// statements
			return 0;
		}
	</code></pre>

	<p>
		<span class="monoText">main()</span> is a function, and the brunt of our
		source code is placed inside the function
		<span class="monoText">main()</span> because
		<span class="monoText">main()</span> is what the operating system calls when
		it executes a C++ program. The <span class="monoText">int</span> prefacing
		<span class="monoText">main()</span> is the function's
		<span class="term">return type</span>, <span class="monoText">main</span> is
		the function's <span class="term">name</span>, the
		<span class="monoText">()</span> enclose the function's
		<span class="term">parameters</span>, and everything inside the curly braces
		<span class="monoText">{}</span> is the
		<span class="term">function body</span>. By convention, we will
		<span class="monoText">return 0</span> to indicate the program ran
		successfully. For example:
	</p>

	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;

		int main() {
			cout << "Hello, world!" << endl;
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		Hello, world!
	</code></pre>

	<p>Another example, gathering user input:</p>

	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;

		int main() {
			int user_num;
			std::cout << "Enter your favorite integer: ";
			std::cin >> user_num;
			std::cout << "Great choice!";
			
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		Enter your favorite number: 10
		Great choice!
	</code></pre>

	<p>
		Notice the differences between the code above. The symbol
		<span class="monoText">std</span> is called a
		<span class="italicsText">namespace</span>. We will explore what a namespace
		is in later sections. The symbol <span class="monoText">cout</span> is a
		method inside the namespace <span class="monoText">std</span>, and it allows
		us to output things to the console. Notice the direction of the
		<span class="italicsText">arrow-arrows</span> (formally called
		<span class="italicsText">chevrons</span>). The symbol
		<span class="monoText">cin</span> is also a method inside the namespace
		<span class="monoText">std</span>, and it allows us to collect user input
		via the console. Again note the direction of the arrow-arrows. In this case,
		we are storing the user's console input to a variable called
		<span class="monoText">user_num</span>.
	</p>

	<p>
		C++ is a compiled language. This separates it from languages like Python,
		which are interpreted. In very broad terms, a compiled language is one whose
		programs must be first entirely translated into machine code by a compiler
		before execution. An interpreted language, however, translates each
		statement into machine code and executes, one by one (these days, most
		interpreted languages translate source code into an intermediate format,
		called <span class="italicsText">byte code</span>). Examples of compiled
		languages include C++, C, <span class="monoText">Go</span>,
		<span class="monoText">Haskell</span>, and
		<span class="monoText">Rust</span>. Examples of interpreted languages
		include <span class="monoText">Python</span>,
		<span class="monoText">JavaScript</span>,
		<span class="monoText">Scheme</span>, <span class="monoText">Ruby</span>,
		etc. Some languages fall somewhere in the middle, like
		<span class="monoText">Java</span>, which first compiles source code to
		bytecode before compiling or interpreting to machine code.
	</p>

	<p>
		The supposed distinction between interpreted and compiled languages is not
		all that meaningful; what is more important is
		<span class="italicsText">how</span> the particular language is understood
		by the computer. The real benefit to languages like C++ is that it takes us
		very close to the metal &mdash; we have access to very low-level computing
		resources, such as direct control over computer memory. We could, of course,
		do the same using C, but it would be too cumbersome to create and handle
		large, complex data structures. Moreover, C++ is a superset of C.
	</p>

	<p>
		From these facts, all of our C++ source code must be
		<span class="italicsText">compiled</span> and
		<span class="italicsText">linked</span> before it
		<span class="italicsText">executes</span>. The processes of compiling and
		linking are collectively called <span class="term">building</span> &mdash;
		our code must first <span class="italicsText">build</span> before it is
		<span class="italicsText">executed</span>.
	</p>

	<p>
		We raise this point because the programs in the following sections are all
		compiled via the command line. Accordingly, we must always be sure we
		perform a <span class="term">clean build</span> with our C++ programs.
		Useful C++ programs tend to contain many
		<span class="monoText">.cpp</span> and
		<span class="monoText">.h</span> files. And when we compile a program, we
		are compiling just that program. Most IDEs either build cleanly by default
		or provide an option to clean before compiling. This is not the case with
		compiling via the terminal, and we must ensure that all of our files are
		compiled again before execution. We can do so either listing all of our
		relevant files when executing <span class="monoText">g++</span> separated by
		a space, or using some other shell command to ensure all the relevant files
		are included when executing <span class="monoText">g++</span>.
	</p>

	<!-- comments -->
	<p>
		<span class="topic">Comments.</span> Comments in C++ take the following
		form:
	</p>
	<pre class="language-cpp"><code>
		// This is a single line comment

		/* 
			* This is
			* a multiline
			* comment
		*/
	</code></pre>

	<!-- includes -->
	<p>
		<span class="topic"><span class="monoText">includes</span>.</span> We can
		utilize code written by other programmers by
		<span class="italicsText">including</span> a header file. There are two ways
		to do so:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		#include "console.h"
	</code></pre>
	<p>
		By convention, angle brackets are used for code from the C++ standard
		library. All other external code, use quotes.
	</p>

	<!-- Console output -->
	<p>
		<span class="topic">Console Output.</span> We will be using a console for
		many of the programs in the following discussions. The console provides a
		means of communicating information from a program to the user of the
		program. To output information to the console, we use the keyword
		<span class="monoText">cout</span>:
	</p>

	<pre class="language-cpp"><code>
		cout << "Hello, world" << endl;
	</code></pre>

	<p>
		We can think of the <span class="monoText">&lt;&lt;</span> operator as
		saying, Send <span class="monoText">"Hello, world!"</span> to the console.
		The keyword <span class="monoText">endl</span> ensures that the cursor in
		the console is placed on a new line. This allows multiple console outputs to
		display on different lines.
	</p>

	<p>
		Notice further the use of semicolons after each statement. Like
		<span class="monoText">Java</span> and C, C++ is a
		<span class="term">semicolon-delimited</span> language, meaning statements
		are indicated as complete with semicolons. Of course, not all all languages
		are semicolon-delimited, or delimited.
		<span class="monoText">Prolog</span> is a
		<span class="italicsText">full-stop delimited</span> language (periods mark
		the end of statements), and <span class="monoText">Python</span> depends
		only on tabbing.
	</p>
</section>

<section id="compiler_v_interpreter">
	<h2>Compiler v. Interpreter</h2>
	<p>
		Some programming languages are
		<span class="term">interpreted languages</span>, others are
		<span class="term">compiled languages</span>, and yet others are somewhere
		in the middle, a sort of hybrid. What is the difference between an
		interpreted language and a compiled language?
	</p>
	<p>
		The most obvious difference is that a compiled language employs a
		<span class="term">compiler</span>, while an interpreted language employs an
		<span class="term">interpreter</span>. Both interpreters and compilers are
		computer programs. The most common task for these programs is to check for
		errors. What errors a compiler or interpreter checks depends on its
		implementation. Some will only check for syntax issues. Others go a step
		further, and check for errors that would normally only be caught at runtime.
		Others will raise <span class="italicsText">warnings</span> &mdash; a
		potential error.
	</p>
	<p>
		The second task both programs perform is translating source code into
		machine code. Interpreted and compiled languages are necessarily non-machine
		code languages, and as such, the computer has no way of understanding them.
		Thus, the particular language's source code must be translated into machine
		code before they can be <span class="italicsText">executed</span>.
	</p>
	<p>
		It is the third task that distinguishes compilers from interpreters.
		Compilers <span class="underlineText">do not</span> handle execution. They
		perform the preliminary step of checking for errors before runtime is used.
		Interpreters, however, take on the task of error-checking, translation, and
		execution all at once.
	</p>
</section>
{% endblock %}
