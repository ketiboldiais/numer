{% extends '../layout.html' %} {% load static %} {% block content %}
<section id="introduction">
	<h2>Data Structures with <span class="monoText">C++</span></h2>
	<p>
		<span class="topic">Why <span class="monoText">C++</span>?</span>
		<span class="monoText">C++</span> is one of the most popular languages at
		the moment. As a popular language, it has a large and active community. And
		with a large and active community, there's plenty of source code to examine
		and libraries to use.
	</p>

	<p>
		Moreover, <span class="monoText">C++</span> is a particularly relevant
		language. It used in implementing numerous applications, ranging from
		operating systems like Windows and Mac OS X, to database languages like
		MySQL, to consumer-facing services like Google, Amazon, PayPal, Facebook,
		and many more.
	</p>

	<p>
		Finally, <span class="monoText">C++</span> is well-suited to learning both
		lower-level and high-level abstractions, ranging from memory management to
		complex algorithms and data structures. This partly due to how powerful
		<span class="monoText">C++</span> is &mdash; it's a compiled,
		highly-scalable, procedural, and object-oriented language. It is also partly
		due to how large its community is. Numerous papers, blog posts, and other
		commentaries on algorithms and data structure analysis are done through a
		<span class="monoText">C++</span> lens. All that said, much of what's
		covered below can be done in other languages, so the focus in the following
		materials is not so much in learning
		<span class="monoText">C++</span> programming, but rather on the
		inter-relationships between
		<span class="italicsText">data structures</span> and
		<span class="italicsText">algorithms</span>.
	</p>

	<p>
		<span class="topic"
			>Brief History of <span class="monoText">C++</span>.</span
		>
		The <span class="monoText">C++</span> languages traces its origins to
		another language, <span class="monoText">C</span>.
		<span class="monoText">C</span> is a very old language, developed in early
		1970s by Dennis Ritchie at Bell Labs. C continues to be used today in
		embedded systems programming (in very rough terms, programming for machines
		like digital watches, washing machines, stoves, fridges, avionics, hybrid
		vehicles, HVAC systems, etc.).
	</p>

	<p>
		In 1979, computer scientist Bjarne Stroustrup invented
		<span class="monoText">C++</span>, a programming language aimed at extending
		<span class="monoText">C</span> to handle classes (.e., object-oriented
		programming). Of note, <span class="monoText">C++</span> is a different
		language from <span class="monoText">Objective-C</span>, a language that
		extends <span class="monoText">C</span> to the OOP sphere, but through a
		different approach. For example,
		<span class="monoText">Objective-C</span> is premised on the message-passing
		approach to object instances (i.e., an object does not call a method, it
		sends a message), while <span class="monoText">C++</span> is premised on the
		<span class="monoText">Simula</span> approach (objects
		<span class="italicsText">call</span> methods).
	</p>

	<p>
		Therein lies the biggest differences between
		<span class="monoText">Objective-C</span> and
		<span class="monoText">C++</span>.
		<span class="monoText">Objective-C</span>, created primarily by computer
		scientists Brad Cox and Tom Love in the early 1980s, was driven largely by
		the features of another language, <span class="monoText">Smalltalk</span>.
		<span class="monoText">C++</span>, in contrast, was inspired in part by the
		features of <span class="monoText">Simula</span>, yet another language. Both
		<span class="monoText">Smalltalk</span> and
		<span class="monoText">Simula</span> took very different approaches to
		object-oriented programming.
	</p>

	<p>
		By 1989, <span class="monoText">C++</span> was released to the public by the
		<span class="monoText">C++</span> standards committee (a committee that
		continues to this day). Several standards have been released since the first
		commercial release: <span class="monoText">C++98</span> in 1998,
		<span class="monoText">C++03</span> in 2003,
		<span class="monoText">C++11</span> in 2011,
		<span class="monoText">C++14</span> in 2014,
		<span class="monoText">C++17</span> in 2017, and
		<span class="monoText">C++20</span> in 2020. The most drastic changes made
		to the language were <span class="monoText">C++11</span>,
		<span class="monoText">C++14</span>, <span class="monoText">C++17</span>,
		and <span class="monoText">C++20</span>. Modern
		<span class="monoText">C++</span> is based almost entirely on these
		standards, and they are the standards we will apply. We call all the
		standards before <span class="monoText">C++11</span>
		<span class="term">classical <span class="monoText">C++</span></span
		>, and everything from <span class="monoText">C++11</span> onwards
		<span class="term">modern <span class="monoText">C++</span></span
		>. The changes are so drastic that Bjarne Stroustrup has described modern
		<span class="monoText">C++</span> as effectively an entirely new language.
	</p>

	<p>
		<span class="topic">Executing a Program.</span> All the programs below are
		executed via the command line. Suppose we have a program written in a file
		called <span class="monoText">main.cpp</span>, containing the following
		code:
	</p>

	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;

		int main() {
			std::cout << "Hello, world!" << std::endl;
		}
	</code></pre>

	<p>
		To execute the code above, we open a terminal session in the directory
		containing <span class="monoText">main.cpp</span>, and execute the following
		line to compile:
	</p>

	<pre class="language-bash"><code>
		g++ -Wall -std=c++20 main.cpp
	</code></pre>

	<p>
		Running the command above, we should see that there are now two files in the
		directory: <span class="monoText">a.out</span> and
		<span class="monoText">main.cpp</span>. To execute the source code in
		<span class="monoText">main.cpp</span>, we run:
	</p>

	<pre class="language-bash"><code>
		./a.out
		
		Hello, world!
	</code></pre>

	<p>
		For the rest of the source code examples following, we will omit these shell
		commands when displaying the output to the console. Note that whenever we
		make changes to a source code file, that source code must be compiled again
		to see the changes take effect.
	</p>

	<p>
		<span class="topic">Preliminaries.</span> For all the programs below, all
		code is written in the curly braces following
		<span class="monoText">main</span>:
	</p>

	<pre class="language-cpp"><code>
		using namespace std;
		int main() {
			// statements
			return 0;
		}
	</code></pre>

	<p>
		<span class="monoText">main()</span> is a function, and the brunt of our
		source code is placed inside the function
		<span class="monoText">main()</span> because
		<span class="monoText">main()</span> is what the operating system calls when
		it executes a <span class="monoText">C++</span> program. The
		<span class="monoText">int</span> prefacing
		<span class="monoText">main()</span> is the function's
		<span class="term">return type</span>, <span class="monoText">main</span> is
		the function's <span class="term">name</span>, the
		<span class="monoText">()</span> enclose the function's
		<span class="term">parameters</span>, and everything inside the curly braces
		<span class="monoText">{}</span> is the
		<span class="term">function body</span>. By convention, we will
		<span class="monoText">return 0</span> to indicate the program ran
		successfully. For example:
	</p>

	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		using namespace std;

		int main() {
			cout << "Hello, world!" << endl;
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		Hello, world!
	</code></pre>

	<p>Another example, gathering user input:</p>

	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;

		int main() {
			int user_num;
			std::cout << "Enter your favorite integer: ";
			std::cin >> user_num;
			std::cout << "Great choice!";
			
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		Enter your favorite number: 10
		Great choice!
	</code></pre>

	<p>
		Notice the differences between the code above. The symbol
		<span class="monoText">std</span> is called a
		<span class="italicsText">namespace</span>. We will explore what a namespace
		is in later sections. The symbol <span class="monoText">cout</span> is a
		method inside the namespace <span class="monoText">std</span>, and it allows
		us to output things to the console. Notice the direction of the
		<span class="italicsText">arrow-arrows</span> (formally called
		<span class="italicsText">chevrons</span>). The symbol
		<span class="monoText">cin</span> is also a method inside the namespace
		<span class="monoText">std</span>, and it allows us to collect user input
		via the console. Again note the direction of the arrow-arrows. In this case,
		we are storing the user's console input to a variable called
		<span class="monoText">user_num</span>.
	</p>

	<p>
		<span class="monoText">C++</span> is a compiled language. This separates it
		from languages like Python, which are interpreted. In very broad terms, a
		compiled language is one whose programs must be first entirely translated
		into machine code by a compiler before execution. An interpreted language,
		however, translates each statement into machine code and executes, one by
		one (these days, most interpreted languages translate source code into an
		intermediate format, called <span class="italicsText">byte code</span>).
		Examples of compiled languages include <span class="monoText">C++</span>,
		<span class="monoText">C</span>, <span class="monoText">Go</span>,
		<span class="monoText">Haskell</span>, and
		<span class="monoText">Rust</span>. Examples of interpreted languages
		include <span class="monoText">Python</span>,
		<span class="monoText">JavaScript</span>,
		<span class="monoText">Scheme</span>, <span class="monoText">Ruby</span>,
		etc. Some languages fall somewhere in the middle, like
		<span class="monoText">Java</span>, which first compiles source code to
		bytecode before compiling or interpreting to machine code.
	</p>

	<p>
		The supposed distinction between interpreted and compiled languages is not
		all that meaningful; what is more important is
		<span class="italicsText">how</span> the particular language is understood
		by the computer. The real benefit to languages like
		<span class="monoText">C++</span> is that it takes us very close to the
		metal &mdash; we have access to very low-level computing resources, such as
		direct control over computer memory. We could, of course, do the same using
		<span class="monoText">C</span>, but it would be too cumbersome to create
		and handle large, complex data structures. Moreover,
		<span class="monoText">C++</span> is a superset of
		<span class="monoText">C</span>.
	</p>

	<p>
		From these facts, all of our <span class="monoText">C++</span> source code
		must be <span class="italicsText">compiled</span> and
		<span class="italicsText">linked</span> before it
		<span class="italicsText">executes</span>. The processes of compiling and
		linking are collectively called <span class="term">building</span> &mdash;
		our code must first <span class="italicsText">build</span> before it is
		<span class="italicsText">executed</span>.
	</p>

	<p>
		We raise this point because the programs in the following sections are all
		compiled via the command line. Accordingly, we must always be sure we
		perform a <span class="term">clean build</span> with our
		<span class="monoText">C++</span> programs. Useful
		<span class="monoText">C++</span> programs tend to contain many
		<span class="monoText">.cpp</span> and
		<span class="monoText">.h</span> files. And when we compile a program, we
		are compiling just that program. Most IDEs either build cleanly by default
		or provide an option to clean before compiling. This is not the case with
		compiling via the terminal, and we must ensure that all of our files are
		compiled again before execution. We can do so either listing all of our
		relevant files when executing <span class="monoText">g++</span> separated by
		a space, or using some other shell command to ensure all the relevant files
		are included when executing <span class="monoText">g++</span>.
	</p>

	<!-- comments -->
	<p>
		<span class="topic">Comments.</span> Comments in
		<span class="monoText">C++</span> take the following form:
	</p>
	<pre class="language-cpp"><code>
		// This is a single line comment

		/* 
			* This is
			* a multiline
			* comment
		*/
	</code></pre>

	<!-- includes -->
	<p>
		<span class="topic"><span class="monoText">includes</span>.</span> We can
		utilize code written by other programmers by
		<span class="italicsText">including</span> a header file. There are two ways
		to do so:
	</p>
	<pre class="language-cpp"><code>
		#include &lt;iostream&gt;
		#include "console.h"
	</code></pre>
	<p>
		By convention, angle brackets are used for code from the
		<span class="monoText">C++</span> standard library. All other external code,
		use quotes.
	</p>

	<!-- Console output -->
	<p>
		<span class="topic">Console Output.</span> We will be using a console for
		many of the programs in the following discussions. The console provides a
		means of communicating information from a program to the user of the
		program. To output information to the console, we use the keyword
		<span class="monoText">cout</span>:
	</p>

	<pre class="language-cpp"><code>
		cout << "Hello, world" << endl;
	</code></pre>

	<p>
		We can think of the <span class="monoText">&lt;&lt;</span> operator as
		saying, Send <span class="monoText">"Hello, world!"</span> to the console.
		The keyword <span class="monoText">endl</span> ensures that the cursor in
		the console is placed on a new line. This allows multiple console outputs to
		display on different lines.
	</p>

	<p>
		Notice further the use of semicolons after each statement. Like
		<span class="monoText">Java</span> and <span class="monoText">C</span>,
		<span class="monoText">C++</span> is a
		<span class="term">semicolon-delimited</span> language, meaning statements
		are indicated as complete with semicolons. Of course, not all all languages
		are semicolon-delimited, or delimited.
		<span class="monoText">Prolog</span> is a
		<span class="italicsText">full-stop delimited</span> language (periods mark
		the end of statements), and <span class="monoText">Python</span> depends
		only on tabbing.
	</p>
</section>
{% endblock %}
