{% extends '../layout.html' %} {% load static %} {% block description %}
<meta name="description" content="Functions in JavaScript" />
{% endblock %} {% block title %}
<title>JavaScript Functions</title>
{% endblock %} {% block content %}
<h1>JavaScript Functions</h1>
<section id="javascript_functions">
	<p>
		<span class="drop">A</span> <b>function</b>, at the most basic level,
		is a sequence of statements bundled together and given a name.
		Essentially, a reusable compound statement, or block of code.
		JavaScript <i>functions</i> are equivalent to what might be called
		<i>procedures</i> or <i>subroutines</i> in other programming languages.
		Once we define a function (and we only do so once), we can execute, or
		<b>call</b>, the function however many times we want. More generally,
		functions allow us to use pieces of code either later or under specific
		conditions. As we know, programs are typically executed top to bottom
		(but, we'll see later JavaScript appears to deviate from this norm).
		With functions, we can call blocks of code elsewhere in the program.
		The most general syntax:
	</p>
	<figure class="math-display">
		<ul class="syntax">
			<li>
				function ${f}$ (${p_0}$, ${\ldots}$, ${p_n}$) {${s_0 \ldots s_n}$}
			</li>
		</ul>
		<figcaption>
			where ${f}$ is the name of the function, ${p_0 \ldots p_n}$ are the
			parameters, and ${s}$ is a statement, or a block of statements, to
			execute
		</figcaption>
	</figure>
	<p>
		A function's
		<b>parameter</b> is a variable (scoped to the function) to be used in
		the function's body. That is to say, a placeholder name to be used by
		the function. By including a parameter, we can pass through
		<b>arguments</b>, or inputs, such as code or data, to be used as local
		variables in the function's body (i.e., the block of code to be
		executed). Parameters are optionalâ€”we can have functions that do not
		take any arguments. Examples:
	</p>
	<pre class="language-javascript">
		<code>
			/*
			Here is a simple function that executes a rudimentary calculation of velocity.
			*/
			function velocity(displacement, time) {
				console.log(displacement / time + " " + "m/s");
			}

			velocity(157, 5); // Call the function
		</code>
		<pre class="language-bash"><code>
			31.4 m/s
		</code></pre>
	</pre>
	<p>A few more:</p>
	<pre class="language-javascript"><code>
		function fahrenheitToCelsius(degrees) {
			return (5 / 9) * (degrees - 32);
		}
		
		function triangleArea(base, height) {
			return (base * height) / 2;
		}
		
		let roomTemperature = fahrenheitToCelsius(77);
		let triangleA = triangleArea(3, 3);
		
		console.log(roomTemperature);
		console.log(triangleA);
	</code></pre>
	<pre class="language-bash"><code>
		25
		4.5
	</code></pre>
	<p>A function without parameters:</p>
	<pre class="language-javascript">
		<code>
			/*
			Here is another function that rolls a die with 20 faces.
			*/
			function rollDice() {
				let roll = Math.floor(Math.random() * 20) + 1;
				console.log(`You rolled: ${roll}`);
			}
			rollDice();

			/*
			This outputs to the console a random number between 1 and 20. We add 1 because the random number could be 0, and we are assuming that the dice does not have a side with the number 0.
			*/
		</code>
	</pre>
	<p>
		A <b>parameter</b> is an <i>alias</i> used for the values, or code,
		that will be passed through to the function. An <b>argument</b> is the
		actual value or code passed through to the function. As an aside, what
		is the difference between a <i>function</i> and a <i>method</i>?
		Functions look similar to <i>methods</i>. In fact, methods are just one
		kind of function. The difference: a method is function limited to an
		object (a <b>receiver</b>). For example, the methods accompanying the
		math object only execute when called with its object.
	</p>

	<section id="default_parameters">
		<h3>Default Parameters</h3>
		<p>
			In many situations, we want to add default parameter values to a
			function.
		</p>
		<pre class="language-javascript">
			<code>
				// Suppose we have a rudimentary function for calculating a spring's tension: 
				function springTension(k, x) {
					return -k * x;
				}
				// In the function above, we want to make sure that the values passed in are numbers. 
				// Passing the number 3.4 and 6.9:
				// Test
				console.log(springTension(3.4, 6.9)); // Output: -23.46
	
				// But, if we leave a number out:
				console.log(springTension(1)); // Output: NaN
				// We get NaN because we did not pass a second argument in, so x is set to undefined.
	
				// One way to avoid this problem is to display in the console instructions:
				function springTension2(k, x) {
					if (typeof k === 'undefined' || typeof x === 'undefined') {
						console.log('2 numbers must be passed');
					} else {
						return -k * x;
					}
				};
				// Test:
				console.log(springTension2(3.4, 6.9)); // Output: -23.46
				console.log(springTension2(3)); // Output: 2 numbers must be passed
	
				// Another way to avoid this problem is to set a default value:
				function springTension3(k, x = 1) { // Notice that we set x = 1. This is the default value.
					return -k * x;
				};
				// Test: 
				console.log(springTension3(3.4, 6.9)); // Output: -23.46
				console.log(springTension3(3.4)); // Output: -3.4								
			</code>
		</pre>
	</section>

	<section id="javascript_return_statement">
		<h3>The Return Statement</h3>
		<p>
			The <var>return</var> statement is what allows us to store the output
			from a function, and pass it on to other functions. A
			<var>return</var> statement is interpreted by JavaScript as an end to
			the function's execution. Thus, once JavaScript reaches a
			<var>return</var> statement, code after that
			<var>return</var> statement (in the same code block) will not
			execute.
		</p>
		<pre class="language-javascript">
			<code>
			/*
			A function that verifies whether a password is at least 8 characters long, contains no spaces, and is not the same as the username. 
			*/
	
			function isPasswordValid(password, username) {
				if (password.length < 8) {
					return false;
				}
				if (password.includes(" ")) {
					return false;
				}
				if (password === username) {
					return false;
				}
				return true;
			}
			console.log(isPasswordValid("boogabooga", "eustice"));
			console.log(isPasswordValid("eustice", "eustice"));
			console.log(isPasswordValid("Cowardly Dog", "muriel"));							
			</code>
		</pre>
		<pre class="language-bash"><code>
			true
			false
			false
		</code></pre>
		<p>
			But, you can have multiple return statements in a function, as long
			as they are in separate code blocks.
		</p>
		<pre class="language-javascript">
			<code>
				// A function that checks whether a name starts with the letter "N"
				function isFirstLetterX(firstName) {
					if (firstName.toUpperCase()[0] === "X") {
						return true;
					} 
					
					else {
						return false;
					}
				}
				console.log(isFirstLetterX("norman"));
				console.log(isFirstLetterX("xeno"));
			</code>
		</pre>
		<pre class="language-bash"><code>
			false
			true
		</code></pre>
		<p>
			The functions above all return Boolean values. In computer science,
			we call these <b>predicate functions</b>. Because these functions
			return Boolean values, we can use them as conditions for conditional
			expressions:
		</p>
		<pre class="language-javascript"><code>
			function isDivisibleBy(n, y) {
				return n % y === 0;
			}
			function printMultiplesOf3Before(endpoint) {
				let multiplesArray = [];
				for (let i = 0; i < endpoint; i++) {
					if (isDivisibleBy(i, 3)) {
						multiplesArray.push(i);
					}
				}
				return multiplesArray;
			}
			let multiples = printMultiplesOf3Before(25);
			console.log(multiples);
		</code></pre>
		<pre class="language-bash"><code>
			[0, 3, 6, 9, 12, 15, 18, 21, 24]
		</code></pre>
	</section>
</section>

<section id="function_scope">
	<h2>Function Scope</h2>
	<p>
		Now that we've discussed functions, our understanding of JavaScript's
		basic syntax is essentially complete. The rest is detail and syntactic
		sugar. This also means that we can now proceed to discussing the lower
		level details of JavaScript. Before we do so, let's state the key
		points regarding scope.
	</p>

	<p>
		<span class="topic">Function Scope.</span> First, like most language,
		variables declared within a function's body are <i>scoped</i> to that
		function. For example:
	</p>
	<pre class="language-javascript"><code>
		function f(n) {
			let sum = 0;
			for (let i = 0; i < n; i++) {
				sum += i;
			}
			console.log(sum);
		}
		f(5);
		console.log(sum);
	</code></pre>
	<pre class="language-bash"><code>
		10
		Uncaught ReferenceError: sum is not defined
	</code></pre>
	<p>
		In the code above, <var>sum</var> is scoped to the function
		<var>f()</var>. We can access <var>sum</var> inside the body of
		<var>f()</var>, but we cannot access it outside the body of
		<var>f()</var>. This is called <b>function scope</b>.
	</p>
	<p>
		<span class="topic">Block Scope.</span> In addition to function scope,
		we have <b>block scope</b>. In JavaScript, we denote blocks with curly
		braces <var>{}</var>. Variables declared within the curly braces are
		scoped to within the curly braces. For example:
	</p>
	<pre class="language-javascript"><code>
		if (true) {
			let x = 1;
			console.log(x);
		}
		console.log(x);
	</code></pre>
	<pre class="language-bash"><code>
		1
		Uncaught ReferenceError: sum is not defined
	</code></pre>

	<p>
		Now, notice what happens when we use
		<var>var</var> instead:
	</p>
	<pre class="language-javascript"><code>
		if (true) {
			var x = 1;
			console.log(x);
		}
		console.log(x);
	</code></pre>
	<pre class="language-bash"><code>
		1
		1
	</code></pre>
	<p>
		With <var>var</var>, we can access <var>x</var> both inside
		<span class="underlineText">and</span> outside the block. Let's try
		<var>const</var>:
	</p>
	<pre class="language-javascript"><code>
		if (true) {
			const x = 1;
			console.log(x);
		}
		console.log(x);
	</code></pre>
	<pre class="language-bash"><code>
		1
		Uncaught ReferenceError: sum is not defined
	</code></pre>
	<p>
		So, from this experiment, we can see that
		<var>var</var> has different scoping rules than <var>const</var> and
		<var>let</var>. The keypoint here is that variables declared with
		<var>var</var> will only be scoped to functions. We can confirm this
		with another experiment:
	</p>
	<pre class="language-javascript"><code>
		function f() {
			var pi = 3.14;
			console.log(pi);
		}
		f();
		console.log(pi);
	</code></pre>
	<pre class="language-bash"><code>
		3.14
		app.js:6 Uncaught ReferenceError: pi is not defined
	</code></pre>
	<p>
		Thus, variables declared with <var>var</var> can be accessed outside
		the block they're declared in. But, if the variable declared with
		<var>var</var> is declared inside a function, it can only be accessed
		within that function.
	</p>

	<p>
		<span class="topic">Lexical Scope.</span> If a function ${g}$ is
		defined inside a function ${f,}$ the bindings in ${f}$ are accessible
		within ${g.}$ This is a natural consequence of function scope. Inside
		${g,}$ we are inside ${f.}$ For example:
	</p>
	<pre class="language-javascript"><code>
		function f() {
			var pi = 3.14;
			console.log(`${pi} inside f`);
			function g() {
				console.log(`${pi} inside g`)
			}
			g();
		}
		f();
		
	</code></pre>
	<pre class="language-bash"><code>
		3.14 inside f
		3.14 inside g
	</code></pre>
	<p>
		Note, however, that because <var>g()</var> is a binding inside
		<var>f()</var>, we cannot access <var>g()</var> outside of
		<var>f()</var>.
	</p>
	<pre class="language-javascript"><code>
		function f() {
			var pi = 3.14;
			console.log(`${pi} inside f`);
			function g() {
				console.log(`${pi} inside g`)
			}
		}
		f();
		g();
	</code></pre>
	<pre class="language-bash"><code>
		3.14 inside f
		Uncaught ReferenceError: g is not defined
	</code></pre>
	<p>
		Note that because of lexical scope and JavaScript's allowance for
		mutability, functions can mutate global variables (another reason why
		we want to avoid global variables as much as possible). In other words,
		functions have access to variables both above and below them. While
		this can be helpful in many situations, it is also poses a looming
		danger. For example, consider the following code:
	</p>
	<pre class="language-javascript"><code>
		let a = 0;

		console.log(`a = ${a}`);

		function f() {
			console.log("f is called")
			return a += 1;
		}

		f();

		console.log(`a = ${a}`);
	</code></pre>
	<pre class="language-bash"><code>
		a = 0
		f is called
		a = 1
	</code></pre>
	<p>
		We can avoid this by erring on the side of declaring variables with
		<var>const</var>, ensuring we use different variable names, or rely on
		<b>shadowing</b>. The easier approach is to avoid immutability as much
		as possible; i.e., erring on the side of using <var>const</var>.
	</p>
	<p>
		Like ML and other functional languages, JavaScript implements
		<i>shadowing</i>. We can have variables with the same name in a
		program, so long as they are declared in different scopes. For example:
	</p>
	<pre class="language-javascript"><code>
		let a = 0;
		console.log(`a[global] = ${a}`)
		function f() {
			let a = 3;
			a += 1;
			console.log('f is called');
			console.log(`a[inside f] = ${a}`);
		}
		f();
		console.log(`a[global] = ${a}`)
	</code></pre>
	<pre class="language-bash"><code>
		a[global] = 0
		f is called
		a[inside f] = 1
		a[global] = 0
	</code></pre>
	<p>
		Compare that to what happens when we remove the declaration for
		<var>a</var> inside <var>f()</var>:
	</p>
	<pre class="language-javascript"><code>
		let a = 0;
		console.log(`a[global] = ${a}`)
		function f() {
			a += 1;
			console.log('f is called');
			console.log(`a[inside f] = ${a}`);
		}
		f();
		console.log(`a[global] = ${a}`)
	</code></pre>
	<pre class="language-bash"><code>
		a[global] = 0
		f is called
		a[inside f] = 1
		a[global] = 1	
	</code></pre>
	<p>
		This is evidence of shadowing. To evaluate a function, JavaScript will
		use the bindings (i.e., variables) in the current scope first. If that
		binding is not present in the current scope, JavaScript will turn to
		the parent scope (in this case, the global environment). If the parent
		scope doesn't contain the binding, then JavaScript will turn to the
		next, all the way up to the global scope.
	</p>
	<p>
		While shadowing can help avoid accidental mutation, the easiest way to
		prevent functions modifying variables outside its scope is to err on
		the side of avoiding mutation all together; i.e., using
		<var>const</var>.
	</p>

	<section id="function_call_mechanics">
		<p>
			<span class="topic">Function Call Mechanics.</span> Having discussed
			scope, it's worth briefly discussing the mechanics of function calls.
			We will take a much closer look at JavaScript's internal details in a
			later section. For now, we'll discuss things from a more generalized
			perspective.
		</p>
		<p>
			When we call a function, several actions occur. First, JavaScript
			evaluates the arguments in the context of the caller. For example, if
			we call the a function <var>f()</var> and pass it the arguments
			<var>f(a, b)</var>, JavaScript will evaluate <var>a</var> and
			<var>b</var> according to the scope where <var>a</var> and
			<var>b</var> are defined. If <var>a</var> and <var>b</var> are not
			defined in the <i>local</i> scope, JavaScript will examine the parent
			scope, then the parent scope's parent scope, and so on (what we
			earlier explained as shadowing).
		</p>
		<p>
			JavaScript generates a <span class="underlineText">copy</span> of the
			argument value, and assigns it to the function's corresponding
			parameter variable. For example, if the function <var>f()</var> has
			the parameter <var>f(length)</var>, when we call <var>f(1)</var>,
			JavaScript creates the binding <var>length = 1</var>. These new
			assignments are done in order. If the function <var>s()</var> had the
			parameters <var>s(a, b)</var>, calling <var>s(0, 1)</var> will create
			the bindings <var>a = 0</var> and <var>b = 1</var>. These new
			bindings are allocated in a new region of memory called a
			<b>stack frame</b>.
		</p>
		<p>
			Unlike most other languages, JavaScript makes no complaints about
			whether we pass too few or too many arguments. For example, if the
			function
			<var>g()</var> has the parameters <var>g(x, y, z)</var>, calling
			<var>g(1, 2)</var> will create the bindings <var>x = 1</var> and
			<var>y = 2</var>. What about <var>z</var>? It's simply
			<var>z = undefined</var>. If we instead called too many arguments,
			e.g., <var>g(1, 2, 3, 4)</var>, the bindings <var>x = 1</var>,
			<var>y = 2</var>, and <var>z = 3</var> are generated, and the fourth
			argument, <var>4</var>, is ignored outright.
		</p>
		<p>
			After storing all of these variables in a new stack frame, JavaScript
			proceeds to evaluating the function body's statements using the new
			stack frame to evaluate the local variables as needed. For example,
			suppose a function's head is <var>f(c)</var> and we
			<var>f()</var> with <var>f(1)</var>. This generates the binding
			<var>c = 1</var>. As JavaScript evaluates the function's body, it
			will evaluate the <var>c</var>s it sees to <var>1</var>.
		</p>
		<p>
			This process ceases entirely the moment JavaScript encounters a
			return-statement. At that moment, it computes the return value and
			substitutes that value in place of the call. For example if we had
			function
			<var>h(a)</var> that increments its argument and we called
			<var>h(1)</var>, the moment it encounters <var>return a++;</var>,
			<var>h(1)</var> is evaluated to <var>2</var>. Once this is done,
			JavaScript removes the stack frame for the called function and
			returns to the caller, continuing from where it left off.
		</p>
	</section>
</section>

<section id="closures">
	<h2>Closures</h2>
	<p>
		Another way to write a function is with a
		<b>function expression</b>. These are essentially <b>closures</b>. The
		template:
	</p>
	<figure class="math-display">
		<ul class="syntax">
			<li>${k}$ ${v}$ = ${f}$(${p_0, \ldots, p_n}$) { ${s}$ }</li>
		</ul>
		<figcaption>
			where ${k}$ is one of the keywords <var>let</var>, <var>const</var>,
			or <var>var</var>; ${v}$ is a variable name; ${f}$ is the function
			name; and ${s}$ is a statement or block of statements to execute
		</figcaption>
	</figure>
	<p>
		Notice the difference between a
		<i>function expression</i> and a <i>function declaration</i>: in a
		<i>function expression</i>, the function itself does not have a name.
		Instead, we store the function in a variable, and then use the variable
		name to call the function. This works because
		<span class="underlineText">functions are objects</span>. Example:
	</p>
	<pre class="language-javascript">
		<code>
			/*
			Here is a function that calculates the distance between two points on a plane (the distance formula)
			*/
			const distanceFormula = function (x1, y1, x2, y2) {
				const x_distance = Math.pow(x2 - x1, 2);
				const y_distance = Math.pow(y2 - y1, 2);
				const sum_x_y_distance = x_distance + y_distance;
				return Math.sqrt(sum_x_y_distance);
			};
			console.log(distanceFormula(0, 0, 1, 2));
			/*
			This outputs to the console:
			2.23606797749979
			*/
		</code>
	</pre>
	<p>
		Because functions are essentially objects, we can store as many
		functions as we want in an array, or in an object.
	</p>
	<p>
		When should we use a closure instead of a function declaration? If the
		most efficient way to accomplish a task is to pass a function as an
		argument, then closures are much more ideal than function declarations.
		This is because function expressions can be passed through as
		arguments, stored in objects and iterables. They're also just more
		concise:
	</p>
	<pre class="language-javascript">
		<code>
			/*
			Suppose we have several chunks of code that we routinely use in our program. It would be very helpful to store these functions in an object, and then call the functions whenever we need to. 
			*/
			const distanceFormula = function (x1, y1, x2, y2) {
				const x_distance = Math.pow(x2 - x1, 2);
				const y_distance = Math.pow(y2 - y1, 2);
				const sum_x_y_distance = x_distance + y_distance;
				return Math.sqrt(sum_x_y_distance);
			};
			const lineSlope = function (x1, y1, x2, y2) {
				const y_distance = y2 - y1;
				const x_distance = x2 - x1;
				return y_distance / x_distance;
			};
			const rectangleArea = function (length, width) {
				return length * width;
			};
			const circleArea = function (radius) {
				return Math.PI * Math.pow(radius, 2);
			};
			const circleCircumference = function (radius) {
				return 2 * Math.PI * radius;
			};

			// Let's store the functions we've created in an object. When we do this, we create methods.
			const mathOps = {
				distanceLinePoints: distanceFormula,
				slopeLine: lineSlope,
				areaRectangle: rectangleArea,
				areaCircle: circleArea,
				perimeterCircle: circleCircumference,
			};
			// We can now call the functions with the object:
			console.log(mathOps.distanceLinePoints(2, 1, 4, 5)); // Returns 4.47213595499958
			console.log(mathOps.slopeLine(3, 3, 5, 8)); // Returns 2.5
			console.log(mathOps.areaRectangle(3.3, 5.89)); // Returns 19.436999999999998
			console.log(mathOps.areaCircle(7.93)); // Returns 197.55873986172875
			console.log(mathOps.perimeterCircle(4.325)); // Returns 27.17477645355171
		</code>
	</pre>
	<p>
		By storing the functions in an object, we have turned the functions
		into
		<b>methods</b>. Similarly, we can store functions in an array. By
		placing functions inside arrays, we can create a more complex function
		where the order of performing the functions matters.
	</p>
	<pre class="language-javascript">
		<code>
			const isInteger = function (num) {
				if (num - Math.floor(num) !== 0) {
					return false;
				}
				return true;
			};
			const isEven = function (num) {
				if (num % 2 === 0) {
					return true;
				}
				return false;
			};
			const isDivisibleBy4 = function (num) {
				if (num % 4 === 0) {
					return true;
				}
				return false;
			};
			const integerTest = [isInteger, isEven, isDivisibleBy4];

			for (let i = 0; i < integerTest.length; i++) {
				console.log(integerTest[i](9));
			}
		</code>
	</pre>
	<pre class="language-bash"><code>
		true
		false
		false
	</code></pre>
	<p>
		Placing functions inside arrays is a powerful tactic for creating
		complex functions. Because order matters in an array, combining a
		<var>for</var> loop with an array of functions allows us to perform
		complicated computations where order matters&ndash;essentially,
		<b>algorithms</b>.
	</p>

	<section id="arrow_functions">
		<h3>Arrow Functions</h3>
		<p>
			An <b>arrow function</b> is just a more compact way of writing a
			function expression. JavaScript provides it as syntactic sugar. The
			template:
		</p>
		<figure class="math-display">
			<div>
				<ul class="syntax">
					<li>${k}$ ${f}$ = (${p}$) => { ${s}$ }</li>
				</ul>
			</div>
			<figcaption>
				where ${k}$ is one of the keywords <var>let</var>,
				<var>const</var>, or <var>var</var>; ${f}$ is variable name; ${p}$
				is a parameter, and ${s}$ are the statements to execute
			</figcaption>
		</figure>
		<p>For example:</p>
		<pre class="language-javascript">
			<code>
				const square = (x) => {
					return x * x;
				}
				console.log(square(4));
			</code>
		</pre>
		<pre class="language-bash"><code>
			16
		</code></pre>
		<p>Another example:</p>
		<pre class="language-javascript">
			<code>
				/*
				This function tests whether a number is even. Here, we passed the number 8.
				*/

				const evenTest = (num) => {
					return num % 2 === 0;
				}
				console.log(evenTest(8));
			</code>
		</pre>
		<pre class="language-bash"><code>
			true
		</code></pre>
		<p>
			If you have <span class="underlineText">only one</span> parameter,
			you can omit the parentheses:
		</p>
		<pre class="language-javascript">
			<code>
				const circumference = radius => {
					return 2 * Math.PI * radius;
				}
				console.log(circumference(3));
			</code>
		</pre>
		<pre class="language-bash"><code>
			18.84955592153876
		</code></pre>
		<p>
			However, note that we can write arrow functions without parentheses
			<span class="underlineText">if and only if</span> we have one
			parameter to the function. If the arrow function is an anonymous
			function, you <span class="underlineText">must</span> include
			parentheses.
		</p>

		<section id="arrow_functions_and_implicit_returns">
			<h4>Arrow Functions and Implicit Returns</h4>
			<p>
				We can write arrow functions even more compactly with
				<b>implicit returns</b>.This will only work in certain situations.
				To see how implicit returns are more compact, examine:
			</p>
			<pre class="language-javascript">
				<code>
					const circumference = function (radius) { // A regular function expression
						return 2 * Math.PI * radius;
					};
		
					const circumference = (radius) => { // An regular arrow function
						return 2 * Math.PI * radius;
					}
		
					const circumference = radius => { // An arrow function without parentheses
						return 2 * Math.PI * radius;
					}
		
					const circumference = radius => ( // An implicit return (no return statement)
						2 * Math.PI * radius
					);
		
					const circumference = radius => 2 * Math.PI * radius; // A one-line implicit return
					console.log(circumference(3));					
					/*
					For all of these expressions, the output to the console:
		
					18.84955592153876
					*/
				</code>
			</pre>
			<p>
				Notice how for <b>implicit returns</b>, there are no parentheses
				around the function's alias, and there is no
				<var>return</var> statement. They can also be written in one line.
				Implicit returns (particularly one-line syntax) are attractive
				because they're short, concise, and take up less lines. But, if the
				function takes many parameters, consider writing the function in
				other syntax: readable code is much easier to debug and work with.
				More importantly, use arrow functions only if the function's body
				consists of 1 expression. JavaScript does not know what to do if
				you wrote the following:
			</p>
			<pre class="language-javascript">
				<code>
					/*
					Say I want to square a number and also determine whether the passed through number is divisible by 4
					*/
					const specialSquare = num => (
						num * num
						if (num % 4 === 0) {
							return true;
						}
					);
					console.log(specialSquare(4));
					/*
					On the console, we get the following error:
		
					SyntaxError: Unexpected token 'if'
					*/
				</code>
			</pre>
			<p>
				The above error is occurring because we put in more than one
				expression.
			</p>
		</section>

		<section id="implicit_returns_and_arrays">
			<h4>Using Implicit Returns and Arrays</h4>
			<p>
				Implicit returns allow us to concisely write functions operating on
				arrays. Consider the following code using the map method, written
				in regular function syntax:
			</p>
			<pre class="language-javascript">
				<code>
					/*
					I have an array of Fibonacci numbers, and I want to multiply each of them by euler's constant, and map the returned values into a new array.
					*/
					const fibonacciNumbers = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144];
					const fibonacciEulerProducts = fibonacciNumbers.map(function (n) {
						return n * Math.E;
					});
					console.log(fibonacciEulerProducts);
					/*
					The console output:
		
					[
					0,
					2.718281828459045,
					2.718281828459045,
					5.43656365691809,
					8.154845485377136,
					13.591409142295225,
					21.74625462767236,
					35.337663769967584,
					57.08391839763995,
					92.42158216760754,
					149.50550056524747,
					241.927082732855,
					391.4325832981025
					]
					*/
				</code>
			</pre>
			<p>The code above can be written shorter with an arrow function:</p>
			<pre class="language-javascript">
				<code>
					const fibonacciNumbers = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144];		
					const fibonacciEulerProducts = fibonacciNumbers.map(n => {
						return n * Math.E;
					});
					console.log(fibonacciEulerProducts);									
				</code>
			</pre>
			<p>And it can be written even shorter with an implicit return:</p>
			<pre class="language-javascript">
				<code>
					const fibonacciNumbers = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144];
					const fibonacciEulerProducts = fibonacciNumbers.map(n => n * Math.E);
					console.log(fibonacciEulerProducts);
				</code>
			</pre>
			<p>
				Bottom line: Implicit returns when used with array methods are
				conducive to concise code. But, remember: We can only have one
				expression with arrow functions (and by implication, implicit
				returns). Thus, to get around this problem, we need to write code
				in a single expression. If that is not possible, then we need to
				use a regular function expression, or define a function elsewhere
				in the code, and pass that function as an argument.
			</p>
		</section>

		<section id="ternary_operators_implicit_returns">
			<h4>Implicit Returns and Ternary Operators</h4>
			<p>
				If the function to be used in a
				<var>.map()</var> or <var>.forEach()</var> method consists of a
				Boolean expression that only returns one of two values given the
				array, then we can use a
				<a href="#ternary_operator">ternary operator</a> to short the code
				even further. Suppose:
			</p>
			<p></p>
			<pre class="language-javascript">
				<code>
					/*
					Here is an array of the values for the partition function for the numbers 1 to 8. (The partition function tells us the number of possible partitions for a number; e.g., the number 3 has 3 partitions: 3+0, 1+2, 1+1+1). Say I want to determine if the each of the values are odd or even.
					*/
					const partitionNum = [1, 2, 3, 5, 7, 11, 15, 22];
					// We can write the map method's function with regular function notation:
					const partitionNumParity = partitionNum.map(function (n) {
						if (n % 2 === 0) return 'even';
						return 'odd';
					});
					console.log(partitionNumParity);			
					
					/*
					Console output: 
					[
					'odd', 'even',
					'odd', 'odd',
					'odd', 'odd',
					'odd', 'even'
					]
					*/
				</code>
			</pre>
			<p>Shortening the code above:</p>
			<pre class="language-javascript">
				<code>
					const partitionNum = [1, 2, 3, 5, 7, 11, 15, 22];
					const partitionNumParity = partitionNum.map((n) => {
						if (n % 2 === 0) return 'even';
						return 'odd';
					});
					console.log(partitionNumParity);		
				</code>
			</pre>
			<p>
				We can write it with an implicit return, but to do so, we cannot
				have multiple return statements (those are multiple expressions!).
				To get around this problem, we use a ternary operator:
			</p>
			<pre class="language-javascript">
				<code>
					const partitionNum = [1, 2, 3, 5, 7, 11, 15, 22];
					const partitionNumParity = partitionNum.map((n) =>
						n % 2 === 0 ?  'even' : 'odd'
					);
					console.log(partitionNumParity);		
				</code>
			</pre>
			<p>Or, in a single line:</p>
			<pre class="language-javascript">
				<code>
					const partitionNum = [1, 2, 3, 5, 7, 11, 15, 22];
					const partitionNumParity = partitionNum.map((n) => n % 2 === 0 ? 'even' : 'odd');
					console.log(partitionNumParity);	
				</code>
			</pre>
		</section>
	</section>
</section>

<section id="arrow_functions_and_this">
	<h3>Arrow Functions and the 'this' Keyword</h3>
	<p>
		One of the key differences between regular function expressions and
		arrow functions is how they behave with the keyword
		<var>this</var>. When a method is written as an arrow function, if its
		body uses the keyword <var>this</var>, the value of
		<var>this</var>
		<span class="underlineText">does not change</span>.
	</p>
	<pre class="language-javascript"><code>
		// The full name function as an arrow function:
		const sR = {
			first: "Srinivasa",
			last: "Ramanujan",
			country: "India",
			fullName: () => {
				console.log(this);
				console.log(`${this.first} ${this.last}`);
			}
		};
		sR.fullName();
	</code></pre>
	<pre class="language-bash"><code>
		WindowÂ {window: Window, self: Window, document: document, name: "", location: Location,Â â€¦}
		undefined undefined
	</code></pre>
	<p>
		Notice that when we display the value of
		<var>this</var> for the function <var>fullName()</var>, we get the back
		the <var>window</var> object. The value of <var>this</var> in an arrow
		function is always the value of <var>this</var> of its parent object
		(in this case, the global scope). This is why methods are generally not
		written as arrow functions inside an object written inside a global
		scope (since we usually write methods to access other properties in
		such an object). But, they are extremely useful when a method itself
		contains a function. To see this utility, consider the code below:
	</p>
	<pre class="language-javascript"><code>
		/*
		Here is method that repeatedly and randomly prints out prime numbers forever.
		We want to start the method with the function start().
		To do this, we need to use the built in method, set.interval(), which takes two parameters, a function, and time value (3000, which equals three seconds)
		*/
		const randPrime = {
			primes: [1, 3, 5, 7, 11, 13, 17],

			pickPrime() {
				const { primes } = this; // Set the value of this to be the primes property
				const idx = Math.floor(Math.random() * primes.length); // Generate a random index
				return primes[idx]; // Output the random index
			},

			// Now we want to call pickPrime with the set interval method:
			start() {
				console.log(this.pickPrime());
				setInterval(function() { console.log(this.pickPrime()) }, 2000)
			}
		};
		// Let's test briefly:
		randPrime.start();
	</code></pre>
	<pre class="language-bash"><code>
		13
		Uncaught TypeError: this.pickPrime is not a function
	</code></pre>
	<p>
		Why did we get the error above? Let's see what the vlaue of
		<var>this</var> is in the function function <var>start()</var>:
	</p>
	<pre class="language-javascript"><code>
		const randPrime = {
			primes: [1, 3, 5, 7, 11, 13, 17],

			pickPrime() {
				const { primes } = this;
				const idx = Math.floor(Math.random() * primes.length);
				return primes[idx];
			},

			start() {
				console.log(this.pickPrime());
				setInterval(function () {
					console.log(this);
					console.log(this.pickPrime())
				}, 2000)
			}
		};
		randPrime.start();
	</code></pre>
	<pre class="language-bash"><code>
		13
		WindowÂ {0: global, window: Window, self: Window, document: document, name: "", location: Location,Â â€¦}
	</code></pre>
	<p>
		Why is the value of <var>this</var> set to the
		<var>window</var> object? Because in the <var>start()</var> method's
		body, we are using the <var>setInterval()</var> method, which has a
		global scope. Thus, the value of <var>this</var>, inside the
		<var>setInterval()</var> method, is the global scope's object,
		<var>window</var>. One way to get around this problem is by storing the
		value of <var>this</var> in a variable before we get to using the
		built-in method:
	</p>
	<pre class="language-javascript"><code>
		const randPrime = {
			primes: [1, 3, 5, 7, 11, 13, 17],

			pickPrime() {
				const { primes } = this;
				const idx = Math.floor(Math.random() * primes.length);
				return primes[idx];
			},

			start() {
				console.log(this.pickPrime());

				const that = this;

				setInterval(function () {
					console.log(that);
					console.log(that.pickPrime())
				}, 2000)
			}
		};
		randPrime.start();						
	</code></pre>
	<pre class="language-bash"><code>
		7
		{primes: Array(7), pickPrime: Æ’, start: Æ’}
		13
		9
		1
		5
	</code></pre>
	<p>
		By storing <var>this</var> in the variable <var>that</var>, we can now
		use the previous value of <var>this</var> in the built-in method
		<var>setInterval()</var>. This was the old way of getting around the
		problem of using <var>this</var> with built-in methods, and when
		viewing old JavaScript code, we will often see the variable name
		<var>that</var>. Arrow functions, however, have taken the mantle and
		provide a much cleaner way of solving the problem:
	</p>
	<pre class="language-javascript"><code>
		const randPrime = {
			primes: [1, 3, 5, 7, 11, 13, 17],

			pickPrime() {
				const { primes } = this;
				const idx = Math.floor(Math.random() * primes.length);
				return primes[idx];
			},

			start() {
				setInterval(() => {
					console.log(this.pickPrime())
				}, 2000)
			}
		};
		randPrime.start();
	</code></pre>
	<pre class="language-bash"><code>
		7
		11
		1
	</code></pre>
	<p>
		The above works because with arrow functions, the value of
		<var>this</var> is always the value <var>this</var> for the function's
		parent object.
	</p>
</section>

<section id="higher_order_functions">
	<h2>Higher Order Functions</h2>
	<p>
		<b>Higher order functions</b> are simply functions that operate
		<i>on</i> or <i>with other</i> functions. These are functions that take
		other functions as arguments, or return functions as output.
		<i>Higher order functions</i> are a staple programming pattern; they
		are used routinely for a wide variety of tasks. For example, a function
		that takes a function as an argument is a higher order function:
	</p>
	<pre class="language-javascript">
		<code>
			/*
			Here is an example of a function that takes a function as an argument.
			*/
			// First, let's make a generic function to pass through to the higher order function.
			function shake() {
				console.log("shake shake shake shake bird! shake shake shake");
			}
			// Then, let's create a higher order function:
			function tooMuchAdderall(func) { // Remember, "func" is just a placeholder name!
				func(); //That placeholder name is attached to the parentheses
				func();
			}
			// Call the higher order function:
			tooMuchAdderall(shake);
			/*
			This outputs to the console:

			shake shake shake shake bird! shake shake shake
			shake shake shake shake bird! shake shake shake
			*/
		</code>
	</pre>
	<p>
		We can have a higher order function execute a function passed as an
		argument an $x$ amount of times by using a
		<var>for</var> loop in the higher function:
	</p>
	<pre class="language-javascript">
		<code>
			// Function to be passed as an argument:
			function shake() {
				console.log("shake shake shake shake bird! shake shake shake");
			}
			// The higher order function that will take the function as an argument:
			function tooMuchAdderall(func, numberOfExecutions) {
				for (let i = 0; i < numberOfExecutions; i++) {
					func();
				}
			}
			// Call the higher order function:
			tooMuchAdderall(shake, 5);
		</code>
		<pre class="language-bash"><code>
			shake shake shake shake bird! shake shake shake
			shake shake shake shake bird! shake shake shake
			shake shake shake shake bird! shake shake shake
			shake shake shake shake bird! shake shake shake
			shake shake shake shake bird! shake shake shake
		</code></pre>
	</pre>
	<p>
		Another higher order function is a function that returns a function.
		These higher order functions are essentially "function
		factories"&mdash;they take the arguments passed to them, and output a
		function. Remember: Functions are essentially data like numbers or
		strings, so they can be passed to other functions as arguments, and
		returned by other functions.
	</p>
	<pre class="language-javascript">
		<code>
			/*
			Suppose we have an array containing objects. The objects list the math fields the college currently has expert mathematicians in, and the number of mathematicians in those fields.
			*/
			const popularMathFields = [
				{ field: "nonassociative rings and algebras", mathematicians: 1 },
				{ field: "category theory", mathematicians: 1 },
				{ field: "lie groups", mathematicians: 4 },
				{ field: "ordinary differential equations", mathematicians: 12 },
				{ field: "partial differential equations", mathematicians: 14 },
				{ field: "operator theory", mathematicians: 12 },
				{ field: "statistics", mathematicians: 28 },
				{ field: "probability theory", mathematicians: 3 },
			];
			/* 
			I'm now reviewing some job applicants for a new position in my math department. The applicants have applied for the fields in the array above, but there are still a lot of applicants. I want to make sure I'm only hiring an applicant if their field has a minimum of x and a maximum of y mathematicians in my department, to be determined later on. How do we do this? One way is to use a higher order function.
			*/
			function inBetweenFunc(min, max) { // The higher order function
				return function (applicantField) { // The outputted function
					for (let element of popularMathFields) { // Target objects in array
						while (applicantField === element.field) { // Make sure field is offered
							if ( // Check if the number of mathematicians is within range
								element.mathematicians >= min &&
								element.mathematicians <= max) 
							{ // Within range? Do this.
								return console.log(`${applicantField} meets range.`); 
							} 
							else { // Not within range? Do this.
								return console.log(`${applicantField} outside range.`); 
							}
						}
					}
				};
			}
			/* 
			Then let's store the inBetweenFunc in a variable, "isFieldNeeded". We've decided that, based on student and market demand and the number of mathematicians, we want the applicant's field to have a minimum of 4 mathematicians in our department, and a maximum of 17 mathematicians:
			*/
			const isFieldNeeded = inBetweenFunc(2, 17);
			// Let's test the function:
			isFieldNeeded("ordinary differential equations");
			isFieldNeeded("lie groups");
			isFieldNeeded("probability theory");
			isFieldNeeded("category theory");
			/*
			The output on the console:

			ordinary differential equations meets range.
			lie groups meets range.
			probability theory meets range.
			category theory outside range.
			*/
		</code>
	</pre>

	<section id="callback_functions">
		<h2>Callback Functions</h2>
		<p>
			A <b>callback function</b> is a function that is passed into another
			function as an argument, which is then invoked inside the outer
			function. Example:
		</p>
		<pre class="language-javascript">
			<code>
				/*
				A common use for callback functions is passing a function into the setTimeout function built in to JavaScript. The setTimeout function calls a function after a certain amount of milliseconds.
				*/
				function poke() {
					console.log("Ouch! Don't poke me.");
				}
				setTimeout(poke, 2000);
	
				/*
				After 2000 milliseconds (2s), the console displays:
	
				Ouch! Don't poke me.
				*/
			</code>
		</pre>
	</section>
</section>

<section id="applying_functions">
	<h2>Special Loops and Methods</h2>
	<p>
		JavaScript provides several looping constructs that allow us to apply
		functions to collections. These are addressed below.
	</p>

	<section id="for_each_method">
		<h3>The For-each Method</h3>
		<p>
			The <var>.forEach()</var> method tells JavaScript: "For each element
			in the array, execute this function." The general syntax of the
			<var>.forEach()</var> method:
		</p>
		<pre class="language-javascript">
			<code>
				<span class="greyText italicsText">array-name</span>.forEach(<span class="greyText italicsText">function-name</span>);
			</code>
		</pre>
		<p>Here's an example:</p>

		<pre class="language-javascript">
			<code>
				/*
				I have an array of primes, and I want to square each of the primes and modulate that square by pi. We could use a for loop or pass each of the elements into a function one by one, but there's a faster way: the forEach method.
				*/
	
				// Suppose we have this array of primes:
				const primes = [1, 3, 5, 7, 11, 13];
				function primePiModulate(n) {
					console.log((n * n) % Math.PI);
				}
				primes.forEach(primePiModulate);		
				/*
				Outputted to the console:
	
				1
				2.7168146928204138
				3.008851424871448
				1.8761101961531033
				1.6194791635878616
				2.495589359740965
				*/						
			</code>
		</pre>
	</section>

	<section id="map_method">
		<h3>The Map Method</h3>
		<p>
			The <var>.map()</var> method creates a new array with the results of
			calling a<i>call back function</i>
			on every element in the array.
		</p>
		<p>
			The general syntax for the
			<var>.map()</var> method:
		</p>
		<pre class="language-javascript">
			<code>
				const <span class="greyText italicsText">array-name</span> = [<span class="greyText italicsText">element-1</span>, <span class="greyText italicsText">element-2</span>, <span class="greyText italicsText">element-3</span>]; 
				const <span class="greyText italicsText">variable-name</span> = <span class="greyText italicsText">array-name</span>.map(function() {
					<span class="greyText italicsText">statements</span>;
				});
			</code>
		</pre>
		<p>
			Application: The user has an array of different radii, and I want to
			find the circumference for their corresponding circles.
		</p>
		<pre class="language-javascript">
			<code>
				const radii = [1, 3, 5, 7, 11, 13, 17];
				const circumferences = radii.map(function (num) {
					return num * 2 * Math.PI;
				});
				console.log(circumferences);		
			</code>
		</pre>
		<pre class="language-bash"><code>
			[
			6.283185307179586,
			18.84955592153876,
			31.41592653589793,
			43.982297150257104,
			69.11503837897544,
			81.68140899333463,
			106.81415022205297
			]
		</code></pre>
		<p>
			Remember: <var>num</var> is just an alias (or placeholder). Each of
			the elements in the array are passed through to the function and are
			used as <var>num</var>.
		</p>
	</section>

	<section id="find_method">
		<h3>The Find Method</h3>
		<p>
			The <var>.find()</var> method returns the value of the first element
			in an array that satisfies a test condition. General syntax:
		</p>
		<pre class="language-javascript">
			<code>
				const <span class="greyText italicsText">arrayName</span> = [<span class="greyText italicsText">element-1</span>, <span class="greyText italicsText">element-2</span>, <span class="greyText italicsText">element-3</span>];
				const <span class="greyText italicsText">variableName</span> = <span class="greyText italicsText">arrayName</span>.find(<span class="greyText italicsText">alias</span> => <span class="greyText italicsText">test-condition</span>);
			</code>
		</pre>
		<p>
			Of course, we can write the
			<var>.find()</var> method with the usual function notations: Using
			the <var>.find()</var> method with a regular function expression:
		</p>
		<pre class="language-javascript">
			<code>
				const <span class="greyText italicsText">arrayName</span> = [<span class="greyText italicsText">element-1</span>, <span class="greyText italicsText">element-2</span>, <span class="greyText italicsText">element-3</span>];
				const <span class="greyText italicsText">variableName</span> = <span class="greyText italicsText">arrayName</span>.find(function(element) {
					return <span class="greyText italicsText">test-condition</span>;
				});
			</code>
		</pre>
		<p>
			For example, below is an array of objects containing different
			hydrogen compounds. The user wants to find the first element
			containing
			<var>'sulfide'</var>.
		</p>
		<pre class="language-javascript">
			<code>
				const chemicals = ['hydrogen peroxide', 'hyponitrous acid', 'hydrogen fluoride', 'hydrogen cyanide', 'hydrogen sulfide', 'lead hydrogen arsenate'];
				let firstSulfide = chemicals.find(element => {
					return element.includes('sulfide')
				});
				console.log(firstSulfide);
			</code>
		</pre>
		<pre class="language-bash"><code>
			hydrogen sulfide
		</code></pre>
		<p>
			The <var>.find()</var> method does not change the array, since its
			only performing a simply find/search. Below is another example, an
			array containing objects with data. Suppose we have an array of
			objects, containing chemicals and their atomic masses. We want to
			find the first element with an atomic mass greater than ${13.}$ and
			less than ${43.764.}$
		</p>
		<pre class="language-javascript">
			<code>
				const chemicals = [
					{chemical: 'krypton', atomic_mass: 83.8},
					{chemical: 'hydrogen', atomic_mass: 1.0079},
					{chemical: 'zirconium', atomic_mass: 91.224},
					{chemical: 'phosphorus', atomic_mass: 30.9738},
					{chemical: 'boron', atomic_mass: 10.811},
					{chemical: 'erbium', atomic_mass: 167.259},
					{chemical: 'sodium', atomic_mass: 22.9897},
					{chemical: 'sulfur', atomic_mass: 32.065},
					{chemical: 'barium', atomic_mass: 137.327},
				]
				const specialChemical = chemicals.find(element => 
					element.atomic_mass > 13.982 && 
					element.atomic_mass < 43.764
				);
				console.log(specialChemical);
			</code>
		</pre>
		<pre class="language-bash"><code>
			{ chemical: 'phosphorus', atomic_mass: 30.9738 }
		</code></pre>
		<p>
			Note that the <var>.find()</var> method is case sensitive. Further
			note: The <var>.find()</var> method only searches for the first
			element that matches the provided condition, and returns that
			element. This implies several things:
		</p>
		<ol>
			<li>
				The <var>.find()</var> method only works if we provide it a
				condition&mdash;an expression that will only evaluate to true or
				false.
			</li>
			<li>
				The <var>.find()</var> method stops its search at the first match.
				It will not continue searching for other matches.
			</li>
		</ol>
	</section>

	<section id="filter_method">
		<h3>The Filter Method</h3>
		<p>
			The <var>.filter()</var> method creates a new array of elements that
			satisfies a condition. Filter allows us to "filter out" subsets of
			elements inside an array. The method works as such:
		</p>
		<ol>
			<li>
				We have an array, and we execute the
				<var>.filter()</var> method on the array.
			</li>
			<li>
				In our .filter() method, we have a
				<b>test function</b>. That test function contains a condition.
			</li>
			<li>
				JavaScript looks at each of the array's elements, and checks
				whether the element meets the condition.
			</li>
			<li>
				If the element meets the condition, the element is put into a new
				array, and JavaScript moves to the next element.
			</li>
			<li>
				If the element does not meet the condition, the element is ignored,
				and JavaScript moves to the next element.
			</li>
			<li>
				JavaScript continues until it has gone through the entire array.
			</li>
		</ol>
		<p>The <var>.filter()</var> method takes the following form:</p>
		<pre class="language-javascript">
			<code>
				const <span class="greyText italicsText">arrayName</span> = [<span class="greyText italicsText">element-1</span>, <span class="greyText italicsText">element-2</span>, <span class="greyText italicsText">element-3</span>];
				const <span class="greyText italicsText">variableName</span> = <span class="greyText italicsText">arrayName</span>.filter(<span class="greyText italicsText">alias</span> => <span class="greyText italicsText">test-condition</span>);									
			</code>
		</pre>
		<p>Or, with a regular function expression:</p>
		<pre class="language-javascript">
			<code>
				const <span class="greyText italicsText">arrayName</span> = [<span class="greyText italicsText">element-1</span>, <span class="greyText italicsText">element-2</span>, <span class="greyText italicsText">element-3</span>];
				const <span class="greyText italicsText">variableName</span> = <span class="greyText italicsText">arrayName</span>.filter(function(element) {
					return <span class="greyText italicsText">test-condition</span>;
				});									
			</code>
		</pre>
		<p>
			Below is a simple example. We have an array of numbers,
			<var>nums</var>. We want all of the even numbers stored in a new
			array.
		</p>
		<pre class="language-javascript">
			<code>
				const nums = [1, 5, 9, 8, 7, 3, 5, 11, 17, 14];
				const evenNums = nums.filter(elements => elements % 2 === 0); 

				// Check if it worked:
				console.log(evenNums);
			</code>
		</pre>
		<pre class="language-bash"><code>
			[8, 14]
		</code></pre>
		<p>
			What is the above code doing? We told JavaScript: "JS, for the array
			<var>nums</var>, I want you to do the following: (1) look at each of
			the elements in the array one by one, (2) check if the element meets
			this condition: elements % 2 === 0, (3) if the element meets the
			condition, place it in a new array; otherwise, ignore it, (4) move to
			the next element, (5) continue until you've gone through the entire
			array, and (4) store that resulting array in this variable
			<var>evenNums</var>".
		</p>
		<p>
			A more complex example: We have an array of different polymers
			(materials made of large molecules bonded together; e.g., plastics
			and resins). The user wants to see all of the polymers that have a
			melting point greater than ${113,}$ but only their names. Following
			that, we want to see all of the polymers that are food safe. Then all
			of the polymers ideal for bottles.
		</p>

		<pre class="language-javascript">
			<code>
				// show polymers with melting point > 113
				const polymers = [
					{
						polymer: 'polyvinyl chloride (PVC)',
						melting_point: 100,
						uses: ['pipes', 'fencing', 'bottles', 'raincoats', 'toys'],
						food_safe: false
					},
					{
						polymer: 'polypropylene (PP)',
						melting_point: 130,
						uses: ['auto parts', 'food containers', 'dishware'],
						food_safe: true
					},
					{
						polymer: 'polyethylene terephthalate (PET)',
						melting_point: 260,
						uses: ['bottles', 'fleece', 'carpet'],
						food_safe: true
					},
					{
						polymer: 'high-density polyethylene (HDPE)',
						melting_point: 130.8,
						uses: ['bottles', 'containers', 'plastic bags'],
						food_safe: true
					},
					{
						polymer: 'low-density polyethylene (LDPE)',
						melting_point: 110,
						uses: ['bottles', 'toys', 'six pack rings', 'pipes'],
						food_safe: true
					},
					{
						polymer: 'polystyrene',
						melting_point: 270,
						uses: ['petri dishes', 'plastic cutlery'],
						food_safe: false
					}
				];
				const hotPolymers = polymers.filter(elements => elements.melting_point > 113);
				for (let element of hotPolymers) {
					console.log(element.polymer);
				};
	
				// Show food safe polymers. 
				const foodSafePolymers = polymers.filter(elements => elements.food_safe === true);
				for (let element of foodSafePolymers) {
					console.log(element.polymer)
				};
	
				// Show polymers good for bottles.
				const bottlePolymers = polymers.filter(elements => (
					elements.uses.includes("bottles")
				));
				for (let element of bottlePolymers) {
					console.log(element.polymer)
				};
			</code>
		</pre>
		<pre class="language-bash"><code>
			polypropylene (PP)
			polyethylene terephthalate (PET)
			high-density polyethylene (HDPE)
			polystyrene

			polypropylene (PP)
			polyethylene terephthalate (PET)
			high-density polyethylene (HDPE)
			low-density polyethylene (LDPE)

			polyvinyl chloride (PVC)
			polyethylene terephthalate (PET)
			high-density polyethylene (HDPE)
			low-density polyethylene (LDPE)
		</code></pre>
		<p>
			<var>.filter()</var> is particularly useful for searching. Suppose we
			have a search feature, and when the user inputs a word in the text
			field, that input is used to search for a match.
		</p>

		<p>
			How do we implement this feature in JavaScript? We can use the
			<var>.filter()</var> method. To illustrate, let's use the same array
			from the preceding example. We want a user to input the polymer
			sought, then output the polymer. Once outputted, we perform the
			search.
		</p>
		<pre class="language-javascript">
			<code>
				const polymers = [
					{
						polymer: 'polyvinyl chloride (PVC)',
						melting_point: 100,
						uses: ['pipes', 'fencing', 'bottles', 'raincoats', 'toys'],
						food_safe: false
					},
					{
						polymer: 'polypropylene (PP)',
						melting_point: 130,
						uses: ['auto parts', 'food containers', 'dishware'],
						food_safe: true
					},
					{
						polymer: 'polyethylene terephthalate (PET)',
						melting_point: 260,
						uses: ['bottles', 'fleece', 'carpet'],
						food_safe: true
					},
					{
						polymer: 'high-density polyethylene (HDPE)',
						melting_point: 130.8,
						uses: ['bottles', 'containers', 'plastic bags'],
						food_safe: true
					},
					{
						polymer: 'low-density polyethylene (LDPE)',
						melting_point: 110,
						uses: ['bottles', 'toys', 'six pack rings', 'pipes'],
						food_safe: true
					},
					{
						polymer: 'polystyrene',
						melting_point: 270,
						uses: ['petri dishes', 'plastic cutlery'],
						food_safe: false
					}
				];
				// JavaScript receives the user's input, and we store it in a variable:
				let query = 'toys';
	
				// Then we do the search 
				// .filter is case sensitive, 
				// must make sure the user's input is all lower case.
				const results = polymers.filter(elements => {
					return elements.uses.includes(query.toLowerCase())
				});
	
				// Search returns the array with matching objects and their properties. 
				// Let's store the name of the matching polymers in a separate array:
				const resultPolymerNames = results.map(function (elements) {
					return elements.polymer;
				})
	
				// Check if it works:
				console.log(resultPolymerNames); 
			</code>
			<pre class="language-bash"><code>
				[ 'polyvinyl chloride (PVC)', 'low-density polyethylene (LDPE)' ]
			</code></pre>
		</pre>
	</section>

	<section id="every_method">
		<h3>The Every Method</h3>
		<p>
			The <var>.every()</var> method tests whether
			<span class="underlineText">all</span> of the elements in an array
			satisfy a condition, and returns a Boolean value (either true or
			false). Because the <var>.every()</var> method only returns Boolean
			values, it is called a <b>Boolean method</b>. The
			<var>.every()</var> method takes the following form:
		</p>
		<pre class="language-javascript">
			<code>
				const <span class="greyText">array-name</span> = [<span class="greyText italicsText">element-1</span>, <span class="greyText italicsText">element-2</span>, <span class="greyText italicsText">element-3</span>];
				<span class="greyText">array-name</span>.every(element => {
					<span class="greyText italicsText">test-condition</span>;
				});
			</code>
		</pre>
		<p>
			For example, suppose we had an array of shape names. We want to check
			if every word is more than four letters long:
		</p>
		<pre class="language-javascript"><code>
			const shapeNames = [
				'circle', 
				'square', 
				'rhombus', 
				'triangle', 
				'pentagon', 
				'hexagon', 
				'octagon'
			];
			const allWordsAreThree = shapeNames.every(
				word => word.length >= 4
			);
			console.log(allWordsAreThree);
		</code></pre>
		<pre class="language-bash"><code>
			true
		</code></pre>
		<p>
			Let's consider another example. We're conducting research on the
			history of science for certain metallic elements, and our researchers
			enter the names of the chemicals they worked on, which are then
			passed into an array. We want to make sure that every element entered
			by a researcher ends with "um" (all metallic elements discovered
			after 1811 have names ending in "um"). Suppose the inputs are passed
			into the array below:
		</p>
		<pre class="language-javascript">
			<code>
				const studiedElements = [
					'cadmium', 
					'lanthanum', 
					'lithium', 
					'thallium', 
					'radium', 
					'aluminum'
				];
				const testEndUm = studiedElements.every(element => {
					return element.includes('um') === true;
				});
				console.log(testEndUm);
			</code>
		</pre>
		<pre class="language-bash"><code>
			true
		</code></pre>
		<p>If we put "arsenic" in the array:</p>
		<pre class="language-javascript"><code>
			const studiedElements = ['cadmium', 'lanthanum', 'lithium', 'thallium', 'radium', 'aluminum', 'arsenic'];
			const testEndUm = studiedElements.every(element => {
				return element.includes('um') === true;
			});
			console.log(testEndUm);
		</code></pre>
		<pre class="language-bash"><code>
			false
		</code></pre>
	</section>

	<section id="some_method">
		<h3>The Some Method</h3>
		<p>
			The <var>.some()</var> method tests whether
			<span class="underlineText">at least one</span> element in an array
			satisfies a condition. The general syntax of the
			<var>.some()</var> method:
		</p>
		<pre class="language-javascript">
			<code>
				const <span class="greyText">array-name</span> = [<span class="greyText italicsText">element-1</span>, <span class="greyText italicsText">element-2</span>, <span class="greyText italicsText">element-3</span>];
				<span class="greyText">array-name</span>.some(element => {
					<span class="greyText italicsText">test-condition</span>;
				});									
			</code>
		</pre>
		<p>
			To illustrate, suppose we've made a piece of software, and we want to
			put it to a focus group. But we want to ensure that there is at least
			someone in the focus group that does not work in STEM. We start with
			an array of participants so far, with their data.
		</p>
		<p>
			We can check if the requirement is met with <var>some</var>. The test
			condition: Whether there is at least one element with a field that is
			not <var>'STEM'</var>.
		</p>
		<pre class="language-javascript">
			<code>
				const focusGroup = [
					{ participantID: '1432', field: 'STEM' },
					{ participantID: '8723', field: 'retail' },
					{ participantID: '9823', field: 'STEM' },
					{ participantID: '9242', field: 'STEM' },
					{ participantID: '7699', field: 'STEM' },
				];
				const groupTest = focusGroup.some(participant => {
					return participant.field !== 'STEM';
				});
				console.log(groupTest);
			</code>
		</pre>
		<pre class="language-bash"><code>
			true
		</code></pre>
		<p>If we remove the element with the field <var>'retail'</var></p>
		<pre class="language-javascript"><code>
			const focusGroup = [
				{ participantID: '1432', field: 'STEM' },
				{ participantID: '9823', field: 'STEM' },
				{ participantID: '9242', field: 'STEM' },
				{ participantID: '7699', field: 'STEM' },
			];
			const groupTest = focusGroup.some(participant => {
				return participant.field !== 'STEM';
			});
			console.log(groupTest);
		</code></pre>
		<pre class="language-bash"><code>
			false
		</code></pre>
		<p>
			<var>.sort()</var> is particularly useful with call back functions.
			Recall that the <var>.sort()</var> method, by default, converts
			numbers into their UTF codes (values of type string), and orders them
			alphabetically ascending. To review: In order to use execute the
			<var>.sort()</var> method on an array of numbers, such that the
			numbers are sorted according to their numeric values, we need to use
			a <b>compare function</b>. The <b>compare function</b> takes the
			form:
		</p>
		<pre class="language-javascript">
			<code>
				<span class="greyText italicsText">arrayName</span>.sort(<span class="greyText italicsText">compareFunc</span>(<span class="greyText italicsText">a</span>, <span class="greyText italicsText">b</span>))
			</code>
		</pre>
		<p>
			If <i>compareFunc</i>(<span class="italicsText">a</span>, <i>b</i>)
			returns a number less than 0, JavaScript sorts <i>a</i> before
			<i>b</i>. If <i>compareFunc</i>(<span class="italicsText">a</span>,
			<i>b</i>) returns 0, JavaScript leaves the order of <i>a</i> and
			<i>b</i> as is. If <i>compareFunc</i>(<span class="italicsText"
				>a</span
			>, <i>b</i>) returns a number greater than 0, JavaScript sorts
			<i>b</i> before <i>a</i>.
		</p>
		<p>Illustration:</p>
		<pre class="language-javascript">
			<code>
				const randomNums = [8.22, 9.32, 1.546, 14.321, 0.43, 2.334, 5.566, 7.89, 9.823, 14.234, 15.442];
				const ascendingSort = randomNums.sort((a, b) => a - b);
				console.log(ascendingSort);
				/*
				Output:
				[ 0.43, 1.546, 2.334, 5.566, 7.89, 8.22, 9.32, 9.823, 14.234, 14.321, 15.442 ]
				*/									
			</code>
		</pre>
		<p>
			Above, we sorted the numbers from least to greatest. But, we can also
			sort the numbers from greatest to least:
		</p>
		<pre class="language-javascript">
			<code>
				const randomNums = [8.22, 9.32, 1.546, 14.321, 0.43, 2.334, 5.566, 7.89, 9.823, 14.234, 15.442];
				const descendingSort = randomNums.sort((a, b) => b - a);
				console.log(descendingSort);
	
				/*
				Output:
				[ 15.442, 14.321, 14.234, 9.823, 9.32, 8.22, 7.89, 5.566, 2.334, 1.546, 0.43 ]
				*/									
			</code>
		</pre>
		<p>
			What did we do differently? We switched
			<i>b</i> and <i>a</i>.
		</p>
		<p>
			If we apply the
			<var>.sort()</var> method to an existing array, without any other
			code instructing JavaScript on what to do with the outputted array,
			the original array is changed.
		</p>
		<p>You can see this with the array from the example above:</p>
		<pre class="language-javascript">
			<code>
				const randomNums = [8.22, 9.32, 1.546, 14.321, 0.43, 2.334, 5.566, 7.89, 9.823, 14.234, 15.442];
				const descendingSort = randomNums.sort((a, b) => b - a);
				// If we display in the console the descending sorted array:
				console.log(descendingSort);
				/*
				Output:
				[ 15.442, 14.321, 14.234, 9.823, 9.32, 8.22, 7.89, 5.566, 2.334, 1.546, 0.43 ]
				*/
	
				// If we display in the console the original array, <i>randomNums</i>
				console.log(randomNums);
				/*
				Output: 
				[ 15.442, 14.321, 14.234, 9.823, 9.32, 8.22, 7.89, 5.566, 2.334, 1.546, 0.43 ]
				*/										
			</code>
		</pre>
		<p>
			There are several ways to prevent this from happening. One way is to
			make a separate variable containing the array to be sorted:
		</p>
		<pre class="language-javascript">
			<code>
				const randomNums = [8.22, 9.32, 1.546, 14.321, 0.43, 2.334, 5.566, 7.89, 9.823, 14.234, 15.442];
				const randomNumsDescending = [8.22, 9.32, 1.546, 14.321, 0.43, 2.334, 5.566, 7.89, 9.823, 14.234, 15.442]; 
				const descendingSort = randomNumsDescending.sort((a, b) => b - a);
				console.log(descendingSort);
				/*
				Output:
				[ 15.442, 14.321, 14.234, 9.823, 9.32, 8.22, 7.89, 5.566, 2.334, 1.546, 0.43 ]
				*/
				console.log(randomNums);
				/*
				Output: 
				[8.22, 9.32, 1.546, 14.321, 0.43, 2.334, 5.566, 7.89, 9.823, 14.234, 15.442]
				*/									
			</code>
		</pre>
		<p>
			Another way is to use a method to copy the data into a new array. For
			example, using the method
			<var>.slice()</var>:
		</p>
		<pre class="language-javascript">
			<code>
				const randomNums = [8.22, 9.32, 1.546, 14.321, 0.43, 2.334, 5.566, 7.89, 9.823, 14.234, 15.442];
				const descendingSort = randomNums.slice().sort((a, b) => b - a);
				console.log(descendingSort);
				/*
				Output: 
				[ 15.442, 14.321, 14.234, 9.823, 9.32, 8.22, 7.89, 5.566, 2.334, 1.546, 0.43 ]
				*/
				console.log(randomNums);
				/*
				Output:
				[ 8.22, 9.32, 1.546, 14.321, 0.43, 2.334, 5.566, 7.89, 9.823, 14.234, 15.442 ]
				*/										
			</code>
		</pre>
	</section>

	<section id="reduce_method">
		<h3>The Reduce Method</h3>
		<p>
			The <var>.reduce()</var> method takes an array of values, and
			<i>reduces</i> them down to a single value. The
			<var>.reduce()</var> method has the following syntax:
		</p>
		<pre class="language-javascript">
			<code>
				const <span class="greyText italicsText">arrayName</span> = [<span class="greyText italicsText">value1</span>, <span class="greyText italicsText">value2</span>, <span class="greyText italicsText">value3</span>];
				<span class="greyText italicsText">arrayName</span>.reduce((<span class="greyText italicsText">accumulator</span>, <span class="greyText italicsText">currentValue</span>) => {
					<span class="greyText italicsText">statements</span>;
				});
			</code>
		</pre>
		<p>
			The <var>.reduce()</var> method has two parameters: the
			<i>accumulator</i>, which stores the returned value from executing
			the method, and <i>currentValue</i>, the alias for each of the
			individual elements in the array. Here is an example of how this
			method works:
		</p>
		<pre class="language-javascript">
			<code>
				// Suppose we have an array of numbers:
				const nums = [3, 2, 4, 9, 11, 17];
				const reduceResult = nums.reduce((accumulator, currentValue) => {
					return accumulator + currentValue;
				});
				console.log(reduceResult);
				/*
				Output: 
				46
				*/									
			</code>
		</pre>
		<p>We can visualize what happens in this method with a table:</p>
		<figure>
			<table class="inheritance">
				<thead>
					<th>Iteration</th>
					<th>accumulator</th>
					<th>currentValue</th>
					<th>return</th>
				</thead>
				<tr>
					<td>first</td>
					<td><var>3</var></td>
					<td><var>2</var></td>
					<td>
						<var>return 3 + 2 = 5</var>
					</td>
				</tr>
				<tr>
					<td>second</td>
					<td><var>5</var></td>
					<td><var>4</var></td>
					<td>
						<var>return 5 + 4 = 9</var>
					</td>
				</tr>
				<tr>
					<td>third</td>
					<td><var>9</var></td>
					<td><var>9</var></td>
					<td>
						<var>return 9 + 9 = 18</var>
					</td>
				</tr>
				<tr>
					<td>fourth</td>
					<td><var>18</var></td>
					<td><var>11</var></td>
					<td>
						<var>return 18 + 11 = 29</var>
					</td>
				</tr>
				<tr>
					<td>fifth</td>
					<td><var>29</var></td>
					<td><var>17</var></td>
					<td>
						<var>return 29 + 17 = 46</var>
					</td>
				</tr>
				<tr>
					<td colspan="4">
						<var>return 46</var>
					</td>
				</tr>
			</table>
		</figure>
		<p>
			After the fifth call, the
			<var>.reduce()</var> method stops&mdash;it has gone through the
			entire array (which makes sense, since there are 5 indices in the
			array). Of course, we are not limited to addition, we can also use
			the <var>.reduce()</var> method with other operators:
		</p>
		<pre class="language-javascript">
			<code>
				// Suppose we have an array of numbers:
				const nums = [3, 2, 4, 9, 11, 17];
	
				const reduceResult = nums.reduce((accumulator, currentValue) => {
					return accumulator * currentValue;
				});
	
				console.log(reduceResult);
	
				/*
				Output: 
				40392
				*/									
			</code>
		</pre>
		<p>
			We can also use the
			<var>.reduce()</var> method for more complex computations:
		</p>
		<pre class="language-javascript">
			<code>
				// Suppose we have an array of prices:
				let prices = [1.24, 1.98, 1.46, 1.78, 2.01, 1.92, 2.03 ];
				// I want to find the highest price in the array:
				const peakPrice = prices.reduce((maxPrice, currentValue) => {
					if (currentValue > max) return currentValue;
					return max;
				});
				console.log(peakPrice);
				/*
				Output:
				2.03
				*/									
			</code>
		</pre>
		<p>This table demonstrates what happens in the code above:</p>
		<figure>
			<table class="inheritance">
				<thead>
					<th>Iteration</th>
					<th>maxPrice</th>
					<th>currentValue</th>
					<th>return</th>
				</thead>
				<tr>
					<td>first</td>
					<td><var>1.24</var></td>
					<td><var>1.98</var></td>
					<td>
						<ul class="nobullets">
							<li>
								<var>1.24 !> 1.98</var>
							</li>
							<li>
								<var>return 1.98</var>
							</li>
						</ul>
					</td>
				</tr>
				<tr>
					<td>second</td>
					<td><var>1.98</var></td>
					<td><var>1.46</var></td>
					<td>
						<ul class="nobullets">
							<li>
								<var>1.98 > 1.46</var>
							</li>
							<li>
								<var>return 1.98</var>
							</li>
						</ul>
					</td>
				</tr>
				<tr>
					<td>third</td>
					<td><var>1.98</var></td>
					<td><var>1.78</var></td>
					<td>
						<ul class="nobullets">
							<li>
								<var>1.98 > 1.78</var>
							</li>
							<li>
								<var>return 1.98</var>
							</li>
						</ul>
					</td>
				</tr>
				<tr>
					<td>fourth</td>
					<td><var>1.98</var></td>
					<td><var>2.01</var></td>
					<td>
						<ul class="nobullets">
							<li>
								<var>1.98 !> 2.01</var>
							</li>
							<li>
								<var>return 2.01</var>
							</li>
						</ul>
					</td>
				</tr>
				<tr>
					<td>fifth</td>
					<td><var>2.01</var></td>
					<td><var>1.92</var></td>
					<td>
						<ul class="nobullets">
							<li>
								<var>2.01 > 1.92</var>
							</li>
							<li>
								<var>return 2.01</var>
							</li>
						</ul>
					</td>
				</tr>
				<tr>
					<td>sixth</td>
					<td><var>2.01</var></td>
					<td><var>2.03</var></td>
					<td>
						<ul class="nobullets">
							<li>
								<var>2.01 !> 2.03</var>
							</li>
							<li>
								<var>return 2.03</var>
							</li>
						</ul>
					</td>
				</tr>
				<tr>
					<td colspan="4">
						<var>return 2.03</var>
					</td>
				</tr>
			</table>
		</figure>
		<p>
			We can write the above code more concisely with the
			<var>Math.max()</var> method and an implicit return:
		</p>
		<pre class="language-javascript">
			<code>
				let prices = [1.24, 1.98, 1.46, 1.78, 2.01, 1.92, 2.03 ];
				const peakPrice = prices.reduce((maxPrice, currentValue) => (
					Math.max(maxPrice, currentValue)
				));
				console.log(peakPrice);
				/*
				Output:
				2.03
				*/							
			</code>
		</pre>
		<p>
			We can also pass an initial value (the starting value) for the
			<var>.reduce()</var> method to start with (i.e., maybe we want to
			start the method with a value not in the array); to do so, we use the
			following syntax:
		</p>
		<pre class="language-javascript">
						<code>
							<span class="greyText italicsText">arrayName</span>.reduce((accumulator, currentValue) => {
								<span class="greyText italicsText">statements</span>;
							}, <span class="greyText italicsText">initialValue</span>)
						</code>
					</pre>
		<p>For example:</p>
		<pre class="language-javascript">
			<code>
				let prices = [1.24, 1.98, 1.46, 1.78, 2.01, 1.92, 2.03];
				// I want to check if there's a price in the array below 1.19:
				const peakPrice = prices.reduce((minPrice, currentValue) => {
					return Math.min(minPrice, currentValue);
				}, 1.19);
				console.log(peakPrice);
				/*
				Output:
				1.19
				*/
				// This means there isn't any price in the array below 1.19
			</code>
		</pre>
	</section>

	<section id="function_calls_spread">
		<h3>Function Calls: Spread</h3>
		<p>
			The <b>spread syntax</b> <var>(...)</var> allows us to expand an
			iterable (e.g., an array or string) in places where zero or more
			arguments or elements are expected, or to expand an object expression
			in places where zero or more properties are expected. Put simply,
			<i>spread</i> allows us to expand an iterable or object expression
			into other places.
		</p>
		<p>
			When <i>spread</i> is used for a function call, it expands an
			iterable into a list of arguments. To be more explicit, consider the
			code below:
		</p>
		<pre class="language-javascript"><code>
				// Say we have an array of numbers:
	
				const arrNums = [13, 5, 9, 11, 3, 2, 18, 17, 1, 6, 0];
	
				// How do we find the maximum value in this array? One way is to use the Math.max method:
	
				let arrNumsMax = Math.max(arrNums);
				console.log(arrNumsMax);
	
				// Problem? It outputs 'NaN'
				// This is because we passed an array's reference into Math.max as an argument, and the Math.max method only takes numbers.
				// Thus, to get around this problem, we need to pass each of the numbers into the method:
	
				let arrNumsMax2 = Math.max(13, 5, 9, 11, 3, 2, 18, 17, 1, 6, 0);
				console.log(arrNumsMax2); // Output: 18
	
				// But, this is far too tedious, and it does not work well when we have hundreds or thousands of arrays. 
				// This is a perfect use case for spread:
				let arrNumsSpread = Math.max(...arrNums);
				console.log(arrNumsSpread) // Output: 18								
			</code></pre>
		<p>
			We can also use <i>spread</i> to create a new array with existing
			arrays. When this is done, the <i>spread syntax</i> takes the
			elements from the existing array, and places them into a new array.
		</p>
		<pre class="language-javascript"><code>
			// We have contractors bidding for a government contract, and we have arrays of their bid prices, corresponding to different days:
			const day1_bids = [3.23, 4.32, 5.32, 5.99, 6.17, 7.88, 7.90, 7.98];
			const day2_bids = [8.15, 8.82, 9.01, 9.05, 9.15, 10.23, 10.25, 10.26];
			const day3_bids = [10.27, 10.29, 11.23, 11.32, 11.35, 11.52, 12.95];
			// We want to create one large array of all of these bid prices. We can do so with the spread syntax:
			const bids = [...day1_bids, ...day2_bids, ...day3_bids];
			console.log(bids);
			/*
			Output:
			[
			3.23,  4.32,  5.32,  5.99,
			6.17,  7.88,   7.9,  7.98,
			8.15,  8.82,  9.01,  9.05,
			9.15, 10.23, 10.25, 10.26,
			10.27, 10.29, 11.23, 11.32,
			11.35, 11.52, 12.95
			]
			*/								
		</code></pre>
		<p>
			Note: The <i>spread syntax</i>, used in this way, is not doing
			anything we have already been able to do. The above can be similarly
			accomplished with the <var>.concat</var> method. <i>Spread</i> is
			more useful when we want to make a copy of an array:
		</p>
		<pre class="language-javascript"><code>
				// an array of ages:
				const age = [23, 34, 29, 19, 36, 15, 42];
				// a copy of the array:
				const ageCopy = [...age];
				console.log(ageCopy);
				/*
				Output:
				[ 23, 34, 29, 19, 36, 15, 42 ]
				*/								
			</code></pre>
		<p>
			Note that the above does not work for arrays containing arrays or
			objects. They will not be cloned. While not a common operation,
			<i>spread</i> can also be used to separate the characters in a string
			as individual elements in an array:
		</p>
		<pre class="language-javascript"><code>
			let greeting = "hello";
			let helloCharacters = [...greeting];
			console.log(helloCharacters);								
		</code></pre>

		<section id="spread_object_literals">
			<h4>Using Spread Syntax with Object Literals</h4>
			<p>
				We can also use the
				<i>spread syntax</i> to copy properties from one
				<i>object literal</i> into another <i>object literal</i>.
			</p>
			<pre class="language-javascript"><code>
				// Here are objects with some properties:
				const gas = { volume: 'indefinite', compressibility: 'easy', flow: 'easy' };
				const liquid = { volume: 'indefinite', compressibility: 'difficult', flow: 'easy' };
				const solid = { volume: 'definite', compressibility: 'difficult', flow: 'difficult' };
				// We're given an element, and we want to add the properties above to the element. 
				const hydrogen = { ...liquid };
				const sulfur = { ...solid };
				const xenon = { ...gas };
				console.log(hydrogen);
				console.log(sulfur);
				console.log(xenon);
				/*
				Output:
				{ volume: 'indefinite', compressibility: 'difficult', flow: 'easy' }
				{ volume: 'definite', compressibility: 'difficult', flow: 'difficult' }
				{ volume: 'indefinite', compressibility: 'easy', flow: 'easy' }
				*/								
			</code></pre>
			<p>We can also add properties on top of copying a property:</p>
			<pre class="language-javascript"><code>
				const gas = { volume: 'indefinite', compressibility: 'easy', flow: 'easy' };
				const liquid = { volume: 'indefinite', compressibility: 'difficult', flow: 'easy' };
				const solid = { volume: 'definite', compressibility: 'difficult', flow: 'difficult' };
		
				const cerium = {
					...solid,
					atomic_number: 58,
					melting_point: 1068
				};
				console.log(cerium);
				/*
				Output:
				{
				volume: 'definite',
				compressibility: 'difficult',
				flow: 'difficult',
				atomic_number: 58,
				melting_point: 1068
				}
				*/								
			</code></pre>
			<p>
				Remember, order matters for when we copy properties (or elements)
				from an object (or array). So, for example:
			</p>
			<pre class="language-javascript"><code>
				const gas = { volume: 'indefinite', compressibility: 'easy', flow: 'easy' };
				const liquid = { volume: 'indefinite', compressibility: 'difficult', flow: 'easy' };
				const solid = { volume: 'definite', compressibility: 'difficult', flow: 'difficult' };
		
				// For the object "astatine", I want to copy all of the elements for solid, but set volume to 'indefinite'
				const astatine = {
					...solid,
					volume: 'indefinite'
				};
				console.log(astatine);
				/*
				Output:
				{
				volume: 'indefinite',
				compressibility: 'difficult',
				flow: 'difficult'
				}
				*/								
			</code></pre>
			<p>
				The above example shows that we can both copy properties and change
				the copied properties, at the same time. When an object is copied
				with
				<i>spread</i> into another, new object, the result is two different
				objects. This means that the objects, while possibly identical in
				that they contain the same data, have difference <i>references</i>,
				and as such, are treated as unique and different entities by
				JavaScript. Just like nested arrays, the <i>spread syntax</i> will
				not work as a way to copy an object if the object itself contains
				objects. Furthermore, you cannot <i>spread</i> an object directly
				into an array (but you can spread an object into an object in an
				array). The <i>spread syntax</i> only applies to spreading objects
				into objects. This also means that you cannot <i>spread</i> an
				object into a function or method that can only operate on an
				iterable (since objects themselves are not iterables).
			</p>
		</section>
	</section>

	<section id="rest_syntax">
		<h3>Rest Syntax</h3>
		<p>
			The <i>Rest syntax</i> looks like the <i>Spread syntax</i>, but
			rather than spreading data, it <i>collects</i> data into
			<span class="underlineText">a single array</span>. To see how this
			syntax works, consider a problem we have with the functions we've
			written so far:
		</p>
		<pre class="language-javascript"><code>
			// Suppose we want to write a function that computes the sum of numbers passed through it.
			// The problem: the function only works for the parameters we give it:
			function sum(a, b) {
				return a + b;
			}
			console.log(sum(2, 3)); // Works fine. Output: 5
			console.log(sum(1, 3, 5, 8)); // Does not work. Output: 5 4
			// So, if we wanted to sum more numbers, we'd have to add more parameters:
			function sum2(a, b, c, d,) {
				return a + b + c + d;
			}
			// But even then, we can only sum a quantity of numbers equal to the quantity of parameters provided.	
		</code></pre>
		<p>
			One way to get around the problem above is to use the
			<i>arguments object</i>, which is an object available inside every
			function we write.
		</p>
		<pre class="language-javascript"><code>
			// Using the arguments object:
			function sum() {
				let total = 0;
				for (let i = 0; i < arguments.length; i++) {
					total += arguments[i];
					return total;
				}
			};
			console.log(sum(1, 2, 4, 2, 9)); // Output: 18
			console.log(sum(1, 3)); // Output: 4								
		</code></pre>
		<p>
			The <i>arguments object</i> is
			<span class="underlineText">not</span> an array, but it is an
			<i>array-like</i> object. It has a <var>.length</var> property, but
			methods like <var>.push()</var> and <var>.pop()</var> will not work
			on it. In essence, the
			<i>arguments object</i>
			contains all of the arguments passed into the function. You see the
			arguments object by displaying in the console the name
			<var>arguments</var>:
		</p>
		<pre class="language-javascript"><code>
			function displayArguments() {
				console.log(arguments);
			}
			
			displayArguments(3, 4, 0, 2, 1);
			/*
			Output:
			[Arguments] { '0': 3, '1': 4, '2': 0, '3': 2, '4': 1 }
			*/								
		</code></pre>
		<p>
			Be very cognizant of this point: the
			<var>arguments</var> object
			<span class="underlineText">is not an array</span>. Consider the
			following:
		</p>
		<pre class="language-javascript"><code>
			// Suppose we write our sum function using an arguments object and the reduce method:
			function sum() {
				return arguments.reduce((total, currentValue) => {
					return total + currentValue;
				})
			}
	
			console.log(sum(2, 3, 6));
			/*
			Output:
			TypeError: arguments.reduce is not a function
			*/
			// We're getting this error because the .reduce method only works on arrays, and the argument object is NOT an array.		
		</code></pre>
		<p>
			To get around the problem above, one way is to turn the
			<var>arguments</var> object into an array:
		</p>
		<pre class="language-javascript"><code>
			function sum() {
				const argsArray = [...arguments]; // Use the spread method to turn the arguments object into an array
				return argsArray.reduce((total, currentValue) => {
					return total + currentValue;
				})
			};
			console.log(sum(2, 3, 6)); // Output: 11								
		</code></pre>
		<p>
			There is no
			<i>arguments object</i>
			inside arrow functions. Instead of using the
			<var>arguments</var> objects, we can use the <i>rest syntax</i>:
		</p>
		<pre class="language-javascript"><code>
			function <span class="greyText italicsText">functionName</span>(...<span class="greyText italicsText">parameters</span>) {
				return <span class="greyText italicsText">statements</span>
			};
		</code></pre>
		<p>
			The <i>rest syntax</i> collects all of the arguments into a single
			array that can then be used in the function's body.
		</p>
		<pre class="language-javascript"><code>
			// We can see the rest syntax's resulting array with the console:
			function showRest(...elements) {
				return console.log(elements)
			};
			showRest(2, 4, 9, 11);
			/*
			Output:
			[ 2, 4, 9, 11 ]
			*/								
		</code></pre>
		<p>
			With the <i>rest syntax</i>, we can write our sum function more
			concisely without using the <var>arguments</var> object:
		</p>
		<pre class="language-javascript"><code>
				function sum(...nums) {
					return nums.reduce((total, currentValue) => {
						return total + currentValue
					})
				};
				console.log(sum(4, 3, 5, 11, 17, 92)); // Output: 132
		</code></pre>
		<p>A more complex example:</p>
		<pre class="language-javascript"><code>	
			// Here is a function that returns a factorial in an array for any number we pass through to it:
			function factorialResults(...nums) {
				return nums.map(function (num) {
					let result = num;
					if (num === 0 || num === 1) {
						return 1; // the factorials of 0 or 1 are special cases
					}
					while (num > 1) { // for everything else, do this
						num--;
						result *= num;
					}
					return result;
				});
			}
			console.log(factorialResults(3, 2, 5, 9)); // Output: [ 6, 2, 120, 362880 ]
			console.log(factorialResults(3)); // Output: [ 6 ]												
		</code></pre>
		<p>
			We can also use the <i>rest syntax</i> to collect all of the
			remaining arguments passed through to a function that have not been
			matched to a parameter:
		</p>
		<pre class="language-javascript"><code>
			// So for example, say we have a function that takes two arguments:
			function nameGenerator(firstName, lastName, ...remains) {
				return console.log(
					`In Japanese, your name would be ordered: ${lastName}, ${firstName} san. "${remains}" ignored.`
				)
			};
			// When we run the function:
			nameGenerator('Sherlock', 'Holmes', 'III', 'Jr.');
			/*
			Output: 
			In Japanese, your name would be ordered: Holmes, Sherlock san. "III,Jr." ignored.
			*/								
		</code></pre>
	</section>
</section>

<section id="functional_programming">
	<h2>Functional Programming</h2>
	<p>
		JavaScript supports functional programming. Below, we present some of
		the more common techniques and designs for functional programming.
		Importantly, we should bear in mind that JavaScript was not designed
		for functional programming. It merely supports it. Thus, like any other
		programming style, we should use functional programming when it's
		suitable for solving a given problem.
	</p>
	<p>
		In examining the following functional programming techniques, it's
		helpful to be cognizant of a few functional programming principles:
	</p>
	<ol class="numd">
		<li>Avoid side-effects.</li>
		<li>Avoid mutation.</li>
		<li>Avoid shared state.</li>
		<li>Use pure functions.</li>
		<li>Use function composition.</li>
		<li>Use declarative code instead of imperative code.</li>
	</ol>
	<p>Let's see some examples of these principles.</p>

	<section id="side_effects">
		<h3>Avoiding Side-effects</h3>
		<p>
			A <b>side-effect</b> is a phenomenon where a procedure changes a
			variable from outside the variable's scope. For example, consider the
			following code:
		</p>
		<pre class="language-javascript"><code>
			let count = 0;
			console.log(count);
			const increment = function () { 
				count++;
				return count;
			}
			increment();
			console.log(count);
		</code></pre>
		<pre class="language-bash"><code>
			0
			1
		</code></pre>
		<p>
			Before the function <var>increment()</var> is called, the variable
			<var>count</var> is bound to the value <var>0</var>. After invoking
			<var>increment()</var>, however, the variable <var>count</var> is now
			<var>1</var>. Modifying <var>count</var> is a side-effect. The
			variable <var>count</var> exists outside the scope of
			<var>increment()</var>, but writing the code above, we've modified
			<var>count</var> from inside <var>increment()</var>'s scope.
		</p>
		<p>
			From a functional programming perspective, this is unnecessary
			danger. The variable <var>count</var> could very well be used by
			hundreds, if not thousands, of modules. The single line
			<var>count++</var> has now changed how all of those modules behave.
			The more we use side-effects, the more unpredictable our programs
			are, and the more unpredictable, the more difficult it is to reason
			about our code.
		</p>
		<p>
			For example, given the code below, how certain are we that the
			console will display <var>1 1 1</var>?
		</p>
		<pre class="language-javascript"><code>
			let x = 1;
			f1();
			console.log(x);
			f2();
			console.log(x);
			f3();
			console.log(x);
		</code></pre>
		<p>
			Given what we saw earlier, the intuitive answer is: It depends on
			what the functions <var>f1()</var>, <var>f2()</var>, and
			<var>f3()</var> do. This <q>it depends</q> answer is precisely what
			we want to avoid. By avoiding side-effects, we can be certain that
			<var>console.log(x)</var> will <em>always</em> display <var>1</var>.
		</p>
		<p>
			That said, we can rewrite the earlier <var>increment()</var> function
			to avoid side-effects:
		</p>
		<pre class="language-javascript"><code>
			let count = 0;
			console.log(count);
			let increment = function(n) { 
				return n + 1;
			} 
			let countIncremented = increment(count);
			console.log(count);
			console.log(countIncremented);
		</code></pre>
		<pre class="language-bash"><code>
			0
			0
			1
		</code></pre>
		<p>
			Writing the function above, we now have <b>pure function</b> &mdash;
			a function with no side-effects. Here's another pure function:
		</p>
		<pre class="language-javascript"><code>
			let weights = [248, 260, 187, 199];
			const average = function (arr) {
				const size = arr.length;
				let sum = 0;
				for (let i = 0; i < size; i++) {
					sum += arr[i];
				}
				return (sum / size);
			};
			const weightsAverage = average(weights);
			console.log(weightsAverage);
		</code></pre>
		<pre class="language-bash"><code>
			223.5
		</code></pre>
		<p>
			Because the function <var>average()</var> does not modify any
			variable outside of its scope, it qualifies as a pure function. Now,
			inside the function, we have mutation, but this does not necessarily
			prevent a function from qualifying as a pure function. Mutation is a
			separate issue. So long as the function has no side-effects, it
			qualifies as a pure function. Otherwise, it's an
			<b>impure function</b>. More specifically, a pure function is a
			function that satisfies the following criteria:
		</p>
		<ol class="checklist">
			<li>
				The function depends on the input provided and not on changing
				external data.
			</li>
			<li>
				The function does not cause side effects. I.e., it does not affect
				changes beyond its scope.
			</li>
			<li>
				The function <em>always</em> returns the same output for a
				specified input.
			</li>
		</ol>
		<p>
			In programs that do not employ functional programming, the most
			common side-effects are the following:
		</p>
		<figure>
			<ul>
				<li>
					Changing a value globally, whether that value is bound to a
					variable, property, or data structure.
				</li>
				<li>Changing the original value of a function's argument.</li>
				<li>Throwing an exception.</li>
				<li>Print to the screen or logging.</li>
				<li>Triggering an external process.</li>
				<li>Invoking other functions with side-effects.</li>
			</ul>
		</figure>
		<p>
			Notice that some of the points above are routine and common
			practices. Indeed, programming without any side-effects whatsoever is
			stiff and unnecessary. Functional programming isn't intended to
			abolish side-effects entirely &mdash; it's intended to manage them.
			When we follow functional programming, we try to
			<i>avoid</i> side-effects. And if we can't avoid side-effects, then
			we try to <i>isolate</i> the side-effects. And if that doesn't work,
			then we try to isolate the impure functions.
		</p>
	</section>

	<section id="avoiding_shared_state">
		<h3>Avoiding Shared State</h3>
	</section>
</section>

<section id="functions_are_objects">
	<h2>Functions Are Objects</h2>
	<p>
		With a greater understanding of functions, we can now study functions
		more deeply. To begin, functions are inherently
		<i>objects</i>. And because functions are objects, we can attach
		properties to functions. All functions have two special properties that
		separate them from other objects: (1) <var><mark>Code</mark></var> and
		(2) <span class="monoText"><mark>Call</mark></span
		>. The <var>Code</var> property contains all of the lines of code that
		the function object will execute. The <var>Call</var> property
		determines whether the function can be called.
	</p>
</section>

{% endblock %}
