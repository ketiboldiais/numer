{% extends '../layout.html' %} {% load static %} {% block description %}
<meta
	name="description"
	content="What is the DOM in JavaScript? An overview of the Document Object Model."
/>
{% endblock %} {% block title %}
<title>The DOM</title>
{% endblock %} {% block content %}
<h1>The Document Object Model (DOM)</h1>
<section id="intro">
	<p>
		<span class="drop">J</span>avaScript is synonymous with web
		development. But how exactly does it generate dynamic web pages? The
		answer is through the <b>Document Object Model</b> (&#8220;DOM&#8221;).
		In this section, we explore how the DOM works, as well as the various
		ways we link JavaScript, HTML, and CSS.
	</p>
	<p>
		To begin, the examples below are based on three separate files:
		<var>lab.html</var>, <var>app.js</var>, and <var>styles.css</var>.
		These files are all within the same directory:
	</p>
	<figure class="math-display">
		<div>
			<pre class="language-pseudo"><code>
				.
				├── lab.html
				├── app.js
				└── styles.css
			</code></pre>
		</div>
	</figure>
	<p>
		The <var>styles.css</var> and <var>app.js</var> files do not contain
		anything for now. The <var>lab.html</var> file, however, contains the
		following code:
	</p>
	<pre class="language-html"><code>
		&lt;!DOCTYPE html&gt;
		&lt;html lang=&quot;en&quot;&gt;
		&lt;head&gt;
		&#x9;&lt;meta charset=&quot;UTF-8&quot;&gt;
		&#x9;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
		&#x9;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
		&#x9;&lt;title&gt;Lab&lt;/title&gt;
		&#x9;&lt;link rel=&quot;stylesheet&quot; href=&quot;./styles.css&quot;&gt;
		&lt;/head&gt;
		&lt;body&gt;
		&#x9;&lt;main&gt;
		&#x9;&#x9;&lt;h1&gt;H1 Tag&lt;/h1&gt;
		&#x9;&#x9;&lt;p&gt;Paragraph tag&lt;/p&gt;
		&#x9;&#x9;&lt;ul&gt;
		&#x9;&#x9;&#x9;&lt;li&gt;List item 1&lt;/li&gt;
		&#x9;&#x9;&#x9;&lt;li&gt;List item 2&lt;/li&gt;
		&#x9;&#x9;&#x9;&lt;li&gt;List item 3&lt;/li&gt;
		&#x9;&#x9;&lt;/ul&gt;
		&#x9;&lt;/main&gt;
		&#x9;&lt;script src=&quot;./app.js&quot;&gt;&lt;/script&gt;
		&lt;/body&gt;
		&lt;/html&gt;
	</code></pre>
	<p>
		Note that the following discussion assumes basic knowledge of HTML and
		CSS. If the syntax above or CSS is entirely foreign, we recommend
		looking up a few basic tutorials on HTML and CSS.
	</p>
</section>

<section id="what_is_the_dom">
	<h2>What is the DOM?</h2>
	<p>
		The DOM is a a representation of a document's structure.<sup></sup>
		While the DOM has grown synonymous with JavaScript, it's not exclusive
		to browsers. Server side programs may also utilize the program.
	</p>
	<div class="note">
		<p>
			For the specification,
			<a href="https://dom.spec.whatwg.org/" target="_blank"
				><i>see</i> <em>DOM Living Standard</em>.</a
			>
		</p>
	</div>
	<p>
		The DOM is implemented as a <b>node tree</b>. From a very high-level
		overview, when the browser loads an HTML document, the browser takes
		all of the HTML elements and returns JavaScript objects. Each of these
		objects is a <b>node</b> on the tree. Some of the nodes have children.
		These nodes are called <b>branch nodes</b>, because they have
		<b>branches</b> to other nodes. Other nodes do not have children, in
		which case they are called <b>leaves</b>.
	</p>
	<p>
		Because each node in the tree is represented as a JavaScript object, we
		can interact with them via JavaScript. Hence, the DOM is simply an
		interface for interacting with HTML documents. For example, given the
		following HTML code:
	</p>
	<pre class="language-html"><code>
		&lt;html&gt;
			&lt;head&gt;
				&lt;title&gt;My Webpage&lt;/title&gt;
			&lt;/head&gt;
			&lt;body&gt;
			&#x9;&lt;h1&gt;Heading&lt;/h1&gt;
			&#x9;&lt;ul&gt;
			&#x9;&#x9;&lt;li&gt;List Item 1&lt;/li&gt;
			&#x9;&#x9;&lt;li&gt;List Item 2&lt;/li&gt;
			&#x9;&lt;/ul&gt;
			&lt;/body&gt;
		&lt;/html&gt;
	</code></pre>
	<p>
		The browser generates a node tree whose nodes are the HTML elements
		represented as objects:
	</p>
	<figure>
		<img
			src="{% static 'images/domTree.svg' %}"
			alt="The DOM Tree Object"
			loading="lazy"
			class="thirty-p"
		/>
	</figure>
	<p>
		The root node is the <var>html</var> element. It is from this node that
		we have all the other nodes: <var>body</var>, <var>h1</var>,
		<var>ul</var>, <var>li</var>, etc. These nodes are all objects. Each
		node has either a <b>parent</b>, <b>children</b>, or both. For example,
		the <var>html</var> element has two children, <var>head</var> and
		<var>body</var>. <var>head</var> has one child, the
		<var>title</var> element.
	</p>
	<p>
		Again, all of these are objects, and the entire node tree is an object.
		Roughly, the tree above looks something like:
	</p>
	<figure class="math-display">
		<div>
			<pre class="language-pseudo"><code>
				Window: {
					document: {
						html: {
							head: {
								title: { innerText: "My Webpage" }
							},
							body: {
								h1: { innerText: "Heading" },
								ul: {
									li: { innerText: "List Item 1" },
									li: { innerText: "List Item 1" }
								}
							}
						}
					}
				}
			</code></pre>
		</div>
	</figure>
	<p>
		The root of the tree is the <b>document object</b>. We can think of the
		document object as the entry point to the rest of the tree. If we run
		<var>console.dir(document)</var> on an HTML page, we can see an entire
		representation of the document (the output is omitted here because of
		its length, but do try it).
	</p>
	<p>
		The above gives us a better sense of what the DOM is. If we wanted to
		see what it actually looks like, open a console on a webpage, and run
		<var>console.log(this)</var>. The rough outline above omits most of
		what's actually contained in the tree &mdash; the DOM contains numerous
		properties and methods.
	</p>
	<p>
		Each of the objects have properties. In the example above, the
		<var>h1</var> object has a property called <var>innerText</var>. Here,
		that property is bound to the value <var>"Heading"</var>, a string.
		These objects all contain numerous properties: Styles, content,
		children, parents, etc. With JavaScript, we can modify these
		properties. We can also create and delete nodes on the tree,
		effectively adding new elements and removing existing ones from the
		HTML document. This discussion reveals a key insight to developing web
		pages with JavaScript: Whenever we use JavaScript to affect changes on
		a webpage, we are really manipulating the leaves and branches in a
		tree.
	</p>
	<p>
		Importantly, there's a distinction between
		<i>elements</i> and <i>nodes</i> in the DOM. All HTML tags constitute
		<i>element nodes</i>. An element node can have children, which may or
		may not be element nodes. For example, the <var>detail</var> tag can
		have a <var>summary</var> element node as a child, but it can also have
		the <i>attribute node</i> <var>open</var>. Similarly, the
		<var>p</var> tag is represented as an element node, but it can also
		have as a child node an <var>a</var> element node, as well as a
		<i>text node</i>.
	</p>
</section>

<section id="targeting_elements">
	<h2>DOM Getters</h2>
	<p>
		From the JavaScript perspective, an HTML page is just one giant object.
		More specifically, a giant tree. Accordingly, to manipulate HTML pages,
		we manipulate the DOM tree's nodes. The first step to doing so is to
		select, or target, nodes in the tree. We can think of these as being
		akin to
		<b>getters</b> in other OOP languages. This is done by using methods
		provided by the DOM. To get started, the HTML and CSS files we're
		working with look like this:
	</p>

	<pre class="language-html"><code>
			&lt;!DOCTYPE html&gt;
			&lt;html lang=&quot;en&quot;&gt;
			&lt;head&gt;
			&#x9;&lt;title&gt;Lab&lt;/title&gt;
			&#x9;&lt;link rel=&quot;stylesheet&quot; href=&quot;./styles.css&quot;&gt;
			&lt;/head&gt;
			&lt;body&gt;
			&#x9;&lt;main&gt;
			&#x9;&#x9;&lt;h1 class=&quot;redText&quot;&gt;H1 Tag&lt;/h1&gt;
			&#x9;&#x9;&lt;p id=&quot;firstP&quot;&gt;Paragraph tag&lt;/p&gt;
			&#x9;&#x9;&lt;ul class=&quot;firstList&quot;&gt;
			&#x9;&#x9;&#x9;&lt;li&gt;List item 1&lt;/li&gt;
			&#x9;&#x9;&#x9;&lt;li&gt;List item 2&lt;/li&gt;
			&#x9;&#x9;&#x9;&lt;li&gt;List item 3&lt;/li&gt;
			&#x9;&#x9;&lt;/ul&gt;
			&#x9;&lt;/main&gt;
			&#x9;&lt;script src=&quot;./app.js&quot;&gt;&lt;/script&gt;
			&lt;/body&gt;
			&lt;/html&gt;
		</code></pre>
	<pre class="language-css"><code>
			main { 
				font-family: sans-serif; 
			}
			.redText { 
				color: red; 
			}
		</code></pre>

	<p>Here is an API for targetting the various nodes in the tree:</p>
	<figure>
		<table class="api">
			<thead>
				<th>Method</th>
				<th>Meaning</th>
				<th>Comments</th>
			</thead>
			<tbody>
				<tr>
					<td colspan="3" style="font-family: var(--serif)">
						Where ${obj}$ is some object in the DOM (e.g.,
						<var>document</var>, <var>ul</var>, <var>section</var>,
						<var>div</var>, etc.):
					</td>
				</tr>
				<tr>
					<td><var>${obj}$.getElementById(${s}$)</var></td>
					<td>
						Where ${v}$ is a string, returns the HTML element with the
						matching
						<var>id</var> attribute with value ${s.}$ If no match is found,
						the return value is <var>null</var>.
					</td>
					<td>By &#8220;HTML element&#8221;, we mean an object.</td>
				</tr>
				<tr>
					<td>
						<var>${obj}$.getElementsByTagName(${s}$)</var>
					</td>
					<td>
						Where ${s}$ is a string, returns an
						<a href="#html_collection"><var>HTMLCollection</var></a>
						of all the elements with the tag name ${s.}$
					</td>
					<td>
						The <var>HTMLCollection</var> looks like an array, but it is
						not an array.
					</td>
				</tr>
				<tr>
					<td>
						<var>${obj}$.getElementsByClassName(${s}$)</var>
					</td>
					<td>
						Where ${s}$ is a string, returns an
						<var>HTMLCollection</var>
						of all the elements with the class name ${s.}$ If no match is
						found, an empty
						<var>HTMLCollection</var>
						is returned.
					</td>
					<td><i>Supra above cell.</i></td>
				</tr>
				<tr>
					<td><var>${obj}$.querySelector(${s}$)</var></td>
					<td>
						Where ${s}$ is a string, returns the
						<span class="underlineText">first</span> element with the
						attribute, class, or element name with the string. If ${s}$ is
						written as a CSS selector, then the method will evalute
						according to the selector. For example,
						<var>document.querySelector('#red')</var> will select the first
						element with the <var>id</var> attribute of value
						<var>'red'</var>.
						<var>document.querySelector('.green')</var> will select the
						first element swith the <var>class</var> attribute set to
						<var>'green'</var>.
					</td>
					<td>
						Essentially an all-in-one method for the other methods above.
						Note that only the
						<span class="underlineText">first</span> match is returned.
						Other matches will not be returned. We can get very creative
						with this method.
						<var>querySelector('div li.big')</var>
						will return the first <var>li</var> element in main a
						<var>div</var> element with the class <var>big</var>. Some
						useful CSS combinators to be aware of:
						<span class="blueText monoText">'${a}$ ${b}$'</span> targets
						the <i>descendants</i> of ${a}$ that are ${b.}$
						<span class="blueText monoText">${a}$ > ${b}$</span> targets
						the <i>children</i> of ${a}$ that are ${b.}$
						<span class="blueText monoText">${a}$ + ${b}$</span> targets
						the adjacent siblings of ${a}$ that are ${b}$ (i.e., select the
						element ${b,}$ which is right after the element ${a}$ on the
						same level).
						<span class="blueText monoText">${a}$ ~ ${b}$</span> targets
						all the siblings after ${a}$ that are ${b.}$
						<var>${a}$[${r}$=${s}$]</var> targets the element ${a}$ with
						the attribute ${r}$ set to the value ${s.}$
					</td>
				</tr>
				<tr>
					<td><var>${obj}$.querySelectorAll(${s}$)</var></td>
					<td>
						Similar operation as <var>querySelector()</var>, but returns a
						<var><a href="">nodeList</a></var> containing
						<span class="underlineText">all</span> the elements matching
						${s.}$
					</td>
					<td>
						<i>Supra above cell.</i> CSS selectors, as string values, can
						be passed as arguments.
					</td>
				</tr>
			</tbody>
		</table>
	</figure>
	<p>
		In the selection methods above, we used the form
		<var>document.${m}$</var>, where ${m}$ is the selection method. We can,
		however, narrow the scope of our selection search by referencing a
		particular node within the document. For example,
		<var>document.element.${m}$</var> will limit the selection search to
		the children of the <var>html</var> element node. The same goes for
		<var>document.head</var> and <var>document.body</var>.
	</p>

	<section id="arrays_and_iterables">
		<h2>DOM Data Structures: Arrays v. Iterables</h2>
		<p>
			Many of the DOM methods return data structures rather than simple
			data. For example, <var>HTMLCollection</var> and <var>NodeList</var>.
			To understand what these data structures are, it's worth revisiting
			arrays and exploring the idea of an <i>iterable</i>. We haven't
			discussed protocols yet, but we can think of the
			<var>iterable</var> protocol as a set of requirements that define
			what constitutes an iterable. Any object that satisfies those
			requirements constitutes an iterable.<sup></sup> If a single
			requirement is not met, however, the object does not constitute an
			iterable. If the object is an iterable, then we can iterate through
			the object with a for-of loop.
		</p>
		<div class="note">
			<p>
				An <b>iterable</b> is any object that implements the
				<var>iterable</var> protocol.
			</p>
		</div>
	</section>

	<section id="html_collection">
		<h3>HTML Collections</h3>
		<p>Consider the return value for each of the methods above:</p>
		<pre class="language-javascript"><code>
			let firstP = document.getElementById("firstP");
			let listItems = document.getElementsByTagName("li");
			let redText = document.getElementsByClassName("redText");

			console.dir(firstP);
			console.dir(listItems);
			console.dir(redText);
		</code></pre>
		<pre class="language-bash"><code>
			p#firstP
			HTMLCollection(1)
			HTMLCollection(2)
		</code></pre>
		<p>
			The HTMLCollection is a list of nodes. As a list of nodes, they look
			and often behave like arrays. They are iterable (i.e., we can iterate
			over the nodes with a a regular for-loop or with a for-of-loop), we
			can index into an HTML collection with square bracket syntax, and we
			can retrieve its length:
		</p>
		<pre class="language-javascript"><code>
			let listItems = document.getElementsByTagName("li");
			let firstItem = listItems[0];
			let listItemsLength = listItems.length;
			console.dir(firstItem);
			console.dir(listItemsLength);
		</code></pre>
		<pre class="language-bash"><code>
			> li
			3
		</code></pre>
		<p>
			Now, while this evidences an array-like data structure, the
			HTMLCollection is <span class="underlineText">not</span> an array.
			They are in fact objects, which, as we know, is a type of record.
			Accordingly, methods like <var>.pop()</var> and
			<var>.push()</var> will not work with HTML collections.
		</p>
		<p>
			First, the HTMLCollection can only contain
			<i>element nodes</i>. Second, the HTMLCollection is
			<b>live</b> &mdash; whenever a new element node is appended to the
			DOM, the corresponding HTMLCollection that would contain that node is
			updated.
		</p>
	</section>

	<section id="node_list">
		<h3>Node Lists</h3>
		<p>
			With the <var>.querySelectorAll()</var> method, we see the following
			return value:
		</p>
		<pre class="language-javascript"><code>
			let list = document.querySelectorAll('li');
			console.dir(list);
			typeof list
		</code></pre>
		<pre class="language-bash"><code>
			> NodeList(3)
			'object'
		</code></pre>
		<p>
			We see <var>NodeList</var>. This is somewhat similar to the
			HTMLCollection, in that it looks and behaves like an array. We can
			iterate over the node list with the <var>forEach</var> method.<sup
			></sup> But again, it is <span class="underlineText">not</span> an
			array. Where the HTML collection is a list of nodes, the NodeList is
			an <i>aggregate</i> of nodes. And as we might expect, the NodeList
			too is an object, a record type.
		</p>
		<div class="note">
			<p>
				A fair warning: The <var>forEach</var> method can be inefficient
				for iterating over a NodeList.
			</p>
		</div>
	</section>

	<section id="dom_token_list">
		<h3>DOM Token Lists</h3>
		<p>
			When using properties like <var>.classList</var>, we see that the
			returned value is a <b>DOMTokenList</b>. This is an
			<b>ordered set</b> data structure. The DOMTokenList is effectively a
			<i>set</i> (a very lightweight data structure), wherein there are no
			duplicates.
		</p>
	</section>
</section>

<section id="dom_traversal">
	<h2>DOM Traversal</h2>
	<p>
		Many of the selection methods can be thought of as ways to traverse the
		DOM. Given a node ${obj,}$ we can move in three directions: left
		(selecting previous siblings), right (selecting later siblings), up
		(selecting parents or ancestors), and down (selecting children or
		descendants). Of course, we can always return a nodeList or an
		HTMLCollection and iterate or index, but it can be much faster to
		simply traverse the DOM directly. The diagram below provides a visual
		aid for deciding which traversal method to use.
	</p>
	<figure>
		<img
			src="{% static 'images/domTraversal.svg' %}"
			alt="Traversal methods"
			loading="lazy"
			style="width: 450px"
		/>
	</figure>
</section>

<section id="manipulating_elements">
	<h2>DOM Manipulation</h2>
	<p>
		Once we have selected an element, we can begin manipulating the
		element. The DOM provides numerous properties and methods we can use
		for manipulation. Below is an API of various properties and methods:
	</p>
	<figure>
		<table class="api">
			<thead>
				<th>Identifier</th>
				<th>Meaning</th>
				<th>Comments</th>
			</thead>
			<tbody>
				<tr>
					<td colspan="3">Methods</td>
				</tr>
				<tr>
					<td><var>${obj}$.getAttribute(${a}$)</var></td>
					<td>
						Returns the value assigned to the attribute ${a}$ of ${obj.}$
						Argument passed, ${a,}$ is of type
						<var>string</var>.
					</td>
					<td>
						Examples: <var>href</var>, <var>src</var>, <var>class</var>,
						<var>type</var>, <var>id</var>, etc.
					</td>
				</tr>
				<tr>
					<td>
						<var>${obj}$.setAttribute(${a}$, ${v}$)</var>
					</td>
					<td>
						Assign to the attribute ${a}$ of ${obj}$ the value ${v.}$ Both
						${a}$ and ${v}$ are arguments of type
						<var>string</var>.
					</td>
					<td></td>
				</tr>
				<tr>
					<td><var>${obj}$.appendChild(${s}$)</var></td>
					<td>Appends the element ${s}$ as a child of ${obj.}$</td>
					<td>
						If ${obj}$ has children, ${s}$ is appended as the last child.
					</td>
				</tr>
				<tr>
					<td>
						<var>${obj}$.append(${s_0, \ldots, s_n}$)</var>
					</td>
					<td>
						Inserts the element objects ${s_0, \ldots, s_n}$ as children of
						${obj}$ in sequence. If ${obj}$ has existing children, the
						objects ${s_0, \ldots, s_n}$ are inserted at
						<span class="underlineText">after</span> the last child.
					</td>
					<td></td>
				</tr>
				<tr>
					<td><var>${obj}$.prepend()</var></td>
					<td>
						Inserts the element objects ${s_0, \ldots, s_n}$ as children of
						${obj}$ in sequence. If ${obj}$ has existing children, the
						objects ${s_0, \ldots, s_n}$ are inserted at
						<span class="underlineText">before</span> the first child.
					</td>
					<td></td>
				</tr>
				<tr>
					<td>
						<span class="monoText"
							>${obj_p}$.insertBefore(${obj_0}$, ${obj_1}$)</span
						>
					</td>
					<td>
						Where ${obj_p}$ is a branch node object (i.e., an object with
						children), inserts the element ${obj_0}$ before the element
						${obj_1}$ as children of ${obj_p.}$
					</td>
					<td></td>
				</tr>
				<tr>
					<td>
						<span class="monoText"
							>${obj_p}$.insertAdjacentElement(${i}$, ${s}$).</span
						>
					</td>
					<td>
						Where ${obj_p}$ is a branch node object, inserts the element
						object ${s}$ at position ${p.}$ Both arguments are strings.
					</td>
					<td>
						${i}$ takes 1 of 4 string values:
						<var>'beforebegin'</var> (before ${obj_p}$ itself),
						<var>'afterbegin'</var> (inside ${obj_p}$ and before its first
						child), <var>'beforeend'</var> (inside ${obj_p}$ and after its
						last child), <var>'afterend'</var> (after ${obj_p}$ itself).
					</td>
				</tr>

				<tr>
					<td><var>${obj}$.removeChild(${s}$)</var></td>
					<td>
						Where ${obj}$ is a branch node and ${s}$ is a child of ${obj,}$
						destroys the child ${s.}$
					</td>
					<td></td>
				</tr>
				<tr>
					<td><var>${obj}$.remove()</var></td>
					<td>Destroys the object ${obj.}$</td>
					<td>No arguments passed to this method.</td>
				</tr>
				<tr>
					<td><var>document.createElement(${s}$)</var></td>
					<td>
						Creates a new element and returns the new element ${s,}$ where
						${s}$ is the element's type as a string. E.g.,
						<var>document.createElement(p)</var> creates a new paragraph
						element.
					</td>
					<td>
						This only creates an element and returns the element's object
						representation. It does not append the element to the page, or
						set its properties like <var>innerText</var>. To do so, we must
						provide additional statements. E.g., use one of the append
						methods to insert the element into the page.
					</td>
				</tr>
				<tr>
					<td><var>getComputedStyle(${obj}$)</var></td>
					<td>
						Returns an object containing all the CSS properties of ${obj}$.
					</td>
					<td>
						Notice that this method is not called with an object. Instead,
						an object is passed into the method. This is because the
						<var>getComputedStyle()</var> method is provided by the
						<var>Window</var>, the global object on the browser. Thus, the
						full call looks like
						<var>Window.getComputedStyle(${obj}$)</var>. The object
						returned contains <span class="underlineText">all</span> of the
						applicable style properties. Many of these properties have
						values, even if we didn't set them, because the browser sets
						many properties by default.
					</td>
				</tr>
				<tr>
					<td><var>${obj.}$cloneNode(${b}$)</var></td>
					<td>
						Returns a copy of ${obj,}$ where ${obj}$ is an existing
						element.
					</td>
					<td>
						The boolean values <var>true</var> and <var>false</var> can be
						passed as arguments to the method. If the value
						<var>true</var> is passed, a <i>deep copy</i> of ${obj}$ is
						made (i.e., ${obj}$ and all its descendants). If
						<var>false</var> is passed, a <i>shallow copy</i> of ${obj}$ is
						made (only ${obj}$ is copied, not its descendants). Note that
						the cloned node has no parent and it is not part of the DOM. It
						must still be appended. Further note that because this clones a
						node, it can lead to duplicate <var>id</var> attribute values.
					</td>
				</tr>
				<tr>
					<td colspan="3">Properties</td>
				</tr>
				<tr>
					<td><var>${obj}$.classList</var></td>
					<td>
						Returns a <var>DOMTokenList</var> of all the values assigned to
						the element's <var>class</var> attribute.
					</td>
					<td>
						This is a useful property for modifying multiple styles on an
						${obj.}$ With <var>.classList</var>, we can call the methods
						<var>${obj}$.classList.add(${s}$)</var> to add a new value to
						${obj}$'s class attribute,
						<var>${obj}$.classList.remove(${s}$)</var> to remove a value in
						${obj}$'s class attribute, and
						<var>${obj}$.toggle(${s}$)</var>, which removes the value ${s}$
						to the class attribute if it's present, and adds the value
						${s}$ if it is absent.
					</td>
				</tr>
				<tr>
					<td><var>${obj}$.innerText</var></td>
					<td>
						Where ${obj}$ is an HTML element object, returns the text (type
						<var>string</var>) in between the tags. When using
						<var>querySelector()</var> on an object with children, the
						returned value is the inner text of all the children in a
						single string (escape sequences used).
					</td>
					<td>
						Changing the value assigned to
						<var>innerText</var> will result in changes the text on the
						page. String returned does not include parts of text hidden via
						CSS, text between script tags, or tags.
					</td>
				</tr>
				<tr>
					<td><var>${obj}.$textContent</var></td>
					<td>
						Similar to <var>innerText</var>, in that it returns the
						contents between the HTML tags. However, the string returned
						will include <span class="underlineText">all</span> the text
						displayed on the page, except for tags.
					</td>
					<td>
						<i>Supra above cell.</i>
						<var>textContent</var> is slightly faster, since it does not
						have to perform additional computations to ignore certain text.
					</td>
				</tr>
				<tr>
					<td><var>${obj}$.innerHTML</var></td>
					<td>
						Returns a string of all the HTML elements (include the tags) in
						${obj.}$
					</td>
					<td>
						<var>innerHTML</var> can be used to add tags, but values
						assigned must be of type
						<var>string.</var>
					</td>
				</tr>
				<tr>
					<td><var>${obj}$.value</var></td>
					<td>
						Returns the value of ${obj.}$ Most commonly used with the
						<var>input</var> tag.
					</td>
					<td></td>
				</tr>
				<tr>
					<td><var>${obj}$.checked</var></td>
					<td>
						Returns the value of an <var>input</var> element with type
						attribute of <var>checkbox</var>. If checked, return value is
						<var>true</var>, otherwise <var>false</var>.
					</td>
					<td></td>
				</tr>
				<tr>
					<td><var>${obj}$.parentElement</var></td>
					<td>Returns the parent element of ${obj.}$</td>
					<td>
						E.g., assuming proper style,
						<var>li.parentElement</var> would return <var>ul</var> or
						<var>ol</var> object. To target the &#8220;grandparent&#8221;
						element, we can write
						<var>${obj}$.parentElement.parentElement</var>. We can think of
						this method as climbing &#8220;up&#8221; the tree.
					</td>
				</tr>
				<tr>
					<td><var>${obj}$.children</var></td>
					<td>
						Returns an HTMLCollection of all the children of ${obj.}$
					</td>
					<td></td>
				</tr>
				<tr>
					<td><var>${obj}$.nextElementSibling</var></td>
					<td>
						Returns the element
						<span class="underlineText">after</span> ${obj}$ on the same
						level in the tree.
					</td>
					<td></td>
				</tr>
				<tr>
					<td><var>${obj}$.previousSibling</var></td>
					<td>
						Returns the element
						<span class="underlineText">before</span> ${obj}$ on the same
						level in the DOM tree.
					</td>
					<td></td>
				</tr>
				<tr>
					<td><var>${obj}$.style</var></td>
					<td>
						Returns an object containing all of the style properties of
						${obj.}$
					</td>
					<td>
						Assuming the page follows standard practices, the properties in
						the returned object are displayed with empty string values.
						This is because the values set in the returned object are
						values provided via
						<span class="underlineText">inline styling</span>. Because
						inline styles are generally considered poor practice, the
						properties will usually have empty string values. To read
						existing values,
						<i>see</i>
						<var>.getComputedStyle()</var> above. We can, however, use the
						<var>.style</var> property to mutate the ${obj}$'s styles. For
						examle, <var>${obj}$.style.color = 'blue'</var> will change the
						text color to blue. Additionally, property names are written in
						JavaScript syntax. E.g., because JavaScript doesn't allow
						dashes in names, the CSS property
						<var>background-color</var> is identified in the object in
						camelCase: <var>backgroundColor</var>. Finally, note that
						mutating this property effectively adds inline styles to the
						${obj.}$ As such, this will overwrite any existing styles we've
						applied via CSS.
					</td>
				</tr>
			</tbody>
		</table>
	</figure>

	<section id="common_idoms">
		<h3>Common Idioms</h3>
		<p>
			Because the DOM provides the means for manipulating HTML pages, there
			are several common idioms for DOM manipulation. We present these
			idioms below.
		</p>
		<section id="changing_multiple_elements">
			<p>
				<span class="topic">Changing Multiple Elements.</span> To change
				multiple elements, one common pattern is to store a NodeList, or
				HTMLCollection, in a variable, then iterate over it:
			</p>
			<pre class="language-javascript"><code>
				const list = document.querySelectorAll('li');
				for (let i = 0; i < list.length; i++) {
					list[i].innerText = "Mutated";
				}
			</code></pre>
			<p>
				The code above changes all the list items inner text to the string
				<var>"Mutated"</var>. This idiom is particularly powerful, in that
				it allows us to change many properties, such as
				<var>.innerHTML</var> and <var>.style</var>.
			</p>
		</section>

		<section id="changing_multiple_styles">
			<p>
				<span class="topic">Applying Multiple Styles.</span> Another common
				idiom is applying multiple styles to an element. This is done by
				appending, removing, or modifying the element's styles applied via
				CSS throuh the element's <var>class</var> attribute. For example,
				say we had the following HTML code:
			</p>
			<pre class="language-html"><code>
				&lt;!DOCTYPE html&gt;
				&lt;html lang=&quot;en&quot;&gt;
				&lt;head&gt;
				&#x9;&lt;title&gt;Lab&lt;/title&gt;
				&#x9;&lt;link rel=&quot;stylesheet&quot; href=&quot;./styles.css&quot;&gt;
				&lt;/head&gt;
				&lt;body&gt;
				&#x9;&lt;main&gt;
				&#x9;&#x9;&lt;h1&gt;H1 Tag&lt;/h1&gt;
				&#x9;&#x9;&lt;p&gt;Paragraph tag&lt;/p&gt;
				&#x9;&#x9;&lt;ul id=&quot;todo&quot;&gt;
				&#x9;&#x9;&#x9;&lt;li class=&quot;incomplete&quot;&gt;List item 1&lt;/li&gt;
				&#x9;&#x9;&#x9;&lt;li class=&quot;incomplete&quot;&gt;List item 2&lt;/li&gt;
				&#x9;&#x9;&#x9;&lt;li class=&quot;incomplete&quot;&gt;List item 3&lt;/li&gt;
				&#x9;&#x9;&lt;/ul&gt;
				&#x9;&lt;/main&gt;
				&#x9;&lt;script src=&quot;./app.js&quot;&gt;&lt;/script&gt;
				&lt;/body&gt;
				&lt;/html&gt;&#x9;
			</code></pre>
			<p>The CSS appears as such:</p>
			<pre class="language-css"><code>
				main {
					font-family: sans-serif;
				}
				.redText {
					color: red;
				}
				.incomplete {
					color: green;
				}
			</code></pre>
			<p>
				Suppose that we wanted to have a list item once its marked
				complete. To do so, we write write a new class in the CSS file:
			</p>
			<pre class="language-css"><code>
				main {
					font-family: sans-serif;
				}
				.redText {
					color: red;
				}
				.incomplete {
					color: green;
				}
				.complete {
					color: grey;
					text-decoration: line-through;
				}
			</code></pre>
			<p>
				We can then apply the <var>.complete</var> class to the respective
				<var>li</var> object:
			</p>
			<pre class="language-javascript"><code>
				const todoList = document.querySelectorAll('li');
				let firstTodo = todoList[0];
				firstTodo.setAttribute('class', 'complete')
			</code></pre>
			<p>
				Alternatively, we could have used a method from the
				<var>.classList</var> property.
			</p>
		</section>
	</section>
</section>

<section id="dom_events">
	<h2>Event-driven Programming</h2>
	<p>
		Once we know how to target and manipulate the DOM tree and its nodes,
		we can begin investigating <i>events</i>. To understand what events
		are, it's helpful to think about the different kinds of programs we can
		write.
	</p>
	<p>
		In much of the preceding sections and volumes, we've been writing
		<b>console programs</b> &mdash; programs that run primarily on the
		console. We can, however, also write
		<b>interactive programs</b> &mdash; programs that allow the user to
		control a program's actions by using <i>peripherals</i>. Such
		peripherals include a keyboard, joystick, mouse, trackpad, microphone,
		etc. When a user performs some action with a peripheral, we call that
		action an <b>event</b>. For example: Clicking on a mouse, hitting the
		enter or arrow keys, touching a particular part of a screen, saying a
		particular word into a microphone, these are all events. Programs that
		are designed to respond to these events are called
		<b>event-driven programs</b>. In their simplest forms, such programs
		take events as input, and return some output.
	</p>
	<p>
		In modern interactive programs, user input does not occur at
		predictable times. For example, think about clicking on the
		&#8220;Agree&#8221; button for a software usage license. Most users
		click the button immediately. Others (however few), will take the time
		to read the license before clicking. The program behind the license
		doesn't tell us when we should click the button (it would be poor
		choice, both business-wise and legally, to require a user to agree to a
		license in less than five seconds). All this is to say that modern
		interactive programs leave it up to the user
		<i>when</i> to trigger an event. And because events are not controlled
		by the program, we say that such programs are <b>asynchronous</b>.
	</p>
	<p>
		In the JavaScript context, we implement such programs through functions
		that anticipate these events. By &#8220;anticipate&#8221; we mean that
		the functions are called <span class="underlineText">only if</span> an
		event occurs. These functions are more generally called
		<b>listeners</b>. We can think of a listener as akin to the string
		telephones we played with in our days of youth:
	</p>
	<figure>
		<img
			src="{% static 'images/listener.svg' %}"
			alt="A string telephone"
			loading="lazy"
			style="width: 300px"
		/>
	</figure>
	<p>
		The listener &#8220;listens&#8221; to whatever the user sends as input,
		which in turn keeps a particular module in the program informed. That
		module then executes whatever statements we provide.
	</p>
	<p>
		Listeners are based on a foundational principle of functional
		programming: Functions are data values, just as an integer or a string
		is a data value. JavaScript abides by this principle in treating
		functions as
		<i>first-class</i>: We can assign them to variables, pass them as
		arguments, express them as arguments, and return them as results. Just
		to confirm that this is the case, recall our discussion on
		<a
			href="{% url 'numerc:js_functions' %}#javascript_function_expressions"
			>function expressions</a
		>. We could write the following function as such:
	</p>
	<pre class="language-javascript"><code>
		function fahrenheitToCelsius(f) {
			return 5 / 9 * (f - 32);
		}
	</code></pre>
	<p>
		But, we could also assign the function to a variable (a
		<i>closure</i>):
	</p>
	<pre class="language-javascript"><code>
		let fahrenheitToCelsius = function(f) { return 5 / 9 * (f - 32); };
	</code></pre>
	<p>
		When first discussed these different syntactical forms, we didn't
		expound to deeply on the advantages of using closures over formal
		function definitions. With listeners, however, there's a signficant
		benefit to using closures: We can declare the function as a local
		variable inside another function (e.g., what we represented as a module
		in the diagram above). In that case, the inner function (the listener)
		includes all of the code in its body, which in turn has access to all
		the local variable in the outer function. To understand how this is so
		useful, we turn to JavaScript's
		<i>event listeners</i>.
	</p>

	<section id="event_listeners">
		<h3>Event Listeners</h3>
		<p>
			In JavaScript, the most common listeners used are
			<b>event listeners</b>. The control flow appears as such:
		</p>
		<figure>
			<img
				src="{% static 'images/eventListener.svg' %}"
				alt="The control flow of an event listener"
				loading="lazy"
				style="width: 300px"
			/>
		</figure>
		<p>
			In the diagram above, the <i>target</i> is whatever element, or
			object, on the page (or in the Browser window) we expect the user the
			interact with, and the listener to listen to. We can think of the
			target as where on a wall we place a cup to listen to an adjacent
			room. The <i>event</i> is the event the function should listen to.
			And the <i>callback</i> is the function containing whatever
			statements we would like to run based on the event listeners output.
			For example, suppose a user clicks a button. The <i>target</i> is a
			<var>button</var>, the <i>event</i> is a <var>click</var>, and the
			<i>code to run</i> is whatever we'd like to do if the user clicks the
			button: E.g., change the position of an element, change text color,
			open a pop-up, etc.
		</p>
		<p>For example, suppose we had the following HTML code:</p>
		<pre class="language-html"><code>
			&lt;!DOCTYPE html&gt;
			&lt;html lang=&quot;en&quot;&gt;
			&lt;head&gt;
			&#x9;&lt;title&gt;Lab&lt;/title&gt;
			&#x9;&lt;link rel=&quot;stylesheet&quot; href=&quot;./styles.css&quot;&gt;
			&lt;/head&gt;
			&lt;body&gt;
			&#x9;&lt;main&gt;
			&#x9;&#x9;&lt;h1&gt;Some Buttons&lt;/h1&gt;
			&#x9;&#x9;&lt;ul&gt;
			&#x9;&#x9;&#x9;&lt;li&gt;&lt;button&gt;Button 1&lt;/button&gt;&lt;/li&gt;
			&#x9;&#x9;&#x9;&lt;li&gt;&lt;button&gt;Button 2&lt;/button&gt;&lt;/li&gt;
			&#x9;&#x9;&#x9;&lt;li&gt;&lt;button&gt;Button 3&lt;/button&gt;&lt;/li&gt;
			&#x9;&#x9;&lt;/ul&gt;
			&#x9;&lt;/main&gt;
			&#x9;&lt;script src=&quot;./app.js&quot;&gt;&lt;/script&gt;
			&lt;/body&gt;
			&lt;/html&gt;&#x9;&#x9;&#x9;
		</code></pre>
		<p>
			Let's consider a very simple example: When the user clicks the first
			button, the console outputs a message:
		</p>
		<pre class="language-javascript"><code>
			const buttonList = document.querySelectorAll('button');
			const firstButton = buttonList[0];

			firstButton.addEventListener('click', () => {
				console.log("First button clicked.");
			});
		</code></pre>
		<p>When we click the button, the console displays:</p>
		<pre class="language-bash"><code>
			First button clicked.
		</code></pre>
		<p>
			In the code above, we used the
			<var>addEventListener()</var> method. This is a method provided by
			the DOM, and it is what we use &#8220;attach&#8221; an event listener
			to a particular target. The template:
		</p>
		<figure class="math-display">
			<ul class="syntax">
				<li>${obj}$.addEventListener(${e_t}$, ${f_c}$);</li>
			</ul>
		</figure>
		<p>
			In the template above, ${obj}$ is some DOM object (e.g., an HTML
			element like a button, paragraph, list item, slider, etc.) The first
			parameter, ${e_t,}$ is the event itself. This is a string value
			specified by the DOM, and there are numerous event values:
			<var>click</var>, <var>mousedown</var>, <var>drag</var>, etc. We will
			explore some of the most common events as we continue. The second
			parameter, ${f_c,}$ is the function that should execute when the
			event occurs. This is called the <b>callback function</b>. It
			contains all of the statements we want to execute in response to the
			event occuring. Putting all this together with respect to the above
			example: The target is the first button element, the event is a
			<var>'click'</var>, and the function is an anonymous function that
			displays to the console a message.
		</p>
		<p>
			This is where we see why having first-class in JavaScript is so
			useful. We can assign the callback function to a variable, and pass
			that variable as an argument to the event listener:
		</p>
		<pre class="language-javascript"><code>
			const buttonList = document.querySelectorAll('button');
			const firstButton = buttonList[0];
			const buttonMesage = () => { console.log("First button clicked.") };

			firstButton.addEventListener('click', buttonMesage);
		</code></pre>
		<p>Clicking the button once more:</p>
		<pre class="language-bash"><code>
			First button clicked.
		</code></pre>

		<section id="listen_to_multiple_objects">
			<p>
				<span class="topic">Attaching Listeners to Multiple Objects.</span>
				A common idiom in JavaScript is to attach listeners to multiple
				objects. For example, think of the upvote button on a Reddit page.
				It would tedious and unwieldy to attach listeners to each of the
				objects &mdash; there are thousands of them. Instead, what we want
				to do is use a loop. For example, suppose we had the following HTML
				code:
			</p>
			<pre class="language-html"><code>
				&lt;!DOCTYPE html&gt;
				&lt;html lang=&quot;en&quot;&gt;
				&#x9;&lt;head&gt;
				&#x9;&#x9;&lt;title&gt;Lab&lt;/title&gt;
				&#x9;&#x9;&lt;link rel=&quot;stylesheet&quot; href=&quot;./styles.css&quot; /&gt;
				&#x9;&lt;/head&gt;
				&#x9;&lt;body&gt;
				&#x9;&#x9;&lt;main&gt;
				&#x9;&#x9;&#x9;&lt;div id=&quot;container&quot;&gt;
				&#x9;&#x9;&#x9;&#x9;&lt;div&gt;&lt;/div&gt;
				&#x9;&#x9;&#x9;&#x9;&lt;div&gt;&lt;/div&gt;
				&#x9;&#x9;&#x9;&#x9;&lt;div&gt;&lt;/div&gt;
				&#x9;&#x9;&#x9;&lt;/div&gt;
				&#x9;&#x9;&lt;/main&gt;
				&#x9;&#x9;&lt;script src=&quot;./app.js&quot;&gt;&lt;/script&gt;
				&#x9;&lt;/body&gt;
				&lt;/html&gt;
			</code></pre>
			<p>Then, in our CSS, we have:</p>
			<pre class="language-css"><code>
				#container {
					display: flex;
					justify-content: center;
					align-items: center;
				}
				div div {
					border: solid thin grey;
					padding: 3em;
					margin: 5em;
				}
			</code></pre>
			<p>
				This displays three square boxes. Now, we want each of the boxes to
				change color when we hover over them. We can do so with the
				following JavaScript code:
			</p>
			<pre class="language-javascript"><code>
				const colors = ['red', 'green', 'blue'];
				const container = document.querySelectorAll('#container div');

				for (let i = 0; i < colors.length; i++) {
					container[i].addEventListener('mouseover', function () {
						this.style.backgroundColor = colors[i];
					})
				}
			</code></pre>
			<p>
				Note that the <var>this</var> keyword refers to the object we're
				attaching the event listener to. In this case,
				<var>container[i]</var>.
			</p>
		</section>
	</section>

	<section id="the_event_object">
		<h3>The Event Object</h3>
		<p>
			With event listeners, we, as the programmers, never actually call the
			callback functions. Instead, the event listener is what calls the
			callback, in response to an event. Moreover, the even listener passes
			an
			<b>event object</b> to the callback. In fact, we can see that the
			event is passed by explicitly naming the argument. Suppose the HTML
			page contains a single button element:
		</p>
		<pre class="language-javascript"><code>
			const button = document.querySelector('button');
			button.addEventListener('click', function (evt) { 
				console.log(evt); 
			});
		</code></pre>
		<pre class="language-bash"><code>
			PointerEvent {isTrusted: true, pointerId: 1, width: 1, height: 1, pressure: 0, …}
		</code></pre>
		<p>
			We see that we get back an object with numerous properties. Notice
			the identifier <var>PointerEvent</var>. This informs us what type of
			event object this is. There are numerous different types of event
			objects: <var>MouseEvent</var>, <var>KeyboardEvent</var>,
			<var>DragEvent</var>, <var>AnimationEvent</var>, and so on. More
			generally, the event objects are classified according to the kind of
			interaction by the user, as well as other forms of interactivity.
			Structurally, the event objects are records, or structs, containing
			various properties pertaining to the particular event. For example,
			the <var>KeyboardEvent</var> has a property called <var>key</var>,
			which returns the key value of the key pressed. The
			<var>MouseEvent</var> has a property called <var>button</var>, which
			returns which button on the mouse was pressed when the mouse event
			was triggered.
		</p>
		<p>
			Event objects are particularly useful because they allow us to be
			more specific with what kinds of inputs we want to trigger callback
			functions. For example, we can use the <var>key</var> property to
			specify that a block of code in the callback function executes only
			if the <var>enter</var> key is pressed. Or we can specify that
			another block executes only if a certain area around the target is
			hovered over with the mouse. In sum, event objects provide us with
			greater control over how events handled.
		</p>
	</section>
</section>

{% endblock %}
