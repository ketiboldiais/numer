{% extends '../layout.html' %} {% load static %} {% block description %}
<meta
	name="description"
	content="What is the DOM in JavaScript? An overview of the Document Object Model."
/>
{% endblock %} {% block title %}
<title>The DOM</title>
{% endblock %} {% block content %}
<h1>The Document Object Model (DOM)</h1>
<section id="intro">
	<p>
		<span class="drop">J</span>avaScript is synonymous with web development. But
		how exactly does it generate dynamic web pages? The answer is through the
		<span class="term">Document Object Model</span> (&#8220;DOM&#8221;). In this
		section, we explore how the DOM works, as well as the various ways we link
		JavaScript, HTML, and CSS.
	</p>
	<p>
		To begin, the examples below are based on three separate files:
		<span class="monoText">lab.html</span>,
		<span class="monoText">app.js</span>, and
		<span class="monoText">styles.css</span>. These files are all within the
		same directory:
	</p>
	<figure class="math-display">
		<div>
			<pre class="language-pseudo"><code>
				.
				├── lab.html
				├── app.js
				└── styles.css
			</code></pre>
		</div>
	</figure>
	<p>
		The <span class="monoText">styles.css</span> and
		<span class="monoText">app.js</span> files do not contain anything for now.
		The <span class="monoText">lab.html</span> file, however, contains the
		following code:
	</p>
	<pre class="language-html"><code>
		&lt;!DOCTYPE html&gt;
		&lt;html lang=&quot;en&quot;&gt;
		&lt;head&gt;
		&#x9;&lt;meta charset=&quot;UTF-8&quot;&gt;
		&#x9;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
		&#x9;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
		&#x9;&lt;title&gt;Lab&lt;/title&gt;
		&#x9;&lt;link rel=&quot;stylesheet&quot; href=&quot;./styles.css&quot;&gt;
		&lt;/head&gt;
		&lt;body&gt;
		&#x9;&lt;main&gt;
		&#x9;&#x9;&lt;h1&gt;H1 Tag&lt;/h1&gt;
		&#x9;&#x9;&lt;p&gt;Paragraph tag&lt;/p&gt;
		&#x9;&#x9;&lt;ul&gt;
		&#x9;&#x9;&#x9;&lt;li&gt;List item 1&lt;/li&gt;
		&#x9;&#x9;&#x9;&lt;li&gt;List item 2&lt;/li&gt;
		&#x9;&#x9;&#x9;&lt;li&gt;List item 3&lt;/li&gt;
		&#x9;&#x9;&lt;/ul&gt;
		&#x9;&lt;/main&gt;
		&#x9;&lt;script src=&quot;./app.js&quot;&gt;&lt;/script&gt;
		&lt;/body&gt;
		&lt;/html&gt;
	</code></pre>
	<p>
		Note that the following discussion assumes basic knowledge of HTML and CSS.
		If the syntax above or CSS is entirely foreign, we recommend looking up a
		few basic tutorials on HTML and CSS.
	</p>
</section>

<section id="what_is_the_dom">
	<h2>What is the DOM?</h2>
	<p>
		The DOM is a a representation of a document's structure.<label
			for="domSpec"
			class="margin-toggle"
			><sup></sup
		></label>
		<input type="checkbox" id="domSpec" class="margin-toggle sidenote-number" />
		<span class="marginnote"
			>For the specification,
			<a href="https://dom.spec.whatwg.org/" target="_blank"
				><span class="italicsText">see</span> <em>DOM Living Standard</em>.</a
			></span
		>
		While the DOM has grown synonymous with JavaScript, it's not exclusive to
		browsers. Server side programs may also utilize the program.
	</p>
	<p>
		The DOM is implemented as a <span class="term">node tree</span>. From a very
		high-level overview, when the browser loads an HTML document, the browser
		takes all of the HTML elements and returns JavaScript objects. Each of these
		objects is a <span class="term">node</span> on the tree. Some of the nodes
		have children. These nodes are called
		<span class="term">branch nodes</span>, because they have
		<span class="term">branches</span> to other nodes. Other nodes do not have
		children, in which case they are called <span class="term">leaves</span>.
	</p>
	<p>
		Because each node in the tree is represented as a JavaScript object, we can
		interact with them via JavaScript. Hence, the DOM is simply an interface for
		interacting with HTML documents. For example, given the following HTML code:
	</p>
	<pre class="language-html"><code>
		&lt;html&gt;
			&lt;head&gt;
				&lt;title&gt;My Webpage&lt;/title&gt;
			&lt;/head&gt;
			&lt;body&gt;
			&#x9;&lt;h1&gt;Heading&lt;/h1&gt;
			&#x9;&lt;ul&gt;
			&#x9;&#x9;&lt;li&gt;List Item 1&lt;/li&gt;
			&#x9;&#x9;&lt;li&gt;List Item 2&lt;/li&gt;
			&#x9;&lt;/ul&gt;
			&lt;/body&gt;
		&lt;/html&gt;
	</code></pre>
	<p>
		The browser generates a node tree whose nodes are the HTML elements
		represented as objects:
	</p>
	<figure>
		<img
			src="{% static 'images/domTree.svg' %}"
			alt="The DOM Tree Object"
			loading="lazy"
			class="fifty-p"
		/>
	</figure>
	<p>
		The root node is the <span class="monoText">html</span> element. It is from
		this node that we have all the other nodes:
		<span class="monoText">body</span>, <span class="monoText">h1</span>,
		<span class="monoText">ul</span>, <span class="monoText">li</span>, etc.
		These nodes are all objects. Each node has either a
		<span class="term">parent</span>, <span class="term">children</span>, or
		both. For example, the <span class="monoText">html</span> element has two
		children, <span class="monoText">head</span> and
		<span class="monoText">body</span>. <span class="monoText">head</span> has
		one child, the <span class="monoText">title</span> element.
	</p>
	<p>
		Again, all of these are objects, and the entire node tree is an object.
		Roughly, the tree above looks something like:
	</p>
	<figure class="math-display">
		<div>
			<pre class="language-pseudo"><code>
				Window: {
					document: {
						html: {
							head: {
								title: { innerText: "My Webpage" }
							},
							body: {
								h1: { innerText: "Heading" },
								ul: {
									li: { innerText: "List Item 1" },
									li: { innerText: "List Item 1" }
								}
							}
						}
					}
				}
			</code></pre>
		</div>
	</figure>
	<p>
		The root of the tree is the <span class="term">document object</span>. We
		can think of the document object as the entry point to the rest of the tree.
		If we run <span class="monoText">console.dir(document)</span> on an HTML
		page, we can see an entire representation of the document (the output is
		omitted here because of its length, but do try it).
	</p>
	<p>
		The above gives us a better sense of what the DOM is. If we wanted to see
		what it actually looks like, open a console on a webpage, and run
		<span class="monoText">console.log(this)</span>. The rough outline above
		omits most of what's actually contained in the tree &mdash; the DOM contains
		numerous properties and methods.
	</p>
	<p>
		Each of the objects have properties. In the example above, the
		<span class="monoText">h1</span> object has a property called
		<span class="monoText">innerText</span>. Here, that property is bound to the
		value <span class="monoText">"Heading"</span>, a string. These objects all
		contain numerous properties: Styles, content, children, parents, etc. With
		JavaScript, we can modify these properties. We can also create and delete
		nodes on the tree, effectively adding new elements and removing existing
		ones from the HTML document. This discussion reveals a key insight to
		developing web pages with JavaScript: Whenever we use JavaScript to affect
		changes on a webpage, we are really manipulating the leaves and branches in
		a tree.
	</p>
	<p>
		Importantly, there's a distinction between
		<span class="italicsText">elements</span> and
		<span class="italicsText">nodes</span> in the DOM. All HTML tags constitute
		<span class="italicsText">element nodes</span>. An element node can have
		children, which may or may not be element nodes. For example, the
		<span class="monoText">detail</span> tag can have a
		<span class="monoText">summary</span> element node as a child, but it can
		also have the <span class="italicsText">attribute node</span>
		<span class="monoText">open</span>. Similarly, the
		<span class="monoText">p</span> tag is represented as an element node, but
		it can also have as a child node an <span class="monoText">a</span> element
		node, as well as a <span class="italicsText">text node</span>.
	</p>
</section>

<section id="targeting_elements">
	<h2>DOM Getters</h2>
	<p>
		From the JavaScript perspective, an HTML page is just one giant object. More
		specifically, a giant tree. Accordingly, to manipulate HTML pages, we
		manipulate the DOM tree's nodes. The first step to doing so is to select, or
		target, nodes in the tree. We can think of these as being akin to
		<span class="term">getters</span> in other OOP languages. This is done by
		using methods provided by the DOM. To get started, the HTML and CSS files
		we're working with look like this:
	</p>

	<pre class="language-html"><code>
			&lt;!DOCTYPE html&gt;
			&lt;html lang=&quot;en&quot;&gt;
			&lt;head&gt;
			&#x9;&lt;title&gt;Lab&lt;/title&gt;
			&#x9;&lt;link rel=&quot;stylesheet&quot; href=&quot;./styles.css&quot;&gt;
			&lt;/head&gt;
			&lt;body&gt;
			&#x9;&lt;main&gt;
			&#x9;&#x9;&lt;h1 class=&quot;redText&quot;&gt;H1 Tag&lt;/h1&gt;
			&#x9;&#x9;&lt;p id=&quot;firstP&quot;&gt;Paragraph tag&lt;/p&gt;
			&#x9;&#x9;&lt;ul class=&quot;firstList&quot;&gt;
			&#x9;&#x9;&#x9;&lt;li&gt;List item 1&lt;/li&gt;
			&#x9;&#x9;&#x9;&lt;li&gt;List item 2&lt;/li&gt;
			&#x9;&#x9;&#x9;&lt;li&gt;List item 3&lt;/li&gt;
			&#x9;&#x9;&lt;/ul&gt;
			&#x9;&lt;/main&gt;
			&#x9;&lt;script src=&quot;./app.js&quot;&gt;&lt;/script&gt;
			&lt;/body&gt;
			&lt;/html&gt;
		</code></pre>
	<pre class="language-css"><code>
			main { 
				font-family: sans-serif; 
			}
			.redText { 
				color: red; 
			}
		</code></pre>

	<p>Here is an API for targetting the various nodes in the tree:</p>
	<figure class="table">
		<table class="api">
			<thead>
				<th>Method</th>
				<th>Meaning</th>
				<th>Comments</th>
			</thead>
			<tbody>
				<tr>
					<td colspan="3" style="font-family: var(--serif)">
						Where ${obj}$ is some object in the DOM (e.g.,
						<span class="monoText">document</span>,
						<span class="monoText">ul</span>,
						<span class="monoText">section</span>,
						<span class="monoText">div</span>, etc.):
					</td>
				</tr>
				<tr>
					<td><span class="monoText">${obj}$.getElementById(${s}$)</span></td>
					<td>
						Where ${v}$ is a string, returns the HTML element with the matching
						<span class="monoText">id</span> attribute with value ${s.}$ If no
						match is found, the return value is
						<span class="monoText">null</span>.
					</td>
					<td>By &#8220;HTML element&#8221;, we mean an object.</td>
				</tr>
				<tr>
					<td>
						<span class="monoText">${obj}$.getElementsByTagName(${s}$)</span>
					</td>
					<td>
						Where ${s}$ is a string, returns an
						<a href="#html_collection"
							><span class="monoText">HTMLCollection</span></a
						>
						of all the elements with the tag name ${s.}$
					</td>
					<td>
						The <span class="monoText">HTMLCollection</span> looks like an
						array, but it is not an array.
					</td>
				</tr>
				<tr>
					<td>
						<span class="monoText">${obj}$.getElementsByClassName(${s}$)</span>
					</td>
					<td>
						Where ${s}$ is a string, returns an
						<span class="monoText">HTMLCollection</span>
						of all the elements with the class name ${s.}$ If no match is found,
						an empty
						<span class="monoText">HTMLCollection</span>
						is returned.
					</td>
					<td><span class="italicsText">Supra above cell.</span></td>
				</tr>
				<tr>
					<td><span class="monoText">${obj}$.querySelector(${s}$)</span></td>
					<td>
						Where ${s}$ is a string, returns the
						<span class="underlineText">first</span> element with the attribute,
						class, or element name with the string. If ${s}$ is written as a CSS
						selector, then the method will evalute according to the selector.
						For example,
						<span class="monoText">document.querySelector('#red')</span> will
						select the first element with the
						<span class="monoText">id</span> attribute of value
						<span class="monoText">'red'</span>.
						<span class="monoText">document.querySelector('.green')</span> will
						select the first element swith the
						<span class="monoText">class</span> attribute set to
						<span class="monoText">'green'</span>.
					</td>
					<td>
						Essentially an all-in-one method for the other methods above. Note
						that only the <span class="underlineText">first</span> match is
						returned. Other matches will not be returned. We can get very
						creative with this method.
						<span class="monoText">querySelector('div li.big')</span>
						will return the first <span class="monoText">li</span> element in
						main a <span class="monoText">div</span> element with the class
						<span class="monoText">big</span>. Some useful CSS combinators to be
						aware of:
						<span class="blueText monoText">'${a}$ ${b}$'</span> targets the
						<span class="italicsText">descendants</span> of ${a}$ that are
						${b.}$ <span class="blueText monoText">${a}$ > ${b}$</span> targets
						the <span class="italicsText">children</span> of ${a}$ that are
						${b.}$ <span class="blueText monoText">${a}$ + ${b}$</span> targets
						the adjacent siblings of ${a}$ that are ${b}$ (i.e., select the
						element ${b,}$ which is right after the element ${a}$ on the same
						level). <span class="blueText monoText">${a}$ ~ ${b}$</span> targets
						all the siblings after ${a}$ that are ${b.}$
						<span class="monoText">${a}$[${r}$=${s}$]</span> targets the element
						${a}$ with the attribute ${r}$ set to the value ${s.}$
					</td>
				</tr>
				<tr>
					<td><span class="monoText">${obj}$.querySelectorAll(${s}$)</span></td>
					<td>
						Similar operation as <span class="monoText">querySelector()</span>,
						but returns a
						<span class="monoText"><a href="">nodeList</a></span> containing
						<span class="underlineText">all</span> the elements matching ${s.}$
					</td>
					<td>
						<i>Supra above cell.</i> CSS selectors, as string values, can be
						passed as arguments.
					</td>
				</tr>
			</tbody>
		</table>
	</figure>
	<p>
		In the selection methods above, we used the form
		<span class="monoText">document.${m}$</span>, where ${m}$ is the selection
		method. We can, however, narrow the scope of our selection search by
		referencing a particular node within the document. For example,
		<span class="monoText">document.element.${m}$</span> will limit the
		selection search to the children of the
		<span class="monoText">html</span> element node. The same goes for
		<span class="monoText">document.head</span> and
		<span class="monoText">document.body</span>.
	</p>

	

	<section id="html_collection">
		<h2>HTML Collections</h2>
		<p>Consider the return value for each of the methods above:</p>
		<pre class="language-javascript"><code>
			let firstP = document.getElementById("firstP");
			let listItems = document.getElementsByTagName("li");
			let redText = document.getElementsByClassName("redText");

			console.dir(firstP);
			console.dir(listItems);
			console.dir(redText);
		</code></pre>
		<pre class="language-bash"><code>
			p#firstP
			HTMLCollection(1)
			HTMLCollection(2)
		</code></pre>
		<p>
			The HTMLCollection is a list of nodes. As a list of nodes, they look and
			often behave like arrays. They are iterable (i.e., we can iterate over the
			nodes with a a regular for-loop or with a for-of-loop), we can index into
			an HTML collection with square bracket syntax, and we can retrieve its
			length:
		</p>
		<pre class="language-javascript"><code>
			let listItems = document.getElementsByTagName("li");
			let firstItem = listItems[0];
			let listItemsLength = listItems.length;
			console.dir(firstItem);
			console.dir(listItemsLength);
		</code></pre>
		<pre class="language-bash"><code>
			> li
			3
		</code></pre>
		<p>
			Now, while this evidences an array-like data structure, the HTMLCollection
			is <span class="underlineText">not</span> an array. They are in fact
			objects, which, as we know, is a type of record. Accordingly, methods like
			<span class="monoText">.pop()</span> and
			<span class="monoText">.push()</span> will not work with HTML collections.
		</p>
		<p>
			First, the HTMLCollection can only contain
			<span class="italicsText">element nodes</span>. Second, the HTMLCollection
			is <span class="term">live</span> &mdash; whenever a new element node is
			append to the DOM, the corresponding HTMLCollection that would contain
			that node is updated.
		</p>
	</section>

	<section id="node_list">
		<h2>Node Lists</h2>
		<p>
			With the <span class="monoText">.querySelectorAll()</span> method, we see
			the following return value:
		</p>
		<pre class="language-javascript"><code>
			let list = document.querySelectorAll('li');
			console.dir(list);
			typeof list
		</code></pre>
		<pre class="language-bash"><code>
			> NodeList(3)
			'object'
		</code></pre>
		<p>
			We see <span class="monoText">NodeList</span>. This is somewhat similar to
			the HTMLCollection, in that it looks and behaves like an array. We can
			iterate over the node list with the
			<span class="monoText">forEach</span> method.<label
				for="forEach"
				class="margin-toggle"
				><sup></sup
			></label>
			<input
				type="checkbox"
				id="forEach"
				class="margin-toggle sidenote-number"
			/>
			<span class="marginnote"
				>A fair warning: The <span class="monoText">forEach</span> method can be
				inefficient for iterating over a NodeList.</span
			>
			But again, it is <span class="underlineText">not</span> an array. Where
			the HTML collection is a list of nodes, the NodeList is an
			<span class="italicsText">aggregate</span> of nodes. And as we might
			expect, the NodeList too is an object, a record type.
		</p>
	</section>

	<section id="dom_token_list">
		<h2>DOM Token Lists</h2>
		<p>
			When using properties like <span class="monoText">.classList</span>, we
			see that the returned value is a <span class="term">DOMTokenList</span>.
			This is an <span class="term">ordered set</span> data structure. The
			DOMTokenList is effectively a <span class="italicsText">set</span> (a very
			lightweight data structure), wherein there are no duplicates.
		</p>
	</section>
</section>

<section id="dom_traversal">
	<h2>DOM Traversal</h2>
	<p>
		Many of the selection methods can be thought of as ways to traverse the
		DOM. Given a node ${obj,}$ we can move in three directions: left
		(selecting previous siblings), right (selecting later siblings), up
		(selecting parents or ancestors), and down (selecting children or
		descendants). Of course, we can always return a nodeList or an
		HTMLCollection and iterate or index, but it can be much faster to simply
		traverse the DOM directly. The diagram below provides a visual aid for
		deciding which traversal method to use.
	</p>
	<figure>
		<img
			src="{% static 'images/domTraversal.svg' %}"
			alt="Traversal methods"
			loading="lazy"
		/>
	</figure>
</section>

<section id="manipulating_elements">
	<h2>DOM Manipulation</h2>
	<p>
		Once we have selected an element, we can begin manipulating the element. The
		DOM provides numerous properties and methods we can use for manipulation.
		Below is an API of various properties and methods:
	</p>
	<figure class="table">
		<table class="api">
			<thead>
				<th>Identifier</th>
				<th>Meaning</th>
				<th>Comments</th>
			</thead>
			<tbody>
				<tr>
					<td
						colspan="3"
						style="
							font-family: var(--serif);
							background-color: rgb(255, 243, 209);
						"
					>
						Methods
					</td>
				</tr>
				<tr>
					<td><span class="monoText">${obj}$.getAttribute(${a}$)</span></td>
					<td>
						Returns the value assigned to the attribute ${a}$ of ${obj.}$
						Argument passed, ${a,}$ is of type
						<span class="monoText">string</span>.
					</td>
					<td>
						Examples: <span class="monoText">href</span>,
						<span class="monoText">src</span>,
						<span class="monoText">class</span>,
						<span class="monoText">type</span>,
						<span class="monoText">id</span>, etc.
					</td>
				</tr>
				<tr>
					<td>
						<span class="monoText">${obj}$.setAttribute(${a}$, ${v}$)</span>
					</td>
					<td>
						Assign to the attribute ${a}$ of ${obj}$ the value ${v.}$ Both ${a}$
						and ${v}$ are arguments of type
						<span class="monoText">string</span>.
					</td>
					<td></td>
				</tr>
				<tr>
					<td><span class="monoText">${obj}$.appendChild(${s}$)</span></td>
					<td>Appends the element ${s}$ as a child of ${obj.}$</td>
					<td>If ${obj}$ has children, ${s}$ is appended as the last child.</td>
				</tr>
				<tr>
					<td>
						<span class="monoText">${obj}$.append(${s_0, \ldots, s_n}$)</span>
					</td>
					<td>
						Inserts the element objects ${s_0, \ldots, s_n}$ as children of
						${obj}$ in sequence. If ${obj}$ has existing children, the objects
						${s_0, \ldots, s_n}$ are inserted at
						<span class="underlineText">after</span> the last child.
					</td>
					<td></td>
				</tr>
				<tr>
					<td><span class="monoText">${obj}$.prepend()</span></td>
					<td>
						Inserts the element objects ${s_0, \ldots, s_n}$ as children of
						${obj}$ in sequence. If ${obj}$ has existing children, the objects
						${s_0, \ldots, s_n}$ are inserted at
						<span class="underlineText">before</span> the first child.
					</td>
					<td></td>
				</tr>
				<tr>
					<td>
						<span class="monoText"
							>${obj_p}$.insertBefore(${obj_0}$, ${obj_1}$)</span
						>
					</td>
					<td>
						Where ${obj_p}$ is a branch node object (i.e., an object with
						children), inserts the element ${obj_0}$ before the element
						${obj_1}$ as children of ${obj_p.}$
					</td>
					<td></td>
				</tr>
				<tr>
					<td>
						<span class="monoText"
							>${obj_p}$.insertAdjacentElement(${i}$, ${s}$).</span
						>
					</td>
					<td>
						Where ${obj_p}$ is a branch node object, inserts the element object
						${s}$ at position ${p.}$ Both arguments are strings.
					</td>
					<td>
						${i}$ takes 1 of 4 string values:
						<span class="monoText">'beforebegin'</span> (before ${obj_p}$
						itself), <span class="monoText">'afterbegin'</span> (inside
						${obj_p}$ and before its first child),
						<span class="monoText">'beforeend'</span> (inside ${obj_p}$ and
						after its last child),
						<span class="monoText">'afterend'</span> (after ${obj_p}$ itself).
					</td>
				</tr>

				<tr>
					<td><span class="monoText">${obj}$.removeChild(${s}$)</span></td>
					<td>
						Where ${obj}$ is a branch node and ${s}$ is a child of ${obj,}$
						destroys the child ${s.}$
					</td>
					<td></td>
				</tr>
				<tr>
					<td><span class="monoText">${obj}$.remove()</span></td>
					<td>Destroys the object ${obj.}$</td>
					<td>No arguments passed to this method.</td>
				</tr>
				<tr>
					<td><span class="monoText">document.createElement(${s}$)</span></td>
					<td>
						Creates a new element and returns the new element ${s,}$ where ${s}$
						is the element's type as a string. E.g.,
						<span class="monoText">document.createElement(p)</span> creates a
						new paragraph element.
					</td>
					<td>
						This only creates an element and returns the element's object
						representation. It does not append the element to the page, or set
						its properties like <span class="monoText">innerText</span>. To do
						so, we must provide additional statements. E.g., use one of the
						append methods to insert the element into the page.
					</td>
				</tr>
				<tr>
					<td><span class="monoText">getComputedStyle(${obj}$)</span></td>
					<td>
						Returns an object containing all the CSS properties of ${obj}$.
					</td>
					<td>
						Notice that this method is not called with an object. Instead, an
						object is passed into the method. This is because the
						<span class="monoText">getComputedStyle()</span> method is provided
						by the <span class="monoText">Window</span>, the global object on
						the browser. Thus, the full call looks like
						<span class="monoText">Window.getComputedStyle(${obj}$)</span>. The
						object returned contains <span class="underlineText">all</span> of
						the applicable style properties. Many of these properties have
						values, even if we didn't set them, because the browser sets many
						properties by default.
					</td>
				</tr>
				<tr>
					<td
						colspan="3"
						style="
							font-family: var(--serif);
							background-color: rgb(255, 243, 209);
						"
					>
						Properties
					</td>
				</tr>
				<tr>
					<td><span class="monoText">${obj}$.classList</span></td>
					<td>
						Returns a <span class="monoText">DOMTokenList</span> of all the
						values assigned to the element's
						<span class="monoText">class</span> attribute.
					</td>
					<td>
						This is a useful property for modifying multiple styles on an
						${obj.}$ With <span class="monoText">.classList</span>, we can call
						the methods
						<span class="monoText">${obj}$.classList.add(${s}$)</span> to add a
						new value to ${obj}$'s class attribute,
						<span class="monoText">${obj}$.classList.remove(${s}$)</span> to
						remove a value in ${obj}$'s class attribute, and
						<span class="monoText">${obj}$.toggle(${s}$)</span>, which removes
						the value ${s}$ to the class attribute if it's present, and adds the
						value ${s}$ if it is absent.
					</td>
				</tr>
				<tr>
					<td><span class="monoText">${obj}$.innerText</span></td>
					<td>
						Where ${obj}$ is an HTML element object, returns the text (type
						<span class="monoText">string</span>) in between the tags. When
						using <span class="monoText">querySelector()</span> on an object
						with children, the returned value is the inner text of all the
						children in a single string (escape sequences used).
					</td>
					<td>
						Changing the value assigned to
						<span class="monoText">innerText</span> will result in changes the
						text on the page. String returned does not include parts of text
						hidden via CSS, text between script tags, or tags.
					</td>
				</tr>
				<tr>
					<td><span class="monoText">${obj}.$textContent</span></td>
					<td>
						Similar to <span class="monoText">innerText</span>, in that it
						returns the contents between the HTML tags. However, the string
						returned will include <span class="underlineText">all</span> the
						text displayed on the page, except for tags.
					</td>
					<td>
						<span class="italicsText">Supra above cell.</span>
						<span class="monoText">textContent</span> is slightly faster, since
						it does not have to perform additional computations to ignore
						certain text.
					</td>
				</tr>
				<tr>
					<td><span class="monoText">${obj}$.innerHTML</span></td>
					<td>
						Returns a string of all the HTML elements (include the tags) in
						${obj.}$
					</td>
					<td>
						<span class="monoText">innerHTML</span> can be used to add tags, but
						values assigned must be of type
						<span class="monoText">string.</span>
					</td>
				</tr>
				<tr>
					<td><span class="monoText">${obj}$.value</span></td>
					<td>
						Returns the value of ${obj.}$ Most commonly used with the
						<span class="monoText">input</span> tag.
					</td>
					<td></td>
				</tr>
				<tr>
					<td><span class="monoText">${obj}$.checked</span></td>
					<td>
						Returns the value of an <span class="monoText">input</span> element
						with type attribute of <span class="monoText">checkbox</span>. If
						checked, return value is <span class="monoText">true</span>,
						otherwise <span class="monoText">false</span>.
					</td>
					<td></td>
				</tr>
				<tr>
					<td><span class="monoText">${obj}$.parentElement</span></td>
					<td>Returns the parent element of ${obj.}$</td>
					<td>
						E.g., assuming proper style,
						<span class="monoText">li.parentElement</span> would return
						<span class="monoText">ul</span> or
						<span class="monoText">ol</span> object. To target the
						&#8220;grandparent&#8221; element, we can write
						<span class="monoText">${obj}$.parentElement.parentElement</span>.
						We can think of this method as climbing &#8220;up&#8221; the tree.
					</td>
				</tr>
				<tr>
					<td><span class="monoText">${obj}$.children</span></td>
					<td>Returns an HTMLCollection of all the children of ${obj.}$</td>
					<td></td>
				</tr>
				<tr>
					<td><span class="monoText">${obj}$.nextElementSibling</span></td>
					<td>
						Returns the element <span class="underlineText">after</span> ${obj}$
						on the same level in the tree.
					</td>
					<td></td>
				</tr>
				<tr>
					<td><span class="monoText">${obj}$.previousSibling</span></td>
					<td>
						Returns the element
						<span class="underlineText">before</span> ${obj}$ on the same level
						in the DOM tree.
					</td>
					<td></td>
				</tr>
				<tr>
					<td><span class="monoText">${obj}$.style</span></td>
					<td>
						Returns an object containing all of the style properties of ${obj.}$
					</td>
					<td>
						Assuming the page follows standard practices, the properties in the
						returned object are displayed with empty string values. This is
						because the values set in the returned object are values provided
						via <span class="underlineText">inline styling</span>. Because
						inline styles are generally considered poor practice, the properties
						will usually have empty string values. To read existing values,
						<span class="italicsText">see</span>
						<span class="monoText">.getComputedStyle()</span> above. We can,
						however, use the <span class="monoText">.style</span> property to
						mutate the ${obj}$'s styles. For examle,
						<span class="monoText">${obj}$.style.color = 'blue'</span> will
						change the text color to blue. Additionally, property names are
						written in JavaScript syntax. E.g., because JavaScript doesn't allow
						dashes in names, the CSS property
						<span class="monoText">background-color</span> is identified in the
						object in camelCase: <span class="monoText">backgroundColor</span>.
						Finally, note that mutating this property effectively adds inline
						styles to the ${obj.}$ As such, this will overwrite any existing
						styles we've applied via CSS.
					</td>
				</tr>
			</tbody>
		</table>
	</figure>

	<section id="common_idoms">
		<h3>Common Idioms</h3>
		<p>
			Because the DOM provides the means for manipulating HTML pages, there are
			several common idioms for DOM manipulation. We present these idioms below.
		</p>
		<section id="changing_multiple_elements">
			<p>
				<span class="topic">Changing Multiple Elements.</span> To change
				multiple elements, one common pattern is to store a NodeList, or
				HTMLCollection, in a variable, then iterate over it:
			</p>
			<pre class="language-javascript"><code>
				const list = document.querySelectorAll('li');
				for (let i = 0; i < list.length; i++) {
					list[i].innerText = "Mutated";
				}
			</code></pre>
			<p>
				The code above changes all the list items inner text to the string
				<span class="monoText">"Mutated"</span>. This idiom is particularly
				powerful, in that it allows us to change many properties, such as
				<span class="monoText">.innerHTML</span> and
				<span class="monoText">.style</span>.
			</p>
		</section>

		<section id="changing_multiple_styles">
			<p>
				<span class="topic">Applying Multiple Styles.</span> Another common
				idiom is applying multiple styles to an element. This is done by
				appending, removing, or modifying the element's styles applied via CSS
				throuh the element's <span class="monoText">class</span> attribute. For
				example, say we had the following HTML code:
			</p>
			<pre class="language-html"><code>
				&lt;!DOCTYPE html&gt;
				&lt;html lang=&quot;en&quot;&gt;
				&lt;head&gt;
				&#x9;&lt;title&gt;Lab&lt;/title&gt;
				&#x9;&lt;link rel=&quot;stylesheet&quot; href=&quot;./styles.css&quot;&gt;
				&lt;/head&gt;
				&lt;body&gt;
				&#x9;&lt;main&gt;
				&#x9;&#x9;&lt;h1&gt;H1 Tag&lt;/h1&gt;
				&#x9;&#x9;&lt;p&gt;Paragraph tag&lt;/p&gt;
				&#x9;&#x9;&lt;ul id=&quot;todo&quot;&gt;
				&#x9;&#x9;&#x9;&lt;li class=&quot;incomplete&quot;&gt;List item 1&lt;/li&gt;
				&#x9;&#x9;&#x9;&lt;li class=&quot;incomplete&quot;&gt;List item 2&lt;/li&gt;
				&#x9;&#x9;&#x9;&lt;li class=&quot;incomplete&quot;&gt;List item 3&lt;/li&gt;
				&#x9;&#x9;&lt;/ul&gt;
				&#x9;&lt;/main&gt;
				&#x9;&lt;script src=&quot;./app.js&quot;&gt;&lt;/script&gt;
				&lt;/body&gt;
				&lt;/html&gt;&#x9;
			</code></pre>
			<p>The CSS appears as such:</p>
			<pre class="language-css"><code>
				main {
					font-family: sans-serif;
				}
				.redText {
					color: red;
				}
				.incomplete {
					color: green;
				}
			</code></pre>
			<p>
				Suppose that we wanted to have a list item once its marked complete. To
				do so, we write write a new class in the CSS file:
			</p>
			<pre class="language-css"><code>
				main {
					font-family: sans-serif;
				}
				.redText {
					color: red;
				}
				.incomplete {
					color: green;
				}
				.complete {
					color: grey;
					text-decoration: line-through;
				}
			</code></pre>
			<p>
				We can then apply the <span class="monoText">.complete</span> class to
				the respective <span class="monoText">li</span> object:
			</p>
			<pre class="language-javascript"><code>
				const todoList = document.querySelectorAll('li');
				let firstTodo = todoList[0];
				firstTodo.setAttribute('class', 'complete')
			</code></pre>
			<p>
				Alternatively, we could have used a method from the
				<span class="monoText">.classList</span> property.
			</p>
		</section>
	</section>
</section>

<section id="dom_events">
	<h2>Event-driven Programming</h2>
	<p>
		Once we know how to target and manipulate the DOM tree and its nodes, we can
		begin investigating <span class="italicsText">events</span>. To understand
		what events are, it's helpful to think about the different kinds of programs
		we can write.
	</p>
	<p>
		In much of the preceding sections and volumes, we've been writing
		<span class="term">console programs</span> &mdash; programs that run
		primarily on the console. We can, however, also write
		<span class="term">interactive programs</span> &mdash; programs that allow
		the user to control a program's actions by using
		<span class="italicsText">peripherals</span>. Such peripherals include a
		keyboard, joystick, mouse, trackpad, microphone, etc. When a user performs
		some action with a peripheral, we call that action an
		<span class="term">event</span>. For example: Clicking on a mouse, hitting
		the enter or arrow keys, touching a particular part of a screen, saying a
		particular word into a microphone, these are all events. Programs that are
		designed to respond to these events are called
		<span class="term">event-driven programs</span>. In their simplest forms,
		such programs take events as input, and return some output.
	</p>
	<p>
		In modern interactive programs, user input does not occur at predictable
		times. For example, think about clicking on the &#8220;Agree&#8221; button
		for a software usage license. Most users click the button immediately.
		Others (however few), will take the time to read the license before
		clicking. The program behind the license doesn't tell us when we should
		click the button (it would be poor choice, both business-wise and legally,
		to require a user to agree to a license in less than five seconds). All this
		is to say that modern interactive programs leave it up to the user
		<span class="italicsText">when</span> to trigger an event. And because
		events are not controlled by the program, we say that such programs are
		<span class="term">asynchronous</span>.
	</p>
	<p>
		In the JavaScript context, we implement such programs through functions that
		anticipate these events. By &#8220;anticipate&#8221; we mean that the
		functions are called <span class="underlineText">only if</span> an event
		occurs. These functions are more generally called
		<span class="term">listeners</span>. We can think of a listener as akin to
		the string telephones we played with in our days of youth:
	</p>
	<figure>
		<img
			src="{% static 'images/listener.svg' %}"
			alt="A string telephone"
			loading="lazy"
			class="sixty-p"
		/>
	</figure>
	<p>
		The listener &#8220;listens&#8221; to whatever the user sends as input,
		which in turn keeps a particular module in the program informed. That module
		then executes whatever statements we provide.
	</p>
	<p>
		Listeners are based on a foundational principle of functional programming:
		Functions are data values, just as an integer or a string is a data value.
		JavaScript abides by this principle in treating functions as
		<span class="italicsText">first-class</span>: We can assign them to
		variables, pass them as arguments, express them as arguments, and return
		them as results. Just to confirm that this is the case, recall our
		discussion on
		<a href="{% url 'numerc:js_functions' %}#javascript_function_expressions"
			>function expressions</a
		>. We could write the following function as such:
	</p>
	<pre class="language-javascript"><code>
		function fahrenheitToCelsius(f) {
			return 5 / 9 * (f - 32);
		}
	</code></pre>
	<p>
		But, we could also assign the function to a variable (a
		<span class="italicsText">closure</span>):
	</p>
	<pre class="language-javascript"><code>
		let fahrenheitToCelsius = function(f) { return 5 / 9 * (f - 32); };
	</code></pre>
	<p>
		When first discussed these different syntactical forms, we didn't expound to
		deeply on the advantages of using closures over formal function definitions.
		With listeners, however, there's a signficant benefit to using closures: We
		can declare the function as a local variable inside another function (e.g.,
		what we represented as a module in the diagram above). In that case, the
		inner function (the listener) includes all of the code in its body, which in
		turn has access to all the local variable in the outer function. To
		understand how this is so useful, we turn to JavaScript's
		<span class="italicsText">event listeners</span>.
	</p>

	<section id="event_listeners">
		<h3>Event Listeners</h3>
		<p>
			In JavaScript, the most common listeners used are
			<span class="term">event listeners</span>. The control flow appears as
			such:
		</p>
		<figure>
			<img
				src="{% static 'images/eventListener.svg' %}"
				alt="The control flow of an event listener"
				loading="lazy"
				class="sixty-p"
			/>
		</figure>
		<p>
			In the diagram above, the <span class="italicsText">target</span> is
			whatever element, or object, on the page (or in the Browser window) we
			expect the user the interact with, and the listener to listen to. We can
			think of the target as where on a wall we place a cup to listen to an
			adjacent room. The <span class="italicsText">event</span> is the event the
			function should listen to. And the
			<span class="italicsText">callback</span> is the function containing
			whatever statements we would like to run based on the event listeners
			output. For example, suppose a user clicks a button. The
			<span class="italicsText">target</span> is a
			<span class="monoText">button</span>, the
			<span class="italicsText">event</span> is a
			<span class="monoText">click</span>, and the
			<span class="italicsText">code to run</span> is whatever we'd like to do
			if the user clicks the button: E.g., change the position of an element,
			change text color, open a pop-up, etc.
		</p>
		<p>For example, suppose we had the following HTML code:</p>
		<pre class="language-html"><code>
			&lt;!DOCTYPE html&gt;
			&lt;html lang=&quot;en&quot;&gt;
			&lt;head&gt;
			&#x9;&lt;title&gt;Lab&lt;/title&gt;
			&#x9;&lt;link rel=&quot;stylesheet&quot; href=&quot;./styles.css&quot;&gt;
			&lt;/head&gt;
			&lt;body&gt;
			&#x9;&lt;main&gt;
			&#x9;&#x9;&lt;h1&gt;Some Buttons&lt;/h1&gt;
			&#x9;&#x9;&lt;ul&gt;
			&#x9;&#x9;&#x9;&lt;li&gt;&lt;button&gt;Button 1&lt;/button&gt;&lt;/li&gt;
			&#x9;&#x9;&#x9;&lt;li&gt;&lt;button&gt;Button 2&lt;/button&gt;&lt;/li&gt;
			&#x9;&#x9;&#x9;&lt;li&gt;&lt;button&gt;Button 3&lt;/button&gt;&lt;/li&gt;
			&#x9;&#x9;&lt;/ul&gt;
			&#x9;&lt;/main&gt;
			&#x9;&lt;script src=&quot;./app.js&quot;&gt;&lt;/script&gt;
			&lt;/body&gt;
			&lt;/html&gt;&#x9;&#x9;&#x9;
		</code></pre>
		<p>
			Let's consider a very simple example: When the user clicks the first
			button, the console outputs a message:
		</p>
		<pre class="language-javascript"><code>
			const buttonList = document.querySelectorAll('button');
			const firstButton = buttonList[0];

			firstButton.addEventListener('click', () => {
				console.log("First button clicked.");
			});
		</code></pre>
		<p>When we click the button, the console displays:</p>
		<pre class="language-bash"><code>
			First button clicked.
		</code></pre>
		<p>
			In the code above, we used the
			<span class="monoText">addEventListener()</span> method. This is a method
			provided by the DOM, and it is what we use &#8220;attach&#8221; an event
			listener to a particular target. The template:
		</p>
		<figure class="math-display">
			<ul class="syntax">
				<li>${obj}$.addEventListener(${e_t}$, ${f_c}$);</li>
			</ul>
		</figure>
		<p>
			In the template above, ${obj}$ is some DOM object (e.g., an HTML element
			like a button, paragraph, list item, slider, etc.) The first parameter,
			${e_t,}$ is the event itself. This is a string value specified by the DOM,
			and there are numerous event values: <span class="monoText">click</span>,
			<span class="monoText">mousedown</span>,
			<span class="monoText">drag</span>, etc. We will explore some of the most
			common events as we continue. The second parameter, ${f_c,}$ is the
			function that should execute when the event occurs. This is called the
			<span class="term">callback function</span>. It contains all of the
			statements we want to execute in response to the event occuring. Putting
			all this together with respect to the above example: The target is the
			first button element, the event is a
			<span class="monoText">'click'</span>, and the function is an anonymous
			function that displays to the console a message.
		</p>
		<p>
			This is where we see why having first-class in JavaScript is so useful. We
			can assign the callback function to a variable, and pass that variable as
			an argument to the event listener:
		</p>
		<pre class="language-javascript"><code>
			const buttonList = document.querySelectorAll('button');
			const firstButton = buttonList[0];
			const buttonMesage = () => { console.log("First button clicked.") };

			firstButton.addEventListener('click', buttonMesage);
		</code></pre>
		<p>Clicking the button once more:</p>
		<pre class="language-bash"><code>
			First button clicked.
		</code></pre>

		<section id="listen_to_multiple_objects">
			<p>
				<span class="topic">Attaching Listeners to Multiple Objects.</span> A
				common idiom in JavaScript is to attach listeners to multiple objects.
				For example, think of the upvote button on a Reddit page. It would
				tedious and unwieldy to attach listeners to each of the objects &mdash;
				there are thousands of them. Instead, what we want to do is use a loop.
				For example, suppose we had the following HTML code:
			</p>
			<pre class="language-html"><code>
				&lt;!DOCTYPE html&gt;
				&lt;html lang=&quot;en&quot;&gt;
				&#x9;&lt;head&gt;
				&#x9;&#x9;&lt;title&gt;Lab&lt;/title&gt;
				&#x9;&#x9;&lt;link rel=&quot;stylesheet&quot; href=&quot;./styles.css&quot; /&gt;
				&#x9;&lt;/head&gt;
				&#x9;&lt;body&gt;
				&#x9;&#x9;&lt;main&gt;
				&#x9;&#x9;&#x9;&lt;div id=&quot;container&quot;&gt;
				&#x9;&#x9;&#x9;&#x9;&lt;div&gt;&lt;/div&gt;
				&#x9;&#x9;&#x9;&#x9;&lt;div&gt;&lt;/div&gt;
				&#x9;&#x9;&#x9;&#x9;&lt;div&gt;&lt;/div&gt;
				&#x9;&#x9;&#x9;&lt;/div&gt;
				&#x9;&#x9;&lt;/main&gt;
				&#x9;&#x9;&lt;script src=&quot;./app.js&quot;&gt;&lt;/script&gt;
				&#x9;&lt;/body&gt;
				&lt;/html&gt;
			</code></pre>
			<p>Then, in our CSS, we have:</p>
			<pre class="language-css"><code>
				#container {
					display: flex;
					justify-content: center;
					align-items: center;
				}
				div div {
					border: solid thin grey;
					padding: 3em;
					margin: 5em;
				}
			</code></pre>
			<p>
				This displays three square boxes. Now, we want each of the boxes to
				change color when we hover over them. We can do so with the following
				JavaScript code:
			</p>
			<pre class="language-javascript"><code>
				const colors = ['red', 'green', 'blue'];
				const container = document.querySelectorAll('#container div');

				for (let i = 0; i < colors.length; i++) {
					container[i].addEventListener('mouseover', function () {
						this.style.backgroundColor = colors[i];
					})
				}
			</code></pre>
			<p>
				Note that the <span class="monoText">this</span> keyword refers to the
				object we're attaching the event listener to. In this case,
				<span class="monoText">container[i]</span>.
			</p>
		</section>
	</section>

	<section id="the_event_object">
		<h3>The Event Object</h3>
		<p>
			With event listeners, we, as the programmers, never actually call the
			callback functions. Instead, the event listener is what calls the
			callback, in response to an event. Moreover, the even listener passes an
			<span class="term">event object</span> to the callback. In fact, we can
			see that the event is passed by explicitly naming the argument. Suppose
			the HTML page contains a single button element:
		</p>
		<pre class="language-javascript"><code>
			const button = document.querySelector('button');
			button.addEventListener('click', function (evt) { 
				console.log(evt); 
			});
		</code></pre>
		<pre class="language-bash"><code>
			PointerEvent {isTrusted: true, pointerId: 1, width: 1, height: 1, pressure: 0, …}
		</code></pre>
		<p>
			We see that we get back an object with numerous properties. Notice the
			identifier <span class="monoText">PointerEvent</span>. This informs us
			what type of event object this is. There are numerous different types of
			event objects: <span class="monoText">MouseEvent</span>,
			<span class="monoText">KeyboardEvent</span>,
			<span class="monoText">DragEvent</span>,
			<span class="monoText">AnimationEvent</span>, and so on. More generally,
			the event objects are classified according to the kind of interaction by
			the user, as well as other forms of interactivity. Structurally, the event
			objects are records, or structs, containing various properties pertaining
			to the particular event. For example, the
			<span class="monoText">KeyboardEvent</span> has a property called
			<span class="monoText">key</span>, which returns the key value of the key
			pressed. The <span class="monoText">MouseEvent</span> has a property
			called <span class="monoText">button</span>, which returns which button on
			the mouse was pressed when the mouse event was triggered.
		</p>
		<p>
			Event objects are particularly useful because they allow us to be more
			specific with what kinds of inputs we want to trigger callback functions.
			For example, we can use the <span class="monoText">key</span> property to
			specify that a block of code in the callback function executes only if the
			<span class="monoText">enter</span> key is pressed. Or we can specify that
			another block executes only if a certain area around the target is hovered
			over with the mouse. In sum, event objects provide us with greater control
			over how events handled.
		</p>
	</section>
</section>

<section id="async_js">
	<h2>Asynchronous Programming</h2>
	<p>
		When we execute JavaScript code, the JavaScript interpreter uses a
		<span class="term">call stack</span> to keep track of its place during
		execution. The call stack is <span class="italicsText">stack</span> data
		structure. This is a very simple data structure that looks, and behaves,
		exactly as it sounds: The last thing we place on the stack is the first
		thing we get from the stack, and the first thing we place in the stack is
		the last thing we get from the stack. For example, a stack of dishes to be
		washed. The dish from yesterday is beneath the dish from today, and the dish
		from ereyesterday is beneath the dish from yesterday. When we wash them, we
		wash the dish from today, then the dish from yesterday, then the dish from
		ereyesterday.
	</p>
	<p>
		In JavaScript, the call stack operates like the dish washing example.
		Suppose the following functions are called sequentially:
	</p>
	<figure class="math-display">
		<div>
			<p>${\lang f(x), g(x), h(x) \rang}$</p>
		</div>
	</figure>
	<p>
		When JavaScript executes the first function, ${f(x),}$ it generates a
		<span class="italicsText">stack frame</span> for ${f(x)}$ and pushes that
		frame <span class="italicsText">pushes</span> ${f(x)}$ to the call stack:
	</p>
	<figure class="math-display">$$ \begin{aligned} f(x) \end{aligned} $$</figure>
	<p>
		When it encounters ${g(x),}$ it generates another stack frame for ${g(x)}$
		pushes that to the call stack:
	</p>
	<figure class="math-display">
		$$ \begin{align*} g(x) \\ \uparrow \\ f(x) \end{align*} $$
	</figure>
	<p>And when it counters ${h(x),}$ the same process occurs:</p>
	<figure class="math-display">
		$$ \begin{aligned} h(x) \\ \uparrow \\ g(x) \\ \uparrow \\ f(x)
		\end{aligned} $$
	</figure>
	<p>
		Once ${h(x)}$ finishes executing, its stack frame is
		<span class="italicsText">popped off</span> the stack:
	</p>
	<figure class="math-display">
		$$ \begin{aligned} g(x) \\ \uparrow \\ f(x) \end{aligned} $$
	</figure>
	<p>When ${g(x)}$ finishes executing, it too is popped off the stack:</p>
	<figure class="math-display">$$ \begin{aligned} f(x) \end{aligned} $$</figure>
	<p>
		This leaves ${f(x),}$ and once ${f(x)}$ finishes executing, it's popped off
		the stack. This control flow applies whether ${g(x)}$ and ${h(x)}$ are
		inside ${f(x),}$ or whether they are all separate functions in the program.
		Nesting, however, impacts the order the call stacks are generated, pushed,
		and popped. In general, when want to determine the order a function's stack
		frames are generated, pushed, and popped, we want to read the program top to
		bottom, right to left.
	</p>
	<p>
		This phenomenon of pushing and popping stack frames stems from a fundamental
		trait of JavaScript: JavaScript is a
		<span class="term">single-threaded language</span>. A single-threaded
		language is a language with a single call stack and a single memory heap. In
		effect, this means that within the language, we can only run one statement
		at a time. Because of this trait, JavaScript programs live in a
		<span class="term">synchronous environment</span> &mdash; an environment
		where functions return (i.e., are popped off) only after they have finished
		executing. Think carefully about what this means. Necessarily, when we call
		a function ${f,}$ nothing else in the program can run. All other functions
		must wait until ${f}$ finishes. This is the defining characteristic of the
		<span class="term">synchronous programming</span>. Tasks are done one at a
		time; there's no such thing as &#8220;multitasking.&#8221;
	</p>
	<p>
		The opposite of a single-threaded language is a
		<span class="term">multithreaded language</span>. With a multithreaded
		language, we can perform simultaneous executions of two or more parts of the
		program (e.g., functions). Multithreading is a defining characteristic of
		<span class="term">parallel programming</span> &mdash; programming where
		functions need not wait for another function to return before executing. Not
		very many languages have built-in support for multithreading. Languages like
		C++ and Java provide multithreading only if the operating system permits it.
		We will see in a moment why multithreading is a relatively rare feature.
	</p>
	<p>
		The opposite of the synchronous environment is an
		<span class="term">asynchronous environment</span> &mdash; an environment
		where multiple functions run and return at various points in time. With an
		asynchronous environment, we can perform
		<span class="term">asynchronous programming</span>: When we call a function
		${f,}$ the program continues to run, calling other functions like ${g}$ and
		${h.}$ When ${f}$ finishes, great, we can use ${f}$'s return value. If not,
		we can continue working on other things.
	</p>
	<p>
		We can compare asynchronous programming and synchronous programming with the
		following analogy: We have to make a caramel glaze and bake a cake. Under
		the synchronous programming model, we must do one or the other, not both,
		before proceeding to the next. In other words, we have to finish making the
		glaze before baking the cake, or we have to finish baking the cake before
		making the glaze. In the asynchronous programming model, we can start baking
		the pie, then while it's in the oven, we move on to the glaze, waiting for
		the pie to finish.
	</p>
	<p>
		We might be thinking, why don't all languages just default to multithreaded
		implementations? If they did so, we would be able to perform asynchronous
		programming as needed. It is, after all, much more efficient to work on the
		glaze while the cake bakes. The answer lies in thinking a little more
		carefully on the analogy. Preparing a glaze alongside baking a cake is
		actually much more complex than it seems. If we start the glaze too early,
		it can harden, decreasing its viscosity. Start too late, and we can burn the
		cake.
	</p>
	<p>
		This same difficulty extends to multithreaded programs. It can be much more
		difficult to reason about what a multithreaded program does at any given
		point in time. We have to keep track of different functions executing at
		once. Moreover, if we reflect a little more deeply, we'd realize that we
		aren't very good at multitasking ourselves. Sure, we can tie our shoelaces
		while talking to someone, but if the conversation was on the mechanics of
		the proof for &#8220;This statement is a theorem,&#8221; no doubt we would
		pause. In fact, some tasks are so involved that we have laws ensuring we
		don't multitask: &#8220;No person may drive ... any motor vehicle while
		composing or sending an electronic text message or an electronic mail
		message.&#8221; Wis. Stat. §346.89(3)(a).
	</p>
	<p>
		Nevertheless, there are some tasks that we can reason about easily. And
		there are some tasks that we <span class="italicsText">want</span> to
		perform while performing another. The fact that these tasks exist is partly
		why we have Bluetooth headsets and speech-to-text software. This extends to
		JavaScript programs. In fact, many websites rely on asynchronous
		programming. When we click the &#8220;Watch&#8221; button on Netflix, a
		request is sent to a server to retrieve the relevant video file. This is
		done with a function, and that function can take time. The page, however,
		doesn't just freeze while the program waits for the function to finish.
		Instead, we're greeted with some animations indicating some loading is going
		on in the background. These animations are performed with functions. How
		does JavaScript achieve something like this?
	</p>

	<section id="asynchronous_callbacks">
		<h3>Asychronous Callbacks</h3>
		<p>
			The more general question is, how do we implement asynchronous programs in
			a synchronous environment? The answer is through
			<span class="term">asynchronous callbacks</span> (also called
			<span class="italicsText">call-after functions</span>). The callback
			functions we saw in the previous examples are instances of
			<span class="term">synchronous callbacks</span> &mdash; callbacks that
			execute immediately. With asynchronous callbacks, the callback is executed
			only after some delay; i.e., at a later point in time. These asynchronous
			callbacks are done with two methods: a
			<span class="term">one-shot timer</span> implemented with the
			<span class="monoText">setTime()</span> method, and an
			<span class="term">interval timer</span>, implemented with the
			<span class="monoText">setInterval()</span> method.
		</p>
		<p>The template for the <span class="monoText">setTime()</span> method:</p>
		<figure class="math-display">
			<ul class="syntax">
				<li>setTimeout(${f}$, ${t}$)</li>
			</ul>
		</figure>
		<p>
			In the template above, ${f}$ is some function, and ${t}$ is an integer
			value of time, measured in milliseconds. And the template for the
			<span class="monoText">setInterval()</span> method:
		</p>
		<figure class="math-display">
			<ul class="syntax">
				<li>setInterval(${f}$, ${I}$)</li>
			</ul>
		</figure>
		<p>
			Here, ${f}$ is some function, and ${I}$ is an integer value of time,
			measured in milliseconds. With
			<span class="monoText">setInterval()</span>, the function ${f}$ is called
			every ${I}$ milliseconds (hence an
			<span class="italicsText">interval time</span>). Furthermore,
			<span class="monoText">setInterval()</span> returns a numeric value ${v}$
			that can be used to stop the timer. This is done by calling the method
			<span class="monoText">clearTimeout()</span>, passing ${v}$ as an argument
			&mdash; <span class="monoText">clearTimeout(${v}$)</span>.
		</p>
		<p>
			Question: But isn't JavaScript itself executing these functions? In other
			words, itsn't JavaScript running another process (keeping track of time)
			while it continues executing the next function? This is an astute
			observation, but the answer is no. These methods are called by JavaScript,
			but executed by the <span class="italicsText">browser</span>. This is
			JavaScript's secret to asynchrony (well, not quite; it's public knowledge,
			just not widely-known). Because JavaScript only has one thread to rely on,
			it sends the tasks of keeping tracking of the delay's time and reminding
			to execute to another program's thread &mdash; the browser's.
		</p>
		<p>
			So now the question is how does this work? Recall that JavaScript lives
			only in a hosted environment. One of these environments is the browser, a
			program more than likely written in C++. Browsers provide numerous
			interfaces, one of which provides methods like
			<span class="monoText">setTimeout()</span> and
			<span class="monoText">setInterval()</span>. When the JavaScript engine
			encounters a call like <span class="monoText">setTimeout()</span>, it
			generates a stack frame for the function, and pushes it onto the call
			stack as it would any other. Once at the call stack, however, the call
			stack itself recognizes <span class="monoText">setTimeout()</span> as one
			of the browser's web API functions and hands them over to the browser. The
			browser then starts a timer, per our argument. Once the time passes, the
			browser inserts a <span class="term">timeout event</span> to a data
			structure called the <span class="term">event queue</span>.
		</p>
		<p>
			The event queue is exactly what it sounds like: A line of entities in
			waiting. The queue exhibits a behavior we're all familiar with &mdash; if
			you're the first in line, you're the first one out (assuming an orderly
			society). In this case, the timeout event inserted into the queue includes
			the function we want executed after the delay. Once the timer is over, the
			JavaScript engine processes the call as usual.
		</p>
		<p>
			With callbacks, we can <span class="italicsText">simulate</span> what
			looks like multithreaded programming, but is not. To understand this
			simulation, we have to be clear about the distinction between
			single-threaded programs, multi-threaded programs, synchronous programs,
			and asynchronous programs.
		</p>
		<p>
			In a <span class="term">single-threaded program</span>, only one command
			is executed in a single process. As we know, JavaScript is a
			single-threaded language. All JavaScript programs are single-threaded. In
			a <span class="term">multi-threaded program</span>, multiple commands are
			executed within a single process. Multi-threaded programs are possible
			only if the operating system supports it. For example, on a Windows system
			with the ThreadFiber package, we can write multi-threaded C programs. In a
			<span class="term">synchronous program</span>, commands are executed one
			by one, immediately after one another. Before we encountered the
			asynchronous callback functions we saw above, our JavaScript programs have
			been synchronous. In an <span class="term">asynchronous program</span>,
			commands are executed one by one, but some commands are delayed (i.e.,
			executed later). We can compare these different approaches via diagram.
			Each of the colored boxes below represents a function:
		</p>
		<figure>
			<img
				src="{% static 'images/approachComparisons.svg' %}"
				alt="Comparing the different approaches, multi-threaded takes the least amoung of time."
				loading="lazy"
				class="seventy-p"
			/>
		</figure>
		<p>
			Once again, with the asynchronous callbacks above, JavaScript is not
			setting a timer and keeping track of it. It hands that work to the browser
			for handling. Once the timer has finished, the function we delayed is
			placed on the callstack.
		</p>
	</section>

	<section id="callback_hell">
		<h4>Callback Hell</h4>
		<p>
			When using callbacks, it's easy to succumb to a pattern where callbacks
			are nested within callbacks. This in turn can lead even deeper nesting,
			resulting in what JavaScript developers call
			<span class="term">callback hell</span>. To understand why these patterns
			occur, it's helpful to think of a procedure that requires outputs from
			other procedures. For example, the procedure for making a hotdog:
		</p>
		<figure class="math-display">
			<div>
				<ol>
					<li>Get hotdog.</li>
					<li>Cook hotdog.</li>
					<li>Get bun.</li>
					<li>Place hotdog on bun.</li>
				</ol>
			</div>
		</figure>
		<p>A synchronous program would appear as such:</p>
		<pre class="language-javascript"><code>
			const makeHotdog = () => {
				const rawHotdog = getHotDog();
				const cookedHotdog = cookHotdog(rawHotdog);
				const bun = getBun();
				const hotdog = placeHotdogOnBun(cookedHotdog, bun);
				return hotdog;
			}

			const hotdog = makeHotdog();
		</code></pre>
		<p>
			An asynchronous program &mdash; one that more closely resembles reality
			&mdash; would appear as such:
		</p>
		<pre class="language-javascript"><code>
			const makeHotdog = () => {
				getHotdog(function(hotdog) {
					cookHotdog(hotdog, function(cookedHotdog) {
						getBun(function(bun) {
							placeHotDogOnBun(bun, hotdog, function(finishedHotdog) {
								nextStep();
							})
						})
					})
				})
			};

			makeHotDog(function (hotdog) => {
				serve(hotdog);
			});
		</code></pre>
		<p>
			For those coming from functional programming backgrounds, the code above
			is likely perfectly readable. For others, however, such deeply nested
			functions can easily lead to confusion. Moreover, this is a relatively
			simple example of a deeply nested callback pattern. These patterns can
			easily nest multiple levels deep.
		</p>
		<p>
			To alleviate and prevent suffering under these patterns, JavaScript
			provides the construct of <span class="term">promises</span>. We examine
			them in the next section.
		</p>
	</section>

	<secton id="promises">
		<h4>Promises</h4>
		<p></p>
	</secton>
</section>

{% endblock %}
