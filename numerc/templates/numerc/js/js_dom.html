{% extends '../layout.html' %} {% load static %} {% block description %}
<meta
	name="description"
	content="What is the DOM in JavaScript? An overview of the Document Object Model."
/>
{% endblock %} {% block title %}
<title>The DOM</title>
{% endblock %} {% block content %}
<h1>The Document Object Model (DOM)</h1>
<section id="intro">
	<p>
		<span class="drop">J</span>avaScript is synonymous with web development. But
		how exactly does it generate dynamic web pages? The answer is through the
		<span class="term">Document Object Model</span> (&#8220;DOM&#8221;). In this
		section, we explore how the DOM works, as well as the various ways we link
		JavaScript, HTML, and CSS.
	</p>
	<p>
		To begin, the examples below are based on three separate files:
		<span class="monoText">lab.html</span>,
		<span class="monoText">app.js</span>, and
		<span class="monoText">styles.css</span>. These files are all within the
		same directory:
	</p>
	<figure class="math-display">
		<div>
			<pre class="language-pseudo"><code>
				.
				├── lab.html
				├── app.js
				└── styles.css
			</code></pre>
		</div>
	</figure>
	<p>
		The <span class="monoText">styles.css</span> and
		<span class="monoText">app.js</span> files do not contain anything for now.
		The <span class="monoText">lab.html</span> file, however, contains the
		following code:
	</p>
	<pre class="language-html"><code>
		&lt;!DOCTYPE html&gt;
		&lt;html lang=&quot;en&quot;&gt;
		&lt;head&gt;
		&#x9;&lt;meta charset=&quot;UTF-8&quot;&gt;
		&#x9;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
		&#x9;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
		&#x9;&lt;title&gt;Lab&lt;/title&gt;
		&#x9;&lt;link rel=&quot;stylesheet&quot; href=&quot;./styles.css&quot;&gt;
		&lt;/head&gt;
		&lt;body&gt;
		&#x9;&lt;main&gt;
		&#x9;&#x9;&lt;h1&gt;H1 Tag&lt;/h1&gt;
		&#x9;&#x9;&lt;p&gt;Paragraph tag&lt;/p&gt;
		&#x9;&#x9;&lt;ul&gt;
		&#x9;&#x9;&#x9;&lt;li&gt;List item 1&lt;/li&gt;
		&#x9;&#x9;&#x9;&lt;li&gt;List item 2&lt;/li&gt;
		&#x9;&#x9;&#x9;&lt;li&gt;List item 3&lt;/li&gt;
		&#x9;&#x9;&lt;/ul&gt;
		&#x9;&lt;/main&gt;
		&#x9;&lt;script src=&quot;./app.js&quot;&gt;&lt;/script&gt;
		&lt;/body&gt;
		&lt;/html&gt;
	</code></pre>
	<p>
		Note that the following discussion assumes basic knowledge of HTML and CSS.
		If the syntax above or CSS is entirely foreign, we recommend looking up a
		few basic tutorials on HTML and CSS.
	</p>
</section>

<section id="what_is_the_dom">
	<h2>What is the DOM?</h2>
	<p>
		The DOM is JavaScript's representation of an HTML document. It is a
		<span class="term">tree</span> data structure, and more specifically, a
		<span class="term">node tree</span>. From a very high-level overview, when
		the browser loads an HTML document, the browser takes all of the HTML
		elements and returns JavaScript objects. Each of these objects is a
		<span class="term">node</span> on the tree. Some of the nodes have children.
		These nodes are called <span class="term">branch nodes</span>, because they
		have <span class="term">branches</span> to other nodes. Other nodes do not
		have children, in which case they are called
		<span class="term">leaves</span>.
	</p>
	<p>
		Because each node in the tree is represented as a JavaScript object, we can
		interact with them via JavaScript. Hence, the DOM is simply an interface for
		interacting with HTML documents. For example, given the following HTML code:
	</p>
	<pre class="language-html"><code>
		&lt;html&gt;
			&lt;head&gt;
				&lt;title&gt;My Webpage&lt;/title&gt;
			&lt;/head&gt;
			&lt;body&gt;
			&#x9;&lt;h1&gt;Heading&lt;/h1&gt;
			&#x9;&lt;ul&gt;
			&#x9;&#x9;&lt;li&gt;List Item 1&lt;/li&gt;
			&#x9;&#x9;&lt;li&gt;List Item 2&lt;/li&gt;
			&#x9;&lt;/ul&gt;
			&lt;/body&gt;
		&lt;/html&gt;
	</code></pre>
	<p>
		The browser generates a node tree whose nodes are the HTML elements
		represented as objects:
	</p>
	<figure>
		<img
			src="{% static 'images/domTree.svg' %}"
			alt="The DOM Tree Object"
			loading="lazy"
			class="thirty-p"
		/>
	</figure>
	<p>
		The root node is the <span class="monoText">html</span> element. It is from
		this node that we have all the other nodes:
		<span class="monoText">body</span>, <span class="monoText">h1</span>,
		<span class="monoText">ul</span>, <span class="monoText">li</span>, etc.
		These nodes are all objects. Each node has either a
		<span class="term">parent</span>, <span class="term">children</span>, or
		both. For example, the <span class="monoText">html</span> element has two
		children, <span class="monoText">head</span> and
		<span class="monoText">body</span>. <span class="monoText">head</span> has
		one child, the <span class="monoText">title</span> element.
	</p>
	<p>
		Again, all of these are objects, and the entire node tree is an object.
		Roughly, the tree above looks something like:
	</p>
	<figure class="math-display">
		<div>
			<pre class="language-pseudo"><code>
				Window: {
					document: {
						html: {
							head: {
								title: { innerText: "My Webpage" }
							},
							body: {
								h1: { innerText: "Heading" },
								ul: {
									li: { innerText: "List Item 1" },
									li: { innerText: "List Item 1" }
								}
							}
						}
					}
				}
			</code></pre>
		</div>
	</figure>
	<p>
		The root of the tree is the <span class="term">document object</span>. We
		can think of the document object as the entry point to the rest of the tree.
		If we run <span class="monoText">console.dir(document)</span> on an HTML
		page, we can see an entire representation of the document (the output is
		omitted here because of its length, but do try it).
	</p>
	<p>
		The above gives us a better sense of what the DOM is. If we wanted to see
		what it actually looks like, open a console on a webpage, and run
		<span class="monoText">console.log(this)</span>. The rough outline above
		omits most of what's actually contained in the tree &mdash; the DOM contains
		numerous properties and methods.
	</p>
	<p>
		Each of the objects have properties. In the example above, the
		<span class="monoText">h1</span> object has a property called
		<span class="monoText">innerText</span>. Here, that property is bound to the
		value <span class="monoText">"Heading"</span>, a string. These objects all
		contain numerous properties: Styles, content, children, parents, etc. With
		JavaScript, we can modify these properties. We can also create and delete
		nodes on the tree, effectively adding new elements and removing existing
		ones from the HTML document. This discussion reveals a key insight to
		developing web pages with JavaScript: Whenever we use JavaScript to affect
		changes on a webpage, we are really manipulating the leaves and branches in
		a tree.
	</p>
</section>

<section id="targeting_elements">
	<h2>DOM Getters</h2>
	<p>
		From the JavaScript perspective, an HTML page is just one giant object. More
		specifically, a giant tree. Accordingly, to manipulate HTML pages, we
		manipulate the DOM tree's nodes. The first step to doing so is to select, or
		target, nodes in the tree. We can think of these as being akin to
		<span class="term">getters</span> in other OOP languages. This is done by
		using methods provided by the DOM. To get started, the HTML and CSS files
		we're working with look like this:
	</p>
	<div class="compare">
		<pre class="language-html"><code>
			&lt;!DOCTYPE html&gt;
			&lt;html lang=&quot;en&quot;&gt;
			&lt;head&gt;
			&#x9;&lt;title&gt;Lab&lt;/title&gt;
			&#x9;&lt;link rel=&quot;stylesheet&quot; href=&quot;./styles.css&quot;&gt;
			&lt;/head&gt;
			&lt;body&gt;
			&#x9;&lt;main&gt;
			&#x9;&#x9;&lt;h1 class=&quot;redText&quot;&gt;H1 Tag&lt;/h1&gt;
			&#x9;&#x9;&lt;p id=&quot;firstP&quot;&gt;Paragraph tag&lt;/p&gt;
			&#x9;&#x9;&lt;ul class=&quot;firstList&quot;&gt;
			&#x9;&#x9;&#x9;&lt;li&gt;List item 1&lt;/li&gt;
			&#x9;&#x9;&#x9;&lt;li&gt;List item 2&lt;/li&gt;
			&#x9;&#x9;&#x9;&lt;li&gt;List item 3&lt;/li&gt;
			&#x9;&#x9;&lt;/ul&gt;
			&#x9;&lt;/main&gt;
			&#x9;&lt;script src=&quot;./app.js&quot;&gt;&lt;/script&gt;
			&lt;/body&gt;
			&lt;/html&gt;
		</code></pre>
		<pre class="language-css"><code>
			main { 
				font-family: sans-serif; 
			}
			.redText { 
				color: red; 
			}
		</code></pre>
	</div>
	<p>Here is an API for targetting the various nodes in the tree:</p>
	<figure class="table">
		<table class="api">
			<thead>
				<th>Method</th>
				<th>Meaning</th>
				<th>Comments</th>
			</thead>
			<tbody>
				<tr>
					<td colspan="3" style="font-family: var(--serif)">
						Where ${obj}$ is some object in the DOM (e.g.,
						<span class="monoText">document</span>,
						<span class="monoText">ul</span>,
						<span class="monoText">section</span>,
						<span class="monoText">div</span>, etc.):
					</td>
				</tr>
				<tr>
					<td><span class="monoText">${obj}$.getElementById(${s}$)</span></td>
					<td>
						Where ${v}$ is a string, returns the HTML element with the matching
						<span class="monoText">id</span> attribute with value ${s.}$ If no
						match is found, the return value is
						<span class="monoText">null</span>.
					</td>
					<td>By &#8220;HTML element&#8221;, we mean an object.</td>
				</tr>
				<tr>
					<td>
						<span class="monoText">${obj}$.getElementsByTagName(${s}$)</span>
					</td>
					<td>
						Where ${s}$ is a string, returns an
						<a href="#html_collection"
							><span class="monoText">HTMLCollection</span></a
						>
						of all the elements with the tag name ${s.}$
					</td>
					<td>
						The <span class="monoText">HTMLCollection</span> looks like an
						array, but it is not an array.
					</td>
				</tr>
				<tr>
					<td>
						<span class="monoText">${obj}$.getElementsByClassName(${s}$)</span>
					</td>
					<td>
						Where ${s}$ is a string, returns an
						<span class="monoText">HTMLCollection</span>
						of all the elements with the class name ${s.}$ If no match is found,
						an empty
						<span class="monoText">HTMLCollection</span>
						is returned.
					</td>
					<td><span class="italicsText">Supra above cell.</span></td>
				</tr>
				<tr>
					<td><span class="monoText">${obj}$.querySelector(${s}$)</span></td>
					<td>
						Where ${s}$ is a string, returns the
						<span class="underlineText">first</span> element with the attribute,
						class, or element name with the string. If ${s}$ is written as a CSS
						selector, then the method will evalute according to the selector.
						For example,
						<span class="monoText">document.querySelector('#red')</span> will
						select the first element with the
						<span class="monoText">id</span> attribute of value
						<span class="monoText">'red'</span>.
						<span class="monoText">document.querySelector('.green')</span> will
						select the first element swith the
						<span class="monoText">class</span> attribute set to
						<span class="monoText">'green'</span>.
					</td>
					<td>
						Essentially an all-in-one method for the other methods above. Note
						that only the <span class="underlineText">first</span> match is
						returned. Other matches will not be returned. We can get very
						creative with this method.
						<span class="monoText">querySelector('div li.big')</span>
						will return the first <span class="monoText">li</span> element in
						main a <span class="monoText">div</span> element with the class
						<span class="monoText">big</span>. Some useful CSS combinators to be
						aware of:
						<span class="blueText monoText">'${a}$ ${b}$'</span> targets the
						<span class="italicsText">descendants</span> of ${a}$ that are
						${b.}$ <span class="blueText monoText">${a}$ > ${b}$</span> targets
						the <span class="italicsText">children</span> of ${a}$ that are
						${b.}$ <span class="blueText monoText">${a}$ + ${b}$</span> targets
						the adjacent siblings of ${a}$ that are ${b}$ (i.e., select the
						element ${b,}$ which is right after the element ${a}$ on the same
						level). <span class="blueText monoText">${a}$ ~ ${b}$</span> targets
						all the siblings after ${a}$ that are ${b.}$
						<span class="monoText">${a}$[${r}$=${s}$]</span> targets the element
						${a}$ with the attribute ${r}$ set to the value ${s.}$
					</td>
				</tr>
				<tr>
					<td><span class="monoText">${obj}$.querySelectorAll(${s}$)</span></td>
					<td>
						Similar operation as <span class="monoText">querySelector()</span>,
						but returns a
						<span class="monoText"><a href="">nodeList</a></span> containing
						<span class="underlineText">all</span> the elements matching ${s.}$
					</td>
					<td>
						<i>Supra above cell.</i> CSS selectors, as string values, can be
						passed as arguments.
					</td>
				</tr>
			</tbody>
		</table>
	</figure>

	<section id="html_collection">
		<h2>HTML Collections</h2>
		<p>Consider the return value for each of the methods above:</p>
		<pre class="language-javascript"><code>
			let firstP = document.getElementById("firstP");
			let listItems = document.getElementsByTagName("li");
			let redText = document.getElementsByClassName("redText");

			console.dir(firstP);
			console.dir(listItems);
			console.dir(redText);
		</code></pre>
		<pre class="language-bash"><code>
			p#firstP
			HTMLCollection(1)
			HTMLCollection(2)
		</code></pre>
		<p>
			The HTMLCollection is a list of nodes. As a list of nodes, they look and
			often behave like arrays. They are iterable, we can index into an HTML
			collection with square bracket syntax, and we can retrieve its length:
		</p>
		<pre class="language-javascript"><code>
			let listItems = document.getElementsByTagName("li");
			let firstItem = listItems[0];
			let listItemsLength = listItems.length;
			console.dir(firstItem);
			console.dir(listItemsLength);
		</code></pre>
		<pre class="language-bash"><code>
			> li
			3
		</code></pre>
		<p>
			Now, while this evidences an array-like data structure, the HTMLCollection
			is <span class="underlineText">not</span> an array. They are in fact
			objects, which, as we know, is a type of record. Accordingly, methods like
			<span class="monoText">.pop()</span> and
			<span class="monoText">.push()</span> will not work with HTML collections.
		</p>
		<p>
			First, the HTMLCollection can only contain
			<span class="italicsText">element nodes</span>. Second, the HTMLCollection
			is <span class="term">live</span> &mdash; whenever a new element node is
			append to the DOM, the corresponding HTMLCollection that would contain
			that node is updated.
		</p>
	</section>

	<section id="node_list">
		<h2>Node Lists</h2>
		<p>
			With the <span class="monoText">.querySelectorAll()</span> method, we see
			the following return value:
		</p>
		<pre class="language-javascript"><code>
			let list = document.querySelectorAll('li');
			console.dir(list);
			typeof list
		</code></pre>
		<pre class="language-bash"><code>
			> NodeList(3)
			'object'
		</code></pre>
		<p>
			We see <span class="monoText">NodeList</span>. This is somewhat similar to
			the HTMLCollection, in that it looks and behaves like an array. We can
			iterate over the node list with the
			<span class="monoText">forEach</span> method.<label
				for="forEach"
				class="margin-toggle"
				><sup></sup
			></label>
			<input
				type="checkbox"
				id="forEach"
				class="margin-toggle sidenote-number"
			/>
			<span class="marginnote"
				>A fair warning: The <span class="monoText">forEach</span> method can be
				inefficient for iterating over a NodeList.</span
			>
			But again, it is <span class="underlineText">not</span> an array. Where
			the HTML collection is a list of nodes, the NodeList is an
			<span class="italicsText">aggregate</span> of nodes. And as we might
			expect, the NodeList too is an object, a record type.
		</p>
	</section>

	<section id="dom_token_list">
		<h2>DOMTokenList</h2>
		<p>
			When using properties like <span class="monoText">.classList</span>, we
			see that the returned value is a <span class="term">DOMTokenList</span>.
			This is an <span class="term">ordered set</span> data structure. The
			DOMTokenList is effectively a <span class="italicsText">set</span> (a very
			lightweight data structure), wherein there are no duplicates.
		</p>
	</section>
</section>

<section id="manipulating_elements">
	<h2>DOM Manipulation</h2>
	<p>
		Once we have selected an element, we can begin manipulating the element. The
		DOM provides numerous properties and methods we can use for manipulation.
		Below is an API of various properties and methods:
	</p>
	<figure class="table">
		<table class="api">
			<thead>
				<th>Identifier</th>
				<th>Meaning</th>
				<th>Comments</th>
			</thead>
			<tbody>
				<tr>
					<td
						colspan="3"
						style="
							font-family: var(--serif);
							background-color: rgb(255, 243, 209);
						"
					>
						Methods
					</td>
				</tr>
				<tr>
					<td><span class="monoText">${obj}$.getAttribute(${a}$)</span></td>
					<td>
						Returns the value assigned to the attribute ${a}$ of ${obj.}$
						Argument passed, ${a,}$ is of type
						<span class="monoText">string</span>.
					</td>
					<td>
						Examples: <span class="monoText">href</span>,
						<span class="monoText">src</span>,
						<span class="monoText">class</span>,
						<span class="monoText">type</span>,
						<span class="monoText">id</span>, etc.
					</td>
				</tr>
				<tr>
					<td>
						<span class="monoText">${obj}$.setAttribute(${a}$, ${v}$)</span>
					</td>
					<td>
						Assign to the attribute ${a}$ of ${obj}$ the value ${v.}$ Both ${a}$
						and ${v}$ are arguments of type
						<span class="monoText">string</span>.
					</td>
					<td></td>
				</tr>
				<tr>
					<td><span class="monoText">${obj}$.appendChild(${s}$)</span></td>
					<td>Appends the element ${s}$ as a child of ${obj.}$</td>
					<td>If ${obj}$ has children, ${s}$ is appended as the last child.</td>
				</tr>
				<tr>
					<td>
						<span class="monoText">${obj}$.append(${s_0, \ldots, s_n}$)</span>
					</td>
					<td>
						Inserts the element objects ${s_0, \ldots, s_n}$ as children of
						${obj}$ in sequence. If ${obj}$ has existing children, the objects
						${s_0, \ldots, s_n}$ are inserted at
						<span class="underlineText">after</span> the last child.
					</td>
					<td></td>
				</tr>
				<tr>
					<td><span class="monoText">${obj}$.prepend()</span></td>
					<td>
						Inserts the element objects ${s_0, \ldots, s_n}$ as children of
						${obj}$ in sequence. If ${obj}$ has existing children, the objects
						${s_0, \ldots, s_n}$ are inserted at
						<span class="underlineText">before</span> the first child.
					</td>
					<td></td>
				</tr>
				<tr>
					<td>
						<span class="monoText"
							>${obj_p}$.insertBefore(${obj_0}$, ${obj_1}$)</span
						>
					</td>
					<td>
						Where ${obj_p}$ is a branch node object (i.e., an object with
						children), inserts the element ${obj_0}$ before the element
						${obj_1}$ as children of ${obj_p.}$
					</td>
					<td></td>
				</tr>
				<tr>
					<td>
						<span class="monoText"
							>${obj_p}$.insertAdjacentElement(${i}$, ${s}$).</span
						>
					</td>
					<td>
						Where ${obj_p}$ is a branch node object, inserts the element object
						${s}$ at position ${p.}$ Both arguments are strings.
					</td>
					<td>
						${i}$ takes 1 of 4 string values:
						<span class="monoText">'beforebegin'</span> (before ${obj_p}$
						itself), <span class="monoText">'afterbegin'</span> (inside
						${obj_p}$ and before its first child),
						<span class="monoText">'beforeend'</span> (inside ${obj_p}$ and
						after its last child),
						<span class="monoText">'afterend'</span> (after ${obj_p}$ itself).
					</td>
				</tr>

				<tr>
					<td><span class="monoText">${obj}$.removeChild(${s}$)</span></td>
					<td>
						Where ${obj}$ is a branch node and ${s}$ is a child of ${obj,}$
						destroys the child ${s.}$
					</td>
					<td></td>
				</tr>
				<tr>
					<td><span class="monoText">${obj}$.remove()</span></td>
					<td>Destroys the object ${obj.}$</td>
					<td>No arguments passed to this method.</td>
				</tr>
				<tr>
					<td><span class="monoText">document.createElement(${s}$)</span></td>
					<td>
						Creates a new element and returns the new element ${s,}$ where ${s}$
						is the element's type as a string. E.g.,
						<span class="monoText">document.createElement(p)</span> creates a
						new paragraph element.
					</td>
					<td>
						This only creates an element and returns the element's object
						representation. It does not append the element to the page, or set
						its properties like <span class="monoText">innerText</span>. To do
						so, we must provide additional statements. E.g., use one of the
						append methods to insert the element into the page.
					</td>
				</tr>
				<tr>
					<td><span class="monoText">getComputedStyle(${obj}$)</span></td>
					<td>
						Returns an object containing all the CSS properties of ${obj}$.
					</td>
					<td>
						Notice that this method is not called with an object. Instead, an
						object is passed into the method. This is because the
						<span class="monoText">getComputedStyle()</span> method is provided
						by the <span class="monoText">Window</span>, the global object on
						the browser. Thus, the full call looks like
						<span class="monoText">Window.getComputedStyle(${obj}$)</span>. The
						object returned contains <span class="underlineText">all</span> of
						the applicable style properties. Many of these properties have
						values, even if we didn't set them, because the browser sets many
						properties by default.
					</td>
				</tr>
				<tr>
					<td
						colspan="3"
						style="
							font-family: var(--serif);
							background-color: rgb(255, 243, 209);
						"
					>
						Properties
					</td>
				</tr>
				<tr>
					<td><span class="monoText">${obj}$.classList</span></td>
					<td>
						Returns a <span class="monoText">DOMTokenList</span> of all the
						values assigned to the element's
						<span class="monoText">class</span> attribute.
					</td>
					<td>
						This is a useful property for modifying multiple styles on an
						${obj.}$ With <span class="monoText">.classList</span>, we can call
						the methods
						<span class="monoText">${obj}$.classList.add(${s}$)</span> to add a
						new value to ${obj}$'s class attribute,
						<span class="monoText">${obj}$.classList.remove(${s}$)</span> to
						remove a value in ${obj}$'s class attribute, and
						<span class="monoText">${obj}$.toggle(${s}$)</span>, which removes
						the value ${s}$ to the class attribute if it's present, and adds the
						value ${s}$ if it is absent.
					</td>
				</tr>
				<tr>
					<td><span class="monoText">${obj}$.innerText</span></td>
					<td>
						Where ${obj}$ is an HTML element object, returns the text (type
						<span class="monoText">string</span>) in between the tags. When
						using <span class="monoText">querySelector()</span> on an object
						with children, the returned value is the inner text of all the
						children in a single string (escape sequences used).
					</td>
					<td>
						Changing the value assigned to
						<span class="monoText">innerText</span> will result in changes the
						text on the page. String returned does not include parts of text
						hidden via CSS, text between script tags, or tags.
					</td>
				</tr>
				<tr>
					<td><span class="monoText">${obj}.$textContent</span></td>
					<td>
						Similar to <span class="monoText">innerText</span>, in that it
						returns the contents between the HTML tags. However, the string
						returned will include <span class="underlineText">all</span> the
						text displayed on the page, except for tags.
					</td>
					<td>
						<span class="italicsText">Supra above cell.</span>
						<span class="monoText">textContent</span> is slightly faster, since
						it does not have to perform additional computations to ignore
						certain text.
					</td>
				</tr>
				<tr>
					<td><span class="monoText">${obj}$.innerHTML</span></td>
					<td>
						Returns a string of all the HTML elements (include the tags) in
						${obj.}$
					</td>
					<td>
						<span class="monoText">innerHTML</span> can be used to add tags, but
						values assigned must be of type
						<span class="monoText">string.</span>
					</td>
				</tr>
				<tr>
					<td><span class="monoText">${obj}$.value</span></td>
					<td>
						Returns the value of ${obj.}$ Most commonly used with the
						<span class="monoText">input</span> tag.
					</td>
					<td></td>
				</tr>
				<tr>
					<td><span class="monoText">${obj}$.checked</span></td>
					<td>
						Returns the value of an <span class="monoText">input</span> element
						with type attribute of <span class="monoText">checkbox</span>. If
						checked, return value is <span class="monoText">true</span>,
						otherwise <span class="monoText">false</span>.
					</td>
					<td></td>
				</tr>
				<tr>
					<td><span class="monoText">${obj}$.parentElement</span></td>
					<td>Returns the parent element of ${obj.}$</td>
					<td>
						E.g., assuming proper style,
						<span class="monoText">li.parentElement</span> would return
						<span class="monoText">ul</span> or
						<span class="monoText">ol</span> object. To target the
						&#8220;grandparent&#8221; element, we can write
						<span class="monoText">${obj}$.parentElement.parentElement</span>.
						We can think of this method as climbing &#8220;up&#8221; the tree.
					</td>
				</tr>
				<tr>
					<td><span class="monoText">${obj}$.children</span></td>
					<td>Returns an HTMLCollection of all the children of ${obj.}$</td>
					<td></td>
				</tr>
				<tr>
					<td><span class="monoText">${obj}$.nextElementSibling</span></td>
					<td>
						Returns the element <span class="underlineText">after</span> ${obj}$
						on the same level in the tree.
					</td>
					<td></td>
				</tr>
				<tr>
					<td><span class="monoText">${obj}$.previousSibling</span></td>
					<td>
						Returns the element
						<span class="underlineText">before</span> ${obj}$ on the same level
						in the DOM tree.
					</td>
					<td></td>
				</tr>
				<tr>
					<td><span class="monoText">${obj}$.style</span></td>
					<td>
						Returns an object containing all of the style properties of ${obj.}$
					</td>
					<td>
						Assuming the page follows standard practices, the properties in the
						returned object are displayed with empty string values. This is
						because the values set in the returned object are values provided
						via <span class="underlineText">inline styling</span>. Because
						inline styles are generally considered poor practice, the properties
						will usually have empty string values. To read existing values,
						<span class="italicsText">see</span>
						<span class="monoText">.getComputedStyle()</span> above. We can,
						however, use the <span class="monoText">.style</span> property to
						mutate the ${obj}$'s styles. For examle,
						<span class="monoText">${obj}$.style.color = 'blue'</span> will
						change the text color to blue. Additionally, property names are
						written in JavaScript syntax. E.g., because JavaScript doesn't allow
						dashes in names, the CSS property
						<span class="monoText">background-color</span> is identified in the
						object in camelCase: <span class="monoText">backgroundColor</span>.
						Finally, note that mutating this property effectively adds inline
						styles to the ${obj.}$ As such, this will overwrite any existing
						styles we've applied via CSS.
					</td>
				</tr>
			</tbody>
		</table>
	</figure>

	<section id="common_idoms">
		<h3>Common Idioms</h3>
		<p>
			Because the DOM provides the means for manipulating HTML pages, there are
			several common idioms for DOM manipulation. We present these idioms below.
		</p>
		<section id="changing_multiple_elements">
			<p>
				<span class="topic">Changing Multiple Elements.</span> To change
				multiple elements, one common pattern is to store a NodeList, or
				HTMLCollection, in a variable, then iterate over it:
			</p>
			<pre class="language-javascript"><code>
				const list = document.querySelectorAll('li');
				for (let i = 0; i < list.length; i++) {
					list[i].innerText = "Mutated";
				}
			</code></pre>
			<p>
				The code above changes all the list items inner text to the string
				<span class="monoText">"Mutated"</span>. This idiom is particularly
				powerful, in that it allows us to change many properties, such as
				<span class="monoText">.innerHTML</span> and
				<span class="monoText">.style</span>.
			</p>
		</section>

		<section id="changing_multiple_styles">
			<p>
				<span class="topic">Applying Multiple Styles.</span> Another common
				idiom is applying multiple styles to an element. This is done by
				appending, removing, or modifying the element's styles applied via CSS
				throuh the element's <span class="monoText">class</span> attribute. For
				example, say we had the following HTML code:
			</p>
			<pre class="language-html"><code>
				&lt;!DOCTYPE html&gt;
				&lt;html lang=&quot;en&quot;&gt;
				&lt;head&gt;
				&#x9;&lt;title&gt;Lab&lt;/title&gt;
				&#x9;&lt;link rel=&quot;stylesheet&quot; href=&quot;./styles.css&quot;&gt;
				&lt;/head&gt;
				&lt;body&gt;
				&#x9;&lt;main&gt;
				&#x9;&#x9;&lt;h1&gt;H1 Tag&lt;/h1&gt;
				&#x9;&#x9;&lt;p&gt;Paragraph tag&lt;/p&gt;
				&#x9;&#x9;&lt;ul id=&quot;todo&quot;&gt;
				&#x9;&#x9;&#x9;&lt;li class=&quot;incomplete&quot;&gt;List item 1&lt;/li&gt;
				&#x9;&#x9;&#x9;&lt;li class=&quot;incomplete&quot;&gt;List item 2&lt;/li&gt;
				&#x9;&#x9;&#x9;&lt;li class=&quot;incomplete&quot;&gt;List item 3&lt;/li&gt;
				&#x9;&#x9;&lt;/ul&gt;
				&#x9;&lt;/main&gt;
				&#x9;&lt;script src=&quot;./app.js&quot;&gt;&lt;/script&gt;
				&lt;/body&gt;
				&lt;/html&gt;&#x9;
			</code></pre>
			<p>The CSS appears as such:</p>
			<pre class="language-css"><code>
				main {
					font-family: sans-serif;
				}
				.redText {
					color: red;
				}
				.incomplete {
					color: green;
				}
			</code></pre>
			<p>
				Suppose that we wanted to have a list item once its marked complete. To
				do so, we write write a new class in the CSS file:
			</p>
			<pre class="language-css"><code>
				main {
					font-family: sans-serif;
				}
				.redText {
					color: red;
				}
				.incomplete {
					color: green;
				}
				.complete {
					color: grey;
					text-decoration: line-through;
				}
			</code></pre>
			<p>
				We can then apply the <span class="monoText">.complete</span> class to
				the respective <span class="monoText">li</span> object:
			</p>
			<pre class="language-javascript"><code>
				const todoList = document.querySelectorAll('li');
				let firstTodo = todoList[0];
				firstTodo.setAttribute('class', 'complete')
			</code></pre>
			<p>
				Alternatively, we could have used a method from the
				<span class="monoText">.classList</span> property.
			</p>
		</section>
	</section>
</section>

<section id="dom_events">
	<h2>Event-driven Programming</h2>
	<p>
		Once we know how to target and manipulate the DOM tree and its nodes, we can
		begin investigating <span class="italicsText">events</span>. To understand
		what events are, it's helpful to think about the different kinds of programs
		we can write.
	</p>
	<p>
		In much of the preceding sections and volumes, we've been writing
		<span class="term">console programs</span> &mdash; programs that run
		primarily on the console. We can, however, also write
		<span class="term">interactive programs</span> &mdash; programs that allow
		the user to control a program's actions by using
		<span class="italicsText">peripherals</span>. Such peripherals include a
		keyboard, joystick, mouse, trackpad, microphone, etc. When a user performs
		some action with a peripheral, we call that action an
		<span class="term">event</span>. For example: Clicking on a mouse, hitting
		the enter or arrow keys, touching a particular part of a screen, saying a
		particular word into a microphone, these are all events. Programs that are
		designed to respond to these events are called
		<span class="term">event-driven programs</span>. In their simplest forms,
		such programs take events as input, and return some output.
	</p>
	<p>
		In modern interactive programs, user input does not occur at predictable
		times. For example, think about clicking on the &#8220;Agree&#8221; button
		for a software usage license. Most users click the button immediately.
		Others (however few), will take the time to read the license before
		clicking. The program behind the license doesn't tell us when we should
		click the button (it would be poor choice, both business-wise and legally,
		to require a user to agree to a license in less than five seconds). All this
		is to say that modern interactive programs leave it up to the user
		<span class="italicsText">when</span> to trigger an event. And because
		events are not controlled by the program, we say that such programs are
		<span class="term">asynchronous</span>.
	</p>
	<p>
		In the JavaScript context, we implement such programs through functions that
		anticipate these events. By &#8220;anticipate&#8221; we mean that the
		functions are called <span class="underlineText">only if</span> an event
		occurs. These functions are more generally called
		<span class="term">listeners</span>. We can think of a listener as akin to
		the string telephones we played with in our days of youth:
	</p>
	<figure>
		<img
			src="{% static 'images/listener.svg' %}"
			alt="A string telephone"
			loading="lazy"
			class="sixty-p"
		/>
	</figure>
	<p>
		The listener &#8220;listens&#8221; to whatever the user sends as input,
		which in turn keeps a particular module in the program informed. That module
		then executes whatever statements we provide.
	</p>
	<p>
		Listeners are based on a foundational principle of functional programming:
		Functions are data values, just as an integer or a string is a data value.
		JavaScript abides by this principle in treating functions as
		<span class="italicsText">first-class</span>: We can assign them to
		variables, pass them as arguments, express them as arguments, and return
		them as results. Just to confirm that this is the case, recall our
		discussion on
		<a href="{% url 'numerc:js_functions' %}#javascript_function_expressions"
			>function expressions</a
		>. We could write the following function as such:
	</p>
	<pre class="language-javascript"><code>
		function fahrenheitToCelsius(f) {
			return 5 / 9 * (f - 32);
		}
	</code></pre>
	<p>
		But, we could also assign the function to a variable (a
		<span class="italicsText">closure</span>):
	</p>
	<pre class="language-javascript"><code>
		let fahrenheitToCelsius = function(f) { return 5 / 9 * (f - 32); };
	</code></pre>
	<p>
		When first discussed these different syntactical forms, we didn't expound to
		deeply on the advantages of using closures over formal function definitions.
		With listeners, however, there's a signficant benefit to using closures: We
		can declare the function as a local variable inside another function (e.g.,
		what we represented as a module in the diagram above). In that case, the
		inner function (the listener) includes all of the code in its body, which in
		turn has access to all the local variable in the outer function.
	</p>
</section>

{% endblock %}
