{% extends '../layout.html' %} {% load static %} {% block description %}
<meta
	name="description"
	content="What is the DOM in JavaScript? An overview of the Document Object Model."
/>
{% endblock %} {% block title %}
<title>The DOM</title>
{% endblock %} {% block content %}
<h1>The Document Object Model (DOM)</h1>
<section id="intro">
	<p>
		<span class="drop">J</span>avaScript is synonymous with web development. But
		how exactly does it generate dynamic web pages? The answer is through the
		<b>Document Object Model</b> (&#8220;DOM&#8221;). In this section, we
		explore how the DOM works, as well as the various ways we link JavaScript,
		HTML, and CSS.
	</p>
	<p>
		To begin, the examples below are based on three separate files:
		<var>lab.html</var>, <var>app.js</var>, and <var>styles.css</var>. These
		files are all within the same directory:
	</p>
	<figure class="math-display">
		<div>
			<pre class="language-pseudo"><code>
				.
				├── lab.html
				├── app.js
				└── styles.css
			</code></pre>
		</div>
	</figure>
	<p>
		The <var>styles.css</var> and <var>app.js</var> files do not contain
		anything for now. The <var>lab.html</var> file, however, contains the
		following code:
	</p>
	<pre class="language-html"><code>
		&lt;!DOCTYPE html&gt;
		&lt;html lang=&quot;en&quot;&gt;
		&lt;head&gt;
		&#x9;&lt;meta charset=&quot;UTF-8&quot;&gt;
		&#x9;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
		&#x9;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
		&#x9;&lt;title&gt;Lab&lt;/title&gt;
		&#x9;&lt;link rel=&quot;stylesheet&quot; href=&quot;./styles.css&quot;&gt;
		&lt;/head&gt;
		&lt;body&gt;
		&#x9;&lt;main&gt;
		&#x9;&#x9;&lt;h1&gt;H1 Tag&lt;/h1&gt;
		&#x9;&#x9;&lt;p&gt;Paragraph tag&lt;/p&gt;
		&#x9;&#x9;&lt;ul&gt;
		&#x9;&#x9;&#x9;&lt;li&gt;List item 1&lt;/li&gt;
		&#x9;&#x9;&#x9;&lt;li&gt;List item 2&lt;/li&gt;
		&#x9;&#x9;&#x9;&lt;li&gt;List item 3&lt;/li&gt;
		&#x9;&#x9;&lt;/ul&gt;
		&#x9;&lt;/main&gt;
		&#x9;&lt;script src=&quot;./app.js&quot;&gt;&lt;/script&gt;
		&lt;/body&gt;
		&lt;/html&gt;
	</code></pre>
	<p>
		Note that the following discussion assumes basic knowledge of HTML and CSS.
		If the syntax above or CSS is entirely foreign, we recommend looking up a
		few basic tutorials on HTML and CSS.
	</p>
</section>

<section id="what_is_the_dom">
	<h2>What is the DOM?</h2>
	<p>
		The DOM is a a representation of a document's structure.<label
			for="domSpec"
			class="margin-toggle"
			><sup></sup
		></label>
		<input type="checkbox" id="domSpec" class="margin-toggle sidenote-number" />
		<span class="marginnote"
			>For the specification,
			<a href="https://dom.spec.whatwg.org/" target="_blank"
				><i>see</i> <em>DOM Living Standard</em>.</a
			></span
		>
		While the DOM has grown synonymous with JavaScript, it's not exclusive to
		browsers. Server side programs may also utilize the program.
	</p>
	<p>
		The DOM is implemented as a <b>node tree</b>. From a very high-level
		overview, when the browser loads an HTML document, the browser takes all of
		the HTML elements and returns JavaScript objects. Each of these objects is a
		<b>node</b> on the tree. Some of the nodes have children. These nodes are
		called <b>branch nodes</b>, because they have <b>branches</b> to other
		nodes. Other nodes do not have children, in which case they are called
		<b>leaves</b>.
	</p>
	<p>
		Because each node in the tree is represented as a JavaScript object, we can
		interact with them via JavaScript. Hence, the DOM is simply an interface for
		interacting with HTML documents. For example, given the following HTML code:
	</p>
	<pre class="language-html"><code>
		&lt;html&gt;
			&lt;head&gt;
				&lt;title&gt;My Webpage&lt;/title&gt;
			&lt;/head&gt;
			&lt;body&gt;
			&#x9;&lt;h1&gt;Heading&lt;/h1&gt;
			&#x9;&lt;ul&gt;
			&#x9;&#x9;&lt;li&gt;List Item 1&lt;/li&gt;
			&#x9;&#x9;&lt;li&gt;List Item 2&lt;/li&gt;
			&#x9;&lt;/ul&gt;
			&lt;/body&gt;
		&lt;/html&gt;
	</code></pre>
	<p>
		The browser generates a node tree whose nodes are the HTML elements
		represented as objects:
	</p>
	<figure>
		<img
			src="{% static 'images/domTree.svg' %}"
			alt="The DOM Tree Object"
			loading="lazy"
			class="thirty-p"
		/>
	</figure>
	<p>
		The root node is the <var>html</var> element. It is from this node that we
		have all the other nodes: <var>body</var>, <var>h1</var>, <var>ul</var>,
		<var>li</var>, etc. These nodes are all objects. Each node has either a
		<b>parent</b>, <b>children</b>, or both. For example, the
		<var>html</var> element has two children, <var>head</var> and
		<var>body</var>. <var>head</var> has one child, the
		<var>title</var> element.
	</p>
	<p>
		Again, all of these are objects, and the entire node tree is an object.
		Roughly, the tree above looks something like:
	</p>
	<figure class="math-display">
		<div>
			<pre class="language-pseudo"><code>
				Window: {
					document: {
						html: {
							head: {
								title: { innerText: "My Webpage" }
							},
							body: {
								h1: { innerText: "Heading" },
								ul: {
									li: { innerText: "List Item 1" },
									li: { innerText: "List Item 1" }
								}
							}
						}
					}
				}
			</code></pre>
		</div>
	</figure>
	<p>
		The root of the tree is the <b>document object</b>. We can think of the
		document object as the entry point to the rest of the tree. If we run
		<var>console.dir(document)</var> on an HTML page, we can see an entire
		representation of the document (the output is omitted here because of its
		length, but do try it).
	</p>
	<p>
		The above gives us a better sense of what the DOM is. If we wanted to see
		what it actually looks like, open a console on a webpage, and run
		<var>console.log(this)</var>. The rough outline above omits most of what's
		actually contained in the tree &mdash; the DOM contains numerous properties
		and methods.
	</p>
	<p>
		Each of the objects have properties. In the example above, the
		<var>h1</var> object has a property called <var>innerText</var>. Here, that
		property is bound to the value <var>"Heading"</var>, a string. These objects
		all contain numerous properties: Styles, content, children, parents, etc.
		With JavaScript, we can modify these properties. We can also create and
		delete nodes on the tree, effectively adding new elements and removing
		existing ones from the HTML document. This discussion reveals a key insight
		to developing web pages with JavaScript: Whenever we use JavaScript to
		affect changes on a webpage, we are really manipulating the leaves and
		branches in a tree.
	</p>
	<p>
		Importantly, there's a distinction between
		<i>elements</i> and <i>nodes</i> in the DOM. All HTML tags constitute
		<i>element nodes</i>. An element node can have children, which may or may
		not be element nodes. For example, the <var>detail</var> tag can have a
		<var>summary</var> element node as a child, but it can also have the
		<i>attribute node</i> <var>open</var>. Similarly, the <var>p</var> tag is
		represented as an element node, but it can also have as a child node an
		<var>a</var> element node, as well as a <i>text node</i>.
	</p>
</section>

<section id="targeting_elements">
	<h2>DOM Getters</h2>
	<p>
		From the JavaScript perspective, an HTML page is just one giant object. More
		specifically, a giant tree. Accordingly, to manipulate HTML pages, we
		manipulate the DOM tree's nodes. The first step to doing so is to select, or
		target, nodes in the tree. We can think of these as being akin to
		<b>getters</b> in other OOP languages. This is done by using methods
		provided by the DOM. To get started, the HTML and CSS files we're working
		with look like this:
	</p>

	<pre class="language-html"><code>
			&lt;!DOCTYPE html&gt;
			&lt;html lang=&quot;en&quot;&gt;
			&lt;head&gt;
			&#x9;&lt;title&gt;Lab&lt;/title&gt;
			&#x9;&lt;link rel=&quot;stylesheet&quot; href=&quot;./styles.css&quot;&gt;
			&lt;/head&gt;
			&lt;body&gt;
			&#x9;&lt;main&gt;
			&#x9;&#x9;&lt;h1 class=&quot;redText&quot;&gt;H1 Tag&lt;/h1&gt;
			&#x9;&#x9;&lt;p id=&quot;firstP&quot;&gt;Paragraph tag&lt;/p&gt;
			&#x9;&#x9;&lt;ul class=&quot;firstList&quot;&gt;
			&#x9;&#x9;&#x9;&lt;li&gt;List item 1&lt;/li&gt;
			&#x9;&#x9;&#x9;&lt;li&gt;List item 2&lt;/li&gt;
			&#x9;&#x9;&#x9;&lt;li&gt;List item 3&lt;/li&gt;
			&#x9;&#x9;&lt;/ul&gt;
			&#x9;&lt;/main&gt;
			&#x9;&lt;script src=&quot;./app.js&quot;&gt;&lt;/script&gt;
			&lt;/body&gt;
			&lt;/html&gt;
		</code></pre>
	<pre class="language-css"><code>
			main { 
				font-family: sans-serif; 
			}
			.redText { 
				color: red; 
			}
		</code></pre>

	<p>Here is an API for targetting the various nodes in the tree:</p>
	<figure class="table">
		<table class="api">
			<thead>
				<th>Method</th>
				<th>Meaning</th>
				<th>Comments</th>
			</thead>
			<tbody>
				<tr>
					<td colspan="3" style="font-family: var(--serif)">
						Where ${obj}$ is some object in the DOM (e.g.,
						<var>document</var>, <var>ul</var>, <var>section</var>,
						<var>div</var>, etc.):
					</td>
				</tr>
				<tr>
					<td><var>${obj}$.getElementById(${s}$)</var></td>
					<td>
						Where ${v}$ is a string, returns the HTML element with the matching
						<var>id</var> attribute with value ${s.}$ If no match is found, the
						return value is <var>null</var>.
					</td>
					<td>By &#8220;HTML element&#8221;, we mean an object.</td>
				</tr>
				<tr>
					<td>
						<var>${obj}$.getElementsByTagName(${s}$)</var>
					</td>
					<td>
						Where ${s}$ is a string, returns an
						<a href="#html_collection"><var>HTMLCollection</var></a>
						of all the elements with the tag name ${s.}$
					</td>
					<td>
						The <var>HTMLCollection</var> looks like an array, but it is not an
						array.
					</td>
				</tr>
				<tr>
					<td>
						<var>${obj}$.getElementsByClassName(${s}$)</var>
					</td>
					<td>
						Where ${s}$ is a string, returns an
						<var>HTMLCollection</var>
						of all the elements with the class name ${s.}$ If no match is found,
						an empty
						<var>HTMLCollection</var>
						is returned.
					</td>
					<td><i>Supra above cell.</i></td>
				</tr>
				<tr>
					<td><var>${obj}$.querySelector(${s}$)</var></td>
					<td>
						Where ${s}$ is a string, returns the
						<span class="underlineText">first</span> element with the attribute,
						class, or element name with the string. If ${s}$ is written as a CSS
						selector, then the method will evalute according to the selector.
						For example, <var>document.querySelector('#red')</var> will select
						the first element with the <var>id</var> attribute of value
						<var>'red'</var>. <var>document.querySelector('.green')</var> will
						select the first element swith the <var>class</var> attribute set to
						<var>'green'</var>.
					</td>
					<td>
						Essentially an all-in-one method for the other methods above. Note
						that only the <span class="underlineText">first</span> match is
						returned. Other matches will not be returned. We can get very
						creative with this method.
						<var>querySelector('div li.big')</var>
						will return the first <var>li</var> element in main a
						<var>div</var> element with the class <var>big</var>. Some useful
						CSS combinators to be aware of:
						<span class="blueText monoText">'${a}$ ${b}$'</span> targets the
						<i>descendants</i> of ${a}$ that are ${b.}$
						<span class="blueText monoText">${a}$ > ${b}$</span> targets the
						<i>children</i> of ${a}$ that are ${b.}$
						<span class="blueText monoText">${a}$ + ${b}$</span> targets the
						adjacent siblings of ${a}$ that are ${b}$ (i.e., select the element
						${b,}$ which is right after the element ${a}$ on the same level).
						<span class="blueText monoText">${a}$ ~ ${b}$</span> targets all the
						siblings after ${a}$ that are ${b.}$
						<var>${a}$[${r}$=${s}$]</var> targets the element ${a}$ with the
						attribute ${r}$ set to the value ${s.}$
					</td>
				</tr>
				<tr>
					<td><var>${obj}$.querySelectorAll(${s}$)</var></td>
					<td>
						Similar operation as <var>querySelector()</var>, but returns a
						<var><a href="">nodeList</a></var> containing
						<span class="underlineText">all</span> the elements matching ${s.}$
					</td>
					<td>
						<i>Supra above cell.</i> CSS selectors, as string values, can be
						passed as arguments.
					</td>
				</tr>
			</tbody>
		</table>
	</figure>
	<p>
		In the selection methods above, we used the form
		<var>document.${m}$</var>, where ${m}$ is the selection method. We can,
		however, narrow the scope of our selection search by referencing a
		particular node within the document. For example,
		<var>document.element.${m}$</var> will limit the selection search to the
		children of the <var>html</var> element node. The same goes for
		<var>document.head</var> and <var>document.body</var>.
	</p>

	<section id="arrays_and_iterables">
		<h2>DOM Data Structures: Arrays v. Iterables</h2>
		<p>
			Many of the DOM methods return data structures rather than simple data.
			For example, <var>HTMLCollection</var> and <var>NodeList</var>. To
			understand what these data structures are, it's worth revisiting arrays
			and exploring the idea of an <i>iterable</i>.
		</p>
		<p>
			An <b>iterable</b> is any object that implements the
			<var>iterable</var> protocol.<label for="iterable" class="margin-toggle"
				><sup></sup
			></label>
			<input
				type="checkbox"
				id="iterable"
				class="margin-toggle sidenote-number"
			/>
			<span class="marginnote"
				>There is one additional requirement: The object has the
				<var>@@iterator</var> method. This is a <var>Symbol.iterator</var>, and
				we will revisit it in later sections.</span
			>
			We haven't discussed protocols yet, but we can think of the
			<var>iterable</var> protocol as a set of requirements that define what
			constitutes an iterable. Any object that satisfies those requirements
			constitutes an iterable. If a single requirement is not met, however, the
			object does not constitute an iterable. If the object is an iterable, then
			we can iterate through the object with a for-of loop.
		</p>
	</section>

	<section id="html_collection">
		<h3>HTML Collections</h3>
		<p>Consider the return value for each of the methods above:</p>
		<pre class="language-javascript"><code>
			let firstP = document.getElementById("firstP");
			let listItems = document.getElementsByTagName("li");
			let redText = document.getElementsByClassName("redText");

			console.dir(firstP);
			console.dir(listItems);
			console.dir(redText);
		</code></pre>
		<pre class="language-bash"><code>
			p#firstP
			HTMLCollection(1)
			HTMLCollection(2)
		</code></pre>
		<p>
			The HTMLCollection is a list of nodes. As a list of nodes, they look and
			often behave like arrays. They are iterable (i.e., we can iterate over the
			nodes with a a regular for-loop or with a for-of-loop), we can index into
			an HTML collection with square bracket syntax, and we can retrieve its
			length:
		</p>
		<pre class="language-javascript"><code>
			let listItems = document.getElementsByTagName("li");
			let firstItem = listItems[0];
			let listItemsLength = listItems.length;
			console.dir(firstItem);
			console.dir(listItemsLength);
		</code></pre>
		<pre class="language-bash"><code>
			> li
			3
		</code></pre>
		<p>
			Now, while this evidences an array-like data structure, the HTMLCollection
			is <span class="underlineText">not</span> an array. They are in fact
			objects, which, as we know, is a type of record. Accordingly, methods like
			<var>.pop()</var> and <var>.push()</var> will not work with HTML
			collections.
		</p>
		<p>
			First, the HTMLCollection can only contain
			<i>element nodes</i>. Second, the HTMLCollection is <b>live</b> &mdash;
			whenever a new element node is appended to the DOM, the corresponding
			HTMLCollection that would contain that node is updated.
		</p>
	</section>

	<section id="node_list">
		<h3>Node Lists</h3>
		<p>
			With the <var>.querySelectorAll()</var> method, we see the following
			return value:
		</p>
		<pre class="language-javascript"><code>
			let list = document.querySelectorAll('li');
			console.dir(list);
			typeof list
		</code></pre>
		<pre class="language-bash"><code>
			> NodeList(3)
			'object'
		</code></pre>
		<p>
			We see <var>NodeList</var>. This is somewhat similar to the
			HTMLCollection, in that it looks and behaves like an array. We can iterate
			over the node list with the <var>forEach</var> method.<label
				for="forEach"
				class="margin-toggle"
				><sup></sup
			></label>
			<input
				type="checkbox"
				id="forEach"
				class="margin-toggle sidenote-number"
			/>
			<span class="marginnote"
				>A fair warning: The <var>forEach</var> method can be inefficient for
				iterating over a NodeList.</span
			>
			But again, it is <span class="underlineText">not</span> an array. Where
			the HTML collection is a list of nodes, the NodeList is an
			<i>aggregate</i> of nodes. And as we might expect, the NodeList too is an
			object, a record type.
		</p>
	</section>

	<section id="dom_token_list">
		<h3>DOM Token Lists</h3>
		<p>
			When using properties like <var>.classList</var>, we see that the returned
			value is a <b>DOMTokenList</b>. This is an <b>ordered set</b> data
			structure. The DOMTokenList is effectively a <i>set</i> (a very
			lightweight data structure), wherein there are no duplicates.
		</p>
	</section>
</section>

<section id="dom_traversal">
	<h2>DOM Traversal</h2>
	<p>
		Many of the selection methods can be thought of as ways to traverse the DOM.
		Given a node ${obj,}$ we can move in three directions: left (selecting
		previous siblings), right (selecting later siblings), up (selecting parents
		or ancestors), and down (selecting children or descendants). Of course, we
		can always return a nodeList or an HTMLCollection and iterate or index, but
		it can be much faster to simply traverse the DOM directly. The diagram below
		provides a visual aid for deciding which traversal method to use.
	</p>
	<figure>
		<img
			src="{% static 'images/domTraversal.svg' %}"
			alt="Traversal methods"
			loading="lazy"
		/>
	</figure>
</section>

<section id="manipulating_elements">
	<h2>DOM Manipulation</h2>
	<p>
		Once we have selected an element, we can begin manipulating the element. The
		DOM provides numerous properties and methods we can use for manipulation.
		Below is an API of various properties and methods:
	</p>
	<figure class="table">
		<table class="api">
			<thead>
				<th>Identifier</th>
				<th>Meaning</th>
				<th>Comments</th>
			</thead>
			<tbody>
				<tr>
					<td
						colspan="3"
						style="
							font-family: var(--serif);
							background-color: rgb(255, 243, 209);
						"
					>
						Methods
					</td>
				</tr>
				<tr>
					<td><var>${obj}$.getAttribute(${a}$)</var></td>
					<td>
						Returns the value assigned to the attribute ${a}$ of ${obj.}$
						Argument passed, ${a,}$ is of type
						<var>string</var>.
					</td>
					<td>
						Examples: <var>href</var>, <var>src</var>, <var>class</var>,
						<var>type</var>, <var>id</var>, etc.
					</td>
				</tr>
				<tr>
					<td>
						<var>${obj}$.setAttribute(${a}$, ${v}$)</var>
					</td>
					<td>
						Assign to the attribute ${a}$ of ${obj}$ the value ${v.}$ Both ${a}$
						and ${v}$ are arguments of type
						<var>string</var>.
					</td>
					<td></td>
				</tr>
				<tr>
					<td><var>${obj}$.appendChild(${s}$)</var></td>
					<td>Appends the element ${s}$ as a child of ${obj.}$</td>
					<td>If ${obj}$ has children, ${s}$ is appended as the last child.</td>
				</tr>
				<tr>
					<td>
						<var>${obj}$.append(${s_0, \ldots, s_n}$)</var>
					</td>
					<td>
						Inserts the element objects ${s_0, \ldots, s_n}$ as children of
						${obj}$ in sequence. If ${obj}$ has existing children, the objects
						${s_0, \ldots, s_n}$ are inserted at
						<span class="underlineText">after</span> the last child.
					</td>
					<td></td>
				</tr>
				<tr>
					<td><var>${obj}$.prepend()</var></td>
					<td>
						Inserts the element objects ${s_0, \ldots, s_n}$ as children of
						${obj}$ in sequence. If ${obj}$ has existing children, the objects
						${s_0, \ldots, s_n}$ are inserted at
						<span class="underlineText">before</span> the first child.
					</td>
					<td></td>
				</tr>
				<tr>
					<td>
						<span class="monoText"
							>${obj_p}$.insertBefore(${obj_0}$, ${obj_1}$)</span
						>
					</td>
					<td>
						Where ${obj_p}$ is a branch node object (i.e., an object with
						children), inserts the element ${obj_0}$ before the element
						${obj_1}$ as children of ${obj_p.}$
					</td>
					<td></td>
				</tr>
				<tr>
					<td>
						<span class="monoText"
							>${obj_p}$.insertAdjacentElement(${i}$, ${s}$).</span
						>
					</td>
					<td>
						Where ${obj_p}$ is a branch node object, inserts the element object
						${s}$ at position ${p.}$ Both arguments are strings.
					</td>
					<td>
						${i}$ takes 1 of 4 string values:
						<var>'beforebegin'</var> (before ${obj_p}$ itself),
						<var>'afterbegin'</var> (inside ${obj_p}$ and before its first
						child), <var>'beforeend'</var> (inside ${obj_p}$ and after its last
						child), <var>'afterend'</var> (after ${obj_p}$ itself).
					</td>
				</tr>

				<tr>
					<td><var>${obj}$.removeChild(${s}$)</var></td>
					<td>
						Where ${obj}$ is a branch node and ${s}$ is a child of ${obj,}$
						destroys the child ${s.}$
					</td>
					<td></td>
				</tr>
				<tr>
					<td><var>${obj}$.remove()</var></td>
					<td>Destroys the object ${obj.}$</td>
					<td>No arguments passed to this method.</td>
				</tr>
				<tr>
					<td><var>document.createElement(${s}$)</var></td>
					<td>
						Creates a new element and returns the new element ${s,}$ where ${s}$
						is the element's type as a string. E.g.,
						<var>document.createElement(p)</var> creates a new paragraph
						element.
					</td>
					<td>
						This only creates an element and returns the element's object
						representation. It does not append the element to the page, or set
						its properties like <var>innerText</var>. To do so, we must provide
						additional statements. E.g., use one of the append methods to insert
						the element into the page.
					</td>
				</tr>
				<tr>
					<td><var>getComputedStyle(${obj}$)</var></td>
					<td>
						Returns an object containing all the CSS properties of ${obj}$.
					</td>
					<td>
						Notice that this method is not called with an object. Instead, an
						object is passed into the method. This is because the
						<var>getComputedStyle()</var> method is provided by the
						<var>Window</var>, the global object on the browser. Thus, the full
						call looks like <var>Window.getComputedStyle(${obj}$)</var>. The
						object returned contains <span class="underlineText">all</span> of
						the applicable style properties. Many of these properties have
						values, even if we didn't set them, because the browser sets many
						properties by default.
					</td>
				</tr>
				<tr>
					<td><var>${obj.}$cloneNode(${b}$)</var></td>
					<td>
						Returns a copy of ${obj,}$ where ${obj}$ is an existing element.
					</td>
					<td>
						The boolean values <var>true</var> and <var>false</var> can be
						passed as arguments to the method. If the value <var>true</var> is
						passed, a <i>deep copy</i> of ${obj}$ is made (i.e., ${obj}$ and all
						its descendants). If <var>false</var> is passed, a
						<i>shallow copy</i> of ${obj}$ is made (only ${obj}$ is copied, not
						its descendants). Note that the cloned node has no parent and it is
						not part of the DOM. It must still be appended. Further note that
						because this clones a node, it can lead to duplicate
						<var>id</var> attribute values.
					</td>
				</tr>
				<tr>
					<td
						colspan="3"
						style="
							font-family: var(--serif);
							background-color: rgb(255, 243, 209);
						"
					>
						Properties
					</td>
				</tr>
				<tr>
					<td><var>${obj}$.classList</var></td>
					<td>
						Returns a <var>DOMTokenList</var> of all the values assigned to the
						element's <var>class</var> attribute.
					</td>
					<td>
						This is a useful property for modifying multiple styles on an
						${obj.}$ With <var>.classList</var>, we can call the methods
						<var>${obj}$.classList.add(${s}$)</var> to add a new value to
						${obj}$'s class attribute,
						<var>${obj}$.classList.remove(${s}$)</var> to remove a value in
						${obj}$'s class attribute, and <var>${obj}$.toggle(${s}$)</var>,
						which removes the value ${s}$ to the class attribute if it's
						present, and adds the value ${s}$ if it is absent.
					</td>
				</tr>
				<tr>
					<td><var>${obj}$.innerText</var></td>
					<td>
						Where ${obj}$ is an HTML element object, returns the text (type
						<var>string</var>) in between the tags. When using
						<var>querySelector()</var> on an object with children, the returned
						value is the inner text of all the children in a single string
						(escape sequences used).
					</td>
					<td>
						Changing the value assigned to
						<var>innerText</var> will result in changes the text on the page.
						String returned does not include parts of text hidden via CSS, text
						between script tags, or tags.
					</td>
				</tr>
				<tr>
					<td><var>${obj}.$textContent</var></td>
					<td>
						Similar to <var>innerText</var>, in that it returns the contents
						between the HTML tags. However, the string returned will include
						<span class="underlineText">all</span> the text displayed on the
						page, except for tags.
					</td>
					<td>
						<i>Supra above cell.</i>
						<var>textContent</var> is slightly faster, since it does not have to
						perform additional computations to ignore certain text.
					</td>
				</tr>
				<tr>
					<td><var>${obj}$.innerHTML</var></td>
					<td>
						Returns a string of all the HTML elements (include the tags) in
						${obj.}$
					</td>
					<td>
						<var>innerHTML</var> can be used to add tags, but values assigned
						must be of type
						<var>string.</var>
					</td>
				</tr>
				<tr>
					<td><var>${obj}$.value</var></td>
					<td>
						Returns the value of ${obj.}$ Most commonly used with the
						<var>input</var> tag.
					</td>
					<td></td>
				</tr>
				<tr>
					<td><var>${obj}$.checked</var></td>
					<td>
						Returns the value of an <var>input</var> element with type attribute
						of <var>checkbox</var>. If checked, return value is <var>true</var>,
						otherwise <var>false</var>.
					</td>
					<td></td>
				</tr>
				<tr>
					<td><var>${obj}$.parentElement</var></td>
					<td>Returns the parent element of ${obj.}$</td>
					<td>
						E.g., assuming proper style,
						<var>li.parentElement</var> would return <var>ul</var> or
						<var>ol</var> object. To target the &#8220;grandparent&#8221;
						element, we can write
						<var>${obj}$.parentElement.parentElement</var>. We can think of this
						method as climbing &#8220;up&#8221; the tree.
					</td>
				</tr>
				<tr>
					<td><var>${obj}$.children</var></td>
					<td>Returns an HTMLCollection of all the children of ${obj.}$</td>
					<td></td>
				</tr>
				<tr>
					<td><var>${obj}$.nextElementSibling</var></td>
					<td>
						Returns the element <span class="underlineText">after</span> ${obj}$
						on the same level in the tree.
					</td>
					<td></td>
				</tr>
				<tr>
					<td><var>${obj}$.previousSibling</var></td>
					<td>
						Returns the element
						<span class="underlineText">before</span> ${obj}$ on the same level
						in the DOM tree.
					</td>
					<td></td>
				</tr>
				<tr>
					<td><var>${obj}$.style</var></td>
					<td>
						Returns an object containing all of the style properties of ${obj.}$
					</td>
					<td>
						Assuming the page follows standard practices, the properties in the
						returned object are displayed with empty string values. This is
						because the values set in the returned object are values provided
						via <span class="underlineText">inline styling</span>. Because
						inline styles are generally considered poor practice, the properties
						will usually have empty string values. To read existing values,
						<i>see</i>
						<var>.getComputedStyle()</var> above. We can, however, use the
						<var>.style</var> property to mutate the ${obj}$'s styles. For
						examle, <var>${obj}$.style.color = 'blue'</var> will change the text
						color to blue. Additionally, property names are written in
						JavaScript syntax. E.g., because JavaScript doesn't allow dashes in
						names, the CSS property <var>background-color</var> is identified in
						the object in camelCase: <var>backgroundColor</var>. Finally, note
						that mutating this property effectively adds inline styles to the
						${obj.}$ As such, this will overwrite any existing styles we've
						applied via CSS.
					</td>
				</tr>
			</tbody>
		</table>
	</figure>

	<section id="common_idoms">
		<h3>Common Idioms</h3>
		<p>
			Because the DOM provides the means for manipulating HTML pages, there are
			several common idioms for DOM manipulation. We present these idioms below.
		</p>
		<section id="changing_multiple_elements">
			<p>
				<span class="topic">Changing Multiple Elements.</span> To change
				multiple elements, one common pattern is to store a NodeList, or
				HTMLCollection, in a variable, then iterate over it:
			</p>
			<pre class="language-javascript"><code>
				const list = document.querySelectorAll('li');
				for (let i = 0; i < list.length; i++) {
					list[i].innerText = "Mutated";
				}
			</code></pre>
			<p>
				The code above changes all the list items inner text to the string
				<var>"Mutated"</var>. This idiom is particularly powerful, in that it
				allows us to change many properties, such as <var>.innerHTML</var> and
				<var>.style</var>.
			</p>
		</section>

		<section id="changing_multiple_styles">
			<p>
				<span class="topic">Applying Multiple Styles.</span> Another common
				idiom is applying multiple styles to an element. This is done by
				appending, removing, or modifying the element's styles applied via CSS
				throuh the element's <var>class</var> attribute. For example, say we had
				the following HTML code:
			</p>
			<pre class="language-html"><code>
				&lt;!DOCTYPE html&gt;
				&lt;html lang=&quot;en&quot;&gt;
				&lt;head&gt;
				&#x9;&lt;title&gt;Lab&lt;/title&gt;
				&#x9;&lt;link rel=&quot;stylesheet&quot; href=&quot;./styles.css&quot;&gt;
				&lt;/head&gt;
				&lt;body&gt;
				&#x9;&lt;main&gt;
				&#x9;&#x9;&lt;h1&gt;H1 Tag&lt;/h1&gt;
				&#x9;&#x9;&lt;p&gt;Paragraph tag&lt;/p&gt;
				&#x9;&#x9;&lt;ul id=&quot;todo&quot;&gt;
				&#x9;&#x9;&#x9;&lt;li class=&quot;incomplete&quot;&gt;List item 1&lt;/li&gt;
				&#x9;&#x9;&#x9;&lt;li class=&quot;incomplete&quot;&gt;List item 2&lt;/li&gt;
				&#x9;&#x9;&#x9;&lt;li class=&quot;incomplete&quot;&gt;List item 3&lt;/li&gt;
				&#x9;&#x9;&lt;/ul&gt;
				&#x9;&lt;/main&gt;
				&#x9;&lt;script src=&quot;./app.js&quot;&gt;&lt;/script&gt;
				&lt;/body&gt;
				&lt;/html&gt;&#x9;
			</code></pre>
			<p>The CSS appears as such:</p>
			<pre class="language-css"><code>
				main {
					font-family: sans-serif;
				}
				.redText {
					color: red;
				}
				.incomplete {
					color: green;
				}
			</code></pre>
			<p>
				Suppose that we wanted to have a list item once its marked complete. To
				do so, we write write a new class in the CSS file:
			</p>
			<pre class="language-css"><code>
				main {
					font-family: sans-serif;
				}
				.redText {
					color: red;
				}
				.incomplete {
					color: green;
				}
				.complete {
					color: grey;
					text-decoration: line-through;
				}
			</code></pre>
			<p>
				We can then apply the <var>.complete</var> class to the respective
				<var>li</var> object:
			</p>
			<pre class="language-javascript"><code>
				const todoList = document.querySelectorAll('li');
				let firstTodo = todoList[0];
				firstTodo.setAttribute('class', 'complete')
			</code></pre>
			<p>
				Alternatively, we could have used a method from the
				<var>.classList</var> property.
			</p>
		</section>
	</section>
</section>

<section id="dom_events">
	<h2>Event-driven Programming</h2>
	<p>
		Once we know how to target and manipulate the DOM tree and its nodes, we can
		begin investigating <i>events</i>. To understand what events are, it's
		helpful to think about the different kinds of programs we can write.
	</p>
	<p>
		In much of the preceding sections and volumes, we've been writing
		<b>console programs</b> &mdash; programs that run primarily on the console.
		We can, however, also write <b>interactive programs</b> &mdash; programs
		that allow the user to control a program's actions by using
		<i>peripherals</i>. Such peripherals include a keyboard, joystick, mouse,
		trackpad, microphone, etc. When a user performs some action with a
		peripheral, we call that action an <b>event</b>. For example: Clicking on a
		mouse, hitting the enter or arrow keys, touching a particular part of a
		screen, saying a particular word into a microphone, these are all events.
		Programs that are designed to respond to these events are called
		<b>event-driven programs</b>. In their simplest forms, such programs take
		events as input, and return some output.
	</p>
	<p>
		In modern interactive programs, user input does not occur at predictable
		times. For example, think about clicking on the &#8220;Agree&#8221; button
		for a software usage license. Most users click the button immediately.
		Others (however few), will take the time to read the license before
		clicking. The program behind the license doesn't tell us when we should
		click the button (it would be poor choice, both business-wise and legally,
		to require a user to agree to a license in less than five seconds). All this
		is to say that modern interactive programs leave it up to the user
		<i>when</i> to trigger an event. And because events are not controlled by
		the program, we say that such programs are <b>asynchronous</b>.
	</p>
	<p>
		In the JavaScript context, we implement such programs through functions that
		anticipate these events. By &#8220;anticipate&#8221; we mean that the
		functions are called <span class="underlineText">only if</span> an event
		occurs. These functions are more generally called <b>listeners</b>. We can
		think of a listener as akin to the string telephones we played with in our
		days of youth:
	</p>
	<figure>
		<img
			src="{% static 'images/listener.svg' %}"
			alt="A string telephone"
			loading="lazy"
			class="sixty-p"
		/>
	</figure>
	<p>
		The listener &#8220;listens&#8221; to whatever the user sends as input,
		which in turn keeps a particular module in the program informed. That module
		then executes whatever statements we provide.
	</p>
	<p>
		Listeners are based on a foundational principle of functional programming:
		Functions are data values, just as an integer or a string is a data value.
		JavaScript abides by this principle in treating functions as
		<i>first-class</i>: We can assign them to variables, pass them as arguments,
		express them as arguments, and return them as results. Just to confirm that
		this is the case, recall our discussion on
		<a href="{% url 'numerc:js_functions' %}#javascript_function_expressions"
			>function expressions</a
		>. We could write the following function as such:
	</p>
	<pre class="language-javascript"><code>
		function fahrenheitToCelsius(f) {
			return 5 / 9 * (f - 32);
		}
	</code></pre>
	<p>
		But, we could also assign the function to a variable (a
		<i>closure</i>):
	</p>
	<pre class="language-javascript"><code>
		let fahrenheitToCelsius = function(f) { return 5 / 9 * (f - 32); };
	</code></pre>
	<p>
		When first discussed these different syntactical forms, we didn't expound to
		deeply on the advantages of using closures over formal function definitions.
		With listeners, however, there's a signficant benefit to using closures: We
		can declare the function as a local variable inside another function (e.g.,
		what we represented as a module in the diagram above). In that case, the
		inner function (the listener) includes all of the code in its body, which in
		turn has access to all the local variable in the outer function. To
		understand how this is so useful, we turn to JavaScript's
		<i>event listeners</i>.
	</p>

	<section id="event_listeners">
		<h3>Event Listeners</h3>
		<p>
			In JavaScript, the most common listeners used are
			<b>event listeners</b>. The control flow appears as such:
		</p>
		<figure>
			<img
				src="{% static 'images/eventListener.svg' %}"
				alt="The control flow of an event listener"
				loading="lazy"
				class="sixty-p"
			/>
		</figure>
		<p>
			In the diagram above, the <i>target</i> is whatever element, or object, on
			the page (or in the Browser window) we expect the user the interact with,
			and the listener to listen to. We can think of the target as where on a
			wall we place a cup to listen to an adjacent room. The <i>event</i> is the
			event the function should listen to. And the <i>callback</i> is the
			function containing whatever statements we would like to run based on the
			event listeners output. For example, suppose a user clicks a button. The
			<i>target</i> is a <var>button</var>, the <i>event</i> is a
			<var>click</var>, and the <i>code to run</i> is whatever we'd like to do
			if the user clicks the button: E.g., change the position of an element,
			change text color, open a pop-up, etc.
		</p>
		<p>For example, suppose we had the following HTML code:</p>
		<pre class="language-html"><code>
			&lt;!DOCTYPE html&gt;
			&lt;html lang=&quot;en&quot;&gt;
			&lt;head&gt;
			&#x9;&lt;title&gt;Lab&lt;/title&gt;
			&#x9;&lt;link rel=&quot;stylesheet&quot; href=&quot;./styles.css&quot;&gt;
			&lt;/head&gt;
			&lt;body&gt;
			&#x9;&lt;main&gt;
			&#x9;&#x9;&lt;h1&gt;Some Buttons&lt;/h1&gt;
			&#x9;&#x9;&lt;ul&gt;
			&#x9;&#x9;&#x9;&lt;li&gt;&lt;button&gt;Button 1&lt;/button&gt;&lt;/li&gt;
			&#x9;&#x9;&#x9;&lt;li&gt;&lt;button&gt;Button 2&lt;/button&gt;&lt;/li&gt;
			&#x9;&#x9;&#x9;&lt;li&gt;&lt;button&gt;Button 3&lt;/button&gt;&lt;/li&gt;
			&#x9;&#x9;&lt;/ul&gt;
			&#x9;&lt;/main&gt;
			&#x9;&lt;script src=&quot;./app.js&quot;&gt;&lt;/script&gt;
			&lt;/body&gt;
			&lt;/html&gt;&#x9;&#x9;&#x9;
		</code></pre>
		<p>
			Let's consider a very simple example: When the user clicks the first
			button, the console outputs a message:
		</p>
		<pre class="language-javascript"><code>
			const buttonList = document.querySelectorAll('button');
			const firstButton = buttonList[0];

			firstButton.addEventListener('click', () => {
				console.log("First button clicked.");
			});
		</code></pre>
		<p>When we click the button, the console displays:</p>
		<pre class="language-bash"><code>
			First button clicked.
		</code></pre>
		<p>
			In the code above, we used the
			<var>addEventListener()</var> method. This is a method provided by the
			DOM, and it is what we use &#8220;attach&#8221; an event listener to a
			particular target. The template:
		</p>
		<figure class="math-display">
			<ul class="syntax">
				<li>${obj}$.addEventListener(${e_t}$, ${f_c}$);</li>
			</ul>
		</figure>
		<p>
			In the template above, ${obj}$ is some DOM object (e.g., an HTML element
			like a button, paragraph, list item, slider, etc.) The first parameter,
			${e_t,}$ is the event itself. This is a string value specified by the DOM,
			and there are numerous event values: <var>click</var>,
			<var>mousedown</var>, <var>drag</var>, etc. We will explore some of the
			most common events as we continue. The second parameter, ${f_c,}$ is the
			function that should execute when the event occurs. This is called the
			<b>callback function</b>. It contains all of the statements we want to
			execute in response to the event occuring. Putting all this together with
			respect to the above example: The target is the first button element, the
			event is a <var>'click'</var>, and the function is an anonymous function
			that displays to the console a message.
		</p>
		<p>
			This is where we see why having first-class in JavaScript is so useful. We
			can assign the callback function to a variable, and pass that variable as
			an argument to the event listener:
		</p>
		<pre class="language-javascript"><code>
			const buttonList = document.querySelectorAll('button');
			const firstButton = buttonList[0];
			const buttonMesage = () => { console.log("First button clicked.") };

			firstButton.addEventListener('click', buttonMesage);
		</code></pre>
		<p>Clicking the button once more:</p>
		<pre class="language-bash"><code>
			First button clicked.
		</code></pre>

		<section id="listen_to_multiple_objects">
			<p>
				<span class="topic">Attaching Listeners to Multiple Objects.</span> A
				common idiom in JavaScript is to attach listeners to multiple objects.
				For example, think of the upvote button on a Reddit page. It would
				tedious and unwieldy to attach listeners to each of the objects &mdash;
				there are thousands of them. Instead, what we want to do is use a loop.
				For example, suppose we had the following HTML code:
			</p>
			<pre class="language-html"><code>
				&lt;!DOCTYPE html&gt;
				&lt;html lang=&quot;en&quot;&gt;
				&#x9;&lt;head&gt;
				&#x9;&#x9;&lt;title&gt;Lab&lt;/title&gt;
				&#x9;&#x9;&lt;link rel=&quot;stylesheet&quot; href=&quot;./styles.css&quot; /&gt;
				&#x9;&lt;/head&gt;
				&#x9;&lt;body&gt;
				&#x9;&#x9;&lt;main&gt;
				&#x9;&#x9;&#x9;&lt;div id=&quot;container&quot;&gt;
				&#x9;&#x9;&#x9;&#x9;&lt;div&gt;&lt;/div&gt;
				&#x9;&#x9;&#x9;&#x9;&lt;div&gt;&lt;/div&gt;
				&#x9;&#x9;&#x9;&#x9;&lt;div&gt;&lt;/div&gt;
				&#x9;&#x9;&#x9;&lt;/div&gt;
				&#x9;&#x9;&lt;/main&gt;
				&#x9;&#x9;&lt;script src=&quot;./app.js&quot;&gt;&lt;/script&gt;
				&#x9;&lt;/body&gt;
				&lt;/html&gt;
			</code></pre>
			<p>Then, in our CSS, we have:</p>
			<pre class="language-css"><code>
				#container {
					display: flex;
					justify-content: center;
					align-items: center;
				}
				div div {
					border: solid thin grey;
					padding: 3em;
					margin: 5em;
				}
			</code></pre>
			<p>
				This displays three square boxes. Now, we want each of the boxes to
				change color when we hover over them. We can do so with the following
				JavaScript code:
			</p>
			<pre class="language-javascript"><code>
				const colors = ['red', 'green', 'blue'];
				const container = document.querySelectorAll('#container div');

				for (let i = 0; i < colors.length; i++) {
					container[i].addEventListener('mouseover', function () {
						this.style.backgroundColor = colors[i];
					})
				}
			</code></pre>
			<p>
				Note that the <var>this</var> keyword refers to the object we're
				attaching the event listener to. In this case, <var>container[i]</var>.
			</p>
		</section>
	</section>

	<section id="the_event_object">
		<h3>The Event Object</h3>
		<p>
			With event listeners, we, as the programmers, never actually call the
			callback functions. Instead, the event listener is what calls the
			callback, in response to an event. Moreover, the even listener passes an
			<b>event object</b> to the callback. In fact, we can see that the event is
			passed by explicitly naming the argument. Suppose the HTML page contains a
			single button element:
		</p>
		<pre class="language-javascript"><code>
			const button = document.querySelector('button');
			button.addEventListener('click', function (evt) { 
				console.log(evt); 
			});
		</code></pre>
		<pre class="language-bash"><code>
			PointerEvent {isTrusted: true, pointerId: 1, width: 1, height: 1, pressure: 0, …}
		</code></pre>
		<p>
			We see that we get back an object with numerous properties. Notice the
			identifier <var>PointerEvent</var>. This informs us what type of event
			object this is. There are numerous different types of event objects:
			<var>MouseEvent</var>, <var>KeyboardEvent</var>, <var>DragEvent</var>,
			<var>AnimationEvent</var>, and so on. More generally, the event objects
			are classified according to the kind of interaction by the user, as well
			as other forms of interactivity. Structurally, the event objects are
			records, or structs, containing various properties pertaining to the
			particular event. For example, the <var>KeyboardEvent</var> has a property
			called <var>key</var>, which returns the key value of the key pressed. The
			<var>MouseEvent</var> has a property called <var>button</var>, which
			returns which button on the mouse was pressed when the mouse event was
			triggered.
		</p>
		<p>
			Event objects are particularly useful because they allow us to be more
			specific with what kinds of inputs we want to trigger callback functions.
			For example, we can use the <var>key</var> property to specify that a
			block of code in the callback function executes only if the
			<var>enter</var> key is pressed. Or we can specify that another block
			executes only if a certain area around the target is hovered over with the
			mouse. In sum, event objects provide us with greater control over how
			events handled.
		</p>
	</section>
</section>

<section id="async_js">
	<h2>Asynchronous Programming</h2>
	<p>
		When we execute JavaScript code, the JavaScript interpreter uses a
		<b>call stack</b> to keep track of its place during execution. The call
		stack is <i>stack</i> data structure. This is a very simple data structure
		that looks, and behaves, exactly as it sounds: The last thing we place on
		the stack is the first thing we get from the stack, and the first thing we
		place in the stack is the last thing we get from the stack. For example, a
		stack of dishes to be washed. The dish from yesterday is beneath the dish
		from today, and the dish from ereyesterday is beneath the dish from
		yesterday. When we wash them, we wash the dish from today, then the dish
		from yesterday, then the dish from ereyesterday.
	</p>
	<p>
		In JavaScript, the call stack operates like the dish washing example.
		Suppose the following functions are called sequentially:
	</p>
	<figure class="math-display">
		<div>
			<p>${\lang f(x), g(x), h(x) \rang}$</p>
		</div>
	</figure>
	<p>
		When JavaScript executes the first function, ${f(x),}$ it generates a
		<i>stack frame</i> for ${f(x)}$ and pushes that frame <i>pushes</i> ${f(x)}$
		to the call stack:
	</p>
	<figure class="math-display">$$ \begin{aligned} f(x) \end{aligned} $$</figure>
	<p>
		When it encounters ${g(x),}$ it generates another stack frame for ${g(x)}$
		pushes that to the call stack:
	</p>
	<figure class="math-display">
		$$ \begin{align*} g(x) \\ \uparrow \\ f(x) \end{align*} $$
	</figure>
	<p>And when it counters ${h(x),}$ the same process occurs:</p>
	<figure class="math-display">
		$$ \begin{aligned} h(x) \\ \uparrow \\ g(x) \\ \uparrow \\ f(x)
		\end{aligned} $$
	</figure>
	<p>
		Once ${h(x)}$ finishes executing, its stack frame is
		<i>popped off</i> the stack:
	</p>
	<figure class="math-display">
		$$ \begin{aligned} g(x) \\ \uparrow \\ f(x) \end{aligned} $$
	</figure>
	<p>When ${g(x)}$ finishes executing, it too is popped off the stack:</p>
	<figure class="math-display">$$ \begin{aligned} f(x) \end{aligned} $$</figure>
	<p>
		This leaves ${f(x),}$ and once ${f(x)}$ finishes executing, it's popped off
		the stack. This control flow applies whether ${g(x)}$ and ${h(x)}$ are
		inside ${f(x),}$ or whether they are all separate functions in the program.
		Nesting, however, impacts the order the call stacks are generated, pushed,
		and popped. In general, when want to determine the order a function's stack
		frames are generated, pushed, and popped, we want to read the program top to
		bottom, right to left.
	</p>
	<p>
		This phenomenon of pushing and popping stack frames stems from a fundamental
		trait of JavaScript: JavaScript is a
		<b>single-threaded language</b>. A single-threaded language is a language
		with a single call stack and a single memory heap. In effect, this means
		that within the language, we can only run one statement at a time. Because
		of this trait, JavaScript programs live in a
		<b>synchronous environment</b> &mdash; an environment where functions return
		(i.e., are popped off) only after they have finished executing. Think
		carefully about what this means. Necessarily, when we call a function ${f,}$
		nothing else in the program can run. All other functions must wait until
		${f}$ finishes. This is the defining characteristic of the
		<b>synchronous programming</b>. Tasks are done one at a time; there's no
		such thing as &#8220;multitasking.&#8221;
	</p>
	<p>
		The opposite of a single-threaded language is a
		<b>multithreaded language</b>. With a multithreaded language, we can perform
		simultaneous executions of two or more parts of the program (e.g.,
		functions). Multithreading is a defining characteristic of
		<b>parallel programming</b> &mdash; programming where functions need not
		wait for another function to return before executing. Not very many
		languages have built-in support for multithreading. Languages like C++ and
		Java provide multithreading only if the operating system permits it. We will
		see in a moment why multithreading is a relatively rare feature.
	</p>
	<p>
		The opposite of the synchronous environment is an
		<b>asynchronous environment</b> &mdash; an environment where multiple
		functions run and return at various points in time. With an asynchronous
		environment, we can perform <b>asynchronous programming</b>: When we call a
		function ${f,}$ the program continues to run, calling other functions like
		${g}$ and ${h.}$ When ${f}$ finishes, great, we can use ${f}$'s return
		value. If not, we can continue working on other things.
	</p>
	<p>
		We can compare asynchronous programming and synchronous programming with the
		following analogy: We have to make a caramel glaze and bake a cake. Under
		the synchronous programming model, we must do one or the other, not both,
		before proceeding to the next. In other words, we have to finish making the
		glaze before baking the cake, or we have to finish baking the cake before
		making the glaze. In the asynchronous programming model, we can start baking
		the pie, then while it's in the oven, we move on to the glaze, waiting for
		the pie to finish.
	</p>
	<p>
		We might be thinking, why don't all languages just default to multithreaded
		implementations? If they did so, we would be able to perform asynchronous
		programming as needed. It is, after all, much more efficient to work on the
		glaze while the cake bakes. The answer lies in thinking a little more
		carefully on the analogy. Preparing a glaze alongside baking a cake is
		actually much more complex than it seems. If we start the glaze too early,
		it can harden, decreasing its viscosity. Start too late, and we can burn the
		cake.
	</p>
	<p>
		This same difficulty extends to multithreaded programs. It can be much more
		difficult to reason about what a multithreaded program does at any given
		point in time. We have to keep track of different functions executing at
		once. Moreover, if we reflect a little more deeply, we'd realize that we
		aren't very good at multitasking ourselves. Sure, we can tie our shoelaces
		while talking to someone, but if the conversation was on the mechanics of
		the proof for &#8220;This statement is a theorem,&#8221; no doubt we would
		pause. In fact, some tasks are so involved that we have laws ensuring we
		don't multitask: &#8220;No person may drive ... any motor vehicle while
		composing or sending an electronic text message or an electronic mail
		message.&#8221; Wis. Stat. §346.89(3)(a).
	</p>
	<p>
		Nevertheless, there are some tasks that we can reason about easily. And
		there are some tasks that we <i>want</i> to perform while performing
		another. The fact that these tasks exist is partly why we have Bluetooth
		headsets and speech-to-text software. This extends to JavaScript programs.
		In fact, many websites rely on asynchronous programming. When we click the
		&#8220;Watch&#8221; button on Netflix, a request is sent to a server to
		retrieve the relevant video file. This is done with a function, and that
		function can take time. The page, however, doesn't just freeze while the
		program waits for the function to finish. Instead, we're greeted with some
		animations indicating some loading is going on in the background. These
		animations are performed with functions. How does JavaScript achieve
		something like this?
	</p>
</section>

<section id="asynchronous_callbacks">
	<h2>Asychronous Callbacks</h2>
	<p>
		The more general question is, how do we implement asynchronous programs in a
		synchronous environment? The answer is through
		<b>asynchronous callbacks</b> (also called <i>call-after functions</i>). The
		callback functions we saw in the previous examples are instances of
		<b>synchronous callbacks</b> &mdash; callbacks that execute immediately.
		With asynchronous callbacks, the callback is executed only after some delay;
		i.e., at a later point in time. These asynchronous callbacks are done one of
		two methods: a <b>one-shot timer</b> implemented with the
		<var>setTime()</var> method, or an <b>interval timer</b>, implemented with
		the <var>setInterval()</var> method.
	</p>
	<p>The template for the <var>setTime()</var> method:</p>
	<figure class="math-display">
		<ul class="syntax">
			<li>setTimeout(${f}$, ${t}$)</li>
		</ul>
	</figure>
	<p>
		In the template above, ${f}$ is some function, and ${t}$ is an integer value
		of time, measured in milliseconds. And the template for the
		<var>setInterval()</var> method:
	</p>
	<figure class="math-display">
		<ul class="syntax">
			<li>setInterval(${f}$, ${I}$)</li>
		</ul>
	</figure>
	<p>
		Here, ${f}$ is some function, and ${I}$ is an integer value of time,
		measured in milliseconds. With
		<var>setInterval()</var>, the function ${f}$ is called every ${I}$
		milliseconds (hence an <i>interval time</i>). Furthermore,
		<var>setInterval()</var> returns a numeric value ${v}$ that can be used to
		stop the timer. This is done by calling the method
		<var>clearTimeout()</var>, passing ${v}$ as an argument &mdash;
		<var>clearTimeout(${v}$)</var>.
	</p>
	<p>For example, consider the following code:</p>
	<pre class="language-javascript"><code>
		function f1() {
			console.log("f1 started.");
			alert("Proceed?");
			console.log("f1 finished.")
		 }
		function f2() {
			console.log("f2 started.");
			console.log("f1 finished.");
		}
		f1();
		f2();
	</code></pre>
	<p>The output:</p>
	<pre class="language-bash"><code>
		f1 started.
		f1 finished.
		// ALERT
		f2 started.
		f2 finished.
	</code></pre>
	<p>
		Executing the code above, we see JavaScript's typical synchronous behavior.
		The function <var>f1()</var> executes first. When it reaches the
		<var>alert()</var> call, it stops and waits for us to click the
		<var>OK</var> button. The function <var>f2()</var> does not execute until we
		respond with the necessary feedback.<label
			for="blocking"
			class="margin-toggle"
			><sup></sup
		></label>
		<input
			type="checkbox"
			id="blocking"
			class="margin-toggle sidenote-number"
		/>
		<span class="marginnote"
			>This behavior &mdash; an evaluation being performed only if the previous
			evaluation has finished &mdash; is called <b>blocking</b>. Blocking can
			lead to many undesirable consequences. For example, if a particular
			evaluation takes a long time to process, our program is effectively stuck.
			It would be far more time-efficient to perform other evaluations while the
			longer evaluation processes.</span
		>
	</p>
	<p>
		The simplest way to make the code above asynchronous is to use a
		<var>setTimeOut()</var> function. The <var>setTimeOut()</var> function takes
		a function as an argument, and executes it after a given amount of time:
	</p>
	<pre class="language-javascript"><code>
		function f1() {
			setTimeout(function () {
				console.log("f1 started.");
				alert("Proceed?");
				console.log("f1 finished.");
			}, 1000);
		}
		function f2() {
			console.log("f2 started.");
			console.log("f2 finished.");
		}
		f1();
		f2();
	</code></pre>
	<pre class="language-bash"><code>
		f2 started.
		f2 finished.
		// Alert
		f1 started.
		f1 finished.
	</code></pre>
	<p>
		Notice that the call order has changed. This is because we've set a time out
		on the <var>f1()</var> function. <var>f1()</var> is called, and after 1
		second, <var>f2()</var> is called. In other words, other functions are
		called while <var>f1()</var> waits &mdash; <var>f1()</var> is an
		<b>asynchronous function</b>. The function inside <var>setTimeOut</var> is a
		<b>callback function</b>.
	</p>
	<div class="mainIdea">
		<p>
			The <var>setTimeOut()</var> function is really an event. When we place the
			callback function inside a <var>setTimeOut()</var> function, we're
			essentially making the function <var>f1()</var> say,
			<q>Go on ahead without me, I'll catch up when I'm ready.</q> When is
			<var>f1()</var> ready? When the event &mdash;
			<i>the time expiring upon our clicking <var>OK</var></i> &mdash; has
			occurred.
		</p>
	</div>
	<p>
		Question: But isn't JavaScript itself executing these functions? In other
		words, itsn't JavaScript running another process (keeping track of time)
		while it continues executing the next function? This is an astute
		observation, but the answer is no. These methods are called by JavaScript,
		but executed by the <i>browser</i>. This is JavaScript's secret to
		asynchrony (well, not quite; it's public knowledge, just not widely-known).
		Because JavaScript only has one thread to rely on, it sends the tasks of
		keeping tracking of the delay's time and reminding to execute to another
		program's thread &mdash; the browser's.
	</p>
	<p>
		So now the question is how does this work? Recall that JavaScript lives only
		in a hosted environment. One of these environments is the browser, a program
		more than likely written in C++. Browsers provide numerous interfaces, one
		of which provides methods like
		<var>setTimeout()</var> and <var>setInterval()</var>. When the JavaScript
		engine encounters a call like <var>setTimeout()</var>, it generates a stack
		frame for the function, and pushes it onto the call stack as it would any
		other. Once at the call stack, however, the call stack itself recognizes
		<var>setTimeout()</var> as one of the browser's web API functions and hands
		them over to the browser. The browser then starts a timer, per our argument.
		Once the time passes, the browser inserts a <b>timeout event</b> to a data
		structure called the <b>event queue</b>.
	</p>
	<p>
		The event queue is exactly what it sounds like: A line of entities in
		waiting. The queue exhibits a behavior we're all familiar with &mdash; if
		you're the first in line, you're the first one out (assuming an orderly
		society). In this case, the timeout event inserted into the queue includes
		the function we want executed after the delay. Once the timer is over, the
		JavaScript engine processes the call as usual.
	</p>
	<p>
		With callbacks, we can <i>simulate</i> what looks like multithreaded
		programming, but is not. To understand this simulation, we have to be clear
		about the distinction between single-threaded programs, multi-threaded
		programs, synchronous programs, and asynchronous programs.
	</p>
	<p>
		In a <b>single-threaded program</b>, only one command is executed in a
		single process. As we know, JavaScript is a single-threaded language. All
		JavaScript programs are single-threaded. In a <b>multi-threaded program</b>,
		multiple commands are executed within a single process. Multi-threaded
		programs are possible only if the operating system supports it. For example,
		on a Windows system with the ThreadFiber package, we can write
		multi-threaded C programs. In a <b>synchronous program</b>, commands are
		executed one by one, immediately after one another. Before we encountered
		the asynchronous callback functions we saw above, our JavaScript programs
		have been synchronous. In an <b>asynchronous program</b>, commands are
		executed one by one, but some commands are delayed (i.e., executed later).
		We can compare these different approaches via diagram. Each of the colored
		boxes below represents a function:
	</p>
	<figure>
		<img
			src="{% static 'images/approachComparisons.svg' %}"
			alt="Comparing the different approaches, multi-threaded takes the least amoung of time."
			loading="lazy"
			class="seventy-p"
		/>
	</figure>
	<p>
		Once again, with the asynchronous callbacks above, JavaScript is not setting
		a timer and keeping track of it. It hands that work to the browser for
		handling. Once the timer has finished, the function we delayed is placed on
		the callstack.
	</p>

	<section id="advantages_and_disadvantages_of_asynchrony">
		<p>
			<span class="topic">Tradeoffs: Asynchronous Programming</span>
			There are costs and benefits to asynchronous programming. Synchronous code
			is far easier to write and reason about. As we've seen, however, it can lead
			to blocking. And because of blocking, there are situations where synchronous
			code is less perfomant. Time is the most valuable resource in programming,
			and it's wasted waiting.
		</p>
		<p>
			With asynchronous programming, our code is more performant. The cost: Code
			is harder to read and reason about. Asynchronous code is also just harder to
			write well in general.
		</p>
	</section>
</section>

<section id="the_event_loop">
	<h2>The Event Loop</h2>
</section>



{% endblock %}
