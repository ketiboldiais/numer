{% extends '../layout.html' %} {% load static %} {% block description %}
<meta
	name="description"
	content="Notes on computer graphics with JavaScript."
/>
{% endblock %} {% block title %}
<title>Computer Graphics with JavaScript</title>
{% endblock %} {% block content %}
<h1>D3JS</h1>
<section id="dthreejs">
	<p>
		<span class="drop">I</span>n this module, we explore D3JS. D3
		(&#8220;Data-Driven Documents&#8221;) is a JavaScript library for creating
		data visualizations. Data visualization is a means of conveying a story or
		an idea as efficiently as possible. It is an exercise of the timeless adage,
		&#8220;A picture is worth a thousand words.&#8221; By visualizing data, the
		viewer is more likely to easily identify patterns or anti-patterns (e.g.,
		disruptions) in data. The base ingredients of data visualization are shape,
		size, and color.
	</p>
	<div class="mainIdea">
		<p>
			Before creating any data visualization, we must answer the following
			questions:
		</p>
		<ol>
			<li>Who is the audience?</li>
			<li>What does the audience know?</li>
			<li>What does the audience need to do with the data?</li>
		</ol>
	</div>
	<p>
		Because data visualizations are only useful if they're perceived, once we've
		determined who the viewer is, we must determine the appropriate visual. Some
		visuals are ideal for representing ratios. Other visuals are best reserved
		for frequencies. Yet others still are best used for densities, chronologies,
		and partitions. Then there are field-specific visuals. A viewer with a
		discrete mathematics background might have no difficulty understanding node
		graphs with loops, but may have difficulty understanding chemical structure
		formulas.
	</p>
	<p>
		Once we've determined the appropriate visual, we have to perform a very
		sensitive but critical step: Hiding clutter. When working with data, it's
		often the case that we have a large amount of unnecessary information. This
		is called <b>clutter</b>, and it can make the visualization difficult, even
		impossible, to read. For example, consider a map of New York City. If
		labeled every street, building, neighborhood, and landmark, we'd like just
		have a fuzzy, grey blob with some letters sticking out. Clearly, we have to
		prioritize what information we want to show. However, if we hide too much,
		we can end up communicating the wrong propositions &mdash; this is equally
		bad, if not worse.
	</p>
	<p>
		Even if we do not remove clutter, we always draw attention through shape,
		size, and color. In other words, if we want the viewer to focus on a
		particular part of the visualization, we manipulate one of the following
		properties of that part: It's shape, size, or color. For example, if some
		parts of a company's cash flow dip dangerously low, we might highlight it in
		a bright red color.
	</p>
	<p>
		D3 is the bridge between raw data and visualization. Every data
		visualization is a bundle of two objects: (1) The
		<b>data</b> and (2) the <b>document</b>. Data is the computer representation
		of real-world information, and for our purposes, it comes in various file
		formats: JSON, CSV, TXT, etc. The document is the representation of that
		data. In JavaScript, the document is an HTML file. Note that this process is
		a one-way street. Real-world information drives data, and data drives the
		document. This is a fundamental principle we must never forget. If we're
		seeing unsightly white space, it is
		<span class="underlineText">not</span> because of the data. It is because of
		the document. We have to make changes to the document via D3. We
		<span class="underlineText">never</span> make changes to the data.
	</p>
	<section id="installing_d3">
		<p>
			<span class="topic">Installing.</span>
			To use D3, we need an HTML file (the document, say,
			<var>index.html</var>) and a JavaScript file (the file we will be writing
			our visualization code in, say <var>app.js</var>). To add D3 to our
			project, we use the D3JS CDN link available
			<a href="https://d3js.org/" target="_blank">here</a>. The script tag
			pointing to the CDN link should be placed before the closing body tag, but
			<span class="underlineText">before</span> the script tag pointing to the
			<var>app.js</var>. For example:
		</p>
		<pre class="language-html"><code>
			&lt;!DOCTYPE html&gt;
			&lt;html lang=&quot;en&quot;&gt;
			&lt;head&gt;
			&#x9;&lt;meta charset=&quot;UTF-8&quot;&gt;
			&#x9;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
			&#x9;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
			&#x9;&lt;link rel=&quot;stylesheet&quot; href=&quot;./styles.css&quot;&gt;
			&#x9;&lt;title&gt;D3 Lab&lt;/title&gt;
			&lt;/head&gt;
			&lt;body&gt;
			&#x9;&lt;main&gt;&lt;/main&gt;
			<span class="redText">&#x9;&lt;script src=&quot;https://d3js.org/d3.v7.min.js&quot;&gt;&lt;/script&gt;</span>
			<span class="redText">&#x9;&lt;script src=&quot;./script.js&quot;&gt;&lt;/script&gt;</span>
			&lt;/body&gt;
			&lt;/html&gt;&#x9;&#x9;
		</code></pre>
	</section>
</section>

<section id="svg_code">
	<h2>SVG</h2>
	<p>
		SVG (&#8220;Scalable Vector Graphics&#8221;) is what D3 uses to create
		charts and graphs. With SVG, images are created with mathematical equations
		and commands. Comparing an SVG image to a JPEG image, if we zoomed in on
		both very closely, we'd find that the JPEG image rapidly loses quality at
		high magnification. We begin seeing the individual pixels and colors
		constituting the JPEG image. If we looked at the SVG image, however, we'd
		find no such distortion. The image is still smooth and crisp. Why? Because
		our machine constantly recalculates the math equations defining the image,
		changing values here and there in response to our actions. Hence the name
		&#8220;Scalable.&#8221;
	</p>
	<p>
		The largest cost to SVG, however, is that the more complicated the image is,
		the more computations the machine must perform. And with more computations,
		the more resource intensive our visualization is &mdash; a significant
		performance concern.
	</p>
	<p>
		There are numerous ways to create SVG elements. One way is to write SVG code
		directly in an HTML file. This is done by enclosing the SVG code in an SVG
		tag:
	</p>
	<figure>
		<ul class="syntax">
			<li>&lt;svg&gt;${~~code~~}$&lt;/svg&gt;</li>
		</ul>
	</figure>
	<p>
		Two attributes most commonly used with the SVG element is
		<var>width</var> and <var>height</var>:
	</p>
	<figure>
		<ul class="syntax">
			<li>&lt;svg width="${n}$" height="${m}$"&gt;${~~code~~}$&lt;/svg&gt;</li>
		</ul>
	</figure>
	<p>
		Both the <var>width</var> and <var>height</var> attributes are used to
		configure the SVG image's dimensions. In the template above, ${n}$ and ${m}$
		can be a percentage (of either the bounding box or viewport), or a number
		with one of the usual HTML units (em, ex, px, in, cm, mm, pt, pc).
	</p>
	<p>
		The SVG element alone doesn't display anything. It's just a container for
		what we actually we want to display. To display a rectangle, for example, we
		use the <var>&lt;rect&gt;&lt;/rect&gt;</var> element, setting its
		<var>width</var> and <var>height</var> to <var>100</var>.
	</p>
	<figure>
		<svg width="100" height="100">
			<rect width="100" height="100"></rect>
		</svg>
	</figure>
	<p>The code for the SVG above looks like:</p>
	<pre class="language-html"><code>
		&lt;svg width=&quot;100&quot; height=&quot;100&quot;&gt;
		&#x9;&lt;rect width=&quot;100&quot; height=&quot;100&quot;&gt;&lt;/rect&gt;
		&lt;/svg&gt;
	</code></pre>
	<p>
		If we include a <var>fill</var> attribute, we can change the color of the
		rectangle. The color value can be a named color, RGBA value, HSV value, or
		hexadecimal. With the color <var>"salmon"</var>:
	</p>
	<figure>
		<svg width="100" height="100">
			<rect width="100" height="100" fill="salmon"></rect>
		</svg>
	</figure>
	<p>The code rendering the rectangle above is:</p>
	<pre class="language-html"><code>
		&lt;svg width=&quot;100&quot; height=&quot;100&quot;&gt;
		&#x9;&lt;rect width=&quot;100&quot; height=&quot;100&quot; fill=&quot;salmon&quot;&gt;&lt;/rect&gt;
		&lt;/svg&gt;
	</code></pre>
	<p>
		If we want to add an &#8220;outline&#8221; to the rectangle, we can include
		the <var>stroke</var> attribute. This attribute is available for all SVG
		shapes. The code:
	</p>
	<pre class="language-html"><code>
		&lt;svg width=&quot;100&quot; height=&quot;100&quot;&gt;
		&#x9;&lt;rect width=&quot;100&quot; height=&quot;100&quot; fill=&quot;salmon&quot; stroke=&quot;#555&quot;&gt;&lt;/rect&gt;
		&lt;/svg&gt;
	</code></pre>
	<p>renders:</p>
	<figure>
		<svg width="100" height="100">
			<rect width="100" height="100" fill="salmon" stroke="#000"></rect>
		</svg>
	</figure>
	<p>
		The stroke is barely visible. This is because we must include a
		<var>stroke-width</var> attribute:
	</p>
	<pre class="language-html"><code>
		&lt;svg width=&quot;100&quot; height=&quot;100&quot;&gt;
		&#x9;&lt;rect
		&#x9;&#x9;width=&quot;100&quot;
		&#x9;&#x9;height=&quot;100&quot;
		&#x9;&#x9;fill=&quot;salmon&quot;
		&#x9;&#x9;stroke=&quot;#555&quot;
		&#x9;&#x9;stroke-width=&quot;10&quot;
		&#x9;&gt;&lt;/rect&gt;
		&lt;/svg&gt;
	</code></pre>
	<p>Rendering:</p>
	<figure>
		<svg width="100" height="100">
			<rect
				width="100"
				height="100"
				fill="salmon"
				stroke="#555"
				stroke-width="10"
			></rect>
		</svg>
	</figure>
	<section id="svg_coordinate_system">
		<h5>The SVG Coordinate System</h5>
		<p>
			To position shapes in an SVG image, the SVG element uses a particular
			coordinate system. If the SVG element has the following attributes set:
		</p>
		<pre class="language-html"><code>
			&lt;svg width=&quot;100&quot; height=&quot;100&quot;&gt;
			&lt;/svg&gt;
		</code></pre>
		<p>We end up with a coordinate system as follows:</p>
		<figure>
			<img
				src="{% static 'images/svg_coordinate_system.svg' %}"
				alt="SVG coordinate system"
				loading="lazy"
				class="thirty-p"
			/>
		</figure>
		<p>
			The <var>height</var> attribute sets the maximum ${y}$-coordinate, and the
			<var>width</var> attribute sets the maximum ${x}$-coordinate. For both
			${x}$- and ${y}$-coordinates, the minimum value is ${0.}$ By default,
			shapes are placed to the upper-left corner, the coordinate ${(0,0).}$ To
			avoid this default, we must explicitly set the shape's <var>x</var> and
			<var>y</var> attributes:
		</p>
		<pre class="language-html"><code>
			&lt;svg width=&quot;100&quot; height=&quot;100&quot;&gt;
			&#x9;&lt;rect
			&#x9;&#x9;x=&quot;5&quot;
			&#x9;&#x9;y=&quot;5&quot;
			&#x9;&#x9;width=&quot;100&quot;
			&#x9;&#x9;height=&quot;100&quot;
			&#x9;&#x9;fill=&quot;salmon&quot;
			&#x9;&#x9;stroke=&quot;#555&quot;
			&#x9;&#x9;stroke-width=&quot;10&quot;
			&#x9;&gt;&lt;/rect&gt;
			&lt;/svg&gt;
		</code></pre>
		<p>
			An important point to note: With SVG elements, the ${y}$-axis tends
			towards positive as we move down, and negative as we move up.
			Additionally, we can provide positive and negative values for the
			<var>x</var> and <var>y</var> attributes.
		</p>
	</section>

	<section id="circle_elements">
		<p>
			<span class="topic">The Circle Element.</span> With the example above, we
			created a rectangle element. We can also create circles. This is done with
			the following template:
		</p>
		<figure>
			<ul class="syntax">
				<li>&lt;circle r="${n}$"&gt;&lt;/circle&gt;</li>
			</ul>
		</figure>
		<p>
			The one required attribute for the circle element is
			<var>r</var>. As we can likely guess, this attribute sets the circle's
			radius. To illustrate, this code:
		</p>
		<pre class="language-html"><code>
			&lt;svg width=&quot;100&quot; height=&quot;100&quot;&gt;
			&#x9;&lt;circle r=&quot;50&quot;&gt;&lt;/circle&gt;
			&lt;/svg&gt;
		</code></pre>
		<p>renders:</p>
		<figure>
			<div>
				<svg width="100" height="100">
					<circle r="50"></circle>
				</svg>
			</div>
		</figure>
		<p>
			Notice that the circle is cut off. This is because of the coordinate
			system we explained previously. By default, all elements are placed to the
			top left. In this case, the center of the circle is placed at coordinate
			${(0,0).}$ To fix this, we provide <var>x</var> and
			<var>y</var> coordinates for the circle explicitly. Unlike other elements,
			the circle element has specific names for the <var>x</var> and
			<var>y</var> attributes:
		</p>
		<pre class="language-html"><code>
			&lt;svg width=&quot;100&quot; height=&quot;100&quot;&gt;
			&#x9;&lt;circle cx=&quot;50&quot; cy=&quot;50&quot; r=&quot;50&quot;&gt;&lt;/circle&gt;
			&lt;/svg&gt;
		</code></pre>
		<p>
			The coordinates for the circle element are <var>cx</var> (<q
				>center ${x}$</q
			>) and <var>cy</var> (<q>center ${y}$</q>). Rendering the code above:
		</p>
		<figure>
			<div>
				<svg width="100" height="100">
					<circle cx="50" cy="50" r="50"></circle>
				</svg>
			</div>
		</figure>
	</section>
	<section id="line_element">
		<p>
			<span class="topic">Line Element.</span> To visualize lines, we use the
			line element. This element has several required attributes::
		</p>
		<figure>
			<ul class="syntax">
				<li>&lt;line</li>
				<ul>
					<li>&#x9;x1=&quot;${n}$&quot;</li>
					<li>&#x9;y1=&quot;${m}$&quot;</li>
					<li>&#x9;x2=&quot;${p}$&quot;</li>
					<li>&#x9;y2=&quot;${q}$&quot;</li>
					<li>&#x9;stroke=&quot;${a}$&quot;</li>
					<li>&#x9;stroke-width=&quot;${b}$&quot;&gt;</li>
				</ul>
				<li>&lt;/line&gt;</li>
			</ul>
		</figure>
		<p>
			The <var>x1</var> and <var>y1</var> attributes set the coordinates for the
			line's starting point. The <var>x2</var> and <var>y2</var> attributes set
			the line's ending point. We must also include <var>stroke</var> (the
			line's color) and a <var>stroke-width</var> attribute (the line's
			thickness).
		</p>
	</section>
	<section id="svg_layering">
		<p>
			<span class="topic">Layering.</span> Importantly, SVG elements are layered
			first element to the bottom, last element to the top. For example, if we
			create a rectangle element, followed by a circle, then a line, the line
			element would lie atop the circle, and the circle atop the rectangle.
		</p>
	</section>

	<section id="svg_paths">
		<h3>Paths</h3>
		<p>
			The most widely-used SVG element is the
			<i>path</i>. A powerful tool for visualizing complex shapes, it can also
			quickly turn into a rat's nest &mdash; there are many, many commands
			associated with paths. The path element is a shape that can be manipulated
			to form any other shape. It can have straight or curved edges, along with
			an unlimited number of sides. All of the attributes we saw previously are
			available for the path attribute, alongside several others.
		</p>
		<p>
			One attribute we'll often see with the path element is the
			<var>d</var> attribute (<var>d</var> for &#8220;data&#8221;). This
			attribute is assigned a list of data and commands. The most commonly used
			commands are <var><mark>M</mark></var> (<q>move to</q>),
			<var><mark>L</mark></var> (<q>line to</q>), and
			<var><mark>Z</mark></var> (<q>close path</q>). For example, for the data,
			we can include coordinates, and for the command, a line between the
			coordinates. Useful commands:
		</p>
		<ul class="ruled">
			<li>
				<span class="greyText monoText"
					>&lt;path d = <span class="redText">"M100,100"</span>&gt;</span
				>
			</li>
			<ul>
				<li>
					The <var>M</var> command stands for <i>moveto</i>. It will move the
					pen tool.
				</li>
				<li>
					The values <var>100,100</var> are the ${x}$- and ${y}$- coordinate
					respectively. Thus, writing <var>M100,100</var> means
					<q>Move the pen to the point ${(100,100).}$</q> By default, the pen
					starts at the coordinates ${(0,0).}$
				</li>
			</ul>
			<li>
				<span class="greyText monoText"
					>&lt;path d = "M100,100
					<span class="redText">L300,150"</span>&gt;</span
				>
			</li>
			<ul>
				<li>
					The <var>L</var> command stands for <i>lineto</i>. Thus, by writing
					<var>L300,150</var>, we are saying,
					<q>Draw a line to the coordinate ${(300,150).}$</q>
				</li>
			</ul>
			<li>
				<span class="greyText monoText"
					>&lt;path d = "M100,100 L300,150
					<span class="redText">Z</span>"&gt;</span
				>
			</li>
			<ul>
				<li>
					The <var>Z</var> command stands for <i>closepath</i>. By terminating
					our path with the command <var>Z</var>, we are saying,
					<q>Bring the pen back to the point ${(100,100).}w</q>
				</li>
			</ul>
		</ul>
		<p>
			Paths are what allow us to draw shapes like polygons. For example, a
			triangle:
		</p>
		<figure>
			<div>
				<svg width="100" height="100">
					<path d="M 80 80 L 80 5 L 5 80 Z" fill="pink" stroke="red"></path>
				</svg>
			</div>
		</figure>
		<p>The code for rendering the triangle above:</p>
		<pre class="language-html"><code>
			&lt;svg width=&quot;100&quot; height=&quot;100&quot;&gt;
			&#x9;&lt;path d=&quot;M 80 80 L 80 5 L 5 80 Z&quot; fill=&quot;pink&quot; stroke=&quot;red&quot;&gt;&lt;/path&gt;
			&lt;/svg&gt;
		</code></pre>
		<p>
			As we can see, writing SVG code is tedious. Imagine having to construct
			something complex like a tree diagram. Recognizing these hurdles, D3 is
			essentially a library that allows us to write SVG code in a much more
			intuitive, expressive, and efficient way.
		</p>
	</section>
</section>

<section id="d3_documentation">
	<h2>D3 Documentation</h2>
	<p>
		D3 is organized as a collection of packages. All of D3's packages can be
		found <a href="https://github.com/d3" target="_blank">here</a>. D3, as a
		whole, is a large package, weighing in at ${542 \text{ kB}.}$ Even the
		minified version is fairly large &mdash; ${262 \text{ kB}.}$ Earlier
		versions of D3 were much larger. Such large sizes result from all the
		features and tools D3 provides. Many of these features, however, are
		specific to certain use cases and not needed by all users. Accordingly, D3's
		authors decided to break the library down into smaller packages, allowing
		users to use which packages they needed. Because of this modular approach,
		rather than using the entire D3 library (which contains all of the
		packages), we can instead use some parts of D3 but not others.
	</p>
	<p>
		Given D3's modular organization, there isn't a single place for
		documentation. Instead, each of D3's packages have their own documentation.
		These individual pieces of documentation are collected in the
		<a href="https://github.com/d3/d3/blob/main/API.md" target="_blank"
			>D3 API Reference Github page</a
		>.
	</p>
</section>

<section id="selections">
	<h2>Selections</h2>
	<p>
		As we saw from the
		<a href="{% url 'numerc:js_dom' %}"><em>DOM Section</em></a
		>, we have a wide variety of ways to select HTML elements. The most commonly
		used being
		<span class="monoText"><mark>document.querySelector('${obj}$')</mark></span
		>. D3, however, provides its own method for selecting elements:
	</p>
	<figure>
		<ul class="syntax">
			<li>d3.select('${obj}$')</li>
		</ul>
	</figure>
	<p>
		where ${obj}$ is an HTML element. D3's selector works in essentially the
		same way as the DOM selector. We can use HTML tag names and CSS selector
		syntax to narrow or broaden queries. The key difference, however, is that
		the object returned from the D3 selection includes additional methods and
		properties beyond what the DOM provides. Accordingly, when working with D3,
		it's often best to use D3's provided selection methods.
	</p>
	<p>Using D3's selector on a paragraph element, we see the following:</p>
	<pre class="language-javascript"><code>
		d3.select('p');
	</code></pre>
	<pre class="language-bash"><code>
		Selection$1 {_groups: Array(1), _parents: Array(1)}
			_groups: [Array(1)]
			_parents: [html]
			[[Prototype]]: Object
	</code></pre>
	<p>
		The <var>d3.select()</var> method will select the first element matching the
		query. Notice that the return is something called a
		<span class="monoText"><mark>Selection</mark></span
		>. This is an object, with several methods and properties, some of which are
		provided by D3. The <var><mark>_parents</mark></var> element above contains
		a list of the selected element's parents. There are many other selectors
		available through D3, and they can be found
		<a href="https://github.com/d3/d3-selection" target="_blank">here</a>.
	</p>
	<p>
		If we wanted to select all elements matching the query, we can use
		<span class="monoText"><mark>d3.selectAll()</mark></span
		>. Unsurprisingly, this works similarly to the
		<var>.querySelectorAll()</var> method provided by the DOM.
	</p>
</section>

<section id="appending">
	<h2>Appending Elements</h2>
	<p>Like the selection methods, D3 provides methods for appending elements.</p>
	<pre class="language-javascript"><code>
		const body = d3.select('body'); 
		body.append('p');
	</code></pre>
	<p>
		Writing the code above, we append a paragraph element to the body element.
		Unlike JavaScript's native DOM methods, D3's
		<var><mark>.append(${s}$)</mark></var> method automatically
		<i>creates</i> and <i>appends</i> the tag name passed as an argument, ${s.}$
	</p>
	<p>
		The output to the <var>.append()</var> method is a
		<var>selection</var> containing the element we created and appended.
	</p>
	<pre class="language-javascript"><code>
		const body = d3.select('body'); 
		const p = body.append('p');
		console.log(p);
	</code></pre>
	<pre class="language-bash"><code>
		Selection$1 {_groups: Array(1), _parents: Array(1)}
			_groups: Array(1)
				0: [p]
				length: 1
				[[Prototype]]: Array(0)
			_parents: Array(1)
				0: html
				length: 1
				[[Prototype]]: Array(0)
			[[Prototype]]: Object
	</code></pre>
</section>

<section id="transformation_methods">
	<h2>Transformation Methods</h2>
	<p>
		After we've made a selection, we likely want to modify the selected
		object(s) somehow. These modifications, called
		<b>transformations</b>, can be done through either native JavaScript or D3's
		provided methods.
		<a
			href="https://github.com/d3/d3-selection#modifying-elements"
			target="_blank"
			>D3's documentation</a
		>
		details these methods. The keypoints to transformation methods are the
		following:
	</p>
	<ul>
		<li>
			If a method selects or creates an element, then a new selection is
			returned.
		</li>
		<li>
			If a method manipulates a selection, then the same selection is returned.
		</li>
	</ul>
	<div class="mainIdea">
		<p>
			In programming more generally, a
			<b>transformation method</b> or <b>transformation function</b> is a
			function that modifies an object's properties.
		</p>
	</div>
	<p>
		The <var>.append()</var> method we saw earlier is actually a transformation
		method (since calling the method modifies the selected element's children
		&mdash; a property). All transformation methods return a selection: the
		previous selection with the modifications applied.
	</p>
	<section id="html_attributes">
		<h3>Modifying HTML Attributes</h3>
		<p>
			One of the most commonly used transformation methods is
			<span class="monoText"><mark>.attr()</mark></span
			>. The template:
		</p>
		<figure>
			<ul class="syntax">
				<li>${obj}$.attr('${a}$', ${v}$)</li>
			</ul>
			<figcaption>
				Where ${obj}$ is some selection, ${a}$ is the name of the attribute (a
				string value), and ${v}$ is the value for the attribute.
			</figcaption>
		</figure>
		<p>For example:</p>
		<pre class="language-javascript"><code>
			const body = d3.select('body'); 
			const p = body.append('p').attr('class', 'foo');
			console.log(p);
		</code></pre>
		<pre class="language-bash"><code>
			Selection$1 {_groups: Array(1), _parents: Array(1)}
				_groups: Array(1)
					0: [p.foo]
					length: 1
					[[Prototype]]: Array(0)
				_parents: [html]
				[[Prototype]]: Object
		</code></pre>
		<p>
			Notice the use of chaining, a common pattern in D3. Writing the statements
			above, we have appended a paragraph element with the class
			<var>'foo'</var> to the body element. Note that if we do not include the
			argument ${v,}$ we will get back the current value of the attribute ${v.}$
		</p>
		<p>
			A <span class="redText">warning</span>: The <var>.attribute()</var> method
			will override existing attributes. If we want to add multiple classes, we
			use:
		</p>
		<figure>
			<ul class="syntax">
				<li>${obj}$.classed('${c}$', ${b}$)</li>
			</ul>
			<figcaption>
				Where ${c}$ is some class name, ${b}$ is a Boolean value (<span
					class="monoText"
					>true</span
				>
				or <var>false</var>), and ${obj}$ is some selection.
			</figcaption>
		</figure>
		<p>
			With the method above, if the parameter ${b}$ is
			<var>true</var>, then class ${c}$ is added to the class list. If ${b}$ is
			<var>false</var>, then the class ${c}$ is or are removed from the class
			list. To add a second class value, we call the method again:
		</p>
		<pre class="language-javascript"><code>
			const p = d3.select('body')
				.append('p')
				.classed('foo', true)
				.classed('bar', true)
		</code></pre>
		<p>
			In the code above, the class values <var>foo</var> and <var>bar</var> are
			added to the paragraph element's class list.
		</p>

		<section id="inline_styles">
			<h4>Inline Styles</h4>
			<p>
				HTML elements have a <var>style</var> attribute, and assigning values to
				this attribute creates an <i>inline style</i>. D3 provides a
				transformer, <span class="monoText"><mark>.style()</mark></span
				>, which we can use for modifications:
			</p>
			<pre class="language-javascript"><code>
				const body = d3.select('body'); 
				const p = body
					.append('p')
					.text('Hello!')
					.style('color', 'red');
			</code></pre>
			<p>
				The paragraph element's text color should now be red. In general, the
				template for <var>.style()</var> is as follows:
			</p>
			<figure>
				<ul class="syntax">
					<li>${obj}$.style('${s}$', '${v}$')</li>
				</ul>
				<figcaption>
					where ${obj}$ is some selection, ${s}$ is the name of the CSS style (a
					string value), and ${v}$ is the value assigned (also a string value).
				</figcaption>
			</figure>
		</section>
	</section>

	<section id="modifying_text">
		<h3>Modifying Text</h3>
		<p>
			Alongside the attribute transformer, we can also transform text with the
			<var><mark>.text()</mark></var> method. The template:
		</p>
		<figure>
			<ul class="syntax">
				<li>${obj}$.text('${s}$')</li>
			</ul>
			<figcaption>
				Where ${obj}$ is some selection, and ${s}$ is the text to insert.
			</figcaption>
		</figure>
		<p>
			Like the attribute transformer, if the argument ${s}$ is not supplied,
			<var>.text()</var> returns the element's current text. For example:
		</p>
		<pre class="language-javascript"><code>
			const body = d3.select('body'); 
			const p = body.append('p').text('Hello!');
		</code></pre>
		<p>
			Writing the code above, we see that the paragraph element now contains the
			inner-text value <var>'Hello!'</var>.
		</p>
	</section>
</section>

<section id="joining_data">
	<h2>Joining Data</h2>
	<ol class="references">
		<li>
			<a href="https://github.com/d3/d3-selection#joining-data" target="_blank"
				>D3, <strong>Documentation: Joining Data</strong></a
			>
		</li>
		<li>
			<a href="https://www.d3indepth.com/datajoins/" target="_blank"
				>D3 in Depth, <strong>Data Joins</strong></a
			>
		</li>
	</ol>
	<p>
		In programming generally, everything we work with is data &mdash; code,
		images, audio, text, videos, it's all data. With D3, there are only two
		categories of data: (1) <b>text</b> and (2) <b>numbers</b>. D3 visualizes
		data by associating datum with HTML and CSS. This process is called
		<b>joining data</b>.
	</p>
	<p>For example, suppose we had the following array of data:</p>
	<pre class="language-javascript"><code>
		const foo = [1.2, 1.4, 1.8, 1.7];
	</code></pre>
	<p>
		We can <i>join</i> the data by associating each element to, say, a paragraph
		element. The first paragraph is associated with ${1.2,}$ the second
		paragraph with ${1.4,}$ the third with ${1.8,}$ and the fourth with ${1.7.}$
		The simplest way to join data is to use the
		<var><mark>.data()</mark></var> method. Suppose we had the following list in
		our HTML:
	</p>
	<pre class="language-html"><code>
		&lt;body&gt;
		&#x9;&lt;main&gt;
		&#x9;&#x9;&lt;ul&gt;
		&#x9;&#x9;&#x9;&lt;li&gt;a&lt;/li&gt;
		&#x9;&#x9;&#x9;&lt;li&gt;b&lt;/li&gt;
		&#x9;&#x9;&#x9;&lt;li&gt;c&lt;/li&gt;
		&#x9;&#x9;&#x9;&lt;li&gt;d&lt;/li&gt;
		&#x9;&#x9;&#x9;&lt;li&gt;e&lt;/li&gt;
		&#x9;&#x9;&lt;/ul&gt;
		&#x9;&lt;/main&gt;
		&#x9;&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/d3/7.2.1/d3.js&quot;&gt;&lt;/script&gt;
		&#x9;&lt;script src=&quot;./script.js&quot;&gt;&lt;/script&gt;
		&lt;/body&gt;		
	</code></pre>
	<p>In our driver file, we write:</p>
	<pre class="language-javascript"><code>
		const data = [1, 2, 3, 4, 5];
		const listItems = d3.selectAll('li')
			.data(data);
	</code></pre>
	<p>
		Each of the list elements is now associated with the values in the
		<var>data</var> array. The first list element is associated with the value
		<var>1</var>, the second with <var>2</var>, and so on. But what do we mean
		by <q>associated</q>? In terms of implementation, each of the list elements
		has a property called <var>__data__</var>. If we examined the property for
		each of these elements, we see that their assigned values are the respective
		elements in the <var>data</var> array.
	</p>
	<p>If we log to the console <var>listItems</var>:</p>
	<pre class="language-bash"><code>
		Selection$1 {_groups: Array(1), _parents: Array(1), _enter: Array(1), _exit: Array(1)}
			_enter: [Array(5)]
			_exit: [Array(5)]
			_groups: [Array(5)]
			_parents: [html]
			[[Prototype]]: Object
	</code></pre>
	<p>
		Let's focus on the properties <var>_enter</var> and <var>_exit</var>. When
		we join data, we must ensure that data and elements are mapped one-to-one.
		If there are more elements than there are data, we should remove the excess
		elements, and if there are fewer elements then there are data, we should
		insert additional elements.
	</p>

	<section id="enter_selection">
		<h3>Enter Selection</h3>
		<p>
			The <var>_enter</var> property indicates data that have not been joined to
			an element. If we look inside this property, we find an empty array
			&mdash; each datum has been joined to an element. Say we removed the first
			three list items in our HTML code and logged to the console
			<var>listItems</var>:
		</p>
		<pre class="language-javascript"><code>
			const data = [1, 2, 3, 4, 5];
			const listItems = d3.selectAll('li')
				.data(data);
			console.log(listItems);
		</code></pre>
		<pre class="language-bash"><code>
			Selection$1 {_groups: Array(1), _parents: Array(1), _enter: Array(1), _exit: Array(1)}
				_enter: Array(1)
					0: (5) [empty × 3, EnterNode, EnterNode]
					length: 1
					[[Prototype]]: Array(0)
				_exit: [Array(3)]
				_groups: [Array(5)]
				_parents: [html]
				[[Prototype]]: Object
		</code></pre>
		<p>
			Notice the expression <var>empty × 3</var>. This is an indicator that the
			first three elements are empty. The last two items, each called
			<var>EnterNode</var>, are <i>virtual elements</i> created by D3. A virtual
			element is a node stored in memory but does not occupy space in the
			document.
		</p>
		<p>
			Let's join the data. To do so, we use the
			<var><mark>.join(${s}$)</mark></var> method. This method takes a string
			argument, ${s,}$ corresponding to the name of an HTML element. In this
			case, we'll use <var>li</var>:
		</p>
		<pre class="language-javascript"><code>
			const data = [1, 2, 3, 4, 5];
			const listItems = d3.selectAll('li')
				.data(data)
				.join('li');
		</code></pre>
		<p>
			Running the code above, we see three new list items inserted after the two
			existing list items. These new list items, however, are not aligned with
			the existing list items, and they contain no content. Furthermore, if we
			inspected the HTML document, we'd find that the list items are appended
			<em>after</em> the body tag. We see these outputs because the
			<var>.join()</var> method only creates and appends new elements to the
			parent element of the current selection. It does not make any
			modifications to properties like style or inner-text.
		</p>
		<p>
			Writing <var>d3.selectAll('li')</var>, the parent element of the selection
			is the <var>html</var> element. Whenever we call the
			<var>.selectAll()</var> method directly through <var>d3</var>, D3
			automatically sets the parent element property to the
			<var>html</var> element. To ensure a particular parent element value, we
			chain the <var>.selectAll()</var> method to a <var>.select()</var> method:
		</p>
		<pre class="language-javascript"><code>
			const data = [1, 2, 3, 4, 5];
			const listItems = d3.select('ul')
				.selectAll('li')
				.data(data)
				.join('li');
		</code></pre>
		<p>
			Writing the code above, when we first call <var>.select('ul')</var>, the
			parent element is <var>html</var>. The selection itself, however, is
			<var>ul</var>. Thus, when we call <var>.selectAll('li')</var> on that
			selection, the parent element for the <var>.selectAll()</var> selection is
			<var>ul</var>. To confirm:
		</p>
		<pre class="language-javascript"><code>
			const data = [1, 2, 3, 4, 5];
			const list = d3.select('ul')
			const listItems = list.selectAll('li')

			console.log(list);
			console.log(listItems);
		</code></pre>
		<pre class="language-bash"><code>
			Selection$1 {_groups: Array(1), _parents: Array(1)}
				_groups: [Array(1)]
				_parents: [html]
				[[Prototype]]: Object
			Selection$1 {_groups: Array(1), _parents: Array(1)}
				_groups: [NodeList(2)]
				_parents: [ul]
				[[Prototype]]: Object
		</code></pre>
		<p>Writing:</p>
		<pre class="language-javascript"><code>
			const data = [1, 2, 3, 4, 5];
			const listItems = d3.select('ul')
				.selectAll('li')
				.data(data)
				.join('li');
		</code></pre>
		<p>
			we should now see that the list items have been appended to the
			<var>ul</var> element as intended. We can then add text to each of the
			list items using the <var>.text()</var> transformer:
		</p>
		<pre class="language-javascript"><code>
			const data = [1, 2, 3, 4, 5];
			const listItems = d3.select('ul')
				.selectAll('li')
				.data(data)
				.join('li')
				.text('List item')
		</code></pre>
		<p>
			Each of the list items now has the text <var>'List item'</var>. Notice
			that this modifies each list item's property. This is because the
			<var>.join()</var> method merges the groups and enters properties all at
			once.
		</p>
	</section>

	<section id="exit_selection">
		<h3>Exit Selection</h3>
		<p>
			The <var>_enter</var> selection returns an array of elements that should
			be included. It's opposite twin is the <var>_exit</var> selection: An
			array of elements that should be <em>removed</em>. D3 provides this method
			because there are situations where we have more elements than there are
			data. In this situations, we should remove the excess elements. To begin,
			let's say we had the following HTML code:
		</p>
		<pre class="language-html"><code>
			&lt;body&gt;
			&#x9;&lt;main&gt;
			&#x9;&#x9;&lt;ul&gt;
			&#x9;&#x9;&#x9;&lt;li&gt;10&lt;/li&gt;
			&#x9;&#x9;&#x9;&lt;li&gt;20&lt;/li&gt;
			&#x9;&#x9;&#x9;&lt;li&gt;30&lt;/li&gt;
			&#x9;&#x9;&#x9;&lt;li&gt;40&lt;/li&gt;
			&#x9;&#x9;&#x9;&lt;li&gt;50&lt;/li&gt;
			&#x9;&#x9;&#x9;&lt;li&gt;60&lt;/li&gt;
			&#x9;&#x9;&#x9;&lt;li&gt;70&lt;/li&gt;
			&#x9;&#x9;&lt;/ul&gt;
			&#x9;&lt;/main&gt;
			&#x9;&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/d3/7.2.1/d3.js&quot;&gt;&lt;/script&gt;
			&#x9;&lt;script src=&quot;./script.js&quot;&gt;&lt;/script&gt;
			&lt;/body&gt;
		</code></pre>
		<p>There are seven list elements. Writing the code below:</p>
		<pre class="language-javascript"><code>
			const data = [1, 2, 3, 4, 5];
			const listItems = d3.select('ul')
				.selectAll('li')
				.data(data)
			console.log(listItems);
		</code></pre>
		<pre class="language-bash"><code>
			Selection$1 {_groups: Array(1), _parents: Array(1), _enter: Array(1), _exit: Array(1)}
				_enter: [Array(5)]
				_exit: Array(1)
					0: Array(7)
						5: li
						6: li
						length: 7
					[[Prototype]]: Array(0)
				length: 1
				[[Prototype]]: Array(0)
			_groups: [Array(5)]
			_parents: [ul]
			[[Prototype]]: Object
		</code></pre>
		<p>
			We see that there five <var>empty</var> and two <var>li</var> values.
			Given that there are five data values, these two additional
			<var>li</var> values indicate excess elements. To remove these methods, we
			can use the <var>join()</var> method again:
		</p>
		<pre class="language-javascript"><code>
			const data = [1, 2, 3, 4, 5];
			const listItems = d3.select('ul')
				.selectAll('li')
				.data(data)
				.join('li')
		</code></pre>
		<p>We now see that the two excess elements have been removed.</p>
	</section>

	<section id="displaying_data">
		<h3>Displaying Data</h3>
		<p>
			Now that we know how to select elements and join data, we now examine ways
			to display data. We have the following HTML code:
		</p>
		<pre class="language-html"><code>
			&lt;body&gt;
			&#x9;&lt;main&gt;
			&#x9;&#x9;&lt;ul&gt;
			&#x9;&#x9;&#x9;&lt;li&gt;a&lt;/li&gt;
			&#x9;&#x9;&#x9;&lt;li&gt;b&lt;/li&gt;
			&#x9;&#x9;&#x9;&lt;li&gt;c&lt;/li&gt;
			&#x9;&#x9;&#x9;&lt;li&gt;d&lt;/li&gt;
			&#x9;&#x9;&#x9;&lt;li&gt;e&lt;/li&gt;
			&#x9;&#x9;&lt;/ul&gt;
			&#x9;&lt;/main&gt;
			&#x9;&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/d3/7.2.1/d3.js&quot;&gt;&lt;/script&gt;
			&#x9;&lt;script src=&quot;./script.js&quot;&gt;&lt;/script&gt;
			&lt;/body&gt;			
		</code></pre>
		<p>and the following JavaScript code in our driver file:</p>
		<pre class="language-javascript"><code>
			const data = [1, 2, 3, 4, 5];
			const listItems = d3.select('ul')
				.selectAll('li')
				.data(data)
				.join('li')
		</code></pre>
		<p>
			We now want to display the data joined to each of the
			<var>li</var> elements. To do so, we first use a callback function that
			takes the data joined as an argument, call it <var>d</var>:
		</p>
		<pre class="language-js"><code>
			const data = [1, 2, 3, 4, 5];
			const listItems = d3.select('ul')
				.selectAll('li')
				.data(data)
				.join('li')
				.text(function (d) {
					return d;
				})
		</code></pre>
		<p>
			The code above works fine, but we can make it more concise with an arrow
			function:
		</p>
		<pre class="language-javascript"><code>
			const data = [1, 2, 3, 4, 5];
			const listItems = d3.select('ul')
				.selectAll('li')
				.data(data)
				.join('li')
				.text(d => d)
		</code></pre>
		<p>
			Executing the code above, we see that the list items, originally with
			character text, now has inner text corresponding to the array values
			joined.
		</p>
	</section>

	<section id="modifying_the_join_method">
		<h3>Modifying the Join Method</h3>
		<p>
			The <var>.join()</var> method can be modified in a variety of ways. For
			example, we can display an animation for an element entering or exiting
			the selection by passing a function argument to the
			<var>.join()</var> method's <var><mark>enter</mark></var> parameter.
			Suppose we had the following HTML code:
		</p>
		<pre class="language-html"><code>
			&lt;body&gt;
			&#x9;&lt;main&gt;
			&#x9;&#x9;&lt;ul&gt;
			&#x9;&#x9;&#x9;&lt;li&gt;1&lt;/li&gt;
			&#x9;&#x9;&#x9;&lt;li&gt;2&lt;/li&gt;
			&#x9;&#x9;&#x9;&lt;li&gt;3&lt;/li&gt;
			&#x9;&#x9;&lt;/ul&gt;
			&#x9;&lt;/main&gt;
			&#x9;&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/d3/7.2.1/d3.js&quot;&gt;&lt;/script&gt;
			&#x9;&lt;script src=&quot;./script.js&quot;&gt;&lt;/script&gt;
			&lt;/body&gt;			
		</code></pre>
		<p>
			Note that there are two missing <var>li</var> elements. In our driver
			file:
		</p>
		<pre class="language-javascript"><code>
			const data = [1, 2, 3, 4, 5];
			const listItems = d3.select('ul')
				.selectAll('li')
				.data(data)
				.join(
					enter => { 
						return enter.append('li')
							.style('color', 'purple')
					}
				)
				.text(d => d)
		</code></pre>
		<p>
			Notice howe we're passing a function to the <var>.join()</var> method. The
			function takes the property <var>enter</var> as an argument, and executes
			<var>enter.append</var>. It is imperative that we include this line.
			Otherwise, there is no selection resulting from calling
			<var>.join()</var>. After calling <var>.append</var>, we then call
			<var>.style()</var>. Examining our list, we should see the two missing
			list items in purple.
		</p>
		<p>
			We can also have the <var>update</var> and <var>exit</var> selections
			return a function:
		</p>
		<pre class="language-javascript"><code>
			const data = [1, 2, 3, 4, 5];
			const listItems = d3.select('ul')
				.selectAll('li')
				.data(data)
				.join(
					enter => { 
						return enter.append('li')
							.style('color', 'purple')
					},
					update => update.style('color', 'green'),
					exit => exit.remove()
				)
				.text(d => d)
		</code></pre>
		<p>The first three list items are now green.</p>
	</section>
</section>

<section id="json_requests">
	<h2>HTTP Requests</h2>
	<ol class="references">
		<li>
			<a href="https://github.com/d3/d3-fetch" target="_blank"
				>D3, <strong>Documentation: D3 Fetch</strong>.</a
			>
		</li>
	</ol>
	<p>
		Recall that every visualization has two components: (1) the data, and (2)
		the document. Usually, data is found in three places:
	</p>
	<figure>
		<ul>
			<li>Directly inside the JavaScript driver file.</li>
			<li>Inside an external file (JSON, CSV, etc.).</li>
			<li>In some API.</li>
		</ul>
	</figure>
	<p>
		In the previous illustrations, we had data directly available in our driver
		file. Many visualizations, however, require large amounts of data, and we
		may or may not have direct access to such data. In these situations, we may
		need to make an HTTP request for the data.
	</p>
	<p>
		D3 provides several methods for executing HTTP requests. The D3 library for
		HTTP requests is
		<a href="https://github.com/d3/d3-fetch" target="_blank">d3-fetch</a>.
		There, are, however, many other libraries for fetching. In this section,
		we'll use D3's fetch library.
	</p>
	<section id="json_requests">
		<h3>JSON Requests</h3>
		<p>
			First, suppose we had three files: <var>index.html</var>,
			<var>script.js</var>, and <var>data.json</var>. Inside the HTML file:
		</p>
		<figure>
			<pre class="language-html"><code>
				&lt;!DOCTYPE html&gt;
				&lt;html lang=&quot;en&quot;&gt;
				&lt;head&gt;
				&#x9;&lt;meta charset=&quot;UTF-8&quot;&gt;
				&#x9;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
				&#x9;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
				&#x9;&lt;link rel=&quot;stylesheet&quot; href=&quot;./styles.css&quot;&gt;
				&#x9;&lt;title&gt;D3&lt;/title&gt;
				&lt;/head&gt;
				&lt;body&gt;
				&#x9;&lt;main&gt;
				&#x9;&#x9;&lt;ul&gt;
				&#x9;&#x9;&#x9;&lt;li&gt;1&lt;/li&gt;
				&#x9;&#x9;&#x9;&lt;li&gt;2&lt;/li&gt;
				&#x9;&#x9;&#x9;&lt;li&gt;3&lt;/li&gt;
				&#x9;&#x9;&lt;/ul&gt;
				&#x9;&lt;/main&gt;
				&#x9;&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/d3/7.2.1/d3.js&quot;&gt;&lt;/script&gt;
				&#x9;&lt;script src=&quot;./script.js&quot;&gt;&lt;/script&gt;
				&lt;/body&gt;
				&lt;/html&gt;&#x9;&#x9;&#x9;&#x9;
			</code></pre>
			<figcaption>index.html</figcaption>
		</figure>
		<p>The JavaScript file is initially empty. Inside the JSON file:</p>
		<figure>
			<pre class="language-javascript"><code>
				[10,20,30,40,50]
			</code></pre>
			<figcaption>data.json</figcaption>
		</figure>
		<p>
			Given these files, we want to use the data inside the
			<var>data.json</var> file. We can do so by calling the
			<var><mark>d3.json()</mark></var> method in our driver file. The template
			for this method:
		</p>
		<figure>
			<ul class="syntax">
				<li>d3.json(${'s'}$)</li>
			</ul>
			<figcaption>Where ${s}$ is a valid file path.</figcaption>
		</figure>
		<p>
			Because our <var>data.json</var> file is in the same directory as our
			<var>script.js</var> file, we can write:
		</p>
		<pre class="language-javascript"><code>
			d3.json('data.json');
		</code></pre>
		<p>
			The return for this function is a promise. We can chain the
			<var>then()</var> method to handle the response by passing an arrow
			function as an argument:
		</p>
		<pre class="language-javascript"><code>
			d3.json('data.json').then((data) => { 
				console.log(data);
			});
		</code></pre>
		<pre class="language-bash"><code>
			Array(5)
				0: 10
				1: 20
				2: 30
				3: 40
				4: 50
				length: 5
				[[Prototype]]: Array(0)
		</code></pre>
		<p>
			From the console, we see that we now have access to the data inside the
			JSON file. Notice that the data returned is already instantiated as a
			JavaScript array. JSON is a much easier format to work with in JavaScript.
			As we'll see later, other formats like CSV require additional processing
			for JavaScript parsing.
		</p>
		<p>
			As an aside, the same function above can be written with async-await
			syntax:
		</p>
		<pre class="language-javascript"><code>
			async function getData() { 
				const data = await d3.json('data.json');
				console.log(data);
			}
			getData();
		</code></pre>
	</section>

	<section id="csv_requests">
		<h3>CSV Requests</h3>
		<p>
			Another common file format for data transfers is
			<b>CSV (<q>Comma Separated Values</q>)</b>. CSV files are used most
			commonly by spreadsheet programs. We can work with CSV files either
			through a text-editor or through software like <i>Google Sheets</i> or
			<i>Microsoft Excel</i>. Inside our project directory, let's create a file
			called <var>data.csv</var>. Inside the file, we have:
		</p>
		<pre class="language-bash"><code>
			10,20,30,40,50
		</code></pre>
		<p>
			We can then load this data into our driver file with D3's
			<var><mark>.csv()</mark></var> method:
		</p>
		<pre class="language-javascript"><code>
			async function getData() { 
				const data = await d3.csv('data.csv')
				console.log(data);
			}
			getData();
		</code></pre>
		<p>
			Like the <var>.json()</var> method, <var>.csv()</var> takes a single
			argument, the CSV file's file path. Examining the console:
		</p>
		<pre class="language-bash"><code>
			[columns: Array(5)]
				columns: Array(5)
					0: "10"
					1: "20"
					2: "30"
					3: "40"
					4: "50"
					length: 5
					[[Prototype]]: Array(0)
				length: 0
				[[Prototype]]: Array(0)
		</code></pre>
		<p>
			Because JavaScript does not understand CSV files, D3 takes the additional
			step of turning the CSV data into an array. In this case, an array called
			<var>columns</var>. The identifier <var>columns</var> comes from the fact
			that CSV files are closely associated with spreadsheets, which are, at
			their core, tables. For example, suppose we had the following spreadsheet
			in Google Sheets:
		</p>
		<figure>
			<table>
				<thead>
					<th>Name</th>
					<th>Age</th>
				</thead>
				<tbody>
					<tr>
						<td>John</td>
						<td>43</td>
					</tr>
					<tr>
						<td>Sachiko</td>
						<td>87</td>
					</tr>
					<tr>
						<td>Glen</td>
						<td>74</td>
					</tr>
				</tbody>
			</table>
		</figure>
		<p>
			If we download this spreadsheet as a CSV and open it in a text editor, we
			see the following:
		</p>
		<pre class="language-bash"><code>
			Name,Age
			John,43
			Sachiko,87
			Glen,74
		</code></pre>
		<p>
			Studying the CSV file, we can see how the lines and values map to the
			original spreadsheet. When we pass a CSV file to <var>.csv()</var>, D3
			identifies the values on the first line as the column names. Hence the
			output array <var>columns</var>. Passing the name-age CSV file into
			<var>.csv()</var>, we see the following output:
		</p>
		<pre class="language-bash"><code>
			(3) [{…}, {…}, {…}, columns: Array(2)]
				0: {Name: 'John', Age: '43'}
				1: {Name: 'Sachiko', Age: '87'}
				2: {Name: 'Glen', Age: '74'}
				columns: (2) ['Name', 'Age']
				length: 3
				[[Prototype]]: Array(0)
		</code></pre>
		<p>
			We still have the <var>columns</var> array, but notice that we now have
			three objects. For each row in the CSV file other than the first, D3
			creates an object.
		</p>
	</section>
</section>
<section id="drawing_charts">
	<h2>Creating Visualizations</h2>
	<p>There are three steps to creating visualizations:</p>
	<ol>
		<li>Fetch the data.</li>
		<li>Draw the chart dimensions.</li>
		<li>Draw the image.</li>
	</ol>
</section>
{% endblock %}
