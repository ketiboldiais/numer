{% extends '../layout.html' %} {% load static %} {% block description %}
<meta
	name="description"
	content="Notes on computer graphics with JavaScript."
/>
<link rel="stylesheet" href="../../../static/numerc/d3demo.css" />
{% endblock %} {% block title %}
<title>Computer Graphics with JavaScript</title>
{% endblock %} {% block content %}
<h1>D3JS</h1>
<section id="dthreejs">
	<p>
		<span class="drop">I</span>n this module, we explore D3JS. D3
		(&#8220;Data-Driven Documents&#8221;) is a JavaScript library for creating
		data visualizations. Data visualization is a means of conveying a story or
		an idea as efficiently as possible. It is an exercise of the timeless adage,
		&#8220;A picture is worth a thousand words.&#8221; By visualizing data, the
		viewer is more likely to easily identify patterns or anti-patterns (e.g.,
		disruptions) in data. The base ingredients of data visualization are shape,
		size, and color.
	</p>
	<div class="mainIdea">
		<p>
			Before creating any data visualization, we must answer the following
			questions:
		</p>
		<ol>
			<li>Who is the audience?</li>
			<li>What does the audience know?</li>
			<li>What does the audience need to do with the data?</li>
		</ol>
	</div>
	<p>
		Because data visualizations are only useful if they're perceived, once we've
		determined who the viewer is, we must determine the appropriate visual. Some
		visuals are ideal for representing ratios. Other visuals are best reserved
		for frequencies. Yet others still are best used for densities, chronologies,
		and partitions. Then there are field-specific visuals. A viewer with a
		discrete mathematics background might have no difficulty understanding node
		graphs with loops, but may have difficulty understanding chemical structure
		formulas.
	</p>
	<p>
		Once we've determined the appropriate visual, we have to perform a very
		sensitive but critical step: Hiding clutter. When working with data, it's
		often the case that we have a large amount of unnecessary information. This
		is called <b>clutter</b>, and it can make the visualization difficult, even
		impossible, to read. For example, consider a map of New York City. If
		labeled every street, building, neighborhood, and landmark, we'd like just
		have a fuzzy, grey blob with some letters sticking out. Clearly, we have to
		prioritize what information we want to show. However, if we hide too much,
		we can end up communicating the wrong propositions &mdash; this is equally
		bad, if not worse.
	</p>
	<p>
		Even if we do not remove clutter, we always draw attention through shape,
		size, and color. In other words, if we want the viewer to focus on a
		particular part of the visualization, we manipulate one of the following
		properties of that part: It's shape, size, or color. For example, if some
		parts of a company's cash flow dip dangerously low, we might highlight it in
		a bright red color.
	</p>
	<p>
		D3 is the bridge between raw data and visualization. Every data
		visualization is a bundle of two objects: (1) The
		<b>data</b> and (2) the <b>document</b>. Data is the computer representation
		of real-world information, and for our purposes, it comes in various file
		formats: JSON, CSV, TXT, etc. The document is the representation of that
		data. In JavaScript, the document is an HTML file. Note that this process is
		a one-way street. Real-world information drives data, and data drives the
		document. This is a fundamental principle we must never forget. If we're
		seeing unsightly white space, it is
		<span class="underlineText">not</span> because of the data. It is because of
		the document. We have to make changes to the document via D3. We
		<span class="underlineText">never</span> make changes to the data.
	</p>
	<section id="installing_d3">
		<p>
			<span class="topic">Installing.</span>
			To use D3, we need an HTML file (the document, say,
			<var>index.html</var>) and a JavaScript file (the file we will be writing
			our visualization code in, say <var>app.js</var>). To add D3 to our
			project, we use the D3JS CDN link available
			<a href="https://d3js.org/" target="_blank">here</a>. The script tag
			pointing to the CDN link should be placed before the closing body tag, but
			<span class="underlineText">before</span> the script tag pointing to the
			<var>app.js</var>. For example:
		</p>
		<pre class="language-html"><code>
			&lt;!DOCTYPE html&gt;
			&lt;html lang=&quot;en&quot;&gt;
			&lt;head&gt;
			&#x9;&lt;meta charset=&quot;UTF-8&quot;&gt;
			&#x9;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
			&#x9;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
			&#x9;&lt;link rel=&quot;stylesheet&quot; href=&quot;./styles.css&quot;&gt;
			&#x9;&lt;title&gt;D3 Lab&lt;/title&gt;
			&lt;/head&gt;
			&lt;body&gt;
			&#x9;&lt;main&gt;&lt;/main&gt;
			<span class="redText">&#x9;&lt;script src=&quot;https://d3js.org/d3.v7.min.js&quot;&gt;&lt;/script&gt;</span>
			<span class="redText">&#x9;&lt;script src=&quot;./script.js&quot;&gt;&lt;/script&gt;</span>
			&lt;/body&gt;
			&lt;/html&gt;&#x9;&#x9;
		</code></pre>
	</section>
</section>

<section id="svg_code">
	<h2>SVG</h2>
	<p>
		SVG (&#8220;Scalable Vector Graphics&#8221;) is what D3 uses to create
		charts and graphs. With SVG, images are created with mathematical equations
		and commands. Comparing an SVG image to a JPEG image, if we zoomed in on
		both very closely, we'd find that the JPEG image rapidly loses quality at
		high magnification. We begin seeing the individual pixels and colors
		constituting the JPEG image. If we looked at the SVG image, however, we'd
		find no such distortion. The image is still smooth and crisp. Why? Because
		our machine constantly recalculates the math equations defining the image,
		changing values here and there in response to our actions. Hence the name
		&#8220;Scalable.&#8221;
	</p>
	<p>
		The largest cost to SVG, however, is that the more complicated the image is,
		the more computations the machine must perform. And with more computations,
		the more resource intensive our visualization is &mdash; a significant
		performance concern.
	</p>
	<p>
		There are numerous ways to create SVG elements. One way is to write SVG code
		directly in an HTML file. This is done by enclosing the SVG code in an SVG
		tag:
	</p>
	<figure>
		<ul class="syntax">
			<li>&lt;svg&gt;${~~code~~}$&lt;/svg&gt;</li>
		</ul>
	</figure>
	<p>
		Two attributes most commonly used with the SVG element is
		<var>width</var> and <var>height</var>:
	</p>
	<figure>
		<ul class="syntax">
			<li>&lt;svg width="${n}$" height="${m}$"&gt;${~~code~~}$&lt;/svg&gt;</li>
		</ul>
	</figure>
	<p>
		Both the <var>width</var> and <var>height</var> attributes are used to
		configure the SVG image's dimensions. In the template above, ${n}$ and ${m}$
		can be a percentage (of either the bounding box or viewport), or a number
		with one of the usual HTML units (em, ex, px, in, cm, mm, pt, pc).
	</p>
	<p>
		The SVG element alone doesn't display anything. It's just a container for
		what we actually we want to display. To display a rectangle, for example, we
		use the <var>&lt;rect&gt;&lt;/rect&gt;</var> element, setting its
		<var>width</var> and <var>height</var> to <var>100</var>.
	</p>
	<figure>
		<svg width="100" height="100">
			<rect width="100" height="100"></rect>
		</svg>
	</figure>
	<p>The code for the SVG above looks like:</p>
	<pre class="language-html"><code>
		&lt;svg width=&quot;100&quot; height=&quot;100&quot;&gt;
		&#x9;&lt;rect width=&quot;100&quot; height=&quot;100&quot;&gt;&lt;/rect&gt;
		&lt;/svg&gt;
	</code></pre>
	<p>
		If we include a <var>fill</var> attribute, we can change the color of the
		rectangle. The color value can be a named color, RGBA value, HSV value, or
		hexadecimal. With the color <var>"salmon"</var>:
	</p>
	<figure>
		<svg width="100" height="100">
			<rect width="100" height="100" fill="salmon"></rect>
		</svg>
	</figure>
	<p>The code rendering the rectangle above is:</p>
	<pre class="language-html"><code>
		&lt;svg width=&quot;100&quot; height=&quot;100&quot;&gt;
		&#x9;&lt;rect width=&quot;100&quot; height=&quot;100&quot; fill=&quot;salmon&quot;&gt;&lt;/rect&gt;
		&lt;/svg&gt;
	</code></pre>
	<p>
		If we want to add an &#8220;outline&#8221; to the rectangle, we can include
		the <var>stroke</var> attribute. This attribute is available for all SVG
		shapes. The code:
	</p>
	<pre class="language-html"><code>
		&lt;svg width=&quot;100&quot; height=&quot;100&quot;&gt;
		&#x9;&lt;rect width=&quot;100&quot; height=&quot;100&quot; fill=&quot;salmon&quot; stroke=&quot;#555&quot;&gt;&lt;/rect&gt;
		&lt;/svg&gt;
	</code></pre>
	<p>renders:</p>
	<figure>
		<svg width="100" height="100">
			<rect width="100" height="100" fill="salmon" stroke="#000"></rect>
		</svg>
	</figure>
	<p>
		The stroke is barely visible. This is because we must include a
		<var>stroke-width</var> attribute:
	</p>
	<pre class="language-html"><code>
		&lt;svg width=&quot;100&quot; height=&quot;100&quot;&gt;
		&#x9;&lt;rect
		&#x9;&#x9;width=&quot;100&quot;
		&#x9;&#x9;height=&quot;100&quot;
		&#x9;&#x9;fill=&quot;salmon&quot;
		&#x9;&#x9;stroke=&quot;#555&quot;
		&#x9;&#x9;stroke-width=&quot;10&quot;
		&#x9;&gt;&lt;/rect&gt;
		&lt;/svg&gt;
	</code></pre>
	<p>Rendering:</p>
	<figure>
		<svg width="100" height="100">
			<rect
				width="100"
				height="100"
				fill="salmon"
				stroke="#555"
				stroke-width="10"
			></rect>
		</svg>
	</figure>
	<section id="svg_coordinate_system">
		<h5>The SVG Coordinate System</h5>
		<p>
			To position shapes in an SVG image, the SVG element uses a particular
			coordinate system. If the SVG element has the following attributes set:
		</p>
		<pre class="language-html"><code>
			&lt;svg width=&quot;100&quot; height=&quot;100&quot;&gt;
			&lt;/svg&gt;
		</code></pre>
		<p>We end up with a coordinate system as follows:</p>
		<figure>
			<img
				src="{% static 'images/svg_coordinate_system.svg' %}"
				alt="SVG coordinate system"
				loading="lazy"
				class="thirty-p"
			/>
		</figure>
		<p>
			The <var>height</var> attribute sets the maximum ${y}$-coordinate, and the
			<var>width</var> attribute sets the maximum ${x}$-coordinate. For both
			${x}$- and ${y}$-coordinates, the minimum value is ${0.}$ By default,
			shapes are placed to the upper-left corner, the coordinate ${(0,0).}$ To
			avoid this default, we must explicitly set the shape's <var>x</var> and
			<var>y</var> attributes:
		</p>
		<pre class="language-html"><code>
			&lt;svg width=&quot;100&quot; height=&quot;100&quot;&gt;
			&#x9;&lt;rect
			&#x9;&#x9;x=&quot;5&quot;
			&#x9;&#x9;y=&quot;5&quot;
			&#x9;&#x9;width=&quot;100&quot;
			&#x9;&#x9;height=&quot;100&quot;
			&#x9;&#x9;fill=&quot;salmon&quot;
			&#x9;&#x9;stroke=&quot;#555&quot;
			&#x9;&#x9;stroke-width=&quot;10&quot;
			&#x9;&gt;&lt;/rect&gt;
			&lt;/svg&gt;
		</code></pre>
		<p>
			An important point to note: With SVG elements, the ${y}$-axis tends
			towards positive as we move down, and negative as we move up.
			Additionally, we can provide positive and negative values for the
			<var>x</var> and <var>y</var> attributes.
		</p>
	</section>

	<section id="circle_elements">
		<p>
			<span class="topic">The Circle Element.</span> With the example above, we
			created a rectangle element. We can also create circles. This is done with
			the following template:
		</p>
		<figure>
			<ul class="syntax">
				<li>&lt;circle r="${n}$"&gt;&lt;/circle&gt;</li>
			</ul>
		</figure>
		<p>
			The one required attribute for the circle element is
			<var>r</var>. As we can likely guess, this attribute sets the circle's
			radius. To illustrate, this code:
		</p>
		<pre class="language-html"><code>
			&lt;svg width=&quot;100&quot; height=&quot;100&quot;&gt;
			&#x9;&lt;circle r=&quot;50&quot;&gt;&lt;/circle&gt;
			&lt;/svg&gt;
		</code></pre>
		<p>renders:</p>
		<figure>
			<div>
				<svg width="100" height="100">
					<circle r="50"></circle>
				</svg>
			</div>
		</figure>
		<p>
			Notice that the circle is cut off. This is because of the coordinate
			system we explained previously. By default, all elements are placed to the
			top left. In this case, the center of the circle is placed at coordinate
			${(0,0).}$ To fix this, we provide <var>x</var> and
			<var>y</var> coordinates for the circle explicitly. Unlike other elements,
			the circle element has specific names for the <var>x</var> and
			<var>y</var> attributes:
		</p>
		<pre class="language-html"><code>
			&lt;svg width=&quot;100&quot; height=&quot;100&quot;&gt;
			&#x9;&lt;circle cx=&quot;50&quot; cy=&quot;50&quot; r=&quot;50&quot;&gt;&lt;/circle&gt;
			&lt;/svg&gt;
		</code></pre>
		<p>
			The coordinates for the circle element are <var>cx</var> (<q
				>center ${x}$</q
			>) and <var>cy</var> (<q>center ${y}$</q>). Rendering the code above:
		</p>
		<figure>
			<div>
				<svg width="100" height="100">
					<circle cx="50" cy="50" r="50"></circle>
				</svg>
			</div>
		</figure>
	</section>
	<section id="line_element">
		<p>
			<span class="topic">Line Element.</span> To visualize lines, we use the
			line element. This element has several required attributes::
		</p>
		<figure>
			<ul class="syntax">
				<li>&lt;line</li>
				<ul>
					<li>&#x9;x1=&quot;${n}$&quot;</li>
					<li>&#x9;y1=&quot;${m}$&quot;</li>
					<li>&#x9;x2=&quot;${p}$&quot;</li>
					<li>&#x9;y2=&quot;${q}$&quot;</li>
					<li>&#x9;stroke=&quot;${a}$&quot;</li>
					<li>&#x9;stroke-width=&quot;${b}$&quot;&gt;</li>
				</ul>
				<li>&lt;/line&gt;</li>
			</ul>
		</figure>
		<p>
			The <var>x1</var> and <var>y1</var> attributes set the coordinates for the
			line's starting point. The <var>x2</var> and <var>y2</var> attributes set
			the line's ending point. We must also include <var>stroke</var> (the
			line's color) and a <var>stroke-width</var> attribute (the line's
			thickness).
		</p>
	</section>
	<section id="svg_layering">
		<p>
			<span class="topic">Layering.</span> Importantly, SVG elements are layered
			first element to the bottom, last element to the top. For example, if we
			create a rectangle element, followed by a circle, then a line, the line
			element would lie atop the circle, and the circle atop the rectangle.
		</p>
	</section>

	<section id="svg_paths">
		<h3>Paths</h3>
		<p>
			The most widely-used SVG element is the
			<i>path</i>. A powerful tool for visualizing complex shapes, it can also
			quickly turn into a rat's nest &mdash; there are many, many commands
			associated with paths. The path element is a shape that can be manipulated
			to form any other shape. It can have straight or curved edges, along with
			an unlimited number of sides. All of the attributes we saw previously are
			available for the path attribute, alongside several others.
		</p>
		<p>
			One attribute we'll often see with the path element is the
			<var>d</var> attribute (<var>d</var> for &#8220;data&#8221;). This
			attribute is assigned a list of data and commands. The most commonly used
			commands are <var><mark>M</mark></var> (<q>move to</q>),
			<var><mark>L</mark></var> (<q>line to</q>), and
			<var><mark>Z</mark></var> (<q>close path</q>). For example, for the data,
			we can include coordinates, and for the command, a line between the
			coordinates. Useful commands:
		</p>
		<ul class="ruled">
			<li>
				<span class="greyText monoText"
					>&lt;path d = <span class="redText">"M100,100"</span>&gt;</span
				>
			</li>
			<ul>
				<li>
					The <var>M</var> command stands for <i>moveto</i>. It will move the
					pen tool.
				</li>
				<li>
					The values <var>100,100</var> are the ${x}$- and ${y}$- coordinate
					respectively. Thus, writing <var>M100,100</var> means
					<q>Move the pen to the point ${(100,100).}$</q> By default, the pen
					starts at the coordinates ${(0,0).}$
				</li>
			</ul>
			<li>
				<span class="greyText monoText"
					>&lt;path d = "M100,100
					<span class="redText">L300,150"</span>&gt;</span
				>
			</li>
			<ul>
				<li>
					The <var>L</var> command stands for <i>lineto</i>. Thus, by writing
					<var>L300,150</var>, we are saying,
					<q>Draw a line to the coordinate ${(300,150).}$</q>
				</li>
			</ul>
			<li>
				<span class="greyText monoText"
					>&lt;path d = "M100,100 L300,150
					<span class="redText">Z</span>"&gt;</span
				>
			</li>
			<ul>
				<li>
					The <var>Z</var> command stands for <i>closepath</i>. By terminating
					our path with the command <var>Z</var>, we are saying,
					<q>Bring the pen back to the point ${(100,100).}w</q>
				</li>
			</ul>
		</ul>
		<p>
			Paths are what allow us to draw shapes like polygons. For example, a
			triangle:
		</p>
		<figure>
			<div>
				<svg width="100" height="100">
					<path d="M 80 80 L 80 5 L 5 80 Z" fill="pink" stroke="red"></path>
				</svg>
			</div>
		</figure>
		<p>The code for rendering the triangle above:</p>
		<pre class="language-html"><code>
			&lt;svg width=&quot;100&quot; height=&quot;100&quot;&gt;
			&#x9;&lt;path d=&quot;M 80 80 L 80 5 L 5 80 Z&quot; fill=&quot;pink&quot; stroke=&quot;red&quot;&gt;&lt;/path&gt;
			&lt;/svg&gt;
		</code></pre>
		<p>
			As we can see, writing SVG code is tedious. Imagine having to construct
			something complex like a tree diagram. Recognizing these hurdles, D3 is
			essentially a library that allows us to write SVG code in a much more
			intuitive, expressive, and efficient way.
		</p>
	</section>
</section>

<section id="d3_documentation">
	<h2>D3 Documentation</h2>
	<p>
		D3 is organized as a collection of packages. All of D3's packages can be
		found <a href="https://github.com/d3" target="_blank">here</a>. D3, as a
		whole, is a large package, weighing in at ${542 \text{ kB}.}$ Even the
		minified version is fairly large &mdash; ${262 \text{ kB}.}$ Earlier
		versions of D3 were much larger. Such large sizes result from all the
		features and tools D3 provides. Many of these features, however, are
		specific to certain use cases and not needed by all users. Accordingly, D3's
		authors decided to break the library down into smaller packages, allowing
		users to use which packages they needed. Because of this modular approach,
		rather than using the entire D3 library (which contains all of the
		packages), we can instead use some parts of D3 but not others.
	</p>
	<p>
		Given D3's modular organization, there isn't a single place for
		documentation. Instead, each of D3's packages have their own documentation.
		These individual pieces of documentation are collected in the
		<a href="https://github.com/d3/d3/blob/main/API.md" target="_blank"
			>D3 API Reference Github page</a
		>.
	</p>
</section>

<section id="selections">
	<h2>Selections</h2>
	<p>
		As we saw from the
		<a href="{% url 'numerc:js_dom' %}"><em>DOM Section</em></a
		>, we have a wide variety of ways to select HTML elements. The most commonly
		used being
		<span class="monoText"><mark>document.querySelector('${obj}$')</mark></span
		>. D3, however, provides its own method for selecting elements:
	</p>
	<figure>
		<ul class="syntax">
			<li>d3.select('${obj}$')</li>
		</ul>
	</figure>
	<p>
		where ${obj}$ is an HTML element. D3's selector works in essentially the
		same way as the DOM selector. We can use HTML tag names and CSS selector
		syntax to narrow or broaden queries. The key difference, however, is that
		the object returned from the D3 selection includes additional methods and
		properties beyond what the DOM provides. Accordingly, when working with D3,
		it's often best to use D3's provided selection methods.
	</p>
	<p>Using D3's selector on a paragraph element, we see the following:</p>
	<pre class="language-javascript"><code>
		d3.select('p');
	</code></pre>
	<pre class="language-bash"><code>
		Selection$1 {_groups: Array(1), _parents: Array(1)}
			_groups: [Array(1)]
			_parents: [html]
			[[Prototype]]: Object
	</code></pre>
	<p>
		The <var>d3.select()</var> method will select the first element matching the
		query. Notice that the return is something called a
		<span class="monoText"><mark>Selection</mark></span
		>. This is an object, with several methods and properties, some of which are
		provided by D3. The <var><mark>_parents</mark></var> element above contains
		a list of the selected element's parents. There are many other selectors
		available through D3, and they can be found
		<a href="https://github.com/d3/d3-selection" target="_blank">here</a>.
	</p>
	<p>
		If we wanted to select all elements matching the query, we can use
		<span class="monoText"><mark>d3.selectAll()</mark></span
		>. Unsurprisingly, this works similarly to the
		<var>.querySelectorAll()</var> method provided by the DOM.
	</p>
</section>

<section id="appending">
	<h2>Appending Elements</h2>
	<p>Like the selection methods, D3 provides methods for appending elements.</p>
	<pre class="language-javascript"><code>
		const body = d3.select('body'); 
		body.append('p');
	</code></pre>
	<p>
		Writing the code above, we append a paragraph element to the body element.
		Unlike JavaScript's native DOM methods, D3's
		<var><mark>.append(${s}$)</mark></var> method automatically
		<i>creates</i> and <i>appends</i> the tag name passed as an argument, ${s.}$
	</p>
	<p>
		The output to the <var>.append()</var> method is a
		<var>selection</var> containing the element we created and appended.
	</p>
	<pre class="language-javascript"><code>
		const body = d3.select('body'); 
		const p = body.append('p');
		console.log(p);
	</code></pre>
	<pre class="language-bash"><code>
		Selection$1 {_groups: Array(1), _parents: Array(1)}
			_groups: Array(1)
				0: [p]
				length: 1
				[[Prototype]]: Array(0)
			_parents: Array(1)
				0: html
				length: 1
				[[Prototype]]: Array(0)
			[[Prototype]]: Object
	</code></pre>
</section>

<section id="transformation_methods">
	<h2>Transformation Methods</h2>
	<p>
		After we've made a selection, we likely want to modify the selected
		object(s) somehow. These modifications, called
		<b>transformations</b>, can be done through either native JavaScript or D3's
		provided methods.
		<a
			href="https://github.com/d3/d3-selection#modifying-elements"
			target="_blank"
			>D3's documentation</a
		>
		details these methods. The keypoints to transformation methods are the
		following:
	</p>
	<ul>
		<li>
			If a method selects or creates an element, then a new selection is
			returned.
		</li>
		<li>
			If a method manipulates a selection, then the same selection is returned.
		</li>
	</ul>
	<div class="mainIdea">
		<p>
			In programming more generally, a
			<b>transformation method</b> or <b>transformation function</b> is a
			function that modifies an object's properties.
		</p>
	</div>
	<p>
		The <var>.append()</var> method we saw earlier is actually a transformation
		method (since calling the method modifies the selected element's children
		&mdash; a property). All transformation methods return a selection: the
		previous selection with the modifications applied.
	</p>
	<section id="html_attributes">
		<h3>Modifying HTML Attributes</h3>
		<p>
			One of the most commonly used transformation methods is
			<span class="monoText"><mark>.attr()</mark></span
			>. The template:
		</p>
		<figure>
			<ul class="syntax">
				<li>${obj}$.attr('${a}$', ${v}$)</li>
			</ul>
			<figcaption>
				Where ${obj}$ is some selection, ${a}$ is the name of the attribute (a
				string value), and ${v}$ is the value for the attribute.
			</figcaption>
		</figure>
		<p>For example:</p>
		<pre class="language-javascript"><code>
			const body = d3.select('body'); 
			const p = body.append('p').attr('class', 'foo');
			console.log(p);
		</code></pre>
		<pre class="language-bash"><code>
			Selection$1 {_groups: Array(1), _parents: Array(1)}
				_groups: Array(1)
					0: [p.foo]
					length: 1
					[[Prototype]]: Array(0)
				_parents: [html]
				[[Prototype]]: Object
		</code></pre>
		<p>
			Notice the use of chaining, a common pattern in D3. Writing the statements
			above, we have appended a paragraph element with the class
			<var>'foo'</var> to the body element. Note that if we do not include the
			argument ${v,}$ we will get back the current value of the attribute ${v.}$
		</p>
		<p>
			A <span class="redText">warning</span>: The <var>.attribute()</var> method
			will override existing attributes. If we want to add multiple classes, we
			use:
		</p>
		<figure>
			<ul class="syntax">
				<li>${obj}$.classed('${c}$', ${b}$)</li>
			</ul>
			<figcaption>
				Where ${c}$ is some class name, ${b}$ is a Boolean value (<span
					class="monoText"
					>true</span
				>
				or <var>false</var>), and ${obj}$ is some selection.
			</figcaption>
		</figure>
		<p>
			With the method above, if the parameter ${b}$ is
			<var>true</var>, then class ${c}$ is added to the class list. If ${b}$ is
			<var>false</var>, then the class ${c}$ is or are removed from the class
			list. To add a second class value, we call the method again:
		</p>
		<pre class="language-javascript"><code>
			const p = d3.select('body')
				.append('p')
				.classed('foo', true)
				.classed('bar', true)
		</code></pre>
		<p>
			In the code above, the class values <var>foo</var> and <var>bar</var> are
			added to the paragraph element's class list.
		</p>

		<section id="inline_styles">
			<h4>Inline Styles</h4>
			<p>
				HTML elements have a <var>style</var> attribute, and assigning values to
				this attribute creates an <i>inline style</i>. D3 provides a
				transformer, <span class="monoText"><mark>.style()</mark></span
				>, which we can use for modifications:
			</p>
			<pre class="language-javascript"><code>
				const body = d3.select('body'); 
				const p = body
					.append('p')
					.text('Hello!')
					.style('color', 'red');
			</code></pre>
			<p>
				The paragraph element's text color should now be red. In general, the
				template for <var>.style()</var> is as follows:
			</p>
			<figure>
				<ul class="syntax">
					<li>${obj}$.style('${s}$', '${v}$')</li>
				</ul>
				<figcaption>
					where ${obj}$ is some selection, ${s}$ is the name of the CSS style (a
					string value), and ${v}$ is the value assigned (also a string value).
				</figcaption>
			</figure>
		</section>
	</section>

	<section id="modifying_text">
		<h3>Modifying Text</h3>
		<p>
			Alongside the attribute transformer, we can also transform text with the
			<var><mark>.text()</mark></var> method. The template:
		</p>
		<figure>
			<ul class="syntax">
				<li>${obj}$.text('${s}$')</li>
			</ul>
			<figcaption>
				Where ${obj}$ is some selection, and ${s}$ is the text to insert.
			</figcaption>
		</figure>
		<p>
			Like the attribute transformer, if the argument ${s}$ is not supplied,
			<var>.text()</var> returns the element's current text. For example:
		</p>
		<pre class="language-javascript"><code>
			const body = d3.select('body'); 
			const p = body.append('p').text('Hello!');
		</code></pre>
		<p>
			Writing the code above, we see that the paragraph element now contains the
			inner-text value <var>'Hello!'</var>.
		</p>
	</section>
</section>

<section id="joining_data">
	<h2>Joining Data</h2>
	<ol class="references">
		<li>
			<a href="https://github.com/d3/d3-selection#joining-data" target="_blank"
				>D3, <strong>Documentation: Joining Data</strong></a
			>
		</li>
		<li>
			<a href="https://www.d3indepth.com/datajoins/" target="_blank"
				>D3 in Depth, <strong>Data Joins</strong></a
			>
		</li>
	</ol>
	<p>
		In programming generally, everything we work with is data &mdash; code,
		images, audio, text, videos, it's all data. With D3, there are only two
		categories of data: (1) <b>text</b> and (2) <b>numbers</b>. D3 visualizes
		data by associating datum with HTML and CSS. This process is called
		<b>joining data</b>.
	</p>
	<p>For example, suppose we had the following array of data:</p>
	<pre class="language-javascript"><code>
		const foo = [1.2, 1.4, 1.8, 1.7];
	</code></pre>
	<p>
		We can <i>join</i> the data by associating each element to, say, a paragraph
		element. The first paragraph is associated with ${1.2,}$ the second
		paragraph with ${1.4,}$ the third with ${1.8,}$ and the fourth with ${1.7.}$
		The simplest way to join data is to use the
		<var><mark>.data()</mark></var> method. Suppose we had the following list in
		our HTML:
	</p>
	<pre class="language-html"><code>
		&lt;body&gt;
		&#x9;&lt;main&gt;
		&#x9;&#x9;&lt;ul&gt;
		&#x9;&#x9;&#x9;&lt;li&gt;a&lt;/li&gt;
		&#x9;&#x9;&#x9;&lt;li&gt;b&lt;/li&gt;
		&#x9;&#x9;&#x9;&lt;li&gt;c&lt;/li&gt;
		&#x9;&#x9;&#x9;&lt;li&gt;d&lt;/li&gt;
		&#x9;&#x9;&#x9;&lt;li&gt;e&lt;/li&gt;
		&#x9;&#x9;&lt;/ul&gt;
		&#x9;&lt;/main&gt;
		&#x9;&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/d3/7.2.1/d3.js&quot;&gt;&lt;/script&gt;
		&#x9;&lt;script src=&quot;./script.js&quot;&gt;&lt;/script&gt;
		&lt;/body&gt;		
	</code></pre>
	<p>In our driver file, we write:</p>
	<pre class="language-javascript"><code>
		const data = [1, 2, 3, 4, 5];
		const listItems = d3.selectAll('li')
			.data(data);
	</code></pre>
	<p>
		Each of the list elements is now associated with the values in the
		<var>data</var> array. The first list element is associated with the value
		<var>1</var>, the second with <var>2</var>, and so on. But what do we mean
		by <q>associated</q>? In terms of implementation, each of the list elements
		has a property called <var>__data__</var>. If we examined the property for
		each of these elements, we see that their assigned values are the respective
		elements in the <var>data</var> array.
	</p>
	<p>If we log to the console <var>listItems</var>:</p>
	<pre class="language-bash"><code>
		Selection$1 {_groups: Array(1), _parents: Array(1), _enter: Array(1), _exit: Array(1)}
			_enter: [Array(5)]
			_exit: [Array(5)]
			_groups: [Array(5)]
			_parents: [html]
			[[Prototype]]: Object
	</code></pre>
	<p>
		Let's focus on the properties <var>_enter</var> and <var>_exit</var>. When
		we join data, we must ensure that data and elements are mapped one-to-one.
		If there are more elements than there are data, we should remove the excess
		elements, and if there are fewer elements then there are data, we should
		insert additional elements.
	</p>

	<section id="enter_selection">
		<h3>Enter Selection</h3>
		<p>
			The <var>_enter</var> property indicates data that have not been joined to
			an element. If we look inside this property, we find an empty array
			&mdash; each datum has been joined to an element. Say we removed the first
			three list items in our HTML code and logged to the console
			<var>listItems</var>:
		</p>
		<pre class="language-javascript"><code>
			const data = [1, 2, 3, 4, 5];
			const listItems = d3.selectAll('li')
				.data(data);
			console.log(listItems);
		</code></pre>
		<pre class="language-bash"><code>
			Selection$1 {_groups: Array(1), _parents: Array(1), _enter: Array(1), _exit: Array(1)}
				_enter: Array(1)
					0: (5) [empty × 3, EnterNode, EnterNode]
					length: 1
					[[Prototype]]: Array(0)
				_exit: [Array(3)]
				_groups: [Array(5)]
				_parents: [html]
				[[Prototype]]: Object
		</code></pre>
		<p>
			Notice the expression <var>empty × 3</var>. This is an indicator that the
			first three elements are empty. The last two items, each called
			<var>EnterNode</var>, are <i>virtual elements</i> created by D3. A virtual
			element is a node stored in memory but does not occupy space in the
			document.
		</p>
		<p>
			Let's join the data. To do so, we use the
			<var><mark>.join(${s}$)</mark></var> method. This method takes a string
			argument, ${s,}$ corresponding to the name of an HTML element. In this
			case, we'll use <var>li</var>:
		</p>
		<pre class="language-javascript"><code>
			const data = [1, 2, 3, 4, 5];
			const listItems = d3.selectAll('li')
				.data(data)
				.join('li');
		</code></pre>
		<p>
			Running the code above, we see three new list items inserted after the two
			existing list items. These new list items, however, are not aligned with
			the existing list items, and they contain no content. Furthermore, if we
			inspected the HTML document, we'd find that the list items are appended
			<em>after</em> the body tag. We see these outputs because the
			<var>.join()</var> method only creates and appends new elements to the
			parent element of the current selection. It does not make any
			modifications to properties like style or inner-text.
		</p>
		<p>
			Writing <var>d3.selectAll('li')</var>, the parent element of the selection
			is the <var>html</var> element. Whenever we call the
			<var>.selectAll()</var> method directly through <var>d3</var>, D3
			automatically sets the parent element property to the
			<var>html</var> element. To ensure a particular parent element value, we
			chain the <var>.selectAll()</var> method to a <var>.select()</var> method:
		</p>
		<pre class="language-javascript"><code>
			const data = [1, 2, 3, 4, 5];
			const listItems = d3.select('ul')
				.selectAll('li')
				.data(data)
				.join('li');
		</code></pre>
		<p>
			Writing the code above, when we first call <var>.select('ul')</var>, the
			parent element is <var>html</var>. The selection itself, however, is
			<var>ul</var>. Thus, when we call <var>.selectAll('li')</var> on that
			selection, the parent element for the <var>.selectAll()</var> selection is
			<var>ul</var>. To confirm:
		</p>
		<pre class="language-javascript"><code>
			const data = [1, 2, 3, 4, 5];
			const list = d3.select('ul')
			const listItems = list.selectAll('li')

			console.log(list);
			console.log(listItems);
		</code></pre>
		<pre class="language-bash"><code>
			Selection$1 {_groups: Array(1), _parents: Array(1)}
				_groups: [Array(1)]
				_parents: [html]
				[[Prototype]]: Object
			Selection$1 {_groups: Array(1), _parents: Array(1)}
				_groups: [NodeList(2)]
				_parents: [ul]
				[[Prototype]]: Object
		</code></pre>
		<p>Writing:</p>
		<pre class="language-javascript"><code>
			const data = [1, 2, 3, 4, 5];
			const listItems = d3.select('ul')
				.selectAll('li')
				.data(data)
				.join('li');
		</code></pre>
		<p>
			we should now see that the list items have been appended to the
			<var>ul</var> element as intended. We can then add text to each of the
			list items using the <var>.text()</var> transformer:
		</p>
		<pre class="language-javascript"><code>
			const data = [1, 2, 3, 4, 5];
			const listItems = d3.select('ul')
				.selectAll('li')
				.data(data)
				.join('li')
				.text('List item')
		</code></pre>
		<p>
			Each of the list items now has the text <var>'List item'</var>. Notice
			that this modifies each list item's property. This is because the
			<var>.join()</var> method merges the groups and enters properties all at
			once.
		</p>
	</section>

	<section id="exit_selection">
		<h3>Exit Selection</h3>
		<p>
			The <var>_enter</var> selection returns an array of elements that should
			be included. It's opposite twin is the <var>_exit</var> selection: An
			array of elements that should be <em>removed</em>. D3 provides this method
			because there are situations where we have more elements than there are
			data. In this situations, we should remove the excess elements. To begin,
			let's say we had the following HTML code:
		</p>
		<pre class="language-html"><code>
			&lt;body&gt;
			&#x9;&lt;main&gt;
			&#x9;&#x9;&lt;ul&gt;
			&#x9;&#x9;&#x9;&lt;li&gt;10&lt;/li&gt;
			&#x9;&#x9;&#x9;&lt;li&gt;20&lt;/li&gt;
			&#x9;&#x9;&#x9;&lt;li&gt;30&lt;/li&gt;
			&#x9;&#x9;&#x9;&lt;li&gt;40&lt;/li&gt;
			&#x9;&#x9;&#x9;&lt;li&gt;50&lt;/li&gt;
			&#x9;&#x9;&#x9;&lt;li&gt;60&lt;/li&gt;
			&#x9;&#x9;&#x9;&lt;li&gt;70&lt;/li&gt;
			&#x9;&#x9;&lt;/ul&gt;
			&#x9;&lt;/main&gt;
			&#x9;&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/d3/7.2.1/d3.js&quot;&gt;&lt;/script&gt;
			&#x9;&lt;script src=&quot;./script.js&quot;&gt;&lt;/script&gt;
			&lt;/body&gt;
		</code></pre>
		<p>There are seven list elements. Writing the code below:</p>
		<pre class="language-javascript"><code>
			const data = [1, 2, 3, 4, 5];
			const listItems = d3.select('ul')
				.selectAll('li')
				.data(data)
			console.log(listItems);
		</code></pre>
		<pre class="language-bash"><code>
			Selection$1 {_groups: Array(1), _parents: Array(1), _enter: Array(1), _exit: Array(1)}
				_enter: [Array(5)]
				_exit: Array(1)
					0: Array(7)
						5: li
						6: li
						length: 7
					[[Prototype]]: Array(0)
				length: 1
				[[Prototype]]: Array(0)
			_groups: [Array(5)]
			_parents: [ul]
			[[Prototype]]: Object
		</code></pre>
		<p>
			We see that there five <var>empty</var> and two <var>li</var> values.
			Given that there are five data values, these two additional
			<var>li</var> values indicate excess elements. To remove these methods, we
			can use the <var>join()</var> method again:
		</p>
		<pre class="language-javascript"><code>
			const data = [1, 2, 3, 4, 5];
			const listItems = d3.select('ul')
				.selectAll('li')
				.data(data)
				.join('li')
		</code></pre>
		<p>We now see that the two excess elements have been removed.</p>
	</section>

	<section id="displaying_data">
		<h3>Displaying Data</h3>
		<p>
			Now that we know how to select elements and join data, we now examine ways
			to display data. We have the following HTML code:
		</p>
		<pre class="language-html"><code>
			&lt;body&gt;
			&#x9;&lt;main&gt;
			&#x9;&#x9;&lt;ul&gt;
			&#x9;&#x9;&#x9;&lt;li&gt;a&lt;/li&gt;
			&#x9;&#x9;&#x9;&lt;li&gt;b&lt;/li&gt;
			&#x9;&#x9;&#x9;&lt;li&gt;c&lt;/li&gt;
			&#x9;&#x9;&#x9;&lt;li&gt;d&lt;/li&gt;
			&#x9;&#x9;&#x9;&lt;li&gt;e&lt;/li&gt;
			&#x9;&#x9;&lt;/ul&gt;
			&#x9;&lt;/main&gt;
			&#x9;&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/d3/7.2.1/d3.js&quot;&gt;&lt;/script&gt;
			&#x9;&lt;script src=&quot;./script.js&quot;&gt;&lt;/script&gt;
			&lt;/body&gt;			
		</code></pre>
		<p>and the following JavaScript code in our driver file:</p>
		<pre class="language-javascript"><code>
			const data = [1, 2, 3, 4, 5];
			const listItems = d3.select('ul')
				.selectAll('li')
				.data(data)
				.join('li')
		</code></pre>
		<p>
			We now want to display the data joined to each of the
			<var>li</var> elements. To do so, we first use a callback function that
			takes the data joined as an argument, call it <var>d</var>:
		</p>
		<pre class="language-js"><code>
			const data = [1, 2, 3, 4, 5];
			const listItems = d3.select('ul')
				.selectAll('li')
				.data(data)
				.join('li')
				.text(function (d) {
					return d;
				})
		</code></pre>
		<p>
			The code above works fine, but we can make it more concise with an arrow
			function:
		</p>
		<pre class="language-javascript"><code>
			const data = [1, 2, 3, 4, 5];
			const listItems = d3.select('ul')
				.selectAll('li')
				.data(data)
				.join('li')
				.text(d => d)
		</code></pre>
		<p>
			Executing the code above, we see that the list items, originally with
			character text, now has inner text corresponding to the array values
			joined.
		</p>
	</section>

	<section id="modifying_the_join_method">
		<h3>Modifying the Join Method</h3>
		<p>
			The <var>.join()</var> method can be modified in a variety of ways. For
			example, we can display an animation for an element entering or exiting
			the selection by passing a function argument to the
			<var>.join()</var> method's <var><mark>enter</mark></var> parameter.
			Suppose we had the following HTML code:
		</p>
		<pre class="language-html"><code>
			&lt;body&gt;
			&#x9;&lt;main&gt;
			&#x9;&#x9;&lt;ul&gt;
			&#x9;&#x9;&#x9;&lt;li&gt;1&lt;/li&gt;
			&#x9;&#x9;&#x9;&lt;li&gt;2&lt;/li&gt;
			&#x9;&#x9;&#x9;&lt;li&gt;3&lt;/li&gt;
			&#x9;&#x9;&lt;/ul&gt;
			&#x9;&lt;/main&gt;
			&#x9;&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/d3/7.2.1/d3.js&quot;&gt;&lt;/script&gt;
			&#x9;&lt;script src=&quot;./script.js&quot;&gt;&lt;/script&gt;
			&lt;/body&gt;			
		</code></pre>
		<p>
			Note that there are two missing <var>li</var> elements. In our driver
			file:
		</p>
		<pre class="language-javascript"><code>
			const data = [1, 2, 3, 4, 5];
			const listItems = d3.select('ul')
				.selectAll('li')
				.data(data)
				.join(
					enter => { 
						return enter.append('li')
							.style('color', 'purple')
					}
				)
				.text(d => d)
		</code></pre>
		<p>
			Notice howe we're passing a function to the <var>.join()</var> method. The
			function takes the property <var>enter</var> as an argument, and executes
			<var>enter.append</var>. It is imperative that we include this line.
			Otherwise, there is no selection resulting from calling
			<var>.join()</var>. After calling <var>.append</var>, we then call
			<var>.style()</var>. Examining our list, we should see the two missing
			list items in purple.
		</p>
		<p>
			We can also have the <var>update</var> and <var>exit</var> selections
			return a function:
		</p>
		<pre class="language-javascript"><code>
			const data = [1, 2, 3, 4, 5];
			const listItems = d3.select('ul')
				.selectAll('li')
				.data(data)
				.join(
					enter => { 
						return enter.append('li')
							.style('color', 'purple')
					},
					update => update.style('color', 'green'),
					exit => exit.remove()
				)
				.text(d => d)
		</code></pre>
		<p>The first three list items are now green.</p>
	</section>
</section>

<section id="json_requests">
	<h2>HTTP Requests</h2>
	<ol class="references">
		<li>
			<a href="https://github.com/d3/d3-fetch" target="_blank"
				>D3, <strong>Documentation: D3 Fetch</strong>.</a
			>
		</li>
	</ol>
	<p>
		Recall that every visualization has two components: (1) the data, and (2)
		the document. Usually, data is found in three places:
	</p>
	<figure>
		<ul>
			<li>Directly inside the JavaScript driver file.</li>
			<li>Inside an external file (JSON, CSV, etc.).</li>
			<li>In some API.</li>
		</ul>
	</figure>
	<p>
		In the previous illustrations, we had data directly available in our driver
		file. Many visualizations, however, require large amounts of data, and we
		may or may not have direct access to such data. In these situations, we may
		need to make an HTTP request for the data.
	</p>
	<p>
		D3 provides several methods for executing HTTP requests. The D3 library for
		HTTP requests is
		<a href="https://github.com/d3/d3-fetch" target="_blank">d3-fetch</a>.
		There, are, however, many other libraries for fetching. In this section,
		we'll use D3's fetch library.
	</p>
	<section id="json_requests">
		<h3>JSON Requests</h3>
		<p>
			First, suppose we had three files: <var>index.html</var>,
			<var>script.js</var>, and <var>data.json</var>. Inside the HTML file:
		</p>
		<figure>
			<pre class="language-html"><code>
				&lt;!DOCTYPE html&gt;
				&lt;html lang=&quot;en&quot;&gt;
				&lt;head&gt;
				&#x9;&lt;meta charset=&quot;UTF-8&quot;&gt;
				&#x9;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
				&#x9;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
				&#x9;&lt;link rel=&quot;stylesheet&quot; href=&quot;./styles.css&quot;&gt;
				&#x9;&lt;title&gt;D3&lt;/title&gt;
				&lt;/head&gt;
				&lt;body&gt;
				&#x9;&lt;main&gt;
				&#x9;&#x9;&lt;ul&gt;
				&#x9;&#x9;&#x9;&lt;li&gt;1&lt;/li&gt;
				&#x9;&#x9;&#x9;&lt;li&gt;2&lt;/li&gt;
				&#x9;&#x9;&#x9;&lt;li&gt;3&lt;/li&gt;
				&#x9;&#x9;&lt;/ul&gt;
				&#x9;&lt;/main&gt;
				&#x9;&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/d3/7.2.1/d3.js&quot;&gt;&lt;/script&gt;
				&#x9;&lt;script src=&quot;./script.js&quot;&gt;&lt;/script&gt;
				&lt;/body&gt;
				&lt;/html&gt;&#x9;&#x9;&#x9;&#x9;
			</code></pre>
			<figcaption>index.html</figcaption>
		</figure>
		<p>The JavaScript file is initially empty. Inside the JSON file:</p>
		<figure>
			<pre class="language-javascript"><code>
				[10,20,30,40,50]
			</code></pre>
			<figcaption>data.json</figcaption>
		</figure>
		<p>
			Given these files, we want to use the data inside the
			<var>data.json</var> file. We can do so by calling the
			<var><mark>d3.json()</mark></var> method in our driver file. The template
			for this method:
		</p>
		<figure>
			<ul class="syntax">
				<li>d3.json(${'s'}$)</li>
			</ul>
			<figcaption>Where ${s}$ is a valid file path.</figcaption>
		</figure>
		<p>
			Because our <var>data.json</var> file is in the same directory as our
			<var>script.js</var> file, we can write:
		</p>
		<pre class="language-javascript"><code>
			d3.json('data.json');
		</code></pre>
		<p>
			The return for this function is a promise. We can chain the
			<var>then()</var> method to handle the response by passing an arrow
			function as an argument:
		</p>
		<pre class="language-javascript"><code>
			d3.json('data.json').then((data) => { 
				console.log(data);
			});
		</code></pre>
		<pre class="language-bash"><code>
			Array(5)
				0: 10
				1: 20
				2: 30
				3: 40
				4: 50
				length: 5
				[[Prototype]]: Array(0)
		</code></pre>
		<p>
			From the console, we see that we now have access to the data inside the
			JSON file. Notice that the data returned is already instantiated as a
			JavaScript array. JSON is a much easier format to work with in JavaScript.
			As we'll see later, other formats like CSV require additional processing
			for JavaScript parsing.
		</p>
		<p>
			As an aside, the same function above can be written with async-await
			syntax:
		</p>
		<pre class="language-javascript"><code>
			async function getData() { 
				const data = await d3.json('data.json');
				console.log(data);
			}
			getData();
		</code></pre>
	</section>

	<section id="csv_requests">
		<h3>CSV Requests</h3>
		<p>
			Another common file format for data transfers is
			<b>CSV (<q>Comma Separated Values</q>)</b>. CSV files are used most
			commonly by spreadsheet programs. We can work with CSV files either
			through a text-editor or through software like <i>Google Sheets</i> or
			<i>Microsoft Excel</i>. Inside our project directory, let's create a file
			called <var>data.csv</var>. Inside the file, we have:
		</p>
		<pre class="language-bash"><code>
			10,20,30,40,50
		</code></pre>
		<p>
			We can then load this data into our driver file with D3's
			<var><mark>.csv()</mark></var> method:
		</p>
		<pre class="language-javascript"><code>
			async function getData() { 
				const data = await d3.csv('data.csv')
				console.log(data);
			}
			getData();
		</code></pre>
		<p>
			Like the <var>.json()</var> method, <var>.csv()</var> takes a single
			argument, the CSV file's file path. Examining the console:
		</p>
		<pre class="language-bash"><code>
			[columns: Array(5)]
				columns: Array(5)
					0: "10"
					1: "20"
					2: "30"
					3: "40"
					4: "50"
					length: 5
					[[Prototype]]: Array(0)
				length: 0
				[[Prototype]]: Array(0)
		</code></pre>
		<p>
			Because JavaScript does not understand CSV files, D3 takes the additional
			step of turning the CSV data into an array. In this case, an array called
			<var>columns</var>. The identifier <var>columns</var> comes from the fact
			that CSV files are closely associated with spreadsheets, which are, at
			their core, tables. For example, suppose we had the following spreadsheet
			in Google Sheets:
		</p>
		<figure>
			<table>
				<thead>
					<th>Name</th>
					<th>Age</th>
				</thead>
				<tbody>
					<tr>
						<td>John</td>
						<td>43</td>
					</tr>
					<tr>
						<td>Sachiko</td>
						<td>87</td>
					</tr>
					<tr>
						<td>Glen</td>
						<td>74</td>
					</tr>
				</tbody>
			</table>
		</figure>
		<p>
			If we download this spreadsheet as a CSV and open it in a text editor, we
			see the following:
		</p>
		<pre class="language-bash"><code>
			Name,Age
			John,43
			Sachiko,87
			Glen,74
		</code></pre>
		<p>
			Studying the CSV file, we can see how the lines and values map to the
			original spreadsheet. When we pass a CSV file to <var>.csv()</var>, D3
			identifies the values on the first line as the column names. Hence the
			output array <var>columns</var>. Passing the name-age CSV file into
			<var>.csv()</var>, we see the following output:
		</p>
		<pre class="language-bash"><code>
			(3) [{…}, {…}, {…}, columns: Array(2)]
				0: {Name: 'John', Age: '43'}
				1: {Name: 'Sachiko', Age: '87'}
				2: {Name: 'Glen', Age: '74'}
				columns: (2) ['Name', 'Age']
				length: 3
				[[Prototype]]: Array(0)
		</code></pre>
		<p>
			We still have the <var>columns</var> array, but notice that we now have
			three objects. For each row in the CSV file other than the first, D3
			creates an object.
		</p>
	</section>
</section>

<section id="drawing_charts">
	<h2>Drawing with Data</h2>
	<p>
		Let's put everything we've learned so far to the test. First, we're working
		with an empty HTML document, placing all of our code in the driver file
		<var>script.js</var>.
	</p>
	<pre class="language-html"><code>
		&lt;!DOCTYPE html&gt;
		&lt;html lang=&quot;en&quot;&gt;
		&lt;head&gt;
		&#x9;&lt;meta charset=&quot;UTF-8&quot;&gt;
		&#x9;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
		&#x9;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
		&#x9;&lt;link rel=&quot;stylesheet&quot; href=&quot;./styles.css&quot;&gt;
		&#x9;&lt;title&gt;D3&lt;/title&gt;
		&lt;/head&gt;
		&lt;body&gt;
		&#x9;&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/d3/7.2.1/d3.js&quot;&gt;&lt;/script&gt;
		&#x9;&lt;script src=&quot;./script.js&quot;&gt;&lt;/script&gt;
		&lt;/body&gt;
		&lt;/html&gt;&#x9;&#x9;
	</code></pre>
	<p>In our <var>script.js</var> file, here's the data we're working with:</p>
	<pre class="language-javascript"><code>
		const dataset = [10, 20, 30, 40, 50];
	</code></pre>
	<p>In our CSS file, we'll write the following:</p>
	<pre class="language-css"><code>
		div.bar {
			display: inline-block;
			width: 20px;
			height: 75px;
			border: thin solid red;
			background-color: salmon;
		}
	</code></pre>
	<p>Going back to our driver file, let's add some div elements:</p>
	<pre class="language-javascript"><code>
		const dataset = [10, 20, 30, 40, 50];
		d3.select('body').selectAll('div')
			.data(dataset)
			.enter()
			.append('div')
			.attr('class', 'bar');
	</code></pre>
	<p>The code above renders:</p>
	<figure class="d3Demo" id="demo1"></figure>
	<p>Let's setting different heights for the div elements:</p>
	<pre class="language-javascript"><code>
		const dataset = [10, 20, 30, 40, 50];
		d3.select('body').selectAll('div')
			.data(dataset)
			.enter()
			.append('div')
			.attr('class', 'bar')
			.style('height', d => `${d}px`);
	</code></pre>
	<p>we get the following:</p>
	<figure class="d3Demo" id="demo2"></figure>
	<p>Let's modify the margin-right property for some spacing:</p>
	<pre class="language-javascript"><code>
		const dataset = [10, 20, 30, 40, 50];
		d3.select('body').selectAll('div')
			.data(dataset)
			.enter()
			.append('div')
			.attr('class', 'bar')
			.style('height', d => `${d}px`);
			.style('margin-right', '2px');
	</code></pre>
	<p>We now see:</p>
	<figure class="d3Demo" id="demo3"></figure>
	<p>
		Notice what happens when we change <var>dataset</var> to some seemingly
		random assortment of values:
	</p>
	<pre class="language-javascript"><code>
		const dataset = [11, 23, 7, 46, 58, 32, 28, 27];
		d3.select('body').selectAll('div')
			.data(dataset)
			.enter()
			.append('div')
			.attr('class', 'bar')
			.style('height', d => `${d}px`);
			.style('margin-right', '2px');
	</code></pre>
	<p>We now see:</p>
	<figure class="d3Demo" id="demo4"></figure>
	<p>
		Using div elements to draw bar charts isn't bad, but we don't usually use D3
		in this way. Instead, D3 is more often used to draw SVGs. Instead of using a
		div element, we'll use SVG. First, we must append the SVG element. On a
		blank driver file, we write the following:
	</p>
	<pre class="language-javascript"><code>
		const dataset = [4, 8, 12, 16, 20];
		const svg = d3.select('body').append('svg');
	</code></pre>
	<p>
		Writing the last statement above, we now have a <i>reference</i> to the SVG
		object. And because we have that reference, we can modify its properties:
	</p>
	<pre class="language-javascript"><code>
		const dataset = [4, 8, 12, 16, 20];
		const svg = d3.select('body').append('svg');
		svg.attr('width', 500)
			.attr('height', 50);
	</code></pre>
	<p>
		The width and height values look like magic numbers at the moment, so let's
		place them in an object. We'll also add a comment for clarity:
	</p>
	<pre class="language-javascript"><code>
		const dataset = [4, 8, 12, 16, 20];
		const dimensions = {
			width: 500,
			height: 50
		};
		const svg = d3.select('body').append('svg');
		// set svg width and height
		svg.attr('width', dimensions.width)
			.attr('height', dimensions.height);
	</code></pre>
	<p>
		At this point, we'll depart from our rectangle bars and draw circles
		instead:
	</p>
	<pre class="language-javascript"><code>
		const dataset = [4, 8, 12, 16, 20];
		const dimensions = {
			width: 500,
			height: 50
		};
		const svg = d3.select('body').append('svg');
		// set svg width and height
		svg.attr('width', dimensions.width)
			.attr('height', dimensions.height);
		// add circles to SVG
		svg.selectAll('circle')
			.data(dataset3)
			.enter()
			.append('circle')
	</code></pre>
	<p>
		We don't see anything yet because the SVG circle elements must have their
		properties initialized. Namely, the <var>cx</var>, <var>cy</var>, and
		<var>r</var> properties:
	</p>
	<pre class="language-javascript"><code>
		const dataset = [4, 8, 12, 16, 20];
		const dimensions = {
			width: 500,
			height: 50
		};
		const svg = d3.select('body').append('svg');
		// set svg width and height
		svg.attr('width', dimensions.width)
			.attr('height', dimensions.height);
		// add circles to SVG
		svg.selectAll('circle')
			.data(dataset3)
			.enter()
			.append('circle')
			.attr('cx', function (d, i) { 
				return (i * 50) + 25;
			})
			.attr('cy', dimensions.height / 2)
			.attr('r', function (d) { 
				return d;
			})
	</code></pre>
	<p>The code above renders:</p>
	<figure class="d3Demo" id="demo5"></figure>
	<p>
		A few things to note from this example. The variable
		<var><mark>d</mark></var> corresponds to each element in the array
		<var>dataset</var>. The name <var>d</var> is purely arbitrary. We could've
		used <var>data</var>, <var>v</var>, <var>e</var>, etc. Second, the variable
		<var><mark>i</mark></var> corresponds to the index of the element
		<var>d</var>. Thus, when we write:
	</p>
	<figure>
		<pre class="language-pseudo"><code>
			.attr('cx', function (d, i) { 
				return (i * 50) + 25;
			})
		</code></pre>
	</figure>
	<p>
		We are setting the center-${x}$-coordinate for each circle at the value
		${50i + 25.}$ Then, when we write:
	</p>
	<figure>
		<pre class="language-pseudo"><code>
			.attr('cy', dimensions.height / 2)
		</code></pre>
	</figure>
	<p>
		we set the center-${y}$-coordinate for each circle at the value ${50/2 =
		25.}$ This results in the following center-coordinates for each of the
		circles:
	</p>
	<div class="func">
		<ul>
			<li><var>dataset[i]</var></li>
			<li><var>(cx, cy)</var></li>
		</ul>
		<ul>
			<li><var>dataset[0]</var></li>
			<li>(25, 25)</li>
		</ul>
		<ul>
			<li><var>dataset[1]</var></li>
			<li>(75, 25)</li>
		</ul>
		<ul>
			<li><var>dataset[2]</var></li>
			<li>(125, 25)</li>
		</ul>
		<ul>
			<li><var>dataset[3]</var></li>
			<li>(175, 25)</li>
		</ul>
		<ul>
			<li><var>dataset[4]</var></li>
			<li>(225, 25)</li>
		</ul>
	</div>
	<p>
		Because each of <var>cy</var> coordinates are the same, the circles are
		aligned. Moreover, by using half of the SVG's height as the
		<var>cy</var> coordinate, the circles are all aligned along the vertical
		center. Let's add some colors:
	</p>
	<pre class="language-javascript"><code>
		const dataset = [4, 8, 12, 16, 20];
		const dimensions = {
			width: 500,
			height: 50
		};
		const svg = d3.select('body').append('svg');
		// set svg width and height
		svg.attr('width', dimensions.width)
			.attr('height', dimensions.height);
		// add circles to SVG
		svg.selectAll('circle')
			.data(dataset3)
			.enter()
			.append('circle')
			.attr('cx', function (d, i) { 
				return (i * 50) + 25;
			})
			.attr('cy', dimensions.height / 2)
			.attr('r', function (d) { 
				return d;
			})
			.attr('fill', 'gold')
			.attr('stroke', 'red')
			.attr('stroke-width', function (d) { 
				return d / 2;
			})
	</code></pre>
	<p>We now have:</p>
	<figure class="d3Demo" id="demo6"></figure>
</section>

<section id="bar_plot">
	<h2>Bart Chart</h2>
	<p>
		Knowing the basics of drawing SVG elements, let's redraw a simple bar chart
		using SVG rectangles rather than divs. In a blank driver file, we have the
		following:
	</p>
	<pre class="language-javascript"><code>
		const svg = body.selectAll('figure#demo7').append('svg')
		const dimensions = [8, 11, 23, 29, 17, 33, 18, 14, 44, 12, 58];
		const dimensions = {
			width: 233,
			height: 130
		};
		const colors = {
			lightGreen: '#DFF2D8',
			darkGreen: '#78866b'
		}
		// set SVG width and height
		svg.attr('width', dimensions.width)
			 .attr('height', dimensions.height);
	</code></pre>
	<p>Let's join the data and add the rectangles:</p>
	<pre class="language-javascript"><code>
		// add rectangles to SVG
		svg.selectAll('rect')
			.data(dataset3)
			.enter()
			.append('rect')
	</code></pre>
	<p>
		Again, these rectangles won't immediately appear, because we have to set
		their properties. In this case, <var><mark>x</mark></var
		>, <var><mark>y</mark></var
		>, <var><mark>width</mark></var
		>, and <var><mark>height</mark></var
		>. We'll also add some stroke and fill colors:
	</p>
	<pre class="language-javascript"><code>
		// add rectangles to SVG
		svg.selectAll('rect')
			.data(dataset3)
			.enter()
			.append('rect')
			.attr('fill', colors.lightGreen)
			.attr('stroke', colors.darkGreen)
			.attr('x', 0)
			.attr('y', 0)
			.attr('width', 20)
			.attr('height', 100)
	</code></pre>
	<p>Running the code above:</p>
	<figure class="d3Demo" id="demo7"></figure>
	<p>
		We're only getting one bar. This is because all of the rectangles have the
		same <var>x</var> and <var>y</var> coordinates &mdash; they're overlapping.
		So, to space them out, we'll need to modify the <var>x</var> property:
	</p>
	<pre class="language-javascript"><code>
		// add rectangles to SVG
		svg.selectAll('rect')
			.data(dataset3)
			.enter()
			.append('rect')
			.attr('fill', colors.lightGreen)
			.attr('stroke', colors.darkGreen)
			.attr('x', function (d, i) { // change x-coordinate
				return i * 21;
			})
			.attr('y', 0)
			.attr('width', 20)
			.attr('height', 100)
	</code></pre>
	<figure class="d3Demo" id="demo8"></figure>
	<p>
		Great, now the're all separate. The rectangles are all the same height
		because we hardcoded <var>100</var>. Let's have the
		<var>height</var> correspond to the data:
	</p>
	<pre class="language-javascript"><code>
		// add rectangles to SVG
		svg.selectAll('rect')
			.data(dataset3)
			.enter()
			.append('rect')
			.attr('fill', colors.lightGreen)
			.attr('stroke', colors.darkGreen)
			.attr('x', function (d, i) { // change x-coordinate
				return i * 21;
			})
			.attr('y', 0)
			.attr('width', 20)
			.attr('height', function(d) {
				return d;
			})
	</code></pre>
	<p>The render looks odd:</p>
	<figure class="d3Demo" id="demo9"></figure>
	<p>
		The bars above are upside down because of the coordinate system used in
		graphics-programming. Recall that the positive ${y}$-axis runs from top to
		bottom, but ${x}$-axis runs as expected. Thus, because each of the
		rectangles have ${y}$-coordinate of ${0,}$ increasing their height extends
		them from top to bottom. To fix this, we have to change the
		${y}$-coordinate:
	</p>
	<pre class="language-javascript"><code>
		// add rectangles to SVG
		svg.selectAll('rect')
			.data(dataset3)
			.enter()
			.append('rect')
			.attr('fill', colors.lightGreen)
			.attr('stroke', colors.darkGreen)
			.attr('x', function (d, i) { // change x-coordinate
				return i * 21;
			})
			.attr('y', function(d) {
				dimensions.height - d;
			})
			.attr('width', 20)
			.attr('height', function(d) {
				return d;
			})
	</code></pre>
	<p>The code above renders:</p>
	<figure class="d3Demo" id="demo10"></figure>
	<p>
		Just to scale things somewhat, we'll use a multiplier for the
		<var>d</var> values for the ${y}$-axis and <var>height</var> properties:
	</p>
	<pre class="language-javascript"><code>
		// add rectangles to SVG
		svg.selectAll('rect')
			.data(dataset3)
			.enter()
			.append('rect')
			.attr('fill', colors.lightGreen)
			.attr('stroke', colors.darkGreen)
			.attr('x', function (d, i) { // change x-coordinate
				return i * 21;
			})
			.attr('y', function(d) {
				dimensions.height - (d*2);
			})
			.attr('width', 20)
			.attr('height', function(d) {
				return d * 4;
			})
	</code></pre>
	<p>Rendering:</p>
	<figure class="d3Demo" id="demo11"></figure>
	<p>
		Instead of using some static color for the fill, we can use a function to
		generate <i>color weights</i>. We'll see this function again when we get to
		heat maps. In our color object, we write:
	</p>
	<pre class="language-javascript"><code>
		const colors = {
			lightGreen: '#DFF2D8',
			darkGreen: '#78866b',
			dynamicGreen: function (d) {
				const red = 255 - Math.round(d * 2);
				const green = 240;
				const blue = 255 - Math.round(d + 80);
				const alpha = 0.5;
				return `rgba(${red}, ${green}, ${blue}, ${alpha})`;
			}
		}
	</code></pre>
	<p>Now we can assign this function to the <var>fill</var> property:</p>
	<pre class="language-javascript"><code>
		// add rectangles to SVG
		svg.selectAll('rect')
			.data(dataset)
			.enter()
			.append('rect')
			.attr('fill', d => colors.dynamicGreen(d))
			.attr('stroke', colors.darkGreen)
			.attr('x', function (d, i) { // change x-coordinate
				return i * 21;
			})
			.attr('y', function(d) {
				dimensions.height - (d*2);
			})
			.attr('width', 20)
			.attr('height', function(d) {
				return d * 4;
			})
	</code></pre>
	<p>Rendering:</p>
	<figure class="d3Demo" id="demo12"></figure>
	<p>
		<span class="topic">Labels.</span> To add labels to our data, we'll use the
		<var>text</var> SVG element. Using the same <var>svg</var> object:
	</p>
	<pre class="language-javascript"><code>
		svg.selectAll('text')
			 .data(dataset)
			 .enter()
			 .append('text')
	</code></pre>
	<p>
		Again, nothing renders because we haven't initialized the
		<var>text</var> object's properties. To do so, we use
		<var><mark>.text()</mark></var> method. This method takes a string as an
		argument, corresponding to the text we want displayed. Furthermore, we'll
		set the <var>text</var> object's <var>x</var> and <var>y</var> coordinates
		to ensure the text objects are centered on our rectangles. We'll also add
		some padding to our bars, just to make the process of centering easier:
	</p>
	<pre class="language-javascript"><code>
		const padding = 3;
		svg.selectAll('text')
			 .data(dimensions)
		   .enter()
		   .append('text')
		   .text(function (d) { 
				 return d;
			 })
			 .attr('width', dimensions.width / dataset.length - demo13padding) // add padding to bars
		   .attr('x', function (d, i) { 
				 return i * (dimensions.width / dimensions.length) + (dimensions.width / dimensions.length - padding) / 2.4; // set x-coordinate
		    })
		   .attr('y', function (d) { 
			   return dimensions.height - (d * 2) + 14; // set y-coordinate
		   })
		   .attr('font-family', 'sans-serif') // set text font family
		   .attr('font-size', '10px') // set text font size
		   .attr('text-anchor', 'middle') // anchor text to middle
			 .attr('fill', colors.darkGreen); // set text color
	</code></pre>
	<p>Rendering:</p>
	<figure class="d3Demo" id="demo13"></figure>
	<p>
		Notice the inordinate amount of magic numbers we're using just to center
		these text elements. And even then, the elements don't look quite right.
		Indeed, this is <em>not</em> how we add labels or center elements in D3. We
		present this approach here purely to demonstrate how tedious this process
		is. In a later section, we'll see that D3 takes care of all of this through
		<i>scale methods</i>.
	</p>
</section>

<section id="scatter_plot">
	<h2>Scatter Plots</h2>
	<p>
		Having examined bar charts, let's consider another basic visualization
		&mdash; the scatter plot. Once again, we'll be working a blank
		<var>index.html</var> file. In our driver file, we have the following data
		set:
	</p>
	<pre class="language-javascript"><code>
		const scatterData = [
			[5, 20],
			[480, 90],
			[250, 50],
			[100, 33],
			[330, 95],
			[410, 12],
			[475, 44],
			[25, 67],
			[85, 21],
			[220, 88],
			[600, 150]
		];
	</code></pre>
	<p>
		Notice that this is an array of arrays. Or, more abstractly, a sequence of
		ordered pairs. In fact, we'll interpret each element of
		<var>scatterData</var> as representing the ordered pair ${(x, y),}$ a
		coordinate. Thus, the <var>scatterData</var> element
		<var>scatterData[${i}$][0]</var> corresponds to the ${x}$-coordinate, and
		the element <var>scatterData[${i}$][1]</var> corresponds to the
		${y}$-coordinate, where ${0 \leq i &lt; \texttt{scatterData.length}.}$
	</p>
	<p>
		To begin, we'll append an SVG element, using a <var>dimensions</var> object
		for constants:
	</p>
	<pre class="language-javascript"><code>
		// scatter data
		const scatterData = [
			[5, 20],
			[480, 90],
			[250, 50],
			[100, 33],
			[330, 95],
			[410, 12],
			[475, 44],
			[25, 67],
			[85, 21],
			[220, 88],
			[600, 150]
		];

		// dimensions for svg
		const scatterDimensions = {
			width  : 500,
			height : 100,
			padding: 1
		};

		// colors for circles
		const scatterColors = {
			darkBlue : '#5da9e9',
			lightBlue: '#e5f4e3'
		};

		// add an svg element
		const svg = d3.select('body').append('svg');
	</code></pre>
	<p>
		Then, we begin adding creating the circles, initializing its properties:
	</p>
	<pre class="language-javascript"><code>
		// initialize and insert svg element
		const svg = d3.select('body').append('svg');

		// set svg dimensions
		svg.attr('width', scatterDimensions.width)
			 .attr('height', scatterDimensions.height);

		svg.selectAll('circle')
			 .data(scatterData)
			 .enter()
			 .append('circle') 		                  // add circles to svg
			 .attr('cx', function (d) { 
					return d[0];                        // x-coordinate is scatterData[i][0]
			 })
			 .attr('cy', function (d) {
					return d[1];                        // y-coordinate is scatterData[i][1]
			 })
			.attr('r', 5);
			.attr('fill', scatterColors.lightBlue)  // add fill color
			.attr('stroke', scatterColors.darkBlue) // add stroke color
	</code></pre>
	<p>Running the code above, we get the following rendering:</p>
	<figure class="d3Demo" id="demo14"></figure>
	<p>
		Suppose we want the circles' sizes to correspond to their ${y}$ values. This
		creates the effect of larger circles corresponding to larger values, and
		smaller circles corresponding to smaller values. To do so, we have to
		manipulate each circle's <i>area</i>, not its <i>radius</i>. Why? Just look
		at the data values. If each of those values were the radius's length in
		pixels, the circles would be massive.
	</p>
	<p>
		Now, the circle element doesn't have an area property, but it does have the
		radius property <var>r</var>. Hence, to manipulate the area, we'll represent
		it in terms of ${r.}$ From geometry, we know that the area of a circle,
		denoted ${A_c,}$ is given by the formula:
	</p>
	<figure>
		<div>
			<p>${\large A_c = \pi r^2}$</p>
		</div>
	</figure>
	<p>with some basic algebra:</p>
	<figure>
		$$ \begin{aligned} A_c &= \pi r^2 \\[1em] \dfrac{A_c}{\pi} &= r^2 \\[1em]
		\sqrt{\dfrac{A_c}{\pi}} &= r \\[1em] r &= \sqrt{\dfrac{A_c}{\pi}} \\[1em]
		\end{aligned} $$
	</figure>
	<p>
		So that's how we get the radius. In JavaScript, we could implement the
		formula above as a function:
	</p>
	<pre class="language-javascript"><code>
		const radiusInTermsOfArea = area => Math.sqrt(area / Math.PI);
	</code></pre>
	<p>
		We want circles with greater ${y}$-values to be larger and circles with
		smaller ${y}$-values to be smaller. Thus, the ${y}$-values map to the
		circle's areas. In execution, the function would operate:
	</p>
	<figure>
		<div>
			<pre class="language-pseudo"><code>
				.attr('r', d => radiusInTermsOfArea(d))
				.attr('r', d => d => Math.sqrt(d / Math.PI))
				.attr('r', Math.sqrt(scatterData[i][0]))
			</code></pre>
		</div>
	</figure>
	<p>
		This isn't exactly what we want however. First, we want the circles at the
		top to be larger than the circles at the bottom. After all, the circles at
		the top are the circles with the largest values. Second, we don't actually
		want to divide ${\pi.}$ Second, we're not working with areas. These are data
		values. If we divided by ${\pi,}$ we'd see that the circles all look fairly
		similar &mdash; we're essentially just dividing by ${3}$ and taking the
		square root, shrinking all of the circles <i>uniformly</i>. Thus, what we
		really want is to subtract the ${y}$-coordinate from the SVG's height, and
		take the square root. This establishes different radii for each circle,
		while keeping things in proportion:<sup></sup>
	</p>
	<div class="note">
		<p>
			Do not worry if the derivation isn't entirely clear. It's employed here
			purely for demonstration purposes. Once we get to scales, all of this will
			click and become much easier.
		</p>
	</div>
	<pre class="language-javascript"><code>
		// initialize and insert svg element
		const svg = d3.select('body').append('svg');

		// set svg dimensions
		svg.attr('width', scatterDimensions.width)
			 .attr('height', scatterDimensions.height);

		svg.selectAll('circle')
			 .data(scatterData)
			 .enter()
			 .append('circle') 		                  // add circles to svg
			 .attr('cx', function (d) { 
					return d[0];                        // x-coordinate is scatterData[i][0]
			 })
			 .attr('cy', function (d) {
					return d[1];                        // y-coordinate is scatterData[i][1]
			 })
			.attr('r', function(d) {
				return Math.sqrt(
					scatterDimensions.height - d[1]     // Change radii
				); 
			});
			.attr('fill', scatterColors.lightBlue)  // add fill color
			.attr('stroke', scatterColors.darkBlue) // add stroke color
	</code></pre>
	<p>The code above renders:</p>
	<figure class="d3Demo" id="demo15"></figure>
	<p>
		Great. Now we have circles with larger values at the top, and circles with
		smaller values at the bottom. If it's still not clear why we used the
		formula above, do not worry. This is <em>not</em> how we establish
		proportions in D3. All of this is much easier when we get to scale methods.
	</p>
	<p>Let's add some labels to our data:</p>
	<pre class="language-javascript"><code>
		svg.selectAll('text')
			 .data(scatterData) 
			 .enter()
			 .append('text')                       // add text element
			 .text(d => `${d[0]},${d[1]}`)         // set the text to display
			 .attr('x', d => d[0])                 // use d[i][0] for x-coordinate
			 .attr('y', d => d[1])                 // use d[i][1] for y-coordinate
			 .attr('font-family', 'sans-serif')    // set font-family
			 .attr('font-size', '11px')            // set font-size
			 .attr('fill', scatterColors.darkBlue) // set fill color
	</code></pre>
	<p>Running the code above, we have the following labels:</p>
	<figure class="d3Demo" id="demo16"></figure>
	<p>
		That's all we're going to do with this plot. It's not bad, but it doesn't
		look good. The difficulties with getting this visualization to look great
		require use to now consider <i>scales.</i>
	</p>
</section>

<section id="scales">
	<h2>Scales</h2>
	<p>
		To understand how scales work, we must revisit a few concepts in
		mathematics. First, from coordinate geometry, we're familiar with the
		Cartesian plane:
	</p>
	<figure>
		<img
			src="{% static 'images/scale1.svg' %}"
			alt="Cartesian plane"
			loading="lazy"
			width="300px"
			height="300px"
		/>
	</figure>
	<p>
		The graph has two <b>axes</b>, the ${y}$-axis, or <i>vertical axis</i>, and
		the ${x}$-axis, or <i>horizontal axis</i>. Each axis has a property called
		its <b>range</b> &mdash; the lower and upper limits of the values on the
		axis. In the graph above, the range for the ${x}$-axis is ${[-3, 3],}$ and
		the range for the ${y}$-axis is also ${[-3, 3].}$
	</p>
	<p>
		Now, the <b>scale</b> of an axis is how much each <q>square</q> in the grid
		above represents. For example, with the graph above, each square has a width
		and height of ${1.}$ The beauty of the coordinate system, however, is that
		we aren't limited to ${1.}$ We could have used a <i>scale</i> such that each
		square had a width of ${0.5}$ and a height of ${0.5.}$ Or we could have used
		a scale where each square had a width of ${\sqrt{2}}$ and a height of
		${\pi.}$ It's entirely up to us.
	</p>
	<p>
		Now, why would we use different scales? To address two problems. First, data
		values aren't always nice sequences with set differences. If our first set
		of data values consisted of ${(0,0), (1,1), (2,2),}$ we could get away with
		using the simple plane above. But if we were suddenly thrown ${(100, 100),}$
		that point wouldn't even fit &mdash; it's outside the range of either axis.
	</p>
	<p>
		Second, we might have data whose ${y}$ or ${x}$ values are substantially
		different from one another in size. For example, if we had data values like
		${(0, 1000),}$ ${(1, 20~000)}$ and ${(2, 300~000),}$ we would want to scale
		the ${y}$-axis's scale appropriately. Otherwise, the graph between these
		points would essentially be a vertical line.
	</p>
	<p>
		D3 allows us to accomplish scaling through its <b>scales</b>. Simply put, a
		scale is just a function that maps values from an input domain to values in
		an output range. For example, suppose we had the following data about store
		visits:
	</p>
	<pre class="language-javascript"><code>
		const storeVisits = [10, 20, 30, 40, 50];
	</code></pre>
	<p>
		If we attempted to visualize these values with a bar chart, we would use the
		rectangle element's height property. With the values above, not a big deal.
		But what if the store suddenly gets ${10~000}$ visits? Well, we'd have a
		rectangle element ${10~000}$ pixels tall. To get around this problem, we
		must <i>scale</i> our model.
	</p>
	<p>The first step to scaling is answering the following questions:</p>
	<figure>
		<ol class="numd">
			<li>What is the data's <i>domain</i>?</li>
			<li>What is the data's <i>codomain</i>?</li>
		</ol>
	</figure>
	<p>
		The data's <b>domain</b> is the range of possible <em>input</em> data
		values. The data's <b>codomain</b> is the range of possible
		<em>output</em> data values. Of the two, the data's codomain is entirely at
		our discretion. The data's domain, however, is dictated by the data we're
		given.
	</p>
	<p>
		For example, with the store visits, the domain is ${[0, 50],}$ or ${[10,
		50].}$ Let's say its ${[10,50].}$ The codomain is up to us. If we say that
		the codomain is ${[10,100],}$ then ${10}$ maps to ${10,}$ and ${50}$ maps to
		${100.}$ In terms of visualization, the shortest bar would be ${10,}$ and
		the tallest would be ${100.}$ The data value ${30}$ is right at the center,
		so it would map to ${50.}$
	</p>
	<p>Now that we have the foundations down, let's consider D3's scales.</p>

	<section id="linear_scale">
		<h3>Linear Scale</h3>
		<p>
			In D3, the <var><mark>d3.scaleLinear()</mark></var> function constructs a
			new continuous scale that performs the mapping example we saw earlier.
			Effectively, the linear scale models a function of the form ${y = mx +
			b,}$ where ${y}$ is a codomain value and ${x}$ is a domain value. The
			template:
		</p>
		<ul class="syntax">
			<li>
				d3.scaleLinear().domain([${x_\ell}$, ${x_h}$]).range([${y_\ell}$,
				${y_h}$])
			</li>
		</ul>
		<p>
			In the template above, the argument
			<var>[${x_\ell}$, ${x_h}$]</var> corresponds to the domain range, and
			<var>[${y_\ell}$, ${y_h}$]</var> corresponds to the codomain range. For
			example, consider the output of running the code:
		</p>
		<pre class="language-javascript"><code>
			const linearScale = d3.scaleLinear()
														.domain([10,50])
														.range([5, 25]);

			console.log(linearScale(10));
			console.log(linearScale(20));
			console.log(linearScale(30));
			console.log(linearScale(40));
			console.log(linearScale(50));
		</code></pre>
		<pre class="language-bash"><code>
			5
			10
			15
			20
			25
		</code></pre>
		<p>
			Let's use a linear scale for our previous scatter plot example. First, the
			scales:
		</p>
		<pre class="language-javascript"><code>
			const xScale = d3.scaleLinear()
				.domain([0, d3.max(scatterData, d => d[0])])
				.range([0, scatterDimensions.width]);

			const yScale = d3.scaleLinear()
				.domain([0, d3.max(scatterData, d => d[1])])
				.range([0, scatterDimensions.height]);
		</code></pre>
		<p>
			We're using a new function here, <var><mark>d3.max()</mark></var
			>. The <var>.max()</var> function has the following form:
		</p>
		<ul class="syntax">
			<li>d3.max(${A}$, ${f_a}$)</li>
		</ul>
		<p>
			The argument ${A}$ is an array of values. The function
			<var>.max()</var> will iterate through the array in seach of the largest
			value. For a one-dimensional array, we need only pass the array as an
			argument. The second parameter, ${f_a,}$ is optional. This parameter is an
			<b>accessor function</b>. In the case of multidimensional arrays, we
			provide the accessor function so that D3 know which values it's supposed
			to find the maximum for.
		</p>
		<p>
			D3 also provides a <var><mark>d3.min()</mark></var> function, which
			operates similarly:
		</p>
		<ul class="syntax">
			<li>d3.min(${A}$, ${f_a}$)</li>
		</ul>
		<p>
			With scales initialized, we can now apply the scales. Before we do so,
			let's initialize a variable for some <var>padding</var>. We'll need it
			later.
		</p>
		<pre class="language-javascript"><code>
			const circlePadding = 20;
		</code></pre>
		<p>
			Next, instead of using the formula we used earliter, we'll let D3 take
			care of it for us. To do so, we'll also write a scale for our radius:
		</p>
		<pre class="language-javascript"><code>
			const rScale = d3.scaleLinear()
				.domain([0, d3.max(scatterData, d => d[1])])
				.range([2, 5]);
		</code></pre>
		<p>Putting all of it together:</p>
		<pre class="language-javascript"><code>
			const svg = body.append("svg");

			const scatterDimensions = {
				width: 400, // easily change proportions by changing these values
				height: 300,
			};

			const circlePadding = 20; // padding for circles

			const xScale = d3.scaleLinear()
				.domain([0, d3.max(scatterData, d => d[0])]) 
				.range([circlePadding, scatterDimensions.width - circlePadding * 2]);

			const yScale = d3.scaleLinear()
				.domain([0, d3.max(scatterData, d => d[1])])
				.range([scatterDimensions17.height - circlePadding, circlePadding]);

			const rScale = d3.scaleLinear()
				.domain([0, d3.max(scatterData, d => d[1])])
				.range([2, 5]); // scale for circles

			svg
				.attr("width", scatterDimensions17.width)
				.attr("height", scatterDimensions17.height);

			svg
				.selectAll("circle")
				.data(scatterData)
				.enter()
				.append("circle")
				.attr("cx", d => xScale(d[0])) // scale the circle's x-coordinate
				.attr("cy", d => yScale(d[1])) // scale the circle's y-coordinate
				.attr("r", d => rScale(d[1]))
				.attr("fill", scatterColors.lightBlue)
				.attr("stroke", scatterColors.darkBlue);

			svg
				.selectAll("text")
				.data(scatterData)
				.enter()
				.append("text")
				.text((d) => `${d[0]},${d[1]}`)
				.attr("x", (d) => xScale(d[0])) // scale the text's x-coordinate
				.attr("y", (d) => yScale(d[1])) // scale the text's y-coordinate
				.attr("font-family", "sans-serif")
				.attr("font-size", "11px")
				.attr("fill", scatterColors.darkBlue)
		</code></pre>
		<p>Running the code above, we have the following rendering:</p>
		<figure class="d3Demo" id="demo17"></figure>
		<p>
			Not bad, but the circles are pretty small. Recall that our earlier
			derivation for the radius involved a square root. D3 provides a scale
			<var><mark>scaleSqrt()</mark></var
			>, which corresponds to a square root scale. This is an ideal scale for
			our circles. We rename our scale to <var>aScale</var> (since the scale
			corresponds to area), and adjust the <var>aScale</var>'s range:
		</p>
		<pre class="language-javascript"><code>
			const aScale = d3.scaleSqrt()
				.domain([0, d3.max(scatterData, d => d[1])])
				.range([2, 10]); // adjust range
		</code></pre>
		<p>The code above renders:</p>
		<figure class="d3Demo" id="demo18"></figure>
	</section>
</section>

<section id="axes">
	<h2>Axes</h2>
	<p>
		Our scatter plot looks nice, but it would be better if we had some axes. In
		D3, axes are functions, much like scales. However, unlike scales, they do
		not return values. Instead, they return the objects that visualize the axis
		&mdash; the line, lable, ticks, arrows, etc. In the code illustrations
		below, we'll use the same scatter plot employed earlier.
	</p>
	<p>In D3, there are four axis constructors:</p>
	<figure>
		<ol class="numd">
			<li>
				<var><mark>d3.axisTop()</mark></var>
			</li>
			<p>Instantiates a top horizontal axis.</p>
			<li>
				<var><mark>d3.axisBottom()</mark></var>
			</li>
			<p>Instantiates a bottom horizontal axis.</p>
			<li>
				<var><mark>d3.axisLeft()</mark></var>
			</li>
			<p>Instantiates a vertical left axis.</p>
			<li>
				<var><mark>d3.axisRight()</mark></var>
			</li>
			<p>Instantiates a vertical right axis.</p>
		</ol>
	</figure>
	<p>
		Consider the <var>d3.axisBottom()</var> constructor. For the axes
		constructors to work, we must provide them a scale. Fortunately, we have our
		<var>xScale</var> from earlier:
	</p>
	<pre class="language-javascript"><code>
		const xAxis = d3.axisBottom().scale(xScale);
	</code></pre>
	<p>
		We now have an axis. To display it, we must call the
		<var>xAxis</var> function. At the very bottom of our diver file, we write:
	</p>
	<pre class="language-javascript"><code>
		svg.append('g')
			 .attr('class', 'axis')
			 .attr('color', scatterColors.darkBlue)
			 .call(xAxisDemo19)
	</code></pre>
	<p>
		This short snippet is placed at the end of the driver file, after
		<em>all other</em> SVG elements have rendered. What this effectively does is
		take all of the SVG elements we've had so far, an object in the DOM, and
		append a group element to its end. That results in a new object, upon which
		we call the <var>xAxis</var> function. The group element is merely there to
		<i>group</i> all of the vectors the <var>xAxis</var> function is about to
		draw.<sup></sup>
	</p>
	<div class="note">
		<p>Writing:</p>
		<pre class="language-pseudo"><code>
			svg.append('g')
				 .call(xAxis);
		</code></pre>
		<p>is functionally the same as writing:</p>
		<pre class="language-pseudo"><code>
			svg.append('g')
				 .call(d3.axisBottom())
				 .scale(xScale);
		</code></pre>
	</div>
	<p>
		Note that we also added a few attributes. First, a
		<var>class</var> attribute, with the value <var>'axis'</var>. It's best
		practice to add classes to newly generated elements whenever possible. This
		allows for both quick debugging and styling as projects get more complex.
		Additionally, we added a simple <var>color</var> attribute for styling.
	</p>
	<p>Running our code thus far:</p>
	<figure class="d3Demo" id="demo19"></figure>
	<p>
		Great. We have a scale. Let's position it to the bottom. To do so, we use
		the <var>transform</var> attribute for SVGs. This allows us to shift an
		entire group element. In this case, we have group element consisting of the
		${x}$-axis. By setting the <var>transform</var> attribute on this element,
		we effectively shift the entire group:
	</p>
	<pre class="language-javascript"><code>
		svg.append('g')
			 .attr('class', 'axis')
			 .attr('color', scatterColors.darkBlue)
			 .attr(
					'transform',
					`translate(0,${scatterDimensions.height - circlePadding})`
			 )
			 .call(xAxisDemo19)
	</code></pre>
	<p>Running the code above, we have:</p>
	<figure class="d3Demo" id="demo20"></figure>
	<p>
		This is pretty good. To show just how responsive the scales are, let's use a
		data set of random values:
	</p>
	<pre class="language-javascript"><code>
		const scatterData = [];
		const dataPoints = 50;
		const xRange = Math.random() * 1000;
		const yRange = Math.random() * 1000;
		for (let i = 0; i < dataPoints; i++) { 
			const newXValue = Math.floor(Math.random() * xRange);
			const newYValue = Math.floor(Math.random() * yRange);
			scatterData.push([newXValue, newYValue]);
		}
	</code></pre>
	<p>
		The code above generates random data values, and pushes them to the
		<var>scatterData</var> array. Refreshing the page will generate a new plot
		each time.
	</p>
	<p>Finally, let's add a ${y}$-axis:</p>
	<pre class="language-javascript"><code>
		const yAxis = d3.axisLeft()
			.scale(yScale)
			.ticks(5);
			// add left y-axis
		svg.append('g')
			.attr('class', 'axis')
			.attr('color', scatterColors.darkBlue)
			.attr('transform', `translate(${circlePadding}, 0)`)
			.call(yAxis)
	</code></pre>
	<p>Just for clarity, we'll remove the text elements. The result:</p>
	<figure class="d3Demo" id="demo21"></figure>
</section>

<section id="updates_transitions_and_motions">
	<h2>Dynamic Datasets</h2>
	<p>
		In our previous examples, we've primarily used
		<i>static datasets</i> &mdash; data sets that do not change. Many data sets,
		however, are <i>dynamic datasets</i> &mdash; data sets that change in
		response to some dynamic variable (e.g., time, user input, size, and so on).
		In D3, we handle dynamic data sets with <b>updates</b> and
		<b>transitions</b>.
	</p>
	<p>To illustrate, we'll create a bar chart. The code:</p>
	<pre class="language-javascript"><code>
		// Add a new SVG
		const barGraph      = body.append("svg");

		// Sizes for the SVG/bar graph
		const barGraphSizes = {
			width : 400,
			height: 250,
		};

		// Colors for bar graph
		const barGraphColors = {
			textColor : "firebrick",
			darkRed   : "salmon",
			dynamicRed: (d) =>
				`rgba(255, ${Math.floor(240 - d)}, ${Math.floor(190 + d)}, 0.7)`,
		};

		// The dataset
		const dataset = [
			5, 10, 13, 19, 
			21, 25, 22, 18, 
			15, 13, 11, 12, 
			15, 20, 18, 17, 
			16, 18, 23, 25,
		];

		// The scales
		const xScale = d3
			.scaleBand()
			.domain(d3.range(dataset.length))
			.rangeRound([0, barGraphSizes.width])
			.paddingInner(0.2);
		const yScale = d3
			.scaleLinear()
			.domain([0, d3.max(dataset)])
			.range([0, barGraphSizes.height]);

		// Set SVG width and height
		const svg = barGraph
			.attr("width", barGraphSizes.width)
			.attr("height", barGraphSizes.height);

		// Create bars
		svg
			.selectAll("rect")
			.data(dataset)
			.enter()
			.append("rect")
			.attr("x", (d, i) => xScale(i))
			.attr("y", (d) => barGraphSizes.height - yScale(d))
			.attr("width", xScale.bandwidth())
			.attr("height", (d) => yScale(d))
			.attr("fill", (d) => barGraphColors.dynamicRed(d))
			.attr("stroke", barGraphColors.darkRed);

		// Create labels
		svg
			.selectAll("text")
			.data(dataset)
			.enter()
			.append("text")
			.text((d) => d)
			.attr("text-anchor", "middle")
			.attr("x", (d, i) => xScale(i) + xScale.bandwidth() / 2)
			.attr("y", (d) => barGraphSizes.height - yScale(d) + 14)
			.attr("font-family", "sans-serif")
			.attr("font-size", "10px")
			.attr("fill", barGraphColors.textColor);
	</code></pre>
	<p>
		Not much is new with the code above, but there are a few new methods we're
		using. First, notice that with the <var>xScale</var>, we're using the
		<var><mark>d3.scaleBand()</mark></var> method. This method constructs a
		scale, just as we saw with the <var>linearScale()</var>. The difference,
		however, is that it's an <b>ordinal scale</b>.
	</p>
	<p>
		Ordinal scales are used with ordinal data &mdash; data that can be
		classified into discrete categories with an inherent order. For example,
		letter grades (A+, A, A-, B+, B, B-, etc.), preferences (strongly agree,
		agree, disagree, strongly disagree, etc.), or assigned sex (male, female,
		N/A). Thus, if we call <var>d3.scaleBand()</var> on the domain
		<var>[1, 2, 3]</var>, D3 sets up a scale where each axis unit is
		evenly-spaced to accomodate for 3 data points.
	</p>
	<p>
		But wait, our data set's values <em>isn't</em> inherently ordered. They're
		all over the place. This is where this line comes in:
	</p>
	<pre class="language-javascript"><code>
		.domain(d3.range(dataset.length))
	</code></pre>
	<p>
		The <var><mark>d3.range()</mark></var> method takes an integer number (in
		this case, <var>dataset.length</var>), and produces an array containing the
		elements <var>0</var>, <var>1</var>, <var>2</var>, <var>3</var>, all the way
		up to <var>dataset.length</var>. Thus, when we call
		<var>d3.scaleBand()</var> on our specified domain, D3 knows to create a
		scale where each axis unit is evenly spaced (here, for the
		<var>xScale</var>).
	</p>
	<p>After calling <var>domain()</var>, we then called:</p>
	<pre class="language-javascript"><code>
		.rangeRound([0, barGraphSizes.width])
	</code></pre>
	<p>
		This line ensures that <var>.scaleBand()</var>'s outputs are rounded,
		preventing any strange pixel values like <var>11.89</var>. Finally, we
		called the method <var><mark>.paddingInner()</mark></var> on the scale. This
		creates some padding between each unit along the <var>xScale</var>.
	</p>
	<p>With all of that, we have the following render:</p>
	<figure class="d3Demo" id="demo22"></figure>
</section>

<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.2.1/d3.js"></script>
<script src="../../../static/numerc/d3demo.js"></script>
{% endblock %}
