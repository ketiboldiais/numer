{% extends '../layout.html' %} {% load static %} {% block description %}
<meta name="description" content="JavaScript at the lower level" />
{% endblock %} {% block title %}
<title>Lower Level JavaScript</title>
{% endblock %} {% block content %}
<h1>JavaScript Beneath the Hood</h1>

<section id="intro">
	<p>
		<span class="drop">W</span> e've now covered the basic syntax for
		JavaScript. We now proceed to a more rigorous investigation of JavaScript's
		lower level details. This discussion will lead to a more nuanced
		understanding of scope, as well as why JavaScript behaves the way it does.
	</p>
</section>

<section id="syntax_parser_revisted">
	<p>
		<span class="topic">Syntax Parser.</span>
		Recall that when we write JavaScript code, we aren't directly interacting
		with the computer. The computer itself doesn't understand what JavaScript
		statements are&mdash;it only understands 1s and 0s. Writing entirely in 1s
		and 0s, however, is difficult for hardware engineers, so an
		<span class="term">assembly language</span> is used; abstractions of those
		1s and 0s. Assembly, however, is difficult to write for non-hardware
		engineers, and it is specifically suited to programming computer hardware.
		It is not meant to dynamically display Twitch streams, macros in Word, or
		stock tickers on Bloomberg. To accomplish this task, a computer language is
		needed. They are abstractions of that assembly language.
	</p>
	<p>
		That programming language, however, can only work if it is written
		<span class="italicsText">correctly</span>, and performs operations that are
		<span class="italicsText">permitted</span>. A
		<span class="term">syntax parser</span>, such as a
		<span class="term">compiler</span> or
		<span class="term">interpreter</span> is a program that performs this task.
		It reads our source code, determines what the code does, and decides whether
		the code's "grammar" is valid. If the source code's syntax is valid, then it
		is translated into <span class="italicsText">assembly</span>, which is then
		translated into 1s and 0s.
	</p>
	<p>
		Note what this means. A programming language is at the mercy of the syntax
		parser, and the syntax parser is a program written by another programmer.
		That syntax parser can decide to do additional things outside of simply
		determining the code's syntax is valid. It can also decide what syntax is
		considered valid. Particularly with JavaScript, this fact can lead to a
		variety of unexpected consequences.
	</p>
</section>

<section id="lexical_environments">
	<p>
		<span class="topic">Lexical Environment.</span> The world "lexical" means
		"having to do with words or grammar." Some programming languages, like
		JavaScript, have <span class="term">lexical environments</span>. If a
		programming language has a
		<span class="italicsText">lexical environment</span>, then the lines where
		we write code <span class="underlineText">matters</span>. In other words,
		you cannot just write anything, anywhere. For example:
	</p>
	<pre class="language-javascript"><code>
		function hello() {
			greeting = "Hello world!"
			console.log(greeting);
		}
	</code></pre>
	<p>Briefly, variables in JavaScript are indicated with the symbols:</p>
	<ul>
		<li><span class="monoText">let</span></li>
		<li><span class="monoText">const</span></li>
		<li><span class="monoText">var</span></li>
	</ul>
	<p>
		When writing variable names, the convention is to use only ASCII characters,
		but we are free to use the full set of Unicode characters.
	</p>
	<p>
		In the code above, the variable
		<span class="monoText">greeting</span> sits
		<span class="italicsText">lexically</span> inside the function
		<span class="monoText">hello()</span>. Moreover, if a programming language
		has a <span class="italicsText">lexical environment</span>, then the
		language gives us an idea of where in the computer's memory our code
		resides, and how it will interact with other parts of the program. Put
		simply, whenever we use the term
		<span class="italicsText">lexical environment</span>, we are referring to
		<span class="underlineText">where</span> the code is in the program, and
		<span class="underlineText">what</span> surrounds that code.
	</p>
</section>

<section id="execution_contexts">
	<p>
		<span class="topic">Execution Contexts.</span> Because programs use multiple
		statements and span multiple lines, if a programming language has a lexical
		environment, then it follows that there are multiple lexical environments.
		Those lexical environments do not all run at the same time. The environment
		that is currently run is managed through
		<span class="term">execution contexts</span>. An
		<span class="italicsText">execution context</span> is simply a wrapper that
		helps manage the code currently running. To do so, it not only contains your
		code, but additional code&mdash;that we may or may not have written&mdash;to
		help the syntax parser process our code.
	</p>
</section>

<section id="objects_revisited">
	<p>
		<span class="topic">Bindings & Objects.</span> When we saw objects, we
		compared them to the Python dictionary. However, objects are a much more
		general construct in JavaScript. Before we discuss objects, however, let's
		revisit the <span class="italicsText">binding</span>. Formally: A
		<span class="term">binding</span> is a
		<span class="italicsText">name</span> that maps to a unique
		<span class="italicsText">value</span>. Essentially, it is a
		<span class="italicsText">name-value pair</span>. The name may be defined
		more than once, <span class="underlineText">but</span> it can only have one
		value in any given execution context. The value itself, however, need not be
		a literal. The name could map to more objects.
	</p>
	<p>
		Having formally defined a binding, we should now have a clearer
		understanding of objects. And <span class="term">object</span> is a
		collection of bindings. More specifically, it is a collection of name-value
		pairs.
	</p>
</section>

<section id="the_global_object">
	<p>
		<span class="topic">The Global Object</span>
		In JavaScript, there is an execution context called the
		<span class="term">global execution context</span>. This is the
		<span class="italicsText">base</span> execution context. All execution
		contexts "lie on top" of the global execution context. Code written in the
		global execution context is accessible to everything everywhere else in the
		program.
	</p>
	<p>
		The global execution context creates two things: (1) a
		<span class="term">global object</span> and (2) a variable called
		<span class="monoText">this</span>. These are created by the JavaScript
		engine whenever code is executed, since all code, in JavaScript, exists in
		an execution context. If we execute JavaScript in the browser, we can see
		the global object by simply typing the keyword
		<span class="monoText">this</span>:
	</p>
	<pre class="language-javascript"><code>
		this
	</code></pre>
	<pre class="language-bash"><code>
		Window {window: Window, self: Window, document: document, name: "", location: Location, …}
	</code></pre>
	<p>
		On the browser, the global object is the
		<span class="monoText">window</span> object. However, the global object is
		not always the <span class="monoText">window</span> object. It depends on
		where we execute JavaScript code. If we ran JavaScript in a separate tab or
		window, the global object would still be called the
		<span class="monoText">window</span> object, but it is a different
		object&mdash;it's a different execution context. In NodeJS, the global
		object is something else entirely. Nevertheless, in every situation, there
		is <span class="underlineText">always</span> a global object whenever we run
		JavaScript.
	</p>
	<p>
		Note that in JavaScript, the word "global" refers to an execution context
		other than a function's. Thus, if we have code that is
		<span class="underlineText">not</span> inside a function, that code resides
		in the global execution context. For example, suppose we wrote the following
		code:
	</p>

	<pre class="language-javascript"><code>
		var x = 'Hello world!';
		function b() {
			return x
		};
	</code></pre>

	<p>Then, in our console, we wrote:</p>

	<pre class="language-javascript"><code>
		window
	</code></pre>
	<pre class="language-bash"><code>
		Window {
			...
			x: "Hello World!"
			b: function b() {}
		}
	</code></pre>
	<p>
		We see that the variable we wrote, <span class="monoText">x</span>, and the
		function we wrote, <span class="monoText">b</span>, reside in the
		<span class="monoText">Window</span> object, the global object. Because they
		are inside the global object, we can reference them by writing:
	</p>

	<pre class="language-javascript"><code>
		window.a
		window.b
	</code></pre>
	<pre class="language-bash"><code>
		"Hello world!"

		ƒ b() {
			
		}
	</code></pre>
</section>

<section id="creation_hoisting">
	<p>
		<span class="topic">Hoisting.</span> If there's one thing that surprises
		newcomers to JavaScript, it's <span class="italicsText">hoisting</span>.
		This phenomenon is best explained by way of example. Suppose we wrote the
		following in a JavaScript file linked to an HTML document:
	</p>

	<pre class="language-javascript"><code>
		var greeting = "Hello world!";

		function bye() {
			console.log("Goodbye!");
		}
		
		bye();

		console.log(greeting);
	</code></pre>

	<p>Loading the HTML page and examining the console:</p>

	<pre class="language-bash"><code>
		"Goodbye!"
		"Hello world!"
	</code></pre>

	<p>This works as expected. Now suppose we rearranged the code:</p>

	<pre class="language-javascript"><code>
		bye();

		console.log(greeting);

		var greeting = "Hello world!";

		function bye() {
			console.log("Goodbye!")
		}
	</code></pre>
	<p>
		Notice what we've done. We moved the call
		<span class="monoText">bye()</span> to the very first line. We've also moved
		the method call <span class="monoText">console.log()</span> to the second
		line. The binding <span class="monoText">greeting</span> has now moved to
		after these two invocations, along with the function initialization for
		<span class="monoText">bye()</span>. If we're coming from a language like
		C++, this should return a compiler error. But notice the output from running
		this code:
	</p>
	<pre class="language-bash"><code>
		"Goodbye!"
		undefined
	</code></pre>
	<p>
		The function <span class="monoText">bye()</span> is actually executed, and
		the console displays <span class="monoText">undefined</span> for the
		variable <span class="monoText">greeting</span>. This is unusual behavior.
		In most programming languages, the function
		<span class="monoText">bye()</span> would not have been executed, since
		executions go from top down. Similarly, we do not get an error from
		executing a method with a variable declared later down the code. To maintain
		some sanity, we do get an error if we completely removed the variable
		declaration:
	</p>

	<pre class="language-javascript"><code>
		bye();

		console.log(greeting);

		function bye() {
			console.log("Goodbye!")
		}
	</code></pre>
	<pre class="language-bash"><code>
		"Goodbye!"
		Uncaught ReferenceError: greeting is not defined
	</code></pre>

	<p>
		In JavaScript, this phenomenon of allowing functions to execute "before" the
		function is defined or variables declared is called
		<span class="term">hoisting</span>. Hoisting occurs because JavaScript
		execution contexts are created in two phases:
	</p>
	<ol>
		<li>The Creation Phase; and</li>
		<li>The Execution Phase</li>
	</ol>

	<section id="creation_phase">
		<p>
			<span class="topic">The Creation Phase</span>
			In the <span class="term">creation phase</span>, three things are created:
			(1) the <span class="italicsText">global object</span>, (2) the variable
			<span class="monoText">this</span>, and (3) the
			<span class="italicsText">outer environment</span>. During the creation
			phase, the syntax parser runs through all of the code, setting everything
			up for translation. During that run, the parser recognizes where we've
			created variables, and where we've created functions. To keep track of
			everything it's doing, it allocates memory for variables and functions.
			This is what we see as <span class="italicsText">hoisting</span>.
		</p>

		<p>
			Contrary to what many think (and teach), the parser does not actually move
			code to the top of the page. What's actually happening is that before the
			code is even executed line by line, the parser has already stored the
			variables and functions we've written in memory. Because the variables and
			functions already exist in memory, when the code actually executes line by
			line, the functions we've written after a particular line (in the global
			object) are accessible.
		</p>

		<p>
			Variables, however, are treatedly differently from functions. With
			functions, the entire function is stored in memory when the parser runs
			through the code. This is why they can be executed when called before
			their arguments are initialized. Variables, however, are only partly
			stored&mdash;the variable declaration and its identifier (name) are stored
			in memory during the parser's run, but the variable's assignment is done
			only during the second phase,
			<span class="italicsText">execution</span>. This means that the JavaScript
			engine does not actually know what a variable's assigned value is until
			the execution phase.
		</p>

		<p>
			Rather than storing the variables assigned value, the parser stores a
			placeholder value in memory space &mdash;
			<span class="monoText">undefined</span>. Storing the placeholder value is
			effectively JavaScript's way of saying "I don't know what the value of
			this variable is yet, but it does have a value." This is the same
			placeholder value that we would have if we never assigned a value to a
			variable. This is why <span class="underlineText">all</span> variables in
			JavaScript are initially set to <span class="monoText">undefined</span>.
		</p>
		<p>
			This discussion also reveals that
			<span class="monoText">undefined</span> does not mean &#8220;not
			defined&#8221;. For example, consider the following code:
		</p>
		<pre class="language-javascript"><code>
			console.log(x)
		</code></pre>
		<pre class="language-bash"><code>
			app.js:1 Uncaught ReferenceError: x is not defined
				at app.js:1
		</code></pre>
		<p>
			We get the error as expected. But if we declared
			<span class="monoText">x</span>:
		</p>
		<pre class="language-javascript"><code>
			var x;
			console.log(x)
		</code></pre>
		<pre class="language-bash"><code>
			undefined
		</code></pre>
		<p>
			We get <span class="monoText">undefined</span>. We can confirm that is the
			case by testing for the equality of <span class="monoText">x</span> to
			<span class="monoText">undefined</span>:
		</p>
		<pre class="language-javascript"><code>
			var x;
			if (x == undefined) {
				console.log("x is undefined")
			} else {
				console.log("x is not defined")
			}
		</code></pre>
		<pre class="language-bash"><code>
			x is undefined
		</code></pre>
	</section>

	<section id="execution_phase">
		<p>
			<span class="topic">Execution Phase</span>
			In the sections above, we discussed the
			<span class="italicsText">creation phase</span>. Once the creation phase
			ends, the <span class="term">execution phase</span> begins. This is where
			the JavaScript interpret begins translating the code into assembly
			language&mdash;code that the computer can understand. Once translated, the
			code is then executed.
		</p>
		<p>Suppose we had the following code:</p>

		<pre class="language-javascript"><code>
			function b() {
				console.log('Called b!')
			}
			b();
			console.log(a);
			var a = 'Hello world!';
			console.log(a);
		</code></pre>

		<p>In the code above, the output looks like the following:</p>

		<pre class="language-javascript"><code>
			"Called b!"
			undefined
			"Hello world!"
		</code></pre>

		<p>
			The function <span class="monoText">b()</span> is executed, then the
			method <span class="monoText">console.log()</span> is executed (with a
			value of <span class="monoText">undefined</span>), then the second
			<span class="monoText">console.log()</span> is executed, with the value
			<span class="monoText">"Hello world!"</span>.
		</p>
		<p>
			Why are there two different values for the variable
			<span class="monoText">a</span>? Because initially, the value of
			<span class="monoText">a</span> was
			<span class="monoText">undefined</span>, as set by the parser in the
			<span class="italicsText">creation phase</span>. In the line just after
			that, however, we assigned <span class="monoText">a</span> the value
			<span class="monoText">"Hello world!"</span>, so the value is no longer
			<span class="monoText">undefined</span>, but a string instead.
		</p>
	</section>
</section>

{% endblock %}
