{% extends '../layout.html' %} {% load static %} {% block description %}
<meta
	name="description"
	content="Notes on regular expressions in JavaScript."
/>
{% endblock %} {% block title %}
<title>JS Regex</title>
{% endblock %} {% block content %}
<h1>Regular Expressions</h1>
<section id="regular_expressions_introduction">
	<p>
		A <b>regular expression</b> is a sequence of characters instructing
		JavaScript on what to search for in a set of data. Regular expressions
		effectively allow us to describe patterns in string type data. For
		example, many
	</p>
	<figure>
		<div>
			<pre class="language-pseudo"><code>
				"The solution's wrong &mdash; there's no decrement; eternal loop!"
			</code></pre>
		</div>
	</figure>
	<p>
		Suppose we wanted to go through this string, removing all of the
		punctuation marks. We could go through each character in the string,
		checking if it falls in a certain range. This isn't wrong, but a better
		way would be to use a <i>regular expression</i> to match punctuation
		marks, then use a replace method to replace the punctuation marks with
		nothing.
	</p>
	<p>
		Regular expressions are a powerful tool for parsing textual forms of
		data. The most common use cases for regular expressions:
	</p>
	<figure>
		<div>
			<ul>
				<li>
					Checking if a user input (password, email, phone number, etc.)
					complies with a particular criteria.
				</li>
				<li>
					Computing the number of times a particular word occurs in a given
					text.
				</li>
				<li>
					Removing from, or inserting in, certain words or characters in a
					given text.
				</li>
				<li>Analyzing a log file for particular data.</li>
				<li>Analyzing a system's structure given its URL or file path.</li>
			</ul>
		</div>
	</figure>
	<p>
		The concept of a regular expression has been around for nearly as long
		as modern computers. Developed by Stephen Keene in 1950, regular
		expressions were (and still are) extensively used by Unix text
		processing utilities. Most notably, <var>grep</var> (<q
			>Global Search for Regular Expressions and Print Matching</q
		>). As computers grew more pervasive, regular expressions were
		standardized under the POSIX standard.
	</p>
	<p>
		In 1997, The computer scientist Philip Hazel introduced a more modern
		version, PCRE (<q>Pearl Compatible Regular Expressions</q>), which is
		now used by a wide variety of tools and languages. Because of this
		uniformity, regular expressions are largely language-agnostic. While
		there are some differences across regular expression use in particular
		languages, these differences are minor. Much of the syntax and grammar
		of regular expressions is the same, whether we're using JavaScript,
		Python, Java, C, C++, and so on.
	</p>
</section>

<section id="creating_regex">
	<h2>Creating a Regular Expression</h2>
	<p>
		Before we can use a regular expression, we must first create the
		regular expression. In JavaScript, regular expressions are objects. And
		as we saw with objects, there are two ways to create regular
		expressions. We can use object-literal syntax, or we can use a
		constructor.
	</p>
	<p>For example, here's a method with a constructor:</p>
	<pre class="language-javascript"><code>
		let regex1 = new RegExp("hello");
	</code></pre>
	<p>
		The <var><mark>RegExp()</mark></var> constructor takes as an argument
		the <i>pattern</i> the regular expression will look for.
	</p>
	<p>In contrast, here's the literal syntax:</p>
	<pre class="language-javascript"><code>
		let regex1 = /hello/;
	</code></pre>
	<p>
		In the syntax above, the first forward slash (<var>/</var>) marks the
		start of the pattern, and the second forward slash marks the end of the
		pattern.
	</p>
	<p>
		Once we have a regex object, we can use the object with JavaScript's
		<var>RegExp</var> methods or the String object wrapper. For example,
		one useful method is <var><mark>.test()</mark></var
		>. This is a method on the regex object, and it has the following
		syntax:
	</p>
	<ul class="syntax">
		<li>${regex}$.test(${s}$)</li>
	</ul>
	<p>
		Here, ${regex}$ is some regex object, and ${s}$ is some string we want
		tested. The <var>.test()</var> method returns true if the pattern in
		${regex}$ is found, and false otherwise. Illustrating:
	</p>
	<pre class="language-javascript"><code>
		const text        = "CS lessons always have a 'hello world' snippet.";
		const regexHello  = new RegExp('hello');
		const regexWorld  = /world/;
		const regexWorlds = /worlds/;

		const helloIsPresent  = regexHello.test(text);
		const worldIsPresent  = regexWorld.test(text);
		const worldsIsPresent = regexWorlds.test(text);

		console.log(helloIsPresent);
		console.log(worldIsPresent);
		console.log(worldsIsPresent);
	</code></pre>
	<pre class="language-bash"><code>
		true
		true
		false
	</code></pre>
	<p>
		We get back <var>true</var>, as expected. Both <var>/hello/</var> and
		<var>/world/</var> were found.<sup></sup> But, we get false for
		<var>/worlds/</var> because there is no match.
	</p>
	<div class="note">
		<p>
			To differentiate strings from regular expression patterns in
			discussion, we will denote regular expression patterns with forward
			slashes, and string values with double quotes.
		</p>
	</div>
	<p>
		Test isn't the only method we can use. There are two methods on the
		regex object, and four methods for the string object. We examine these
		methods in turn.
	</p>
	<section id="exect">
		<h3>The Exec Method</h3>
		<p>Consider the output of the following code:</p>
		<pre class="language-javascript"><code>
			const text       = "CS lessons always have a 'hello world' snippet.";
			const regexHello = /hello/;
			const regexWorld = /world/;

			const helloExec = regexHello.exec(text);
			const worldExec = regexWorld.exec(text);

			console.log(helloExec);
			console.log(worldExec);
		</code></pre>
		<pre class="language-bash"><code>
			Array(1)
				[
					'hello',
					index : 26,
					input : "CS lessons always have a 'hello world' snippet.",
					length: 1,
					groups: undefined
				]
			Array(1)
				[
					'world',
					index : 32,
					input : "CS lessons always have a 'hello world' snippet.",
					length: 1,
					groups: undefined
				]
		</code></pre>
		<p>
			Notice that we get back arrays. Both of these arrays contain the
			subsrings that matched our regular expression patterns,
			<var>/hello/</var> and <var>/world/</var>. This demonstrates that
			<var><mark>exec()</mark></var> returns an array of the substrings
			that match the regular expression in a given string.
		</p>
		<p>
			There are also several pieces of information &mdash; properties
			&mdash; that accompany the array object returned. First, a property
			<var><mark>index</mark></var
			>, which provides where in the string the match occurred. For
			example, with the matching <var>'hello'</var>, the beginning of the
			match is at index <var>26</var> (the index corresponding to the
			position of each character in the string). With the matching
			<var>'world'</var>, the beginning of the match is at index
			<var>32</var>.
		</p>
	</section>
</section>

<section id="string_methods">
	<h2>String Methods</h2>
	<p>
		Whenever we create strings in JavaScript, the strings are produced with
		a
		<var>string</var> object wrapper. This object wrapper provides several
		<i>string methods</i>, four of which can be used with regex objects.
	</p>

	<section id="match">
		<h3>The Match Method</h3>
		<p>The match method has the following syntax:</p>
		<ul class="syntax">
			<li>${s}$.match(${regex}$)</li>
		</ul>
		<p>
			where ${s}$ is a string value, and ${regex}$ is a regular expression.
			This method works like the <var>exec()</var> method. It returns an
			array containing the match (if any), as well as a few other helpful
			bits of information:
		</p>
		<pre class="language-javascript"><code>
			const text = "Toshiro Mifune";
			const regex = /Mifune/;
			const result = text.match(regex);

			console.log(result);
		</code></pre>
		<pre class="language-bash"><code>
			[ 'Mifune', index: 8, input: 'Toshiro Mifune', groups: undefined ]
		</code></pre>
	</section>

	<section id="search">
		<h3>The Search Method</h3>
		<p>
			Alongside the <var>match()</var> method, the string object wrapper
			also provides the <var><mark>search()</mark></var> method. The syntax
			is the same as <var>match()</var>:
		</p>
		<ul class="syntax">
			<li>${s}$.search(${regex}$)</li>
		</ul>
		<p>
			In contrast to <var>match()</var>, <var>search()</var> merely returns
			the index of the matched regex:
		</p>
		<pre class="language-javascript"><code>
			const text = "Toshiro Mifune";
			const regex = /Mifune/;
			const result = text.match(regex);

			console.log(result);
		</code></pre>
		<pre class="language-bash"><code>
			8
		</code></pre>
		<p>
			Notice that this is the same <var>8</var> we saw from
			<var>match()</var>'s output. It's the index where the regex first
			occurs.
		</p>
		<pre class="language-javascript"><code>
			const text = "Toshiro Mifune";
			const regex = /Mifune/;
			const result = text.search(regex);
			console.log(result);
			console.log('text[8] = %s', text[8]);
		</code></pre>
		<pre class="language-bash"><code>
			8
			text[8] = M
		</code></pre>
		<p>If no match is found, <var>search()</var> returns <var>-1</var>:</p>
		<pre class="language-javascript"><code>
			const text = "Toshiro Mifune";
			const regex = /Maru/;
			const result = text.search(regex);
			console.log(result);
		</code></pre>
		<pre class="language-bash"><code>
			-1
		</code></pre>
	</section>

	<section id="replace">
		<h3>The Replace Method</h3>
		<p>
			Suppose we want to replace a matching substring with a particular
			string value. We can do so with the <var>replace()</var> method. The
			general syntax:
		</p>
		<ul class="syntax">
			<li>${s_p}$.replace(${regex}$, ${s_n}$)</li>
		</ul>
		<p>
			Where ${s_p}$ is an existing string, ${regex}$ is the regular
			expression to match, and ${s_n}$ is the string we want to replace the
			matching ${regex}$ with. For example:
		</p>
		<pre class="language-javascript"><code>
			const text = "strawberry pie";
			console.log(text);
			const regex = /pie/;
			const result = text.replace(regex, "cake");
			console.log(result);
			console.log(text);
		</code></pre>
		<pre class="language-bash"><code>
			strawberry pie
			strawberry cake
			strawberry pie
		</code></pre>
		<p>
			Notice how the matching substring <var>pie</var> was replace with
			<var>cake</var>. Importantly, the <var>replace()</var> method does
			not mutate the original string. If we want to use the modified
			string, we must bind it to a variable.
		</p>
		<p>
			Moreover, with the way we're using <var>replace()</var> at the
			moment, the method will only replace the first match it encounters:
		</p>
		<pre class="language-javascript"><code>
			const text = "strawberry pie pie";
			console.log(text);
			const regex = /pie/;
			const result = text.replace(regex, "cake");
			console.log(result);
			console.log(text);
		</code></pre>
		<pre class="language-bash"><code>
			strawberry pie pie
			strawberry cake pie
			strawberry pie pie
		</code></pre>
		<p>
			In later sections, we will see how to replace <em>all</em> instances
			of a regex-matched substring.
		</p>
	</section>

	<section id="split">
		<h3>The Split Method</h3>
		<p>
			Earlier in this volume, we saw the
			<var><mark>split()</mark></var> method:
		</p>
		<pre class="language-javascript"><code>
			const text = "mango, lychee, rambutan";
			const arr = text.split(', ');
			console.log(arr);
		</code></pre>
		<pre class="language-bash"><code>
			[ 'mango', 'lychee', 'rambutan' ]
		</code></pre>
		<p>
			Using the separator <var>, </var> (a commma followed by a space) we
			can store each substring separated by a commoa and a space in the
			string <var>text</var> as an element in an array. Notice what happens
			when we use a regular expression as a separator:
		</p>
		<pre class="language-javascript"><code>
			const text = "010";
			const regex = /1/;
			const arr = text.split(regex);
			console.log(arr);
		</code></pre>
		<pre class="language-bash"><code>
			[ '0', '0' ]
		</code></pre>
		<p>
			This output conforms with how <var>split()</var> works. By passing a
			regular expression as a separator, the array returned does not
			include the regex-matched substring, since the regex is used as a
			separator.
		</p>
		<p>
			While ones and zeros are nice, a much more common use of regular
			expressions is to break down a sentence into an array of words. To do
			so, we use the regular expression syntax for a space &mdash;
			<var><mark>\s</mark></var> (backward slash s):
		</p>
		<pre class="language-javascript"><code>
			const text = "One man's constant is another man's variable.";
			const regex = /\s/;
			const arr = text.split(regex);
			console.log(arr);
		</code></pre>
		<pre class="language-bash"><code>
			[ 'One', "man's", 'constant', 'is', 'another', "man's", 'variable.' ]
		</code></pre>
		<p>
			Now we're talking. We turned the string <var>text</var> into an array
			of words. That's very cool.
		</p>
	</section>

	<section id="regex_flags">
		<h3>Regex Flags</h3>
		<p>Consider the following code:</p>
		<pre class="language-javascript"><code>
			const text = "One man's constant is another man's variable.";
			const regex = /man's/;
			const result = text.replace(regex, "function's");
			console.log(result);
		</code></pre>
		<pre class="language-bash"><code>
			One function's constant is another man's variable.
		</code></pre>
		<p>
			The <var>replace()</var> function is only replacing the first match.
			If we included in the regular expression the symbol <var>g</var>,
			however, we get the following:
		</p>
		<pre class="language-javascript"><code>
			const text = "One man's constant is another man's variable.";
			const regex = /man's/<mark>g</mark>;
			const result = text.replace(regex, "function's");
			console.log(result);
		</code></pre>
		<pre class="language-bash"><code>
			One function's constant is another function's variable.
		</code></pre>
		<p>
			The symbol <var>g</var> is called a <b>regex flag</b> or a
			<b>modifier</b>. Think of it as a way of tailoring how a pattern
			matching should be done. In JavaScript, there are two ways to include
			regular expression flags:
		</p>
		<div class="split">
			<figure>
				<ul class="syntax">
					<li>/${pattern}$/${flags}$;</li>
				</ul>
				<figcaption>Method 1.</figcaption>
			</figure>
			<figure>
				<ul class="syntax">
					<li>new RegExp("${pattern}$", ${flags}$);</li>
				</ul>
				<figcaption>Method 2.</figcaption>
			</figure>
		</div>
		<p>The three most common flags:</p>
		<ol>
			<li>
				<var><mark>g</mark></var> This flag indicates
				<b>global matching</b>. It will match more than one occurrence.
				I.e., it will find every pattern for that match within the string.
				Without the global flag, only the first match is found.
			</li>
			<li>
				<var><mark>i</mark></var> This flag indicates
				<b>case-insensitivity matching</b>. If this flag is used,
				case-insensitive matches are found. For example,
				<var>/ny/</var> will find the ${2^2}$ possible matches:
				<var>ny</var>, <var>Ny</var>, <var>nY</var>, and <var>NY</var>.
			</li>
			<li>
				<var><mark>m</mark></var> This flag indicates
				<b>multiline matching</b>. It will return matches across multiple
				lines.
			</li>
		</ol>
		<p>
			We can combine regular expression flags for more tailored pattern
			matching:
		</p>
		<pre class="language-javascript"><code>
			const text = "Change the nyc, NyC, and nyC to NYC.";
			const regex = /nyc/<mark>gi</mark>;
			const result = text.replace(regex, "NYC");
			console.log(text);
			console.log(result);
		</code></pre>
		<pre class="language-bash"><code>
			Change the nyc, NyC, and nyC to NYC.
			Change the NYC, NYC, and NYC to NYC.
		</code></pre>
	</section>
</section>

<section id="metacharacters">
	<h2>Metacharacters</h2>
	<p>
		To understand why and how regular expressions work, we have to take a
		step back and think about how patterns of characters are built. Words
		are just one kind of character pattern. But we also have many others
		&mdash; phone numbers, passwords, usernames, addresses, hash codes, and
		even meaningless sequences.
	</p>
	<p>
		When we command the JavaScript engine to look for a match, the engine
		will go through the string value, examining each character one at a
		time. If a pattern consists of a single character, the engine must
		determine if the character it's looking at matches the single
		character.
	</p>
	<p>
		For patterns with multiple characters, the engine first determines if
		the character it's look at matches the first character in the pattern.
		If it does, it then checks if the next character to look at matches the
		second character. If it does, then it goes to the third, and so on. But
		if it does not match, then the engine must <q>rewind</q> or return to
		the first character, and continue checking again. For example, suppose
		we had the string value below, and we want to find the matches to the
		regular expression following it:
	</p>
	<pre class="language-javascript"><code>
		let str = "aba ada";
		let regex = /ada/;
	</code></pre>
	<p>In memory, the string appears as follows:</p>
	<div id="array1"></div>
	<p>
		First, the regular expression to match is <var>/ada/</var>, so
		JavaScript looks at the first character in the array:
	</p>
	<div id="array2"></div>
	<p>
		Here, it sees that there's a match, so it goes to the next character:
	</p>
	<div id="array3"></div>
	<p>
		Here, the character doesn't match, so it goes back to the first
		character:
	</p>
	<div id="array4"></div>
	<p>
		The engine knows the first character matches and the second character
		does not, so it doesn't bother checking for matches and goes to the
		third:
	</p>
	<div id="array5"></div>
	<p>
		Here it sees that there is a match, so it checks the next character:
	</p>
	<div id="array6"></div>
	<p>No match, so it goes back to the previous character and continues.</p>
	<div id="array7"></div>
	<p>
		Once it encounters the fifth character, it finds that it's a match, and
		continues, ultimately finding the pattern:
	</p>
	<div id="array8"></div>
	<p>
		If the global flag is set, the engine continues searching. Otherwise,
		it stops.
	</p>
	<p>
		Now, because the whole point of regular expressions is pattern
		matching, we must have a way of writing patterns of characters. This is
		a peculiar problem &mdash; we have to use characters to write the
		patterns of characters. Accordingly, regular expressions have ${18}$
		special <b>metacharacters</b> with specific meanings for specifying
		patterns:
	</p>
	<div class="split">
		<ul>
			<li>
				<var><mark>^</mark></var> (caret)
			</li>
			<li>
				<var><mark>$</mark></var> (dollar sign)
			</li>
			<li>
				<var><mark>.</mark></var> (dot/period)
			</li>
			<li>
				<var><mark>*</mark></var> (asterisk)
			</li>
			<li>
				<var><mark>+</mark></var> (plus sign)
			</li>
			<li>
				<var><mark>?</mark></var> (eroteme/interrogation mark)
			</li>
			<li>
				<var><mark>=</mark></var> (equality)
			</li>
			<li>
				<var><mark>!</mark></var> (exclamation mark)
			</li>
			<li>
				<var><mark>:</mark></var> (colon)
			</li>
			<li>
				<var><mark>|</mark></var> (pipe/vertical bar)
			</li>
		</ul>
		<ul>
			<li>
				<var><mark>\</mark></var> (backslash)
			</li>
			<li>
				<var><mark>/</mark></var> (solidus/slash)
			</li>
			<li>
				<var><mark>(</mark></var> (left parentheses)
			</li>
			<li>
				<var><mark>)</mark></var> (right parentheses)
			</li>
			<li>
				<var><mark>[</mark></var> (left bracket)
			</li>
			<li>
				<var><mark>]</mark></var> (right bracket)
			</li>
			<li>
				<var><mark>{</mark></var> (left brace)
			</li>
			<li>
				<var><mark>}</mark></var> (right brace)
			</li>
		</ul>
	</div>
	<p>We examine each of these characters in turn.</p>
	<section id="wild_card">
		<h3>The Wildcard Character (<var>.</var>)</h3>
		<p>
			In regular expressions, the dot symbol <var><mark>.</mark></var> is
			called the <b>wildcard character</b>. It's name is descriptive of its
			use &mdash; <var><mark>.</mark></var> can be <em>anything</em>. In
			other words, when we use <var><mark>.</mark></var> in a regular
			expression, it represents any <em>single</em> character, with the
			exception of some control characters like <var>new line</var> (more
			on this later).
		</p>
		<p>For example:</p>
		<pre class="language-javascript"><code>
			const text = "How is it that hot?";
			const regex = /<mark>h.t</mark>/gi;
			const result = text.match(regex);
			console.log(result);
		</code></pre>
		<pre class="language-bash"><code>
			[ 'hat', 'hot' ]
		</code></pre>
		<p>
			Observe the matches. When we write: <var>/h.t/</var>, we are
			specifying a pattern that:
		</p>
		<ol>
			<li>
				Starts with the character <var>h</var>, lowercase or uppercase.
			</li>
			<li>
				Ends with the character <var>t</var>, lowercase or uppercase.
			</li>
			<li>With <em>one</em> character in between, any character.</li>
		</ol>
		<p>
			Again, <var><mark>.</mark></var> only matches a single character.
			Consider this output:
		</p>
		<pre class="language-javascript"><code>
			const text = "How is it that hooot?";
			const regex = /h.t/gi;
			const result = text.match(regex);
			console.log(result);
		</code></pre>
		<pre class="language-bash"><code>
			[ 'hat' ]
		</code></pre>
		<p>If we instead wrote:</p>
		<pre class="language-javascript"><code>
			const text = "How is it that hooot?";
			const regex = /<mark>h...t</mark>/gi;
			const result = text.match(regex);
			console.log(result);
		</code></pre>
		<pre class="language-bash"><code>
			[ 'hooot' ]
		</code></pre>
		<p>
			Importantly, some non-printable characters will not match with
			<var><mark>.</mark></var
			>. For example, the new line character (the character from hitting
			the <var>enter</var> key). But, <var><mark>.</mark></var> will match
			with spaces and tabs. If we did want to match <i>all</i> characters,
			including all the non-printable characters, we can use the
			<var><mark>s</mark></var> flag, called the <b>dot all flag</b>.
		</p>
		<p>
			What if we wanted to actually match a period rather than the
			wildcard? To do so, we use the <b>escape metacharacter</b>.
		</p>
	</section>
	<section id="backslash">
		<h3>The Escape Character (<var>\</var>)</h3>
		<p>
			The escape character, <var><mark>\</mark></var
			>, is what we use to escape a metacharacter. It essentially says,
			<q>I mean the actual character, not the metacharacter.</q> For
			example, consider the output of the following code:
		</p>
		<pre class="language-javascript"><code>
			const text = "(a+b)^2 = a^2 + 2ab + b^2";
			const regex = /(a+b)/gi;
			const result = text.match(regex);
			console.log(result);
		</code></pre>
		<pre class="language-bash"><code>
			[ 'ab' ]
		</code></pre>
		<p>
			We wanted to match the pattern <var>(a+b)</var>, but we're getting a
			strange result. This is because the parentheses and plus sign are
			being treated as meta characters. What we instead want to do is
			escape these metacharacters:
		</p>
		<pre class="language-javascript"><code>
			const text = "(a+b)^2 = a^2 + 2ab + b^2";
			const regex = /<mark>\(a\+b\)</mark>/gi;
			const result = text.match(regex);
			console.log(result);
		</code></pre>
		<pre class="language-bash"><code>
			[ '(a+b)' ]
		</code></pre>
		<p>
			What if we were looking for a backslash? Well, we just escape the
			backslash:
		</p>
		<pre class="language-javascript"><code>
			const regex = /\\hello/;
		</code></pre>
		<p>
			The regex pattern above will match the string containing
			<var>"\hello"</var>.
		</p>
	</section>

	<section id="control_characters">
		<h3>Control Characters</h3>
		<p>
			When we hit the tab or return key on a keyboard, we enter characters
			called <b>control characters</b>. These characters are:
		</p>
		<ol>
			<li>
				<var><mark>\t</mark></var> (the tab character)
			</li>
			<li>
				<var><mark>\v</mark></var> (the vertical tab character)
			</li>
			<li>
				<var><mark>\n</mark></var> (the newline tab character)
			</li>
			<li>
				<var><mark>\r</mark></var> (the carriage return character)
			</li>
			<li>
				<var><mark>\s</mark></var> (the space character)
			</li>
		</ol>
	</section>
	<p>
		We can use the control characters for pattern matching just as we would
		the normal characters, as long as we use the escape sequences above.
	</p>
	<pre class="language-javascript"><code>
		const regex1 = /h\tt/; // pattern is: h, tab, t
		const regex2 = /h\nt/; // pattern is: h, newline, t
		const regex3 = /h\vt/; // pattern is: h, vertical-tab, t
		const regex3 = /h\st/; // pattern is: h, space, t
	</code></pre>
</section>

<section id="character_sets">
	<h2>Character Sets</h2>
	<p>British and American spelling have recurring differences:</p>
	<ol>
		<li>
			Words ending in <i>-or</i> in American English often ends with
			<i>-our</i> in British English. For example, ${(color,~colour),}$
			${(flavor,~flavour),}$ or ${(labor,~labour).}$
		</li>
		<li>
			Words ending in <i>-er</i> in American English often end with
			<i>-re</i> in British English. E.g., ${(center,~centre),}$
			${(fiber,~fibre),}$ or ${(meter,~metre).}$
		</li>
		<li>
			British English sometimes keeps a silent <i>e</i>, where American
			English does not: ${(ageing,~aging)}$ or ${(routeing,~routing).}$
		</li>
	</ol>
	<p>
		The list goes on. One clear difference is the spelling for the color
		<i>gray</i>. In British English, the more common spelling is
		<i>grey</i>. Using this example, suppose we have the following string:
	</p>
	<pre class="language-javascript"><code>
		const str = "The color grey is also gray."
	</code></pre>
	<p>
		We want to find all instances of the color gray, but how? The trick is
		to use a <b>character set</b>:
	</p>
	<pre class="language-javascript"><code>
		let regex = /gr[ae]y/
	</code></pre>
	<p>
		Notice the square brackets <var><mark>[]</mark></var
		>. In regex, writing <var>/gr[ae]y</var> specifies the pattern:
	</p>
	<ol>
		<li>The first character is <var>g</var>,</li>
		<li>The second character is <var>r</var>,</li>
		<li>
			The third character is <em>one of</em>: <var>a</var> or <var>e</var>.
		</li>
		<li>The fourth character is <var>y</var>.</li>
	</ol>
	<p>Illustrating:</p>
	<pre class="language-javascript"><code>
		const text = "The color grey is also gray.";
		const regex = /gr[ae]y/g;
		const result = text.match(regex);
		console.log(result);
	</code></pre>
	<pre class="language-bash"><code>
		['grey', 'gray']
	</code></pre>
	<p>We can combine character sets for more tailored matches:</p>
	<pre class="language-javascript"><code>
		const text = "They marched there with their guns.";
		const regex = /the[ir][re]/g;
		const result = text.match(regex);
		console.log(result);
	</code></pre>
	<pre class="language-bash"><code>
		[ 'there', 'their' ]
	</code></pre>
	<p>
		Importantly, metacharacters do not behave like metacharacter inside a
		character set. For example:
	</p>
	<pre class="language-javascript"><code>
		jsconst text = "3.1, 2.2, 1.9";
		const regex = /[.].[.]/gi;
		const result = text.match(regex);
		console.log(result);
	</code></pre>
	<p>
		In the regex above, we tried to use the wildcard metacharacter inside a
		character set. This doesn't work because inside the character set, it's
		treated as a period, not the wildcard metacharacter. We don't want to
		use metacharacters inside character sets &mdash; that would defeat the
		purpose of the character set. It's mean to specify characters, not to
		act as a separator. Accordingly, we want to write:
	</p>
	<pre class="language-javascript"><code>
		const text = "3.1, 2.2, 1.9";
		const regex = /.\../gi;
		const result = text.match(regex);
		console.log(result);
	</code></pre>
	<pre class="language-bash"><code>
		[ '3.1', '2.2', '1.9' ]
	</code></pre>
	<p>
		One exception to the rule against using metacharacters inside character
		sets, however, is the <i>range character</i>, denoted as a
		<i>hyphen</i> (<var>-</var>).
	</p>
	<section id="ranges">
		<h3>Specifying Ranges</h3>
		<p>Suppose we had the following string:</p>
		<pre class="language-javascript"><code>
			const text = "(Bob, 1992), (Anne, 1993), (Jack, 1990), (Sam, 1990)";
		</code></pre>
		<p>
			We want to find all of the years before <var>1993</var>. We could
			manually write <var>[012]</var>, but a faster way would to just use
			the range character:
		</p>
		<pre class="language-javascript"><code>
			const text = "(Bob, 1992), (Anne, 1993), (Jack, 1990), (Sam, 1990)";
			const regex = /199[0-2]/g;
			const result = text.match(regex);
			console.log(result);
		</code></pre>
		<pre class="language-bash"><code>
			[ '1992', '1990', '1990' ]
		</code></pre>
		<p>
			With ranges, we aren't just limited to numbers. We can also use
			ranges of letters:
		</p>
		<pre class="language-javascript"><code>
			const text = "Dan, Han, Ian, Jan";
			const regex = /[a-h]an/gi;
			const result = text.match(regex);
			console.log(result);
		</code></pre>
		<pre class="language-bash"><code>
			[ 'Dan', 'Han' ]
		</code></pre>
		<p>We can also combine numeric and textual ranges:</p>
		<pre class="language-javascript"><code>
			const text = "0xFFFF 0xA89F";
			const regex = /0x[0-9A-F][0-9A-F][0-9A-F][0-9A-F]/g;
			const result = text.match(regex);
			console.log(result);
		</code></pre>
		<pre class="language-bash"><code>
			[ '0xFFFF', '0xA89F' ]
		</code></pre>
	</section>
	<section id="excluding_characters">
		<h3>Excluding Characters</h3>
		<p>
			Sometimes, we want to exclude characters from a pattern. For example,
			suppose we had the following string:
		</p>
		<pre class="language-javascript"><code>
			const text = "1992, 1993, 1989, 1984, 1999";
		</code></pre>
		<p>
			We want to find all of the matches to some year in the ${90}$s. To do
			so, we can write:
		</p>
		<pre class="language-javascript"><code>
			const text = "1992, 1993, 1989, 1984, 1999";
			const regex = /19[^8][0-9]/g;
			const result = text.match(regex);
			console.log(result);
		</code></pre>
		<pre class="language-bash"><code>
			[ '1992', '1993', '1999' ]
		</code></pre>
		<p>
			If the string include years from the ${70}$s or ${60}$s, we can
			exclude a range:
		</p>
		<pre class="language-javascript"><code>
			const text = "1992, 1993, 1973, 1989, 1984, 1999";
			const regex = /19[^0-8][0-9]/g;
			const result = text.match(regex);
			console.log(result);
		</code></pre>
		<pre class="language-bash"><code>
			[ '1992', '1993', '1999' ]
		</code></pre>
	</section>

	<section id="character_set_shorthands">
		<h3>Character Set Shorthands</h3>
		<p>
			Characters are so often used that regular expression syntax provides
			<b>character set shorthands</b> &mdash; shorter ways to denote a
			particular character set. These shorthands are:
		</p>
		<table class="alg">
			<thead>
				<th>Shorthand Character</th>
				<th>Character Set Denoted</th>
				<th>Remark</th>
			</thead>
			<tbody>
				<tr>
					<td>
						<var><mark>\d</mark></var>
					</td>
					<td><var>[0-9]</var></td>
					<td>Matches <i>any one</i> digit character.</td>
				</tr>
				<tr>
					<td>
						<var><mark>\D</mark></var>
					</td>
					<td><var>[^0-9]</var></td>
					<td>Matches <i>any one</i> non-digit character.</td>
				</tr>
				<tr>
					<td>
						<var><mark>\w</mark></var>
					</td>
					<td><var>[a-zA-Z0-9_]</var></td>
					<td>Matches <i>any one</i> word character.</td>
				</tr>
				<tr>
					<td>
						<var><mark>\W</mark></var>
					</td>
					<td><var>[^a-zA-Z0-9_]</var></td>
					<td>Matches <i>any one</i> non-word character.</td>
				</tr>
				<tr>
					<td>
						<var><mark>\s</mark></var>
					</td>
					<td><var>[ \n\r\t\f]</var></td>
					<td>Matches <i>any one</i> space character.</td>
				</tr>
				<tr>
					<td>
						<var><mark>\S</mark></var>
					</td>
					<td><var>[^ \n\r\t\f]</var></td>
					<td>Matches <i>any one</i> non-space character.</td>
				</tr>
			</tbody>
		</table>
	</section>
</section>
<script src="../../../static/numerc/staticArray.js"></script>

{% endblock %}
