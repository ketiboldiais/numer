{% extends '../layout.html' %} {% load static %} {% block description %}
<meta
	name="description"
	content="Notes on regular expressions in JavaScript."
/>
{% endblock %} {% block title %}
<title>JS Regex</title>
{% endblock %} {% block content %}
<h1>Regular Expressions</h1>
<section id="regular_expressions_introduction">
	<p>
		A <b>regular expression</b> is a sequence of characters instructing
		JavaScript on what to search for in a set of data. Regular expressions
		effectively allow us to describe patterns in string type data. For example,
		many
	</p>
	<figure>
		<div>
			<pre class="language-pseudo"><code>
				"The solution's wrong &mdash; there's no decrement; eternal loop!"
			</code></pre>
		</div>
	</figure>
	<p>
		Suppose we wanted to go through this string, removing all of the punctuation
		marks. We could go through each character in the string, checking if it
		falls in a certain range. This isn't wrong, but a better way would be to use
		a <i>regular expression</i> to match punctuation marks, then use a replace
		method to replace the punctuation marks with nothing.
	</p>
	<p>
		Regular expressions are a powerful tool for parsing textual forms of data.
		The most common use cases for regular expressions:
	</p>
	<figure>
		<div>
			<ul>
				<li>
					Checking if a user input (password, email, phone number, etc.)
					complies with a particular criteria.
				</li>
				<li>
					Computing the number of times a particular word occurs in a given
					text.
				</li>
				<li>
					Removing from, or inserting in, certain words or characters in a given
					text.
				</li>
				<li>Analyzing a log file for particular data.</li>
				<li>Analyzing a system's structure given its URL or file path.</li>
			</ul>
		</div>
	</figure>
	<p>
		The concept of a regular expression has been around for nearly as long as
		modern computers. Developed by Stephen Keene in 1950, regular expressions
		were (and still are) extensively used by Unix text processing utilities.
		Most notably, <var>grep</var> (<q
			>Global Search for Regular Expressions and Print Matching</q
		>). As computers grew more pervasive, regular expressions were standardized
		under the POSIX standard.
	</p>
	<p>
		In 1997, The computer scientist Philip Hazel introduced a more modern
		version, PCRE (<q>Pearl Compatible Regular Expressions</q>), which is now
		used by a wide variety of tools and languages. Because of this uniformity,
		regular expressions are largely language-agnostic. While there are some
		differences across regular expression use in particular languages, these
		differences are minor. Much of the syntax and grammar of regular expressions
		is the same, whether we're using JavaScript, Python, Java, C, C++, and so
		on.
	</p>
</section>

<section id="creating_regex">
	<h2>Creating a Regular Expression</h2>
	<p>
		Before we can use a regular expression, we must first create the regular
		expression. In JavaScript, regular expressions are objects. And as we saw
		with objects, there are two ways to create regular expressions. We can use
		object-literal syntax, or we can use a constructor.
	</p>
	<p>For example, here's a method with a constructor:</p>
	<pre class="language-javascript"><code>
		let regex1 = new RegExp("hello");
	</code></pre>
	<p>
		The <var><mark>RegExp()</mark></var> constructor takes as an argument the
		<i>pattern</i> the regular expression will look for.
	</p>
	<p>In contrast, here's the literal syntax:</p>
	<pre class="language-javascript"><code>
		let regex1 = /hello/;
	</code></pre>
	<p>
		In the syntax above, the first forward slash (<var>/</var>) marks the start
		of the pattern, and the second forward slash marks the end of the pattern.
	</p>
	<p>
		Once we have a regex object, we can use the object with JavaScript's
		<var>RegExp</var> methods or the String object wrapper. For example, one
		useful method is <var><mark>.test()</mark></var
		>. This is a method on the regex object, and it has the following syntax:
	</p>
	<ul class="syntax">
		<li>${regex}$.test(${s}$)</li>
	</ul>
	<p>
		Here, ${regex}$ is some regex object, and ${s}$ is some string we want
		tested. The <var>.test()</var> method returns true if the pattern in
		${regex}$ is found, and false otherwise. Illustrating:
	</p>
	<pre class="language-javascript"><code>
		const text        = "CS lessons always have a 'hello world' snippet.";
		const regexHello  = new RegExp('hello');
		const regexWorld  = /world/;
		const regexWorlds = /worlds/;

		const helloIsPresent  = regexHello.test(text);
		const worldIsPresent  = regexWorld.test(text);
		const worldsIsPresent = regexWorlds.test(text);

		console.log(helloIsPresent);
		console.log(worldIsPresent);
		console.log(worldsIsPresent);
	</code></pre>
	<pre class="language-bash"><code>
		true
		true
		false
	</code></pre>
	<p>
		We get back <var>true</var>, as expected. Both <var>/hello/</var> and
		<var>/world/</var> were found.<sup></sup> But, we get false for
		<var>/worlds/</var> because there is no match.
	</p>
	<div class="note">
		<p>
			To differentiate strings from regular expression patterns in discussion,
			we will denote regular expression patterns with forward slashes, and
			string values with double quotes.
		</p>
	</div>
	<p>
		Test isn't the only method we can use. There are two methods on the regex
		object, and four methods for the string object. We examine these methods in
		turn.
	</p>
	<section id="exect">
		<h3>The Exec Method</h3>
		<p>Consider the output of the following code:</p>
		<pre class="language-javascript"><code>
			const text       = "CS lessons always have a 'hello world' snippet.";
			const regexHello = /hello/;
			const regexWorld = /world/;

			const helloExec = regexHello.exec(text);
			const worldExec = regexWorld.exec(text);

			console.log(helloExec);
			console.log(worldExec);
		</code></pre>
		<pre class="language-bash"><code>
			Array(1)
				[
					'hello',
					index : 26,
					input : "CS lessons always have a 'hello world' snippet.",
					length: 1,
					groups: undefined
				]
			Array(1)
				[
					'world',
					index : 32,
					input : "CS lessons always have a 'hello world' snippet.",
					length: 1,
					groups: undefined
				]
		</code></pre>
		<p>
			Notice that we get back arrays. Both of these arrays contain the subsrings
			that matched our regular expression patterns, <var>/hello/</var> and
			<var>/world/</var>. This demonstrates that
			<var><mark>exec()</mark></var> returns an array of the substrings that
			match the regular expression in a given string.
		</p>
		<p>
			There are also several pieces of information &mdash; properties &mdash;
			that accompany the array object returned. First, a property
			<var><mark>index</mark></var
			>, which provides where in the string the match occurred. For example,
			with the matching <var>'hello'</var>, the beginning of the match is at
			index <var>26</var> (the index corresponding to the position of each
			character in the string). With the matching <var>'world'</var>, the
			beginning of the match is at index <var>32</var>.
		</p>
	</section>
</section>

<section id="string_methods">
	<h2>String Methods</h2>
	<p>
		Whenever we create strings in JavaScript, the strings are produced with a
		<var>string</var> object wrapper. This object wrapper provides several
		<i>string methods</i>, four of which can be used with regex objects.
	</p>

	<section id="match">
		<h3>The Match Method</h3>
		<p>The match method has the following syntax:</p>
		<ul class="syntax">
			<li>${s}$.match(${regex}$)</li>
		</ul>
		<p>
			where ${s}$ is a string value, and ${regex}$ is a regular expression. This
			method works like the <var>exec()</var> method. It returns an array
			containing the match (if any), as well as a few other helpful bits of
			information:
		</p>
		<pre class="language-javascript"><code>
			const text = "Toshiro Mifune";
			const regex = /Mifune/;
			const result = text.match(regex);

			console.log(result);
		</code></pre>
		<pre class="language-bash"><code>
			[ 'Mifune', index: 8, input: 'Toshiro Mifune', groups: undefined ]
		</code></pre>
	</section>

	<section id="search">
		<h3>The Search Method</h3>
		<p>
			Alongside the <var>match()</var> method, the string object wrapper also
			provides the <var><mark>search()</mark></var> method. The syntax is the
			same as <var>match()</var>:
		</p>
		<ul class="syntax">
			<li>${s}$.search(${regex}$)</li>
		</ul>
		<p>
			In contrast to <var>match()</var>, <var>search()</var> merely returns the
			index of the matched regex:
		</p>
		<pre class="language-javascript"><code>
			const text = "Toshiro Mifune";
			const regex = /Mifune/;
			const result = text.match(regex);

			console.log(result);
		</code></pre>
		<pre class="language-bash"><code>
			8
		</code></pre>
		<p>
			Notice that this is the same <var>8</var> we saw from <var>match()</var>'s
			output. It's the index where the regex first occurs.
		</p>
		<pre class="language-javascript"><code>
			const text = "Toshiro Mifune";
			const regex = /Mifune/;
			const result = text.search(regex);
			console.log(result);
			console.log('text[8] = %s', text[8]);
		</code></pre>
		<pre class="language-bash"><code>
			8
			text[8] = M
		</code></pre>
		<p>If no match is found, <var>search()</var> returns <var>-1</var>:</p>
		<pre class="language-javascript"><code>
			const text = "Toshiro Mifune";
			const regex = /Maru/;
			const result = text.search(regex);
			console.log(result);
		</code></pre>
		<pre class="language-bash"><code>
			-1
		</code></pre>
	</section>

	<section id="replace">
		<h3>The Replace Method</h3>
		<p>
			Suppose we want to replace a matching substring with a particular string
			value. We can do so with the <var>replace()</var> method. The general
			syntax:
		</p>
		<ul class="syntax">
			<li>${s_p}$.replace(${regex}$, ${s_n}$)</li>
		</ul>
		<p>
			Where ${s_p}$ is an existing string, ${regex}$ is the regular expression
			to match, and ${s_n}$ is the string we want to replace the matching
			${regex}$ with. For example:
		</p>
		<pre class="language-javascript"><code>
			const text = "strawberry pie";
			console.log(text);
			const regex = /pie/;
			const result = text.replace(regex, "cake");
			console.log(result);
			console.log(text);
		</code></pre>
		<pre class="language-bash"><code>
			strawberry pie
			strawberry cake
			strawberry pie
		</code></pre>
		<p>
			Notice how the matching substring <var>pie</var> was replace with
			<var>cake</var>. Importantly, the <var>replace()</var> method does not
			mutate the original string. If we want to use the modified string, we must
			bind it to a variable.
		</p>
		<p>
			Moreover, with the way we're using <var>replace()</var> at the moment, the
			method will only replace the first match it encounters:
		</p>
		<pre class="language-javascript"><code>
			const text = "strawberry pie pie";
			console.log(text);
			const regex = /pie/;
			const result = text.replace(regex, "cake");
			console.log(result);
			console.log(text);
		</code></pre>
		<pre class="language-bash"><code>
			strawberry pie pie
			strawberry cake pie
			strawberry pie pie
		</code></pre>
		<p>
			In later sections, we will see how to replace <em>all</em> instances of a
			regex-matched substring.
		</p>
	</section>

	<section id="split">
		<h3>The Split Method</h3>
		<p>
			Earlier in this volume, we saw the <var><mark>split()</mark></var> method:
		</p>
		<pre class="language-javascript"><code>
			const text = "mango, lychee, rambutan";
			const arr = text.split(', ');
			console.log(arr);
		</code></pre>
		<pre class="language-bash"><code>
			[ 'mango', 'lychee', 'rambutan' ]
		</code></pre>
		<p>
			Using the separator <var>, </var> (a commma followed by a space) we can
			store each substring separated by a commoa and a space in the string
			<var>text</var> as an element in an array. Notice what happens when we use
			a regular expression as a separator:
		</p>
		<pre class="language-javascript"><code>
			const text = "010";
			const regex = /1/;
			const arr = text.split(regex);
			console.log(arr);
		</code></pre>
		<pre class="language-bash"><code>
			[ '0', '0' ]
		</code></pre>
		<p>
			This output conforms with how <var>split()</var> works. By passing a
			regular expression as a separator, the array returned does not include the
			regex-matched substring, since the regex is used as a separator.
		</p>
		<p>
			While ones and zeros are nice, a much more common use of regular
			expressions is to break down a sentence into an array of words. To do so,
			we use the regular expression syntax for a space &mdash;
			<var><mark>\s</mark></var> (backward slash s):
		</p>
		<pre class="language-javascript"><code>
			const text = "One man's constant is another man's variable.";
			const regex = /\s/;
			const arr = text.split(regex);
			console.log(arr);
		</code></pre>
		<pre class="language-bash"><code>
			[ 'One', "man's", 'constant', 'is', 'another', "man's", 'variable.' ]
		</code></pre>
		<p>
			Now we're talking. We turned the string <var>text</var> into an array of
			words. That's very cool.
		</p>
	</section>
</section>

{% endblock %}
