{% extends '../layout.html' %} {% load static %} {% block description %}
<meta name="description" content="Notes on ThreeJS" />
{% endblock %} {% block title %}
<title>ThreeJS</title>
{% endblock %} {% block content %}
<h1>ThreeJS</h1>
<section id="threejs">
	<p>
		<span class="drop">T</span>hreeJS is a JavaScript library that enables
		developers to create 3D visualizations and experiences for the web. We can
		think of it as an abstraction of <span class="term">WebGL</span> (&#8220;Web
		Graphics Library&#8221;).<label for="three" class="margin-toggle"
			><sup></sup
		></label>
		<input type="checkbox" id="three" class="margin-toggle sidenote-number" />
		<span class="marginnote"
			>ThreeJS can also work with SVG and CSS, but because it's geared primarily
			at abstracting WebGL, SVG and CSS functionalities remain limited.</span
		>
		WebGL itself is a JavaScript API that renders triangles. Yes &mdash;
		impressive 3D graphics in websites are done via triangles. These triangle
		renderings are displayed in some HTML element (most commonly, a
		<span class="monoText">canvas</span>). 3D effects result from the fact that
		these triangles are rendered at breathtaking speeds. These speeds are
		possible because WebGL uses the host machine's GPU (Graphic Processing
		Unit). The advantage to using the GPU is because of parallel computation. As
		we know, JavaScript is a single-threaded language. And as a single-threaded
		language, the vast majority of computations &mdash; done by the CPU &mdash;
		can only be done one a time. Those computations are fast, but with graphics,
		visualizations are better rendered with parallel computations &mdash; we
		want to render a gargantuan amount of triangles all at once. For JavaScript,
		this is only feasible through the GPU.
	</p>
	<aside>
		<figure>
			<img
				src="{% static 'images/triangles_cube.svg' %}"
				alt="Triangles form a cube"
				loading="lazy"
				class="seventy-p"
			/>
			<figcaption>Triangles forming a cube</figcaption>
		</figure>
	</aside>
	<p>
		The idea behind rendering triangles is that we position three vertices, and
		state that there are edges connecting them. These instructions are written
		in <span class="term">shaders</span>, a topic we will discuss in later
		sections, and are forwarded to the GPU. The GPU then processes these
		instructions and displays particular colors to the individual pixels bounded
		by the vertices and edges. This is a remarkably fast process. By
		manipulating the positions of various vertices all at once &mdash; which in
		turn changes the colors of the individual pixels all at once &mdash; we can
		create the effect of a 3D dimensional object. The entities that perform
		these manipulations are specified functions. A
		<span class="italicsText">camera</span>, for example, is one such function.
		By manipulating the vertices in a particular way, we create the effect of
		seeing the 3D object from different angles, when in reality, we're just
		changing the position values for many vertices all at once.
	</p>
	<p>
		A fair question we might have is why not just use WebGL directly then?
		Indeed, we can. Many projects in
		<span class="italicsText">haute graphique</span> &mdash; very high-end
		graphics work &mdash; are written directly in WebGL for better control. And
		with better control, the programmer can optimize for performance as needed.
		The tradeoff, however, is that WebGL is painfully difficult to write.
		Drawing a single triangle on an HTML
		<span class="monoText">canvas</span> element would take, at a minimum, a
		hundred lines of code.
	</p>
</section>

<section id="scene">
	<h2>The Scene</h2>
	<p>
		To install ThreeJS, see the
		<a
			href="https://threejs.org/docs/#manual/en/introduction/Installation"
			target="_blank"
			>ThreeJS installation page</a
		>. It's recommended to use ThreeJS via Webpack. With the ThreeJS library
		available, we have access to a variable called
		<span class="monoText"><mark>THREE</mark></span
		>. ThreeJS is structured with classes, and most of these classes are
		accessible via the variable <span class="monoText">THREE</span>.
	</p>
	<p>
		To actually display ThreeJS renderings, we must have some container that
		houses all of the renderings. This is called a
		<span class="term">scene</span>. More generally, to display renderings, we
		need, at a minimum, the following:
	</p>
	<figure>
		<ol class="checklist">
			<li>A scene</li>
			<li>An object</li>
			<li>A camera</li>
			<li>A renderer</li>
		</ol>
	</figure>
	<p>
		The scene is akin to a movie set. It's where all of the objects, models,
		cameras, lights, and more are placed. After we place everything we need in
		that scene, we ask ThreeJS to <span class="italicsText">render</span> the
		scene. To create a scene, we write the following:
	</p>
	<pre class="language-javascript"><code>
		const scene = new THREE.Scene();
	</code></pre>
	<p>
		Writing the above, we've instantiated a scene. We can then place an
		<span class="term">object</span> in that scene. An object is any geometric
		object, or more generally, whatever it is what we want to render. It might
		be a cube, a sphere, a model for a building, person, video game character,
		etc. For now, we'll start with a basic cube.
	</p>
	<p>
		An object is really an abstract term for a <span class="term">mesh</span>. A
		mesh is a combination of two things: (1) a
		<span class="term">geometry</span>, and (2) a
		<span class="term">material</span>. We can think of a geometry as defining
		the object's boundaries in space (i.e., it's shape), and the material as
		defining how the object looks (i.e., it's colors). More accurately, the
		geometry is an abstraction for writing the instruction establishing the
		vertices discussed earlier. ThreeJS provides numerous
		<a
			href="https://threejs.org/docs/#api/en/geometries/BoxGeometry"
			target="_blank"
			>geometries</a
		>
		and
		<a
			href="https://threejs.org/docs/#api/en/materials/LineBasicMaterial"
			target="_blank"
			>materials</a
		>. For our humble cube, we will use the ThreeJS properties
		<span class="monoText"><mark>BoxGeometry</mark></span> and
		<span class="monoText"><mark>MeshBasicMaterial</mark></span
		>:
	</p>
	<pre class="language-javascript"><code>
		const scene = new THREE.Scene();
		const geometry = new THREE.BoxGeometry(1, 1, 1);
		const material = new THREE.MeshBasicMaterial({ color: 'red' });
	</code></pre>
	<p>
		The values <span class="monoText">(1, 1, 1)</span> can be interpreted as any
		unit &mdash; pixels, kilometers, meters, etc. It's entirely up to us how we
		interpret those units. However, once we establish an interpretation, it's
		imperative that we use that interpretation consistently. This is because
		&#8220;units&#8221; in ThreeJS come down to proportions. If we interpret the
		cube as having a length, width, and height of 1 meter, respectively, then we
		must use that interpretation when we place other objects in relation to the
		cube.
	</p>
	<p>
		For the material, notice that we passed an object. In later sections, we'll
		see that materials can easily increase in complexity. And as we know, we
		want to manage increased complexity with various data structures. In this
		case, we use an object. For
		<span class="monoText"><mark>color</mark></span> property, we used a named
		color. We can also use hexadecimal, RGB, and HSL values. Hexadecimal is the
		more common color format, and we can write hexadecimal values directly:
	</p>
	<pre class="language-javascript"><code>
		const scene = new THREE.Scene();
		const geometry = new THREE.BoxGeometry(1, 1, 1);
		const material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
	</code></pre>
	<p>
		With the geometry and material initialized, we can now initialize the mesh:
	</p>
	<pre class="language-javascript"><code>
		const scene = new THREE.Scene();
		const geometry = new THREE.BoxGeometry(1, 1, 1);
		const material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
		const mesh = new THREE.Mesh(geometry, material);
	</code></pre>
	<p>
		We now have a mesh. To see this mesh, however, we must add it to the scene:
	</p>
	<pre class="language-javascript"><code>
		const scene = new THREE.Scene();
		const geometry = new THREE.BoxGeometry(1, 1, 1);
		const material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
		const mesh = new THREE.Mesh(geometry, material);
		scene.add(mesh);
	</code></pre>
	<p>
		We now need a camera. Without a camera, we have no way of seeing what's in
		the scene. ThreeJS provides
		<a
			href="https://threejs.org/docs/#api/en/cameras/ArrayCamera"
			target="_blank"
			>many kinds of cameras</a
		>. For now, we will use a camera called
		<span class="monoText"><mark>PerspectiveCamera</mark></span
		>:
	</p>
	<pre class="language-javascript"><code>
		const scene = new THREE.Scene();
		const geometry = new THREE.BoxGeometry(1, 1, 1);
		const material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
		const mesh = new THREE.Mesh(geometry, material);
		scene.add(mesh);
		const camera = new THREE.PerspectiveCamera()
	</code></pre>
	<p>
		Above, we initialized a new perspective camera called
		<span class="monoText">camera</span>. The perspective camera is designed to
		mimic the way the human eye sees. To get the camera to work, we must provide
		the constructor a few parameters:
	</p>
	<figure>
		<div>
			<ul class="syntax">
				<li>
					new THREE.PerspectiveCamera(${fov}$, ${aspect}$, ${near}$, ${far}$)
				</li>
			</ul>
		</div>
	</figure>
	<p>
		We cover these parameters one at a time. First, the ${fov}$ parameter
		(&#8220;Field-of-view&#8221;) sets the vertical vision angle &mdash; how
		much we can see up and down. This might seem odd, as the intuitive response
		is that our field of view is often measured in terms of the horizontal
		visual angle (i.e., our
		<span class="italicsText">peripheral vision</span>). The game development
		community (often at the forefront of computer graphics), however, has found
		that both development and user experience is much more intuitive when
		working with vertical visual angles. <br /><br />
		With a larger field of view, we see everything everywhere, but the things we
		see appear distorted. With a smaller field of view, we see things as if
		we're peering through a scope. There are less things visible, but the things
		that are visible are proportionate and close.
	</p>
	<p>With the above information, we write:</p>
	<pre class="language-javascript"><code>
		const scene = new THREE.Scene();
		const geometry = new THREE.BoxGeometry(1, 1, 1);
		const material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
		const mesh = new THREE.Mesh(geometry, material);
		scene.add(mesh);
		const camera = new THREE.PerspectiveCamera(75)
	</code></pre>
	<p>
		The second parameter, ${asp}$, establishes the
		<span class="italicsText">aspect ratio</span>. This is simply the width of
		the renderer divided by its height. We will see the renderer shortly, but
		for now, we can think of the width and height as the dimensions of the
		renderer. It's considered best practice to initialize the dimension values
		in an object, then refer to the values via object notation:
	</p>
	<pre class="language-javascript"><code>
		const scene = new THREE.Scene();
		const geometry = new THREE.BoxGeometry(1, 1, 1);
		const material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
		const mesh = new THREE.Mesh(geometry, material);
		scene.add(mesh);
		const sizes = {
			width: 800;
			height: 800;
		}
		const camera = new THREE.PerspectiveCamera(
			75, 
			sizes.width / sizes.height
		)
	</code></pre>
	<p>
		We will examine the other parameters in later sections. But with just the
		two parameters above, we now add the camera to the scene:
	</p>
	<pre class="language-javascript"><code>
		const scene = new THREE.Scene();
		const geometry = new THREE.BoxGeometry(1, 1, 1);
		const material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
		const mesh = new THREE.Mesh(geometry, material);
		scene.add(mesh);
		const sizes = {
			width: 800;
			height: 800;
		}
		const camera = new THREE.PerspectiveCamera(
			75, 
			sizes.width / sizes.height
		)
		scene.add(camera);
	</code></pre>
	<p>
		The final step is to <span class="italicsText">render</span> the scene. This
		is what sets off the process for drawing everything we've written. The
		function that performs the render is called a
		<span class="term">renderer</span>. When the renderer is called, the scene
		is rendered from the camera's point of view, and the result is returned.
		That result is then drawn into the HTML element selected to display the
		result. In our case, we will use a
		<span class="monoText">canvas</span> element. We can either write the
		<span class="monoText">canvas</span> element directly in our HTML document,
		or have ThreeJS do it for us. To simplify things, we'll write the
		<span class="monoText">canvas</span> element directly:
	</p>
	<pre class="language-html"><code>
		&lt;!DOCTYPE html&gt;
		&lt;html lang=&quot;en&quot;&gt;
		&lt;head&gt;
		&#x9;&lt;meta charset=&quot;UTF-8&quot;&gt;
		&#x9;&lt;title&gt;ThreeJS Lab&lt;/title&gt;
		&lt;/head&gt;
		&lt;body&gt;
		<span class="redText">&#x9;&lt;canvas class=&quot;webgl&quot;&gt;&lt;/canvas&gt;</span>
			&lt;script src=&quot;./three.min.js&quot;&gt;&lt;/script&gt;
			&lt;script src=&quot;./script.js&quot;&gt;&lt;/script&gt;
		&lt;/body&gt;
		&lt;/html&gt;
	</code></pre>
	<p>
		Ignore the class attribute <span class="monoText">"webgl"</span> for now. We
		will use it in a later section. The main point is that there's a
		<span class="monoText">canvas</span> element inside the HTML document we're
		working with. The HTML <span class="monoText">canvas</span> element itself
		is just an element that allows us to draw objects in via JavaScript. By
		calling the renderer, ThreeJS will use WebGL to draw the render inside the
		<span class="monoText">canvas</span>.
	</p>
	<p>
		That said, before we add the renderer, we must first create it. Like
		<span class="monoText">material</span> a renderer can easily grow complex.
		Accordingly, we use an object containing several properties. One of those
		properties is the <span class="monoText">canvas</span> element. Thus, we
		must target the <span class="monoText">canvas</span> element and store it as
		a property:
	</p>
	<pre class="language-javascript"><code>
		const scene = new THREE.Scene();
		const geometry = new THREE.BoxGeometry(1, 1, 1);
		const material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
		const mesh = new THREE.Mesh(geometry, material);
		scene.add(mesh);
		const sizes = {
			width: 800;
			height: 800;
		}
		const camera = new THREE.PerspectiveCamera(
			75, 
			sizes.width / sizes.height
		)
		scene.add(camera);
		const canvas = document.querySelector('.webgl');
		const renderer = new THREE.WebGLRenderer({
			canvas: canvas;
		});
	</code></pre>
	<p>
		If we refresh the HTML page, we'd see black rectangle, no cube in sight. To
		see our cube, we must first give the renderer a size:
	</p>
	<pre class="language-javascript"><code>
		const scene = new THREE.Scene();
		const geometry = new THREE.BoxGeometry(1, 1, 1);
		const material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
		const mesh = new THREE.Mesh(geometry, material);
		scene.add(mesh);
		const sizes = {
			width: 800;
			height: 800;
		}
		const camera = new THREE.PerspectiveCamera(
			75, 
			sizes.width / sizes.height
		)
		scene.add(camera);
		const canvas = document.querySelector('.webgl');
		const renderer = new THREE.WebGLRenderer({
			canvas: canvas;
		});
		renderer.setSize(sizes.width, sizes.height);
	</code></pre>
	<p>
		When we resize the renderer, we resize the canvas. This is why we see the
		size of the black rectangle increase. Next, we must call the
		<span class="monoText">render()</span> function:
	</p>
	<pre class="language-javascript"><code>
		const scene = new THREE.Scene();
		const geometry = new THREE.BoxGeometry(1, 1, 1);
		const material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
		const mesh = new THREE.Mesh(geometry, material);
		scene.add(mesh);
		const sizes = {
			width: 800;
			height: 800;
		}
		const camera = new THREE.PerspectiveCamera(
			75, 
			sizes.width / sizes.height
		)
		scene.add(camera);
		const canvas = document.querySelector('.webgl');
		const renderer = new THREE.WebGLRenderer({
			canvas: canvas;
		});
		renderer.setSize(sizes.width, sizes.height);
		renderer.render(scene, camera);
	</code></pre>
	<p>
		Even with the code above, we still don't see a cube. Why? Because the camera
		is actually <span class="underlineText">inside</span> the cube. We have to
		move the camera away from the cube. To move the camera &mdash; and really,
		to move any object &mdash; we use the following properties (where ${obj}$ is
		an object):
	</p>
	<ul class="ruled">
		<li>
			<span class="monoText"><mark>${obj}$.position</mark></span>
		</li>
		<ul>
			<li>
				The <span class="monoText">position</span> property is an object literal
				with three properties: <span class="monoText"><mark>x</mark></span
				>, <span class="monoText"><mark>y</mark></span
				>, and <span class="monoText"><mark>z</mark>.</span> Each of these
				properties represents the ${x}$-, ${y}$-, and ${z}$-axis values
				respectively.
			</li>
			<li>
				Note that axis interpretation varies widely across libraries. In
				ThreeJS, the ${x}$-axis is interpreted as left-right movement, the
				${y}$-axis as up-down movement, and the ${z}$-axis is forward-backward
				movement.
			</li>
		</ul>
		<li>
			<span class="monoText"><mark>${obj}$.rotation</mark></span>
		</li>
		<ul>
			<li>
				The <span class="monoText"><mark>rotation</mark></span> property
				represents an object's local rotation, in
				<span class="underlineText">radians</span>.
			</li>
		</ul>
		<li>
			<span class="monoText"><mark>${obj}$.scale</mark></span>
		</li>
		<ul>
			<li>
				The <span class="monoText"><mark>scale</mark></span> property represents
				an object's local scale.
			</li>
		</ul>
	</ul>
	<p>
		Knowing these properties, we want to move the camera backwards (i.e.,
		towards us):
	</p>
	<pre class="language-javascript"><code>
		const scene = new THREE.Scene();
		const geometry = new THREE.BoxGeometry(1, 1, 1);
		const material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
		const mesh = new THREE.Mesh(geometry, material);
		scene.add(mesh);
		const sizes = {
			width: 800;
			height: 800;
		}
		const camera = new THREE.PerspectiveCamera(
			75, 
			sizes.width / sizes.height
		)
		camera.position.z = 3; // move the camera
		scene.add(camera);
		const canvas = document.querySelector('.webgl');
		const renderer = new THREE.WebGLRenderer({
			canvas: canvas;
		});
		renderer.setSize(sizes.width, sizes.height);
		renderer.render(scene, camera);
	</code></pre>
	<p>
		We should now see a red square. It is actually a cube, we just need to move
		the camera to the right:
	</p>
	<pre class="language-javascript"><code>
		const scene = new THREE.Scene();
		const geometry = new THREE.BoxGeometry(1, 1, 1);
		const material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
		const mesh = new THREE.Mesh(geometry, material);
		scene.add(mesh);
		const sizes = {
			width: 800;
			height: 800;
		}
		const camera = new THREE.PerspectiveCamera(
			75, 
			sizes.width / sizes.height
		)
		camera.position.z = 3; // move the camera back
		camera.position.x = 2; // move the camera right
		scene.add(camera);
		const canvas = document.querySelector('.webgl');
		const renderer = new THREE.WebGLRenderer({
			canvas: canvas;
		});
		renderer.setSize(sizes.width, sizes.height);
		renderer.render(scene, camera);
	</code></pre>
</section>

<section id="transforming_objects">
	<h2>Transforming Objects</h2>
	<p>
		To <span class="term">transform</span> an object is to modify some property
		of the object. Transformation is the first step towards
		<span class="italicsText">animating</span> the object. In ThreeJS, the four
		properties most relevant to transformation are:
	</p>
	<figure>
		<ul>
			<li>
				<span class="monoText"><mark>position</mark></span>
			</li>
			<li>
				<span class="monoText"><mark>scale</mark></span>
			</li>
			<li>
				<span class="monoText"><mark>rotation</mark></span>
			</li>
			<li>
				<span class="monoText"><mark>quaternion</mark></span>
			</li>
		</ul>
	</figure>
	<p>
		All of these properties originate in a class called
		<span class="monoText"><mark>Object3D</mark>.</span> From the
		<span class="monoText">Object3D</span> class we have classes like
		<span class="monoText">PerspectiveCamera</span> and
		<span class="monoText">Mesh</span>.
	</p>
	<section id="position">
		<h3>The Position Property</h3>
		<p>
			As stated earlier, the <span class="monoText">position</span> property
			originates in the class <span class="monoText">Object3D</span>. Thus, any
			object whose ancestor class is <span class="monoText">Object3D</span> has
			a <span class="monoText">position</span> property. The
			<span class="monoText">position</span> property itself is a combination of
			three properties:
		</p>
		<ul class="ruled">
			<li>
				<span class="monoText">${Obj}$.x</span>
			</li>
			<ul>
				<li>Sets the ${x}$-axis coordinate.</li>
			</ul>
			<li>
				<span class="monoText">${Obj}$.y</span>
			</li>
			<ul>
				<li>Sets the ${y}$-axis coordinate.</li>
			</ul>
			<li>
				<span class="monoText">${Obj}$.z</span>
			</li>
			<ul>
				<li>Sets the ${z}$-axis coordinate.</li>
			</ul>
		</ul>
		<p>For example, using the same code from the previous section:</p>
		<pre class="language-javascript"><code>
			mesh.position.y = 1; // move the mesh up by 1
			mesh.position.y = -1; // move the mesh down by 1

			mesh.position.x = 1; // move the mesh right by 1
			mesh.position.x = -1; // move the mesh down by 1

			mesh.position.z = 1; // move the mesh forward by 1
			mesh.position.z = -1; // move the mesh back by 1
		</code></pre>
		<p>We can also update all three positions in a single line:</p>
		<pre class="language-javascript"><code>
			/*
			 * Move the mesh right, up, forward by 1.
			*/
			mesh.position.set(1, 1, 1); 
		</code></pre>
		<p>When using the single-line approach, the syntax is:</p>
		<figure>
			<ul class="syntax">
				<li>${Obj}$.position.set(${x}$, ${y}$, ${z}$)</li>
			</ul>
		</figure>
		<p>
			Although the comments to the code above are true, they are true insofar as
			we are using a perspective camera. Interpreting the axes entirely depends
			on the camera &mdash; which establishes
			<span class="italicsText">our</span> position when we view the object. If
			we think about this carefully, this makes perfect sense. The word
			&#8220;right&#8221; and &#8220;left&#8221; are entirely subjective; hence
			the existence of questions like &#8220;My left or your left?&#8221; The
			same goes for &#8220;up&#8221; and &#8220;down.&#8221; If van Helsing
			stands on the floor while Dracula suspends from the ceiling, Helsing's
			&#8220;down&#8221; is Dracula's &#8220;up,&#8221; and Dracula's
			&#8220;up&#8221; is Helsing's &#8220;down.&#8221; The words
			&#8220;forward&#8221; and &#8220;backward&#8221; are not immune either. If
			Don Quixote stands in front of a car and the car reverses towards Panza,
			the car is moving &#8220;backward&#8221; from Don Quixote and
			&#8220;forward&#8221; towards Panza.
		</p>
		<p>
			Equally arbitrary is the number we used above,
			<span class="monoText">1.</span> The distance of ${1}$ unit is entirely
			determined by our interpretation. We can think of it was 1 nanometer, 1
			meter, 1 mile, 1 lightyear, and so on. As stated in the earlier section,
			distances in ThreeJS are measured in terms of proportions. Thus, once
			we've settled on an interpretation, we must keep that interpretation in
			mind when we use numbers for other objects.
		</p>
		<p>
			The <span class="monoText">position</span> property also inherits from a
			class called <span class="monoText"><mark>Vector3</mark></span
			>. The <span class="monoText">Vector3</span> class contains numerous
			methods we will use extensively. One such method is
			<span class="monoText"><mark>.length()</mark></span
			>:
		</p>
		<pre class="language-javascript"><code>
			mesh.position.x = 0.7;
			mesh.position.y = -0.6;
			mesh.position.z = 1;
			console.log(mesh.position.length());
		</code></pre>
		<pre class="language-bash"><code>
			1.3601470508735443
		</code></pre>
		<p>
			The output above is effectively how far our mesh is from the scene's
			center. We can also obtain the distance between the object and the camera
			(note that there must be a camera before we asking for the distance to the
			camera):
		</p>
		<pre class="language-javascript"><code>
			mesh.position.x = 0.7;
			mesh.position.y = -0.6;
			mesh.position.z = 1;

			// after the camera initialization

			console.log(mesh.position.distanceTo(camera.position));
		</code></pre>
		<pre class="language-bash"><code>
			2.202271554554524
		</code></pre>
		<p>
			One particularly useful method is
			<span class="monoText"><mark>.normalize()</mark></span
			>. This method will take the length of a particular vector, and reduce it
			to a length of <span class="monoText">1</span>:
		</p>
		<pre class="language-javascript"><code>
			mesh.position.x = 0.7;
			mesh.position.y = -0.6;
			mesh.position.z = 1;

			mesh.position.normalize();
		</code></pre>
		<section id="position_helper">
			<h4>Axes Helper</h4>
			<p>
				Because axes can get confusing when working with many different cameras,
				ThreeJS provides a tool called
				<span class="monoText"><mark>AxesHelper</mark></span
				>. This is just a visualization of the axes we're working with. To
				create it, we write the code below. Note that because the axes helper is
				an object, it must be added to the scene:
			</p>
			<pre class="language-javascript"><code>
				const axesHelper = new THREE.AxesHelper();
				scene.add(axesHelper);
			</code></pre>
			<p>
				With the axes helper, the axes are color-coded, each with a length of
				<span class="underlineText">1 unit</span>:
			</p>
			<figure>
				<ul>
					<li>
						The
						<span class="redText">red</span> line corresponds to the
						<span class="redText">${\text{$x$-axis}}$</span>
					</li>
					<li>
						The
						<span class="greenText">green</span> line corresponds to the
						<span class="greenText">${\text{$y$-axis}}$</span>
					</li>
					<li>
						The
						<span class="blueText">blue</span> line corresponds to the
						<span class="blueText">${\text{$z$-axis}}$</span>
					</li>
				</ul>
			</figure>
			<p>
				With the perspective camera set to default, we likely do not see the
				${\text{$z$-axis}}$ line. This is because the perspective camera, by
				default, points straight ahead. To see the ${\text{$z$-axis},}$ we must
				change the camera position:
			</p>
			<pre class="language-javascript"><code>
				const axesHelper = new THREE.AxesHelper();
				scene.add(axesHelper);

				// camera initialized

				camera.position.z = 3;
				camera.position.y = 1;
				camera.position.x = 1;
				scene.add(camera);
			</code></pre>
		</section>
	</section>

	<section id="scale">
		<h3>Scale</h3>
		<p>
			Like the position property, the
			<span class="monoText"><mark>scale</mark></span> property is also a
			<span class="monoText">Vector3</span>. The
			<span class="monoText">scale</span> property will change the scale (i.e.,
			the unit proportions) of the particular object. For example, the default
			value of each axis is ${1.}$ We can change this default value by modifying
			the <span class="monoText">scale</span> property:
		</p>
		<pre class="language-javascript"><code>
			mesh.scale.x = 2; // change the x-axis scale to 2
			mesh.scale.y = 3; // change the y-axis scale to 3
			mesh.scale.z = 0.5; // change the z-axis scale to 0.5
		</code></pre>
	</section>

	<section id="rotating_objects">
		<h3>Rotating Objects</h3>
		<p>To rotate objects, we have two properties available for modification:</p>
		<figure>
			<ul>
				<li>
					<span class="monoText">
						<mark>rotation</mark>
					</span>
				</li>
				<li>
					<span class="monoText">
						<mark>quaternion</mark>
					</span>
				</li>
			</ul>
		</figure>
		<p>
			Modifying either of the properties above will achieve a rotation.
			Importantly, updating one will update the other. Let's first consider the
			<span class="monoText">rotation</span> property.
		</p>
		<p>With <span class="monoText">rotation</span>, there three properties:</p>
		<ul>
			<li>
				<span class="monoText"><mark>x</mark></span
				>, which sets the ${\text{$x$-axis}}$ angle in radians, the default
				being ${0.}$
			</li>
			<li>
				<span class="monoText"> <mark>y</mark></span
				>, which sets the ${\text{$y$-axis}}$ angle in radians, the default
				being ${0.}$
			</li>
			<li>
				<span class="monoText"><mark>z</mark></span
				>, which sets the ${\text{$z$-axis}}$ angle in radians, the default
				being ${0.}$
			</li>
		</ul>
		<p>
			Each of these properties inherits from a class called
			<span class="monoText"><mark>Euler</mark></span
			>. The idea behind <span class="monoText">rotation</span> is that the
			object rotates about a stick piercing through the center of the object.
			Thus, when we use the <span class="monoText">rotation</span> property, we
			must think about which axis we're rotating the object on (i.e., from which
			direction the stick pierces through the object).
		</p>
		<figure>
			<img
				src="{% static 'images/euler_rotation.svg' %}"
				alt="Euler rotation"
				loading="lazy"
				class="forty-p"
			/>
			<figcaption>
				As always, bear in mind that the axes are entirely dependent on where we
				view the object (i.e., the camera's position).
			</figcaption>
		</figure>
		<p>Stating the rotations follows the usual dot notation:</p>
		<pre class="language-javascript"><code>
			mesh.rotation.x = 0.5 // rotate about the x-axis
			mesh.rotation.y = 0.5 // rotate about the y-axis
			mesh.rotation.z = 0.5 // rotate about the z-axis
		</code></pre>
		<p>
			Because the rotations are measured in radians, a rotation value of ${\pi}$
			results in rotation equivalent to ${{180}^\circ,}$ and a value of ${2
			\pi}$ results in a full revolution, ${{360}^\circ.}$
		</p>
		<pre class="language-javascript"><code>
			// rotate about the y-axis half a circle
			mesh.rotation.y = Math.pi

			// rotate about the z-axis a full circle
			mesh.rotation.z = 2 * MATH.pi 
		</code></pre>
		<section id="gimbal_lock">
			<h4>Gimbal Lock</h4>
			<p>
				We must take care when working with rotations. Whenever we rotate an
				axis, we might unintentionally rotate the other axis. This is because
				the <span class="monoText">rotation</span> property always follows the
				order <span class="monoText">x</span>, <span class="monoText">y</span>,
				and <span class="monoText">z</span>. Consider the illustration above. If
				we rotate the object about the ${\text{$z$-axis}}$ by ${\pi / 2,}$ the
				${\text{$y$-}}$ and ${\text{$z$-axes}}$ point in different directions:
			</p>
			<figure>
				<img
					src="{% static 'images/euler_rotation2.svg' %}"
					alt="Euler rotation"
					loading="lazy"
					class="forty-p"
				/>
			</figure>
			<p>
				Moreover, because these axes are arbitrary (it depends on the camera's
				position), we can mistakenly rotate, say, the ${\text{$x$-axis}}$ when
				we actually intended to rotate the ${\text{$y$-axis}.}$ If we rotate an
				axis far enough, we can get into a situation called a
				<span class="term">gimbal lock</span> &mdash; a phenomenon where it
				appears as if one of the axes is stuck, or doesn't work anymore.
			</p>
			<p>
				One way to avoid this problem is to change the default order with the
				<span class="monoText"><mark>.reorder()</mark></span> method:
			</p>
			<pre class="language-javascript"><code>
				// change the rotation order to y-, x-, z-axis
				mesh.rotation.reorder('yxz')
				// rotations
			</code></pre>
			<p>
				The last comment above is included to indicate that the reordering must
				occur before we rotate.
			</p>
			<p>
				As we can likely tell, it seems tedious to have to write these
				reorderings over and over again before rotations. Because of this
				nuisance, ThreeJS provides another property for rotation,
				<span class="monoText"><mark>quaternion</mark></span
				>. We will cover quaternions in a later section, but the idea behind the
				quaternion is that we can use some algebra to ensure rotations are
				consistent. Because the mathematics is fairly involved, we will devote
				an entire section for quaternions in a later discussion.
			</p>
		</section>
	</section>
	<section id="look_at">
		<h3>Look at a Particular Point</h3>
		<p>
			When working with transformations, it's often helpful to keep the camera
			pointed at a particular point. This way, no matter how we transform the
			object, the camera points at a constant location, allowing us some
			uniformity in evaluating transformations. To do so, we use
			<span class="monoText"><mark>lookAt()</mark></span
			>, a method available to all
			<span class="monoText">Object3D</span> instances (e.g., cameras):
		</p>
		<pre class="language-javascript"><code>
			// initialize camera
			camera.lookAt(new THREE.Vector(0, -1, 0));
		</code></pre>
		<p>
			By writing the code above, the camera will always point at the coordinate
			${(0, -1, 0).}$ This coordinate, however, may or may not be on the mesh.
			If we wanted to keep the camera pointed at the mesh, we can use the mesh's
			position property:
		</p>
		<pre class="language-javascript"><code>
			// initialize camera and mesh
			camera.lookAt(mesh.position);
		</code></pre>
		<p>
			With the above code, the camera now always points to the center of the
			mesh.
		</p>
	</section>
	<section id="grouping_objects">
		<h3>Grouping</h3>
		<p>
			From our discussion thus far, it should be obvious that transforming
			objects can lead to many lines of code. Because of this fact, it's best
			practice to <span class="italicsText">group</span> objects whenever
			possible. For example, 3D rendering of a house might consist of many
			component 3D renderings &mdash; the rendering for a door, a table, the
			walls, a roof, and so on. If the house is just one rendering in a bigger
			rendering of, say, a landscape, we do not want to have to move each of the
			component renderings one-by-one. Instead, we should gather all of these
			component renderings into a group, then manipulate the properties for that
			group. If we want to move the house to another position in the landscape,
			we manipulate the position property for the house, rather than the
			position property for the walls, roof, table, lamp, and so on.
		</p>
		<p>
			To make a group, we use the
			<span class="monoText"><mark>group()</mark></span> method:
		</p>
		<pre class="language-javascript"><code>
			// create two cubes
			const cube1 = new THREE.mesh(
				new THREE.BoxGeometry(1,1,1),
				new THREE.MeshBasicMaterial({color: 0xff0000})
			);
			const cube2 = new THREE.mesh(
				new THREE.BoxGeometry(1,1,1),
				new THREE.MeshBasicMaterial({color: 0x00ff00})
			);

			// create the group
			const group1 = new Three.Group();

			// add the cubes to the group
			group1.add(cube1, cube2);

			// add the group to the scene
			scene.add(group1);
		</code></pre>
		<p>
			Notice that we used slightly different syntax to instantiate the meshes.
			We can directly pass the properties into the constructor. Importantly, we
			must remember to always add our groups to the scene. Otherwise, we won't
			see anything displayed.
		</p>
		<p>
			With the two cubes in a group, we can transform them all together by
			transforming the group:
		</p>
		<pre class="language-javascript"><code>
			group.position.y = 1; // move the group by 1 on the y-axis
		</code></pre>
	</section>
</section>

<section id="introduction_to_animations">
	<h2>A Brief Look at Animations</h2>
	<p>
		Animating in ThreeJS &mdash; and JavaScript more generally &mdash; is
		analogous to stop motion animations. The idea is that we move points
		slightly, take a picture, move points again, take a picture, move points
		again, take a picture, and so on. The act of &#8220;take a picture&#8221; is
		rendering. Take many, many pictures and present them one at time very
		quickly &mdash; we create the illusion of movement.
	</p>

	<section id="frame_rates">
		<h3>Frame Rates</h3>
		<p>
			The speed at which the pictures are shown (or, in flipbookese, how fast we
			flip through book), is called a <span class="term">frame rate</span>, and
			it's usually measured in the unit FPS (Frames Per Second). With higher
			frame rates, &#8220;motion&#8221; appears smooth or fluid (think high-end
			video games like <span class="italicsText">Diablo III</span>). With lower
			frame rates, motion appears choppy (think some silly GIF).
		</p>
		<div class="mainIdea">
			<p>
				Frame rate: The frequency at which consecutive images are captured or
				displayed.
			</p>
		</div>
		<p>
			Higher frame rates, however, do not imply better viewing experience. In
			fact, the topic of an &#8220;ideal framerate&#8221; is subject to fiery
			debate. Many of the movies and TV shows we see run at ${24 \text{ FPS}.}$
			For cinematography, productions using frame rates beyond ${24 \text{
			FPS}}$ tend to suffer from a phenomenon called the
			<span class="italicsText">soap opera effect</span> (take a look at clip
			from a product like
			<span class="italicsText">Days of our Lives</span> &mdash; it has a
			distinctive &#8220;look.&#8221;) Video games, at a minimum, generally run
			on ${60 \text{ FPS}.}$
		</p>
		<p>
			Furthermore, a viewing experience is also impacted by
			<span class="term">frame time</span> &mdash; how long a frame stays in
			view. We can have a frame rate of ${60 \text{ FPS},}$ but if frame times
			are inconsistent (e.g., one frame lasts for ${2 \text{ mS}}$ and another
			${5 \text{ mS},}$) we see phenomenon called
			<span class="term">stuttering</span> &mdash; small &#8220;pauses&#8221; or
			&#8220;stills&#8221; in the motion.
		</p>
		<p>
			The issue with frame rates and animations is that computers have different
			frame rates. Many computers run on ${60 \text{ FPS,}}$ but more powerful
			computers can run on ${120 \text{ FPS}.}$ Because of these variations, if
			we animated a spinning propeller, the propeller might appear to spin much,
			much faster on machines with higher frame rates. This is not what we want.
			Our animations must look the same, regardless of the machine's frame rate.
		</p>
		<p>
			Before we solve this problem, let's talk about how to animate to begin
			with. The JavaScript API provides a method that allows us to take the
			pictures we need:
		</p>
		<figure>
			<ul class="syntax">
				<li>window.requestAnimationFrame(${f_c}$)</li>
			</ul>
			<figcaption>
				where ${f_c}$ is a <span class="italicsText">callback function</span>.
			</figcaption>
		</figure>
		<p>
			The procedure for animating is to pass object transformations into the
			<span class="monoText">requestAnimationFrame()</span> method, perform the
			renderings therein, then call the
			<span class="monoText">requestAnimationFrame()</span> in the next call.
			This is a little tricky to think about, but we can clarify by thinking of
			the method's purpose: The purpose of
			<span class="monoText">requestAnimationFrame()</span> is to call a
			function provided in the <span class="underlineText">next</span> frame. To
			perform animations, we must always keep this fact in the back of our
			minds. The method <span class="monoText">requestAnimationFrame()</span>,
			despite its name, is <span class="underlineText">not</span> a function
			that performs animations; it's a function that calls some function in the
			next frame just once.
		</p>
		<p>
			For example, suppose we've instantiated all of our meshes and cameras, and
			added them to the scene. To animate our mesh, we first need the callback
			function:
		</p>
		<pre class="language-javascript"><code>
			const tick = () => {
				window.requestAnimationFrame(tick);
			};
			tick();
		</code></pre>
		<p>
			By writing the function above, we are telling JavaScript to call the
			<span class="monoText">tick</span> function on the next frame, then on
			that frame, call the <span class="monoText">tick</span> function on the
			next frame, and on the next frame, and so on.
		</p>
		<p>
			Because the <span class="monoText">tick()</span> function is constantly
			being called at different times, we can pass our transformations and
			renderings into the <span class="monoText">tick()</span> function. Using
			some ThreeJS methods that update the transformations and renderings, we
			effectively modify object properties many, many times:
		</p>
		<pre class="language-javascript"><code>
			const tick = () => {
				// update object properties
				mesh.position.x += 0.01;

				// render
				renderer.render(scene, camera);

				// call the tick function for the next frame
				window.requestAnimationFrame(tick);
			};
			tick();
		</code></pre>
		<p>
			The code above will display the mesh moving along the ${x}$-axis. If we
			instead wrote:
		</p>
		<pre class="language-javascript"><code>
			const tick = () => {
				// update object properties
				mesh.rotation.y += 0.01;

				// render
				renderer.render(scene, camera);

				// call the tick function for the next frame
				window.requestAnimationFrame(tick);
			};
			tick();
		</code></pre>
		<p>
			We would see our mesh rotating about the ${y}$-axis. At this point, we now
			run into our previous problem. On a machine with a higher frame rate, the
			mesh would move or rotate much faster than a machine with a lower frame
			rate. This is because the number of calls to the
			<span class="monoText">tick()</span> equals the number of frames per
			second. More frames per second &mdash; more calls to
			<span class="monoText">tick()</span> &mdash; more updates to the
			properties.
		</p>
		<p>
			There are many ways to solve this problem. A common solution is to
			<span class="italicsText">adapt to the framerate</span>. The idea behind
			this solution is to use a <span class="term">timestamp</span> of the
			current time, or date. Because the timestamp will be the same for all
			users, regardless of frame rate, we can use the timestamp as a common
			starting point for all viewers. With the timestamp, we compare the current
			timestamp against the previous timestamp. Because both timestamps are
			constant, the difference between the two timestamps is constant. We'll
			call this difference <span class="monoText">deltaTime</span>. Because
			<span class="monoText">deltaTime</span> is constant, we can then use it to
			establish uniformity across frame rates.
		</p>
		<p>
			To initialize a timestamp, we use the native method
			<span class="monoText"><mark>Date.now()</mark>:</span>
		</p>
		<pre class="language-javascript"><code>
			let previousTime = Date.now();
			const tick = () => {
				// current time for frame
				const currentTime = Date.now();
				
				// elapsed time
				const deltaTime = currentTime - previousTime;

				// update the previous time for the next tick to use
				previousTime = currentTime;

				// update object properties
				mesh.rotation.y += 0.01;

				// render
				renderer.render(scene, camera);

				// call the tick function for the next frame
				window.requestAnimationFrame(tick);
			};
			tick();
		</code></pre>
		<p>
			Because the <span class="monoText">deltaTime</span> value is constant,
			multiplying that value with the values for property updates creates
			uniformity across frame rates:
		</p>
		<pre class="language-javascript"><code>
			let previousTime = Date.now();
			const tick = () => {
				// current time for frame
				const currentTime = Date.now();
				
				// elapsed time
				const deltaTime = currentTime - previousTime;

				// update the previous time for the next tick to use
				previousTime = currentTime;

				// update object properties
				mesh.rotation.y += 0.01 * deltaTime;

				// render
				renderer.render(scene, camera);

				// call the tick function for the next frame
				window.requestAnimationFrame(tick);
			};
			tick();
		</code></pre>
		<p>
			Another fix is to use ThreeJS's built-in solution,
			<span class="monoText"><mark>Clock()</mark></span
			>. The <span class="monoText">Clock</span> object provides a method called
			<span class="monoText">getElapsedTime()</span>, which essentially computes
			the <span class="monoText">deltaTime</span> we saw earlier:
		</p>
		<pre class="language-javascript"><code>
			const clock = new THREE.Clock();
			const tick = () => {
				// elapsed time
				const deltaTime = clock.getElapsedTime();

				// update object properties
				mesh.rotation.y = deltaTime;

				// render
				renderer.render(scene, camera);

				// call the tick function for the next frame
				window.requestAnimationFrame(tick);
			};
			tick();
		</code></pre>
		<p>
			Importantly, the <span class="monoText">getElapsedTime()</span> method
			returns the elapsed time in seconds. Because this is a number value that
			changes, we can assign this number directly to
			<span class="monoText">mesh.rotation.y</span>. If we want to perform 1
			revolution per second:
		</p>
		<pre class="language-javascript"><code>
			const clock = new THREE.Clock();
			const tick = () => {
				// elapsed time
				const deltaTime = clock.getElapsedTime();

				// update object properties
				mesh.rotation.y = deltaTime * Math.PI * 2;

				// render
				renderer.render(scene, camera);

				// call the tick function for the next frame
				window.requestAnimationFrame(tick);
			};
			tick();
		</code></pre>
		<p>
			If we want animations that cycle through various movements, we rely on
			trigonometry. We know that the functions ${y = \sin x,}$ ${y = \cos x,}$
			${y = \tan x,}$ and their inverses are all cyclical functions.
			Accordingly, we can use this fact to perform repetitive animations, like a
			mesh oscillating up and down:
		</p>
		<pre class="language-javascript"><code>
			const clock = new THREE.Clock();
			const tick = () => {
				// elapsed time
				const deltaTime = clock.getElapsedTime();

				// update object properties
				mesh.rotation.y = Math.sin(elapsedTime);

				// render
				renderer.render(scene, camera);

				// call the tick function for the next frame
				window.requestAnimationFrame(tick);
			};
			tick();
		</code></pre>
	</section>
</section>

<section id="cameras">
	<h2>Cameras</h2>
	<p>In this section, we discuss cameras in further detail.</p>
	<section id="camera">
		<h3>Perspective Camera</h3>
		<p>
			The perspective camera renders a scene with perspective. For example, here
			is a camera initialization:
		</p>
		<pre class="language-javascript"><code>
			const sizes = {
				width: 800,
				height: 600
			}
			const camera = new THREE.PerspectiveCamera(100, sizes.width / sizes.height, 1, 3);
			camera.position.x = 2;
			camera.position.y = 2;
			camera.position.z = 2;
		</code></pre>
		<p>
			Click on the underlined parts of the template below for an explanation of
			each argument:
		</p>
		<figure>
			<ul class="syntax">
				<li>
					let cam = new THREE.PerspectiveCamera(<span class="pop">${fov}$</span
					>, <span class="pop">${asp}$</span>,
					<span class="pop">${near}$</span>, <span class="pop">${far}$</span>)
				</li>
				<div class="popText">
					<p>
						This is the
						<span class="boldText">Field of View (FOV)</span> parameter. It's
						measured in degrees, and essentially returns the vertical vision
						angle &mdash; how much we can see up and down.
					</p>
				</div>
				<div class="popText">
					<p>
						This is <span class="boldText">aspect</span> argument. By default,
						it is set to 1. In the code above, we used an object. We can think
						of this as setting how much area the camera covers (i.e., the canvas
						size).
					</p>
				</div>
				<div class="popText">
					<p>
						This is the <span class="boldText">near</span> argument, effectively
						how &#8220;close&#8221; an object is to the camera. Any object
						closer than this value will not be seen.
					</p>
				</div>
				<div class="popText">
					<p>
						This is the <span class="boldText">far</span> argument, how
						&#8220;far&#8221; the object is to the camera. Any object farther
						than this value will not be seen.
					</p>
				</div>
			</ul>
		</figure>
		<p>
			<span class="topic">FOV Parameter.</span>
			The larger the FOV argument, the more likely we are to distort the
			objects. Beyond ${{75}^\circ,}$ objects begin looking very small. Often,
			it's best to stay within the range of ${{45}^\circ}$ through
			${{75}^\circ.}$
		</p>
		<p>
			<span class="topic">Aspect Ratio Parameter.</span>
			The aspect ratio argument is a ratio of width:height. We can think of this
			as setting the width and the height of the render.
		</p>
		<p>
			<span class="topic">Near & Far Parameters.</span> The near and far
			parameters correspond to how close and how far the camera can see. If an
			object is (1) closer than near, or (2) further than far, then the object
			will not be seen.
		</p>
		<p>
			A common mistake with this parameter is setting
			<span class="monoText">near = 0.0001</span> and
			<span class="monoText">far = 99999</span>. Although this largely keeps
			objects within view, it almost always introduces a bug called
			<span class="term">z-fighting</span>. When two objects are too close to
			one another along the ${z}$-axis, the GPU has difficulty determining which
			of the two objects is &#8220;seen.&#8221; This leads to the objects coming
			into conflict.
		</p>
	</section>

	<section id="orthographic_camera">
		<h3>Orthographic Camera</h3>
		<p>
			Unlike the perspective camera, the orthographic camera has no perspective.
			Thus, objects seen through an orthographic camera have the same size,
			regardless of their distance to the camera.
		</p>
		<p>The template for initializing an orthographic camera:</p>
		<figure>
			<ul class="syntax">
				<li>
					const c = new THREE.OrthographicCamera(<span class="pop"
						>${left}$</span
					>, <span class="pop">${right}$</span>,
					<span class="pop">${top}$</span>, <span class="pop">${bottom}$</span>,
					<span class="pop">${near}$</span>, <span class="pop">${far}$</span>);
				</li>
				<div class="popText">
					<p>The ${left}$ parameter indicates how far left the camera sees.</p>
				</div>
				<div class="popText">
					<p>
						The ${right}$ parameter indicates how far right the camera sees.
					</p>
				</div>
				<div class="popText">
					<p>The ${top}$ parameter indicates how far up the camera sees.</p>
				</div>
				<div class="popText">
					<p>
						The ${bottom}$ parameter indicates how far down the camera sees.
					</p>
				</div>
				<div class="popText">
					<p>
						This is the <span class="boldText">near</span> argument, effectively
						how &#8220;close&#8221; an object is to the camera. Any object
						closer than this value will not be seen.
					</p>
				</div>
				<div class="popText">
					<p>
						This is the <span class="boldText">far</span> argument, how
						&#8220;far&#8221; the object is to the camera. Any object farther
						than this value will not be seen.
					</p>
				</div>
			</ul>
		</figure>
		<p>
			With the orthographic camera, we want to think of the camera's field of
			view as a cube. What it sees directly in front of it is a square, and the
			object lies on that square. Compare that with the perspective camera,
			which has a field of view akin to a cylinder. Because of this, the
			orthographic camera must know the how far left, right, top, and bottom we
			render. Anything beyond those points is not seen. Furthermore, just like
			the perspective camera, we can include arguments for the parameters
			${near}$ and ${far.}$
		</p>
		<p>
			When using an orthographic camera, it's often the case that changes to
			near and far can distort the shape. To prevent this from occurring, we
			want to use the aspect ratio &mdash; the ratio of width:height. We then
			multiply this ratio to the ${left}$ and ${right}$ arguments:
		</p>
		<pre class="language-javascript"><code>
			const sizes = {
				width: 400,
				height: 400
			}
			const aspectRatio = sizes.width / sizes.height;
			const camera = new THREE.OrthographicCamera(
				-1 * aspectRatio, 
				1 * aspectRatio, 
				1, 
				-1, 
				0.1, 
				100
			);
		</code></pre>
	</section>

	<section id="custom_camera_controls">
		<h3>Controlling the Camera</h3>
		<p>
			Because ThreeJS deals with both 3D objects and their movements, cameras
			must be mobile. Think of a movie set. The camera operators move the
			cameras here and there as needed. There isn't just one camera, or multiple
			cameras, remaining in place.
		</p>
		<p>
			One way to move the camera is through the cursor. For example, if the
			cursor moves to the left, we want the camera to move left, if the cursor
			moves right, the camera moves right, and so on.
		</p>
		<p>
			To move the camera, we must know the coordinates of the cursor. If we run
			the code below, we'll see that we get back the ${x}$-coordinates of the
			cursor's position in real time:
		</p>
		<pre class="language-javascript"><code>
			window.addEventListener('mousemove', (event) => { 
				console.log(event.clientX);
			});
		</code></pre>
		<p>And if we use the following function:</p>
		<pre class="language-javascript"><code>
			window.addEventListener('mousemove', (event) => { 
				console.log(event.clientY);
			});
		</code></pre>
		<p>
			We get the ${y}$-coordinates of the cursor's position. The values we see
			in the console are pixel values. This is not very useful. If the window
			gets large enough, the values run into the thousands, and if the window
			gets small enough (e.g., on a mobile device), we stay in the hundred
			range. A much more useful metric would be one that keeps these values
			proportional. For example, one metric would be using the values ${0}$
			through ${1.}$ No matter what the window size is, we stay within this
			range.
		</p>
		<p>To begin, we'll store the values we need in an object:</p>
		<pre class="language-javascript"><code>
			const cursor = {
				x: 0,
				y: 0
			};
			window.addEventListener('mousemove', (event) => { 
					cursor.x = event.clientX;
					cursor.y = event.clientY;
			});
		</code></pre>
		<p>
			To keep these values within the range of ${0}$ to ${1,}$ we simply divide
			the values by the size of our viewport:
		</p>
		<pre class="language-javascript"><code>
			const sizes = {
				width: 400,
				height: 400
			};
			const cursor = {
				x: 0,
				y: 0
			};
			window.addEventListener('mousemove', (event) => { 
					cursor.x = event.clientX / sizes.width;
					cursor.y = event.clientY / sizes.height;
			});
		</code></pre>
		<p>
			Note that the <span class="monoText">width</span> and
			<span class="monoText">height</span> values above are not necessarily the
			viewport's dimensions. They might be the dimensions for a
			<span class="monoText">canvas</span> element. In later sections, we will
			consider ways to obtain the actual viewport's dimensions.
		</p>
		<p>
			With the approach above, we're getting only positive values. What if we
			wanted to have positive and negative values, similar to a Cartesian
			coordinate system? The solution is to just subtract ${0.5:}$
		</p>
		<pre class="language-javascript"><code>
			const sizes = {
				width: 400,
				height: 400
			};
			const cursor = {
				x: 0,
				y: 0
			};
			window.addEventListener('mousemove', (event) => { 
					cursor.x = event.clientX / sizes.width - 0.5;
					cursor.y = event.clientY / sizes.height - 0.5;
			});
		</code></pre>
		<p>
			Why ${0.5?}$ Because the values range from ${0}$ to ${1.}$ By subtracting
			${0.5,}$ the range now becomes ${[-0.5, 0.5].}$ The difference between
			this implementation and the Cartesian coordinate system is the moving the
			mouse towards the top yields negative ${y}$-values, and moving the mouse
			towards the bottom yields positive ${y}$-values. The ${x}$-axis works as
			expected &mdash; moving towards the left, we get negative ${x}$-values,
			moving towards the right, we get positive ${x}$-values.
		</p>
		<p>
			Having these values, we can update the camera through the
			<span class="monoText">tick()</span> function:
		</p>
		<pre class="language-javascript"><code>
			<span class="greyText">const tick = () => {</span>

				camera.position.x = cursor.x * 2;
				camera.position.y = cursor.y * 2;

				<span class="greyText">renderer.render(scene, camera);</span>

				<span class="greyText">window.requestAnimationFrame(tick);</span>
			<span class="greyText">}</span>
			<span class="greyText">tick();</span>
		</code></pre>
		<p>
			Running all of the relevant code, we might notice that the camera acts
			odd. If we move the cursor left, the camera moves right. If we move the
			cursor right, the camera moves left. And if we move up and down, the
			object appears to follow the camera. This is because of that earlier fact
			we noted: In ThreeJS, the ${y}$-axis is negative towards the top, and
			positive towards the bottom. This means we must invert the
			${y-}$coordinate value:
		</p>
		<pre class="language-javascript"><code>
			<span class="greyText">const sizes = {
				width: 400,
				height: 400
			};
			const cursor = {
				x: 0,
				y: 0
			};
			window.addEventListener('mousemove', (event) => { 
					cursor.x = event.clientX / sizes.width - 0.5;</span>
					cursor.y = -(event.clientY / sizes.height - 0.5);
			<span class="greyText">});</span>
		</code></pre>
		<p>
			If we want to make sure the camera is always looking at the center of the
			cube (while still panning around):
		</p>
		<pre class="language-javascript"><code>
			<span class="greyText">const tick = () => {

				camera.position.x = cursor.x * 2;
				camera.position.y = cursor.y * 2;</span>
				camera.lookAt(new THREE.Vector3());

				<span class="greyText">renderer.render(scene, camera);</span>

				<span class="greyText">window.requestAnimationFrame(tick);</span>
			<span class="greyText">}</span>
			<span class="greyText">tick();</span>
		</code></pre>
		<p>
			Alternatively, we can simply pass the object's position as an argument to
			<span class="monoText">lookAt()</span>:
		</p>
		<pre class="language-javascript"><code>
			<span class="greyText">const tick = () => {

				camera.position.x = cursor.x * 2;
				camera.position.y = cursor.y * 2;</span>
				camera.lookAt(mesh.position);

				<span class="greyText">renderer.render(scene, camera);</span>

				<span class="greyText">window.requestAnimationFrame(tick);</span>
			<span class="greyText">}</span>
			<span class="greyText">tick();</span>
		</code></pre>
		<p>
			We still, however, have a limitation: We can't see behind the object. To
			remedy this, we want to have the camera rotate around the object. And to
			rotate the camera around the object, we're going to use trigonometry.
		</p>
		<p>
			As we know, the trigonometric functions are cyclical. For both ${y = \sin
			x}$ and ${y = \cos x,}$ the domain is ${\R,}$ and we can see that it is
			cyclical by way of a table:
		</p>
		<figure>
			<div class="func">
				<ul>
					<li>${x}$</li>
					<li>${y}$</li>
				</ul>
				<ul>
					<li>0</li>
					<li>0</li>
				</ul>
				<ul>
					<li>${\dfrac{\pi}{2}}$</li>
					<li>1</li>
				</ul>
				<ul>
					<li>${\pi}$</li>
					<li>0</li>
				</ul>
				<ul>
					<li>${\dfrac{3\pi}{2}}$</li>
					<li>-1</li>
				</ul>
				<ul>
					<li>${2 \pi}$</li>
					<li>0</li>
				</ul>
				<ul>
					<li>${\dfrac{5 \pi}{2}}$</li>
					<li>1</li>
				</ul>
				<ul>
					<li>${3 \pi}$</li>
					<li>0</li>
				</ul>
				<ul>
					<li>${\dfrac{7 \pi}{2}}$</li>
					<li>-1</li>
				</ul>
				<ul>
					<li>${4 \pi}$</li>
					<li>0</li>
				</ul>
			</div>
			<figcaption>The ${x}$ and ${y}$ values of ${y = \sin x.}$</figcaption>
		</figure>
		<p>And for ${y = \cos x}$ we have:</p>
		<figure>
			<div class="func">
				<ul>
					<li>${x}$</li>
					<li>${y}$</li>
				</ul>
				<ul>
					<li>0</li>
					<li>1</li>
				</ul>
				<ul>
					<li>${\dfrac{\pi}{2}}$</li>
					<li>0</li>
				</ul>
				<ul>
					<li>${\pi}$</li>
					<li>-1</li>
				</ul>
				<ul>
					<li>${\dfrac{3\pi}{2}}$</li>
					<li>0</li>
				</ul>
				<ul>
					<li>${2 \pi}$</li>
					<li>1</li>
				</ul>
				<ul>
					<li>${\dfrac{5 \pi}{2}}$</li>
					<li>0</li>
				</ul>
				<ul>
					<li>${3 \pi}$</li>
					<li>-1</li>
				</ul>
				<ul>
					<li>${\dfrac{7 \pi}{2}}$</li>
					<li>0</li>
				</ul>
				<ul>
					<li>${4 \pi}$</li>
					<li>1</li>
				</ul>
			</div>
			<figcaption>The ${x}$ and ${y}$ values of ${y = \cos x.}$</figcaption>
		</figure>
		<p>
			Because of these oscillations, if we use ${\cos x}$ to represent the
			${x}$-coordinate and ${\sin x}$ to represent the ${y}$-coordinate, we
			essentially have coordinates all along a circle. Knowing these facts, the
			question then, is, which axes do we move along? Because we aren't moving
			up and down (we're just trying to see behind the object), the axes we will
			travel are the ${x}$- and ${z}$-axis.
		</p>
		<pre class="language-javascript"><code>
			<span class="greyText">const tick = () => {</span>

				camera.position.x = Math.sin(cursor.x * Math.PI * 2) * 3;
				camera.position.y = cursor.y * 5;
				camera.position.z = Math.cos(cursor.x * Math.PI * 2) * 3;
				camera.lookAt(new THREE.Vector3());

				<span class="greyText">renderer.render(scene, camera);</span>

				<span class="greyText">window.requestAnimationFrame(tick);</span>
			<span class="greyText">}</span>
			<span class="greyText">tick();</span>
		</code></pre>
	</section>

	<section id="built_in_controls">
		<h3>Built-in Controls</h3>
		<p>
			The control we mentioned above is an example of a custom control. ThreeJS
			also provides <span class="term">built-in controls</span>. These built-in
			controls are:
		</p>
		<figure>
			<ul>
				<li><span class="monoText">DeviceOrientationControls</span></li>
				<li><span class="monoText">FirstPersonControls</span></li>
				<li><span class="monoText">FlyControls</span></li>
				<li><span class="monoText">OrbitControls</span></li>
				<li><span class="monoText">PointerLockControls</span></li>
				<li><span class="monoText">TrackBallControls</span></li>
			</ul>
		</figure>
		<p>We examine each of these controls in turn.</p>

		<section id="device_orientation_control">
			<h4>Device Orientation Controls</h4>
			<p>
				<span class="monoText">DeviceOrientationControls</span>
				retrieve the device orientation as set on the device, operating system,
				or browser. With this information, we can rotate the camera based on
				orientation.
			</p>
		</section>

		<section id="fly_controls">
			<h4>Fly Controls</h4>
			<p>
				We can think of <span class="monoText">FlyControls</span> as allowing us
				to move the camera as if we were operating a fighter jet &mdash; we can
				rotate on all 3 axes (e.g., performing a barrel roll), as well as moving
				forward and back.
			</p>
		</section>

		<section id="first_person_controls">
			<h4>First Person Controls</h4>
			<p>
				<span class="monoText">FirstPersonControls</span> are similar to fly
				controls, but with restriction: The
				<span class="italicsText">up</span> axis is fixed. Where fly controls
				allow us to do &#8220;aerial tricks,&#8221; first person controls are
				more like a Boeing-747 &mdash; it can look down, but there is an upper
				bound on how much it can look up.
			</p>
		</section>

		<section id="pointer_lock_control">
			<h4>Pointer Lock Controls</h4>
			<p>
				<span class="monoText">PointerLockControls</span> are akin to the
				controls we see in a game like Minecraft. We can look up, down, left,
				right, from a <span class="italicsText">fixed position</span>. Think of
				this as operating the camera on the the Mars rover. We can see in all
				directions, but only from a &#8220;locked&#8221; position.
			</p>
		</section>

		<section id="orbit_control">
			<h4>Orbit Controls</h4>
			<p>
				<span class="monoText">OrbitControls</span> allow us to move in all
				directions, <span class="underlineText">except</span> below the floor (a
				vertical angle limit). This is very much like operating a drone or
				satellite. The camera &#8220;orbits&#8221; the object.
			</p>
		</section>

		<section id="trackball_controls">
			<p>
				<span class="monoText">TrackballControls</span> are similar to orbit
				controls, but do not have the vertical angle limit we see with orbit
				controls.
			</p>
		</section>
	</section>
</section>

<section id="full_screen_and_resizing">
	<h2>Full-screen & Resizing</h2>
	<p>
		As we know, ThreeJS renders its visualizations in a canvas element. We can
		think of the canvas element as the universe where ThreeJS renderings exist.
		Depending on our desires, we often need to shrink, expand, or more generally
		resize the universe. Perhaps we want only want the canvas element to cover a
		portion of the viewport. Or we might want just the opposite, the canvas
		element covering the entire viewport. This all comes down to full-screening
		and resizing.
	</p>
	<div class="mainIdea">
		<p>
			Some important distinctions: The
			<span class="italicsText">viewport</span> is the area within the browser
			that displays webpage content. The
			<span class="italicsText">window</span> is the entire browser's area (the
			viewport plus the header bar with the URL). The
			<span class="italicsText">screen</span> is the entire monitor's display
			area.
		</p>
	</div>
	<p>
		Let's say we want our visualization to cover the entire viewport. We can do
		so by obtaining the viewport's height and width:
	</p>
	<pre class="language-javascript"><code>
		const sizes = {
			width: window.innerWidth,
			height: window.innerHeight
		}
	</code></pre>
	<p>
		Note that these properties are found in the
		<span class="monoText">window</span> object, but they are width and height
		of the viewport, note the window.
	</p>
	<p>
		When we use these sizes for the renderer, the renderer now covers the entire
		viewport. There may, however, be some margins. The trick to fixing this is
		to add some class attribute to the HTML element
		<span class="monoText">canvas</span> itself, then use the position property
		in CSS:
	</p>
	<pre class="language-css"><code>
		.webgl {
			position: fixed;
			top: 0;
			left: 0;
			outline: none;
		}
	</code></pre>
	<p>
		The <span class="monoText">outline: none;</span> styling is used to get rid
		of any default outlines that the browser renders for the
		<span class="monoText">canvas</span> element (depending on the browser, this
		might look like a thin blue line around the canvas element).
	</p>
	<section id="handle_resizing">
		<p>
			<span class="topic">Handle Resizing.</span> One problem we might have
			noticed with the above changes is that they aren't responsive. If we
			enlarge the window or narrow it, the canvas element does not change unless
			we reload the page.
		</p>
		<p>The fix is to use an event listener:</p>
		<pre class="language-javascript"><code>
			const sizes = {
				width: window.innerWidth,
				height: window.innerHeight
			}
			
			window.addEventListener('resize', () => {
				// update sizes 
				sizes.width = window.innerWidth;
				sizes.height = window.innerHeight;
			});
		</code></pre>
		<p>
			Above, we updated the sizes with the event listener, but this isn't
			enough. The sizes are used by different parts of our rendering, but it
			doesn't actually update the container for our scene. Thus, the next thing
			we must do is update the camera. For the camera, we must update the aspect
			ratio.
		</p>
		<pre class="language-javascript"><code>
			const sizes = {
				width: window.innerWidth,
				height: window.innerHeight
			}
			
			window.addEventListener('resize', () => {
				// update sizes 
				sizes.width = window.innerWidth;
				sizes.height = window.innerHeight;

				// update camera
				camera.aspect = sizes.width / sizes.height;
			});
		</code></pre>
		<p>
			This is still not enough. Even if we update the camera's aspect, ThreeJS
			doesn't know that aspect is being updated dynamically. To be precise,
			updating the camera's aspect property doesn't update the camera's
			<span class="italicsText">projection matrix</span>. Accordingly, we must
			call the built-in method
			<span class="monoText">updateProjectionMatrix()</span>:
		</p>
		<pre class="language-javascript"><code>
			const = sizes = {
				width: window.innerWidth,
				height: window.innerHeight
			};
			window.addEventListener('resize', () => {
				// update sizes
				sizes.width = window.innerWidth;
				sizes.height = window.innerHeight;

				// update camera
				camera.aspect = sizes.width / sizes.height;
				camera.updateProjectMatrix();
			})
		</code></pre>
		<p>
			Updating the camera's projection matrix, we see that resizing the window
			causes some sort of resizing, but it's not quite what we want. Expanding
			the window seems to stretch the mesh, and narrowing the window appears to
			contract the mesh.
		</p>
		<p>
			We're seeing this behavior because we're only updating the camera, but not
			the renderer. Accordingly, we must update the renderer's size:
		</p>
		<pre class="language-javascript"><code>
			const = sizes = {
				width: window.innerWidth,
				height: window.innerHeight
			};
			window.addEventListener('resize', () => {
				// update sizes
				sizes.width = window.innerWidth;
				sizes.height = window.innerHeight;

				// update camera
				camera.aspect = sizes.width / sizes.height;
				camera.updateProjectMatrix();

				// update the renderer
				renderer.setSize(sizes.width, sizes.height)
			})
		</code></pre>
		<p>
			Performing this update, we now see our scene expanding and contracting
			responsively.
		</p>
	</section>

	<section id="pixel_ratios">
		<h3>Pixel Ratios</h3>
		<p>
			On some machines, the mesh rendering &mdash; whether through ThreeJS or
			some other graphics software &mdash; might appear blurry or jagged. When
			we see this behavior, the most likely culprit is a screen with a pixel
			ratio greater than ${1.}$
		</p>
		<p>
			The <span class="term">pixel ratio</span> is a ratio of the number of
			physical pixels there are for one pixel unit in software.<label
				for="pixel"
				class="margin-toggle"
				><sup></sup
			></label>
			<input type="checkbox" id="pixel" class="margin-toggle sidenote-number" />
			<span class="marginnote"
				>The word &#8220;pixel&#8221; is a blending of &#8220;picture
				element.&#8221;</span
			>
			Inherent in this definition is the distinction between a
			<span class="italicsText">physical pixel</span> and the
			<span class="italicsText">logical pixel</span>. The logical pixel is a
			pixel unit, denoted ${\text{px}.}$ It is the software interpretation of a
			pixel. The physical pixel, however, is a single composition of molecules
			between two transparent electrons (i.e., the tiny squares we see if we
			look at an electronic screen with a magnifying glass).
		</p>
		<p>
			Keeping this distinction in mind, there are a few terms we should be clear
			about:
		</p>
		<ul>
			<li>
				<span class="term">Resolution</span> is the number of physical pixels
				along the width and the number of physical pixels along the height.
				Thus, a resolution of ${16 \times 12}$ denotes some collection of pixels
				${16}$ pixels horizontally and ${12}$ pixels vertically. Resolution,
				more generally, is the product:
				<figure>
					<div>
						<p>${width \times height.}$</p>
					</div>
				</figure>
			</li>
			<li>
				<span class="term">Aspect ratio</span> is the reduced form of a
				resolution. For example, with a resolution of of ${16 \times 12,}$ the
				greatest common factor is ${4,}$ so the aspect ratio is ${4:3.}$ The
				aspect ratio, more generally, is the ratio:
				<figure>
					<div>
						<p>${width:height.}$</p>
					</div>
				</figure>
				In computer graphics and cinematography, when captured content has a
				wider aspect ratio than the display, we often see black bars at the top
				and bottom of the screen. This is called
				<span class="term">letterboxing</span>. When the captured content has a
				taller aspect ratio than the display, black bars appear at the left and
				right sides of the screen. This is called
				<span class="term">pillarboxing</span>.
			</li>
			<li>
				A <span class="term">screen size</span> is the diagonal length of the
				screen, usually measured in inches or centimeters. For example, given a
				resolution of ${16 \times 12,}$ the screen size can be computed as:
			</li>
			<li>
				<span class="term">Pixels Per Inch (PPI)</span> is a measure of pixel
				density (i.e., how closely packed the physical pixels are), represented
				as the ratio ${\dfrac{d}{s}}$ where ${d}$ is the diagonal number of
				pixels, and ${s}$ is the screen size. For example, for the ${16 \times
				12}$ device, the diagonal number of pixels is:
				<figure>
					<div>
						<p>${\text{screen size} = \sqrt{16^2 + 12^2} \approx 20.2731}$</p>
					</div>
				</figure>
				If the screen size is ${8.2 \text{ in.},}$ the device has a PPI of:
				<figure>
					<div>
						<p>${\dfrac{20.2731}{8.2} \approx 2.4723}$</p>
					</div>
				</figure>
				This essentially tells us that the device fits about ${2}$ pixels for
				every inch.
			</li>
			<li>
				The <span class="term">device pixel ratio</span>, or
				<span class="italicsText">pixel ratio</span> for short, is the number of
				<span class="italicsText">physical pixels</span> for each
				<span class="italicsText">logical pixel</span>.
			</li>
		</ul>
		<p>
			For many years, all screens had a pixel ratio of ${1.}$ In that bygone
			era, one physical pixel corresponded to one logical pixel. However, some
			very clever hardware and software engineers at places like Apple began
			creating screens that supported a pixel ratio of two (in Apple's case, the
			so-branded <span class="italicsText">Retina&trade; displays</span>). With
			a pixel ratio of two, developers can render ${4}$ pixel units for each
			physical pixel. Eventually, other device manufacturers noticed this
			opportunity and began creating screens supporting even higher pixel ratios
			&mdash; three (giving ${9}$ pixels units to render), four (${16}$ pixel
			units to render), five (${25}$ pixel units), and even six (${36}$ pixel
			units). To get our device's pixel ratio, we can use the
			<span class="monoText"><mark>window.devicePixelRatio</mark></span>
			property.
		</p>
		<p>
			Currently, higher pixel ratios are a double-edged sword. On the one hand,
			these higher pixel ratios lead to much more detailed images, and by
			extension, fluid and smooth animations. On the other hand, higher pixel
			ratios are enormously costly on the GPU, and the GPU industry has not
			progressed nearly as fast as its display counterpart. This is a
			significant problem when we consider the fact that we've now arrived at a
			situation where the highest pixel ratios are on the weakest machines
			&mdash; mobile phones. There is no technological reason for having such
			high pixel ratios on mobiles; their GPUs simply cannot exploit these
			increased numbers. In fact, to the naked eye, the mobile device with a
			pixel ratio of three is indistinguishable from devices with higher pixel
			ratios. How did it come to this? Frighteningly clever marketing teams.
		</p>
		<p>
			Because of the variations in pixel ratio, we must write code accounting
			for these differences:
		</p>
		<pre class="language-javascript"><code>
			renderer.setPixelRatio(window.devicePixelRatio);
		</code></pre>
		<p>
			Writing the code above ensures that our renderer conforms to the relevant
			machine's pixel ratio. Recall, however, that there are devices with
			outrageous pixel ratios like five. Because of the GPU cost, we must limit
			our rendering to a particular pixel ratio:
		</p>
		<pre class="language-javascript"><code>
			renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
		</code></pre>
		<p>
			The code above reads: If the pixel ratio is less than two, set that as the
			pixel ratio, otherwise, use two. Of note, it's considered best-practice to
			place the pixel ratio setter inside the resize function we used earlier:
		</p>
		<pre class="language-javascript"><code>
			const sizes = {
				width: window.innerWidth,
				height: window.innerHeight
			}
		
			window.addEventListener('resize', () => {
				// update sizes 
				sizes.width = window.innerWidth;
				sizes.height = window.innerHeight;
		
				// update camera
				camera.aspect = sizes.width / sizes.height;
				camera.updateProjectionMatrix();
		
				// update the renderer
				renderer.setSize(sizes.width, sizes.height)
				renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
			});
		</code></pre>
		<p>
			We do so because more users today connect smaller devices to larger
			displays (e.g., linking a laptop to a monitor via HDMI). By placing the
			pixel ratio setter inside our resizing function, our rendering can
			self-modify when viewed on a larger resolution device.
		</p>
	</section>
	<section id="full_screen_toggle">
		<h3>Full-screen</h3>
		<p>
			Full-screen visualizations allow us to create more immersive experiences.
			The first step is to implement a way to toggle full-screen. In the
			illustrations below, we'll use a double-click approach, but there are many
			other ways: a button, a keyboard shortcut, a dropdown, etc.
		</p>
		<p>
			Four double-click, we'll use an event listener with a double click event:
		</p>
		<figure>
			<ul class="syntax">
				<li>window.addEventListener('dblclick', ${f_c}$)</li>
			</ul>
			<figcaption>where ${f_c}$ is a callback function</figcaption>
		</figure>
		<p>
			The DOM provides a read-only property called
			<span class="monoText"><mark>${obj}$.fullscreenElement</mark></span
			>, which returns <span class="monoText">true</span> if some element
			${obj}$ is in full-screen mode, and
			<span class="monoText">false</span> otherwise. We can use this as a test
			condition for toggling between the different states:
		</p>
		<pre class="language-javascript"><code>
			window.addEventListener('dblclick', () => { 
				if (!document.fullscreenElement) {
					console.log('go fullscreen');
				} else { 
					console.log('leave fullscreen');
				}
			})
		</code></pre>
		<p>Double clicking our viewport:</p>
		<pre class="language-javascript"><code>
			go fullscreen
		</code></pre>
		<p>
			It works as expected. Next, we use another DOM method,
			<span class="monoText"><mark>.requestFullscreen()</mark></span> to toggle
			full-screen mode. Because our scene is in a
			<span class="monoText">canvas</span> element, we call this method on the
			<span class="monoText">canvas</span> element. And to exit full-screen
			mode, we call the
			<span class="monoText"><mark>document.exitFullScreen()</mark></span>
			method:
		</p>
		<pre class="language-bash"><code>
			window.addEventListener('dblclick', () => { 
				if (!document.fullscreenElement) {
					canvas.requestFullscreen();
				} else { 
					document.exitFullscreen();
				}
			})
		</code></pre>
		<p>
			Now when the user double clicks on the
			<span class="monoText">canvas</span> element (the scene), our
			visualization goes into full-screen mode, and on another double-click (or
			pressing the <span class="monoText">esc</span> key), the user exits
			full-screen mode.
		</p>
	</section>
</section>

<section id="geometries">
	<h2>Geometries</h2>
	<p>
		Recall that a <span class="term">geometry</span> is the shape, our outline
		of some object we want to render. In our previous examples, we used
		ThreeJS's <span class="monoText"><mark>BoxGeometry</mark></span
		>. We now examine other geometries.
	</p>
	<aside>
		<figure>
			<img
				src="{% static 'images/geometry_cylinder.svg' %}"
				alt=""
				loading="lazy"
				class="eighty-p"
			/>
			<figcaption>The geometry behind a cylinder</figcaption>
		</figure>
	</aside>
	<p>
		To begin, we consider a few additional details about geometries. A geometry
		is composed of <span class="term">vertices</span> and
		<span class="term">faces</span>. In 3D graphics, a vertex is a point
		coordinate in 3D space. A face is the surface that results from joining
		vertices together with triangles. We can also use geometries for particles.
		When used in this manner, we set aside the faces, and just use the vertices.
		But for now, we will focus on vertices and faces.
	</p>
	<p>
		A geometry can store more than just the vertex coordinates. Every vertex has
		a position, but we can also assign colors, number values, size,
		ThreeJS-specific properties, any kind of data. Before we create our own
		geometries, we should know ThreeJS's native geometries.
	</p>
	<p>
		All native geometries in ThreeJS inherit from the
		<span class="monoText"><mark>BufferGeometry</mark></span> class. Within the
		<span class="monoText">BufferGeometry</span> class, there are many built-in
		methods and properties we can use. The documentation can be found
		<a
			href="https://threejs.org/docs/#api/en/core/BufferGeometry"
			target="blank"
			>here</a
		>. Some useful methods:
	</p>
	<ul class="ruled">
		<li>
			<span class="monoText"><mark>.rotateX</mark></span
			>, <span class="monoText"><mark>.rotateY</mark></span
			>, <span class="monoText"><mark>.rotateZ</mark></span>
		</li>
		<ul>
			<li>Rotate the geometry (not the mesh) along the relevant axis.</li>
			<li>These methods take a float argument, measured in radians.</li>
		</ul>
		<li>
			<span class="monoText"><mark>.translate(${x}$, ${y}$, ${z}$)</mark></span>
		</li>
		<ul>
			<li>
				Translate the geometry (not the mesh) along the axes, where ${x,}$
				${y,}$ and ${z}$ are floats.
			</li>
		</ul>
	</ul>
	<p>
		The native geometries in ThreeJS are implemented as classes inheriting from
		<span class="monoText">BufferGeometry</span>. Below are some of the more
		commonly used geometries, but a full list can be found in
		<a
			href="https://threejs.org/docs/#api/en/geometries/BoxGeometry"
			target="_blank"
			>the documentation</a
		>:
	</p>
	<ul class="ruled">
		<li>
			<span class="monoText"
				>const ${c}$ = new THREE.BoxGeometry(${w}$, ${h}$, ${d}$)</span
			>
		</li>
		<ul>
			<li>
				Instantiates a cuboid with the width ${w,}$ height ${h,}$ and depth
				${d.}$
			</li>
		</ul>
		<li>
			<span class="monoText"
				>const ${c}$ = new THREE.PlaneGeometry(${w}$, ${h}$)</span
			>
		</li>
		<ul>
			<li>
				Instantiates a plane with width ${w}$ along the ${x}$-axis, and a height
				${h}$ along the ${y}$-axis.
			</li>
		</ul>
		<li>
			<span class="monoText"
				>const ${c}$ = new THREE.CircleGeometry(${r}$, ${s}$)</span
			>
		</li>
		<ul>
			<li>
				Instantiates a circle of radius ${r,}$ with segments ${s.}$ Because
				everything is drawn via triangles, the integer ${s}$ determines the
				number of triangles used to draw the triangle. A minimum of ${3}$ is
				needed, and the default is ${8.}$ The more triangles are used, the
				&#8220;smoother&#8221; the circle looks.
			</li>
		</ul>
		<li>
			<span class="monoText"
				>const ${c}$ = new THREE.SphereGeometry(${r}$, ${w_s}$, ${h_s}$)</span
			>
		</li>
		<ul>
			<li>
				Instantiates a sphere of radius ${r.}$ The integer argument ${w_s}$ sets
				the number of horizontal segments (default ${32,}$ minimum ${3,}$), and
				the integer argument ${h_s}$ sets the number of vertical segments
				(default ${16,}$ minimum ${2}$).
			</li>
		</ul>
		<li>
			<span class="monoText"
				>const ${c}$ = new THREE.ConeGeometry(${r}$, ${h}$, ${rs}$)</span
			>
		</li>
		<ul>
			<li>
				Instantiates a cone with a base of radius ${r,}$ and a height ${h.}$ The
				integer argument ${rs}$ sets the number of segmented faces around the
				cone's circumference. The default is ${8,}$ higher values render a
				smoother cone.
			</li>
		</ul>
		<li>
			<span class="monoText"
				>const ${c}$ = new THREE.CylinderGeometry(${r_t}$, ${r_b}$, ${h}$,
				${rs}$)</span
			>
		</li>
		<ul>
			<li>
				Instantiates a cylinder. Given that a cylinder has two circle bases, the
				float argument ${r_t}$ sets the radius for the top base, and the float
				argument ${r_b}$ sets the radius for the bottom. The float argument
				${h}$ sets the height, and the integer argument ${r_s}$ sets the number
				of segmented faces around the cylinder's circumference.
			</li>
		</ul>
		<li>
			<span class="monoText"
				>const ${c}$ = new THREE.RingGeometry(${r_i}$, ${r_o}$,
				${\theta_s}$)</span
			>
		</li>
		<ul>
			<li>
				Instantiates a disk with a hole through its center. The float argument
				${r_i}$ sets the inner radius, and ${r_o}$ the outer radius. The integer
				argument ${\theta_s}$ sets the number of segments; a greater integer
				will render a rounder disk.
			</li>
		</ul>
		<li>
			<span class="monoText"
				>const ${c}$ = new THREE.TextGeometry(${s}$, ${p}$)</span
			>
		</li>
		<ul>
			<li>
				Instantiates a text geometry. The text to render is the string argument
				${s,}$ and the parameters are passed via the object-literal ${p.}$
			</li>
		</ul>
	</ul>

	<p>
		From the small sampling of the API above, we can see that there are numerous
		native geometries available at our disposal. Before we consider creating our
		own geometries, we should always examine the documentation to determine
		whether an implementation already exists. For the most complex geometries,
		we will need to use 3D-modelling programs like Blender.
	</p>
	<section id="segments">
		<h3>Segments</h3>
		<p>
			In the previous API table, we saw some parameters related to
			<span class="term">segments</span>. These parameters, at a higher level,
			impact the number of triangles used to draw the geometry's faces. To
			understand how these segments work, let's consider the cube. Recall that
			to instantiate a cube, we write:
		</p>
		<pre class="language-javascript"><code>
			const cube = new THREE.BoxGeometry(1, 1, 1);
		</code></pre>
		<p>
			The full parameter list for <span class="monoText">BoxGeometry()</span>,
			however, is the following:
		</p>
		<figure>
			<ul class="syntax">
				<li>
					THREE.BoxGeometry(${w}$, ${h}$, ${d}$, ${s_w}$, ${s_h}$, ${s_d}$)
				</li>
			</ul>
		</figure>
		<p>
			The ${s}$ parameters, all integers, correspond to the number of segments.
			${s_w}$ maps to the number of width segments, ${s_h}$ the height segments,
			and ${s_d}$ the depth segments. By default, each of these parameters is
			assigned the value ${1.}$ Focusing on ${s_h,}$ if ${s_h = 1,}$ the cube
			looks like:
		</p>
		<figure>
			<img
				src="{% static 'images/segment_cube1.svg' %}"
				alt="segment of 1 cube"
				loading="lazy"
				class="twenty-p"
			/>
		</figure>
		<p>Notice that there are exactly ${1 \times 2 = 2}$ triangles.</p>
		<p>
			When ${s_h = 2,}$ we draw two segments from the midpoints, generating what
			we can think of as four squares. Each square then forms two triangles,
			yielding ${2 \times 4 = 8}$ triangles.:
		</p>
		<figure>
			<img
				src="{% static 'images/segment_cube2.svg' %}"
				alt="segment of 2 cube"
				loading="lazy"
				class="twenty-p"
			/>
		</figure>
		<p>
			At ${s_h = 3,}$ we have ${3 \times 3 = 9}$ squares, and ${3 \times 2 = 9}$
			triangles. At ${s_h = 4,}$ we have ${4 \times 4 = 16}$ squares and ${16
			\times 2 = 32}$ triangles. Generalizing this pattern:
		</p>
		<figure>
			<div>
				<p>${n = 2s^2}$</p>
			</div>
			<figcaption>
				where ${n}$ is the number of triangles, and ${s}$ is the number of
				segments.
			</figcaption>
		</figure>
		<p>
			Why do we need more triangles? Well, for a simple geometry like a cube,
			the more triangles does not produce any visible difference. However, for
			geometries with curvatures, the number of triangles determines how smooth
			the curvatures are:
		</p>
		<figure>
			<img
				src="{% static 'images/sphere.svg' %}"
				alt="Triangles forming a sphere"
				loading="lazy"
				class="forty-p"
			/>
		</figure>
		<p>
			For all meshes, we can see the geometry's consisting triangles by
			including in the <span class="monoText">material</span>'s parameters a
			<span class="monoText"><mark>wireframe</mark></span> property set to
			<span class="monoText">true</span>:
		</p>
		<pre class="language-javascript"><code>
			const material = new THREE.MeshBasicMaterial({
				color: 0xff0000,
				wireframe: true
			})
		</code></pre>
	</section>
	<section id="custom_buffer_geometries">
		<h3>Custom Buffer Geometries</h3>
		<p>
			Suppose we wanted to create a triangle on our own, without relying on
			ThreeJS's built-in geometries. To do so, we must create our own buffer
			geometry.
		</p>
		<p>
			To create custom buffer geometries, we must use a
			<span class="monoText"><mark>Float32Array</mark></span> &mdash; a typed
			array of fixed length in the JavaScript language. Specifically, a
			<span class="monoText">Float32Array</span> is an array that can only store
			<span class="monoText">float</span> values.
		</p>
		<p>
			To initialize the <span class="monoText">Float32Array</span>, we use the
			following syntax:
		</p>
		<figure>
			<ul class="syntax">
				<li>new Float32Array(${n}$)</li>
			</ul>
			<figcaption>
				where ${n}$ is an <span class="monoText">int</span> value, corresponding
				to the length of the array.
			</figcaption>
		</figure>
		<p>For example:</p>
		<pre class="language-javascript"><code>
			const positionsArray = new Float32Array(9);
		</code></pre>
		<p>
			With the <span class="monoText">Float32Array</span> instantiated, we can
			then assign values to the array's positions:
		</p>
		<pre class="language-javascript"><code>
			const positionsArray = new Float32Array(9);
			positionsArray[0] = 0;
			positionsArray[1] = 0;
			positionsArray[2] = 0;

			positionsArray[3] = 0;
			positionsArray[4] = 1;
			positionsArray[5] = 0;

			positionsArray[6] = 1;
			positionsArray[7] = 0;
			positionsArray[8] = 0;
		</code></pre>
		<p>
			Tying this to ThreeJS is the following: Every three positions is the
			coordinate to vertex, with the positions corresponding to the ${x-}$,
			${y}$-, and ${z}$-axis respectively. Given that a triangle consists of
			three vertices, we have the following interpretation:
		</p>
		<pre class="language-javascript"><code>
			const positionsArray = new Float32Array(9);

			// vertex 1
			positionsArray[0] = 0; // x-coordinate
			positionsArray[1] = 0; // y-coordinate
			positionsArray[2] = 0; // z-coordinate

			// vertex 2
			positionsArray[3] = 0;
			positionsArray[4] = 1;
			positionsArray[5] = 0;

			// vertex 3
			positionsArray[6] = 1;
			positionsArray[7] = 0;
			positionsArray[8] = 0;
		</code></pre>
		<p>
			Rather than writing all of the lines above individually, we can accomplish
			the same result in a single line:
		</p>
		<pre class="language-javascript"><code>
			const positionsArray = new Float32Array([
				0, 0, 0,
				0, 1, 0,
				0, 1, 0
			]);
		</code></pre>
		<p>
			Why aren't we just using regular JavaScript arrays? Because computers can
			handle the <span class="monoText">Float32Array</span> much more easily
			than a regular array. With the standard array, there's a longer checklist
			the machine must go through before returning an output.
			<span class="monoText">Float32Array</span> significantly shortens that
			checklist. The array consists entirely of floats, so type inference is
			quick; the array's length is fixed so no calculations are necessary; the
			array is immutable so even fewer calculations must be made.
		</p>
		<p>
			Once we've initialized our positions array, we must convert the
			<span class="monoText">Float32Array</span> to a
			<span class="monoText"><mark>BufferAttribute</mark></span> object &mdash;
			essentially a container for attribute data (in this case, our positions).
		</p>
		<pre class="language-javascript"><code>
			const positionsArray = new Float32Array([
				0, 0, 0,
				0, 1, 0,
				1, 0, 0
			]);
			const positionsAttribute = new THREE.BufferAttribute(positionsArray, 3);
		</code></pre>
		<p>
			Notice how we passed the <span class="monoText">positionsArray</span> into
			the constructor, followed by the integer <span class="monoText">3</span>.
			This integer essentially tells the constructor that each of the floats in
			<span class="monoText">positionsArray</span> are grouped by three
			(corresponding to the coordinates of each vertex).
		</p>
		<p>
			With our coordinates now stored in a
			<span class="monoText">BufferAttribute</span>, we can now create a new
			geometry using the coordinates. We do so by passing appropriate label and
			the <span class="monoText">positionsAttribute</span> into the geometry's
			<span class="monoText">.setAttribute()</span> method:
		</p>
		<pre class="language-javascript"><code>
			const positionsArray = new Float32Array([
				0, 0, 0,
				0, 1, 0,
				1, 0, 0
			]);
			const positionsAttribute = new THREE.BufferAttribute(positionsArray, 3);
			const geometry = new THREE.BufferGeometry();
			geometry.setAttribute('position', positionsAttribute);
		</code></pre>
		<p>
			What exactly is the string argument
			<span class="monoText">'position'</span>? This is the value that ThreeJS's
			<span class="italicsText">shaders</span> will use. We will cover shaders
			in a later section, but for now, think of the
			<span class="monoText">'position'</span> argument as telling ThreeJS's
			shaders, &#8220;These are coordinates.&#8221;
		</p>
		<section id="multiple_custom_geometries">
			<h4>Multiple Custom Geometries</h4>
			<p>
				Above, we created a single triangle. How do we create multiple
				triangles? We use the same procedure from last. We'll start with a
				variable, <span class="monoText">triangleCount</span>, for the number of
				our triangles we want:
			</p>
			<pre class="language-javascript"><code>
				const triangleCount = 50;
			</code></pre>
			<p>
				Then, we'll create a positions array. Each triangle must have three
				coordinates, and each coordinate must have have three positions, so we
				multiply <span class="monoText">triangleCount</span> by 9:
			</p>
			<pre class="language-javascript"><code>
				const triangleCount = 50;
				const positionsArray = new Float32Array(triangleCount * 3 * 3);
			</code></pre>
			<p>
				Because we're just generating fifty triangles, we can fill the
				<span class="monoText">positionsArray</span> with random values:
			</p>
			<pre class="language-javascript"><code>
				const triangleCount = 50;
				const positionsArray = new Float32Array(triangleCount * 3 * 3);
				for (let i = 0; i < (count * 3 * 3); i++) { 
						positionsArray[i] = Math.random();
				}
			</code></pre>
			<p>
				Then we store the <span class="monoText">positionsArray</span> in
				<span class="monoText">BufferAttribute</span> and add this attribute to
				a geometry:
			</p>
			<pre class="language-javascript"><code>
				const triangleCount = 50;
				const positionsArray = new Float32Array(triangleCount * 3 * 3);
				for (let i = 0; i < (triangleCount * 3 * 3); i++) { 
					positionsArray[i] = Math.random();
				}
				const positionsAttribute = new THREE.BufferAttribute(positionsArray, 3);
				const geometry = new THREE.BufferGeometry();
				geometry.setAttribute('position', positionsAttribute);
			</code></pre>
			<p></p>
		</section>
	</section>
</section>

<section id="debug_ui">
	<h2>Debug UI</h2>
	<p>
		In many ThreeJS projects, we can see a rectangular interface in the corner
		displaying performance-related metrics and other real-time data. This small
		interface is called a <span class="term">debug UI</span>.
	</p>
	<p>
		To implement a debug UI, we have two options: (1) create our own, or (2) use
		a library. And with option (2), we again have options: dat.GUI, ControlKit,
		Guify, Oui, and many others.
	</p>
</section>
{% endblock %}
