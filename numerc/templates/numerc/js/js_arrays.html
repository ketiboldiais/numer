{% extends '../layout.html' %} {% load static %} {% block description %}
<meta
	name="description"
	content="Collections in JavaScript: Arrays, objects, and loops."
/>
{% endblock %} {% block title %}
<title>Collections & Loops</title>
{% endblock %} {% block content %}
<h1>Collections & Loops</h1>
<section id="intro">
	<p>
		<span class="drop">C</span>ollections are groups of related data. In this
		section, we explore two collections provided natively by JavaScript: Arrays
		and objects. Because JavaScript provides special looping constructs for
		arrays and objects, we will investigate iteration once we've established
		familiarity with the basic collections.
	</p>
</section>

<section id="arrays">
	<h2>Arrays</h2>
	<p>
		Arrays are the simplest
		<i>data structure</i>; they are a collection of values, where
		<i>order matters</i>. Examples of an array include: list of comments on a
		post, a collection of levels in a game, or a playlist of songs. Every value
		can be collected and placed in an order. The resulting ordered collection is
		called an <i>array</i>. Arrays can also collect and order other arrays.
	</p>
	<p>
		To create an array in JavaScript, we use square brackets
		<var>[]</var>. Here is an empty array:
	</p>
	<pre class="language-javascript">
		<code>
			let special_numbers = [];
		</code>
	</pre>
	<p>An array of strings:</p>
	<pre class="language-javascript">
		<code>
			let colors = ['red', 'orange', 'blue', 'green'];
		</code>
	</pre>
	<p>An array of numbers:</p>
	<pre class="language-javascript">
		<code>
			let primes = [1, 3, 5, 7, 11];
		</code>
	</pre>
	<p>A mixed array:</p>
	<pre class="language-javascript">
		<code>
			let randomStuff = [true, 68, "bird", null];
		</code>
	</pre>

	<section id="array_indices">
		<p>
			<span class="topic">Indices in an Array</span>
			The values in an array are <b>indexed</b>, meaning that each value in the
			array has an <b>index</b>, or position within the array, starting from 0.
			So, for example:
		</p>
		<pre class="language-javascript">
			<code>
				let colors = ['red', 'orange', 'yellow', 'blue'];
				colors[0] // returns 'red'
				colors[1] // returns 'orange'
				colors[2] // returns 'yellow'
				colors[3] // returns 'blue'
			</code>
		</pre>
	</section>

	<section id="array_length">
		<p>
			<span class="topic">Array Length</span>
			Much like how they can be applied to strings and variables, we can find
			the length of an array (how many values it holds) with the
			<var>.length</var> method.
		</p>
		<pre class="language-javascript">
			<code>
				let colors = ['red', 'orange', 'yellow', 'blue'];
				colors.length; // Returns 4, the array named <i>colors</i> contains 4 values.
			</code>
		</pre>
		<p>If we want to get the last value in an array:</p>
		<pre class="language-javascript">
			<code>
				let colors = ['red', 'orange', 'yellow', 'blue'];
				colors[colors.length - 1] // returns 'blue';
				/*
				This works because colors.length returns a number value. That number value is 4, the number of values in the array. Subtract 1, and you have the number 3. So, the code is telling JavaScript, get the value with index of 3 in the array of colors (the index of 3 is the last item in the array.)
				*/
			</code>
		</pre>
	</section>

	<section id="modifying_arrays">
		<h3>Modifying Arrays</h3>
		<p>
			Say that we've set an array. We can change the values inside that array by
			going back and manually changing them, but that would be horribly
			inefficient (and you likely do no want to do that for a very large
			program). Instead of manually changing the values in the array, we can use
			their indices:
		</p>
		<pre class="language-javascript">
			<code>
				let colors = ['red', 'blue', 'green'];
				colors[0] = 'purple';
				colors[1] = 'violet';
				colors[2] = 'black';
				// The above will change the array <i>colors</i> to the following:
				colors = ['purple', 'violet', 'black'];
			</code>
		</pre>
		<p>We can also use methods to change the values in an array:</p>
		<pre class="language-javascript">
			<code>
				// Here is our initial shopping list
				shoppingList = ['Bud Light', 'Merlot', 'Vodka', 'Tequila'];
	
				// Guest called, wants Cabernet, not Merlot: 
				shoppingList[1] = 'Cabernet';
	
				// Another guest called, wants Rum, not Tequila:
				shoppingList[shoppingList.length - 1] = 'Rum';
	
				// Yet another guest called, requesting Tequila to be added
				shoppingList[shoppingList.length] = 'Tequila';
	
				console.log(shoppingList);
			</code>
		</pre>
		<pre class="language-bash"><code>
			['Bud Light', 'Cabernet', 'Vodka', 'Rum', 'Tequila']
		</code></pre>

		<section id="push()_method">
			<p>
				<span class="topic">Appending.</span>
				The <var>push()</var> method adds one or more elements to the end of an
				array, and returns the new length of the array.
			</p>
			<pre class="language-javascript">
				<code>
					let vectors = ['w', 'x', 'y'];
					vectors.push('z');
					console.log(vectors);
				</code>
			</pre>
			<pre class="language-bash"><code>
				['w', 'x', 'y', 'z']
			</code></pre>
		</section>

		<section id="pop()_method">
			<p>
				<span class="topic">Removing.</span>
				The <var>pop()</var> method removes a value at the end of an array.
			</p>
			<pre class="language-javascript">
				<code>
					let procedures = ['w', 'x', 'y', 'z'];
					procedures.pop('z');
					console.log(procedures);
				</code>
			</pre>
			<pre class="language-bash"><code>
				['w', 'x', 'y']
			</code></pre>
		</section>

		<section id="shift()_method">
			<p>
				<span class="topic">Shifting</span>
				The <var>shift()</var> method removes a value from the start of an
				array:
			</p>
			<pre class="language-javascript">
				<code>
					let procedures = ['w', 'x', 'y', 'z'];
					procedures.shift('w');
					console.log(procedures);
				</code>
			</pre>
			<pre class="language-bash"><code>
				['x', 'y', 'z']
			</code></pre>
		</section>

		<section id="unshift()_method">
			<p>
				<span class="topic">Unshifting.</span>
				The <var>unshift()</var> method adds a value to the start of an array:
			</p>
			<pre class="language-javascript">
				<code>
					let procedures = ['w', 'x', 'y', 'z'];
					procedures.unshift('v');
					console.log(procedures);
				</code>
			</pre>
			<pre class="language-bash"><code>
				['v', 'w', 'x', 'y', 'z']
			</code></pre>
		</section>

		<section id="concat()_method">
			<p>
				<span class="topic">Concatenating.</span>
				The <var>concat()</var> method
				<span class="underlineText">creates a new array</span>
				from merging two arrays; there is no change to the original.
			</p>
			<pre class="language-javascript">
				<code>
					let x = ['a', 'b', 'c'];
					let y = ['d', 'e', 'f'];
					let xAndy = x.concat(y);
					console.log(xAndy);
					
				</code>
			</pre>
			<pre class="language-bash"><code>
				['a', 'b', 'c', 'd', 'e', 'f']
			</code></pre>
			<p>
				When using the <var>concat()</var> method,
				<span class="underlineText">order matters</span>. So, for example,
				suppose you have the following:
			</p>
			<pre class="language-javascript"><code>
				array1.concat(array2).concat(array3)
			</code></pre>
			<p>The new array is:</p>
			<figure class="math-display">
				<div>
					<p>
						<!-- prettier-ignore -->
						<var>[${array1}$-${values}$ ${array2}$-${values}$ ${array3}$-${values}$]</var>
					</p>
				</div>
			</figure>
		</section>

		<section id="includes()_method">
			<p>
				<span class="topic">Does it include?</span>
				The <var>includes()</var> method is a Boolean methodâ€”it returns either
				<span class="greenText">true</span> or
				<span class="redText">false</span>. If the value is found in the array,
				the method returns <span class="greenText">true</span>. If the value is
				not found in the array, the method returns
				<span class="redText">false</span>.
			</p>
			<pre class="language-javascript">
				<code>
					let subjects = ['math', 'physics', 'cs', 'chemistry'];
					subjects.includes('physics');  // true
				</code>
			</pre>
			<p>
				The <var>includes()</var> method can also take a number as a second
				argument. The number passed in represents the <i>starting index</i> for
				JavaScript's search. By passing in a number $x$, we essentially ask
				JavaScript: "Is the value contained in the part of the array starting
				from index $x$? For example:
			</p>
			<pre class="language-javascript">
				<code>
					let var_Array = ['w', 'x', 'y', 'z'];
					var_Array.includes('w', var.Array.length / 2); // false
				</code>
			</pre>
			<p>
				In the code above, we are actually asking: JavaScript, is this true or
				false: The value <var>'w'</var> is inside the array, and, more
				specifically, in the part of the array starting from <var>i = 2</var>.
				This returns false, since <var>'w'</var> is in the first half of the
				array, starting from <var>i = 0</var>.
			</p>
		</section>

		<section id="indexOf()_array_method">
			<p>
				<span class="topic">What's the index of?</span>
				The <var>indexOf()</var> method works in the same way with arrays as it
				does with strings. In other words, the <var>indexOf()</var> method finds
				the index of a value in the array. If the method finds the value, it
				returns its index (an integer $x$, where $x \geq 0$). If the method does
				not find the value, it returns -1. Like the
				<var>includes()</var> method, we can pass through a second argument, an
				integer, into the method's arguments, to specify where the method should
				operate.
			</p>
			<pre class="language-javascript">
				<code>
					let frequencies = ['1Mhz', '3Mhz', '7Mhz', '15Mhz'];
		
					frequencies.indexOf('1Mhz'); 
					// This returns 0, the index of '1Mhz'
					
					frequencies.indexOf('3Mhz', frequencies.length / 2);
					// This returns -1, because we told JavaScript to only search for '3Mhz' in the part of the array starting from index = 2, and there is no such value in that part of the array.
		
					frequencies.indexOf('7Mhz', frequencies.length / 2); 
					// This returns 2. We told JavaScript, "Search for '7Mhz' in the part of the array starting from index = 2. JavaScript found the value, and returned its index, 2."
				</code>
			</pre>
		</section>

		<section id="reverse()_method_arrays">
			<p>
				<span class="topic">Reversing.</span>
				The <var>reverse()</var> method changes the original array by reversing
				the order of its values. Note that the <var>reverse()</var> method
				changes the original array; once applied, the original array is replaced
				by the new array resulting from the method.
			</p>
			<pre class="language-javascript">
				<code>
					let arr = [1, 2, 3, 4, 5];
					arr.reverse();
					/*
					This changes the original array into:
					arr = [5, 4, 3, 2, 1]
					*/
				</code>
			</pre>
		</section>

		<section id="join()_method_arrays">
			<p>
				<span class="topic">Joining.</span>
				The <var>join()</var> method takes all the values in an array, and
				combines them into a single string, as originally ordered. Remember, the
				return from a <var>join()</var> method is a string. Thus, if you us the
				<var>join()</var> method with an array of numbers, the result is a
				string of those numbers.
			</p>
			<pre class="language-javascript">
				<code>
					let letters = ['q', 'u', 'a', 'd', 'r', 'a', 't', 'i', 'c'];
					
					letters.join('');
					// This returns a single string, joined with an empty string: 'quadratic'
					
					letters.join('-');
					// This returns a single string, joined with the string '-': 'q-u-a-d-r-a-t-i-c'
	
					letters.reverse().join('');
					// This reverses the array <i>letters</i>, and returns a single string, joined with an empty string: 'citardauq'
				</code>
			</pre>
		</section>

		<section id="slice()_method_arrays">
			<p>
				<span class="topic">Sub-arrays.</span>
				Like the <var>slice()</var> method applied to strings, the
				<var>slice()</var> method applied to arrays takes a portion of an array,
				and creates a new array with that portion, without changing or affecting
				the original array. The <var>slice()</var> method usually takes two
				arguments:
			</p>
			<ol>
				<li>
					The starting index in the original array to start the slice; and
				</li>
				<li>
					The end index in the original array (but, in the slice, it does not
					include the value with the end index).
				</li>
			</ol>
			<p>
				If no numbers are passed into the
				<var>.slice()</var> method, then an entire copy of the array is made.
				So, for example:
			</p>
			<pre class="language-javascript">
				<code>
					let sets = ['A', 'B', 'C', 'D', 'E'];
					let slicedSets = sets.slice(1, 3);
					/* We've created a new array called <i>slicedSets</i>:
					slicedSets = ['B', 'C']
					*/
				</code>
			</pre>
			<p>
				By passing a negative number, say $-x$ into the
				<var>slice()</var> method, we essentially tell JavaScript: "For this
				array, slice the portion starting $x$ from the last index." For example:
			</p>
			<pre class="language-javascript">
				<code>
					let sets = ['A', 'B', 'C', 'D', 'E'];
					let subSet = sets.slice(-2);
					/*
					This code says, make a slice starting 2 from the last index (here, the last index is 5, so the slice starts at 3). This will include the last index.
					
					So, the resulting array:
					subset = ['C', 'D', 'E']
					*/
				</code>
			</pre>
			<p>
				If 2 negative numbers are passed as arguments into the
				<var>slice()</var> method, say $-x$ and $-y$, then the slice starts at
				$x$ index from the last index of the array, and the slice ends at $y$
				index from the last index of the array. Illustration:
			</p>
			<pre class="language-javascript">
				<code>
					let sets = ["A", "B", "C", "D", "E"];
					let subSet = sets.slice(-3, -1);
					/*
					Here, we tell JavaScript, start the slice at the index 3 units from the last index (in this case, index = 2), and end the slice 1 unit from the last index (index = 4).
	
					Thus:
					subSet = ['C', 'D']
					*/
				</code>
			</pre>
		</section>

		<section id="splice()_method">
			<p>
				<span class="topic">Splicing.</span>
				The <var>splice()</var> method can either remove, replace, or add new
				values in an array. <var>splice()</var> is primarily used for changes to
				the middle of an array, since changes to the beginning or end of an
				array are usually handled with <var>push()</var>, <var>pop()</var>,
				<var>shift()</var>, and <var>unshift()</var>. Splice can take at least
				three different values:
			</p>
			<ol>
				<li>the start index (an integer)</li>
				<li>the specific value we want to delete</li>
				<li>the specific value we want to insert</li>
			</ol>
			<p>So, for example:</p>
			<pre class="language-javascript">
				<code>
					let vectors = ['velocity', 'acceleration', 'momentum'];
					vectors.splice(1, 0, 'weight');
					/*
					In the above code, we changed the original array vectors to the following: 
					vectors = ['velocity', 'weight', 'acceleration', 'momentum']
					*/
				</code>
			</pre>
			<p>
				The <var>splice()</var> method changes the original array. I.e., once
				applied, the original array is no more---it is now the modified, spliced
				array.
			</p>
		</section>

		<section id="sort()_method">
			<p>
				<span class="topic">Sorting.</span>
				The <var>sort()</var> method sorts the elements of an array in place,
				and returns the sorted array. The sort order can be alphabetic, numeric,
				ascending, or descending. By default, <var>sort()</var> sorts an array's
				elements as strings in alphabetic and ascending order. To sort the
				string elements of an array alphabetically:
			</p>

			<pre class="language-javascript">
				<code>
					let shapes = ['square', 'circle', 'triangle', 'pentagon', 'rhombus'];
					shapes.sort();
					/* 
					This returns a sorted array: 
					['circle', 'pentagon', 'rhombus', 'square', 'triangle']
					*/
				</code>
			</pre>
		</section>
	</section>

	<section id="arrays_reference_type">
		<h3>Reference Types</h3>
		<p>
			When a variable is declared and assigned a primitive type value, a
			<b>value type variable</b> is created. Once a
			<i>value type variable</i> is created, JavaScript stores it in memory, and
			more specifically, JavaScript <i>stores the variable's assigned value</i>.
			This is <span class="underlineText">not</span> the case for variables
			declared and assigned an array.
		</p>
		<p>
			Arrays are too large and take up memory unnecessarily. Instead of storing
			the array, JavaScript stores the array's
			<b>reference</b>. An array's <i>reference</i> is a string of numbers, akin
			to a memory address. This has a significant impact on the way
			<code>const</code> works with arrays.
		</p>
		<p>
			Because assigning an array to a variable does not actually store the array
			in the variable (it stores the array's reference), we can change the
			elements within an array, even if we assign the array to a variable
			declared with
			<var>const</var>.This is because once an array is created and stored in a
			variable, its reference <span class="underlineText">never</span> changes.
		</p>
		<p>
			As such, because the variable declared and assigned with
			<var>const</var> is storing a reference (which never changes), rather than
			the actual array itself, the array can be changed later down the program.
		</p>
		<p>
			This also means that if you declare a variable with
			<var>const</var> and assign an array to it, you cannot change that
			reference later (i.e., assigning to the variable an entirely new array).
			Because of this behavior, it is almost always the case that
			<var>const</var> should be used for arrays, unless there is a reason for
			needing a variable to point to different arrays (in which case,
			<var>let</var> should be used).
		</p>
	</section>

	<section id="nested_arrays">
		<h3>Nested Arrays</h3>
		<p>
			It is perfectly fine to have arrays containing arrays (but, before nesting
			an array, consider whether there is an alternative or better data
			structure).
		</p>

		<pre class="language-javascript">
			<code>
				/*
				Here is an array containing three arrays.
				*/
				const courses = [
					['mechanics', 'E & M', 'thermodynamics'],
					['calculus', 'differential equations', 'real analysis'],
					['algorithms', 'data structures', 'operating systems']
				]
			</code>
		</pre>

		<p>
			To access the elements of a nested array, we can perform the following:
		</p>

		<pre class="language-javascript"><code>
			const arr1 = [
				[1, 3, 5, 9],
				[3, 2, 9, 10],
				[11, 3, 6, 9]
			]
			// Suppose we want the third element of the second array:
			arr1[1][2];
			/*
			This returns 9.
			[1] tells JavaScript, look at the element with index of 1---in this case, the second array.
			[2] tells JavaScript, inside that array, look at the element with index of 2---in this case, the number 9.
			*/
		</code></pre>
	</section>

	<section id="array_objects">
		<h3>Other Ways to Implement Arrays</h3>
		<p>
			Recall that arrays are an
			<i>ordered collection</i> data structure. In terms of datatype, arrays are
			objects. Now we're adding another trait: As objects, arrays behave like
			iterables &mdash; a particular kind of object. But, not every iterable is
			an array. For example, NodeList, String, Map, and Set are all iterables.
			Objects of these types are iterables, and we can iterate through them with
			a for-of loop. But, objects of type NodeList are
			<span class="underlineText">not</span> arrays. They are
			<i>array-like objects</i>, in that they have a length property, and use
			indices for accessing.
		</p>
		<p>
			To better understand the differences between an array and an array-like
			object, let's revisit arrays. Recall the method for creating arrays we're
			familiar with:
		</p>
		<pre class="language-javascript"><code>
			const arr = [1]
		</code></pre>
		<p>
			No surprises here. This statement creates a singleton, an array with only
			one element. It's also the most common way to create an array. But it
			turns out the above statement isn't the only way:
		</p>
		<pre class="language-javascript"><code>
			const arr = Array(1);
			const arr = new Array(1);
			const arr = Array.of(1);
			const arr = Array.from(1);
		</code></pre>
		<p>
			Although each of the statements above creates an array, they all do so
			differently. To see these differences, we revisit the
			<var>length</var> property of an array. We know that when we create an
			array in JavaScript the way we usually do (with square brackets) we create
			an array whose length can grow and shrink:
		</p>
		<pre class="language-javascript"><code>
			let arr = [1, 2, 3];
			console.log(arr);
			console.log(arr.length);
		</code></pre>
		<pre class="language-bash"><code>
			[1, 2, 3]
			3
		</code></pre>
		<p>When use the <var>Array()</var> function, we get the same result:</p>
		<pre class="language-javascript"><code>
			let arr = Array(1, 2, 3);
			console.log(arr);
			console.log(arr.length);
		</code></pre>
		<pre class="language-bash"><code>
			[1, 2, 3]
			3
		</code></pre>
		<p>The same goes for <var>new Array()</var>:</p>
		<pre class="language-javascript"><code>
			let arr = new Array(1, 2, 3);
			console.log(arr);
			console.log(arr.length);
		</code></pre>
		<pre class="language-bash"><code>
			[1, 2, 3]
			3
		</code></pre>
		<p>Now notice what happens when we pass a single argument:</p>
		<pre class="language-javascript"><code>
			let arr1 = [1];
			let arr2 = Array(1);
			let arr3 = new Array(1);
			console.log(arr1);
			console.log(arr1.length);
			console.log(arr2);
			console.log(arr2.length);
			console.log(arr3);
			console.log(arr3.length);
		</code></pre>
		<pre class="language-bash"><code>
			[1]
			1
			[empty]
			1
			[empty]
			1
		</code></pre>
		<p>
			When we use the square bracket syntax for initialization (<span
				class="monoText"
				>arr1</span
			>), we get an array as expected. But, using <var>Array()</var> or
			<var>new Array()</var>, we get an empty array with a length of
			<var>1</var>. What's happening here?
		</p>
		<p>
			We're seeing this behavior because
			<var>Array()</var> is a function that returns a static array if only one
			argument is passed to it. Both <var>Array()</var> and
			<var>new Array()</var> are essentially the same. The only difference is
			that <var>Array()</var> is a function, while <var>new Array()</var> is a
			constructor. Either or, passing only one argument is interpreted as the
			resulting array's length. Passing multiple arguments, the values are
			interpeted as the resulting array's elements.
		</p>
	</section>
</section>

<section id="object_literals">
	<h2>Object-literals</h2>
	<p>
		If there's anything about JavaScript that merits slander, it's the way it
		uses the word &#8220;object.&#8221; Across most languages, the word
		&#8220;object&#8221; refers to an instance of an abstract data type (e.g.,
		in languages like Java and Python, an instance of a particular class).
		JavaScript also uses this semantic, but confusingly uses the word
		&#8220;object&#8221; to refer to any collection of individual data items. In
		other programming languages, the JavaScript object data structure would be
		given one of many specific names: <var>struct</var>, <var>record</var>, or
		<var>aggregate</var>. The JavaScript object data structure is more broadly
		referred to as a <i>record data type</i>, or simply a <i>record</i>.
	</p>
	<div class="mainIdea">
		<p>
			There are two interpretations for the word &#8220;object&#8221; in
			JavaScript, and we will resolve the ambiguity by using different terms.
			When we use the word &#8220;object&#8221; alone, we are referring to a
			collection of values. When we use the word &#8220;object-literal,&#8221;
			we are referring to a record-type data structure similar to a
			<var>struct</var>.
		</p>
	</div>
	<p>
		Recognizing this ambiguity, some JavaScript developers use the term
		&#8220;object-literal&#8221;. This doesn't fix the issue entirely, but we'll
		use this terminology to resolve ambiguities between the object data
		structure and the broader notion of an object: An
		<b>object-literal</b> is a record-type data structure. We raise this issue
		now because many JavaScript newcomers, especially those with previous OOP
		experience, mistakenly adopt a notion that JavaScript's object-literal is an
		instance of some class. It is not. It is a record data type like a
		<var>struct</var>.
	</p>
	<p>
		That said, an object-literal is a collection of
		<b>properties</b> or <b>methods</b>.<label
			for="methodOOP"
			class="margin-toggle"
			><sup></sup
		></label>
		<input
			type="checkbox"
			id="methodOOP"
			class="margin-toggle sidenote-number"
		/>
		<span class="marginnote"
			>For those coming from Java: The object is
			<span class="underlineText">not</span> a <i>class</i>. It is more like a
			<var>struct</var> in C++.</span
		>The object-literal is analogous to the Python <i>dictionary</i>. An
		object-literal's property consists of a <b>key-value pair</b> &mdash; a key
		(think of it as a label, or identifier), and the data paired with it. We
		call the key's name the <b>property name</b>. The value paired to the key is
		called the <b>property value</b>. With object-literals, the name of a key is
		always a value of one of three types:
	</p>
	<figure>
		<ul>
			<li>
				<var><mark>String</mark></var>
			</li>
			<li>
				<var><mark>Number</mark></var>
			</li>
			<li>
				<var><mark>Symbol</mark></var>
			</li>
		</ul>
	</figure>
	<div class="mainIdea">
		<p>
			We can think of the object-literal as akin to a stack of shelves. Each
			shelf has a label &mdash; the key &mdash; and an item on that shelf
			&mdash; the value. The label and the item together constitute a single
			shelf &mdash; the property.
		</p>
	</div>
	<p>
		We will use string value keys first, and later examine number and symbol.
		Importantly, records like the object-literal are distinct from classes in
		OOP. They're an older type of data structure, tracing their origins to C. We
		use object-literals to represent situations in the real world where
		independent pieces of data are all part of single, unified structure. Unlike
		the array, records are often of different types and are identified by name
		rather than index.
	</p>
	<p>
		For example, suppose we have some data for velocity, acceleration, momentum,
		and weight. Now suppose that we have the same exact kind of data for another
		event. If we modeled the data, we might generate the following table:
	</p>
	<figure class="math-display">
		<table class="dataTable">
			<thead>
				<td></td>
				<th>First Reading</th>
				<th>Second Reading</th>
			</thead>
			<tr>
				<td>Velocity</td>
				<td>1.14</td>
				<td>1.26</td>
			</tr>
			<tr>
				<td>Acceleration</td>
				<td>1.09</td>
				<td>1.05</td>
			</tr>
			<tr>
				<td>Momentum</td>
				<td>2.33</td>
				<td>2.43</td>
			</tr>
			<tr>
				<td>Weight</td>
				<td>13.4</td>
				<td>13.9</td>
			</tr>
		</table>
	</figure>
	<p>
		How do we store this data? One option is to store each of the values
		individually with their own variables. The problem: While that may work for
		a handful of data values, it would quickly become cumbersome, even
		infeasible, for thousands of data values.
	</p>
	<p>
		Another option is to use an array. We still have a problem: This would still
		be tedious. We would need some sort of key (with comments), distinguishing
		between the data and distinguishing between the events.
	</p>
	<p>
		The solution to this problem is to use an object literal. Object literals
		allow us to group data together, but more importantly, rather than relying
		on each of the data value's index, we can
		<b>label</b> the data. By labeling the data, we can access the assigned
		values with custom keys, rather than with an index.
	</p>
	<div class="mainIdea">
		<p>
			Object-literals contain a
			<b>key-value pair</b>. A <b>key</b> is an identifier mapped to a unique
			<b>value</b>. That key can be defined more than once, but it can only have
			<span class="underlineText">one</span> value in any given
			<i>execution context</i>. That value itself can be numeric data, textual
			data, an array, or more key-value pairs. The object literal is a
			<b>collection</b> of these key-value pairs.
		</p>
	</div>
	<p>
		JavaScript's object-literal syntax is more broadly referred to as
		<b>JavaScript Object Notation (JSON)</b>. In JSON, we specify objects simply
		by listing its contents in a sequence of name-value pairs. The name and the
		value are separated by a colon, the name-value pairs are separated by
		commas, and the entire list of name-value pairs is enclosed in curly braces.
		Here's a simple, but very useful object-literal &mdash; the abstract data
		type of a <b>point</b>:
	</p>
	<pre class="language-javascript"><code>
		let p1 = { x: 0, y: 0 };
	</code></pre>
	<p>
		Notice that we didn't actually surround the keys with double quotes. While
		keys must be strings, we do not have to explicitly declare them as strings.
		JavaScript will coerce these values into strings. We can, however,
		explicitly declare them as strings. This in turn allows us to have
		&#8220;identifiers&#8221; with spaces and other characters we typically
		aren't permitted:
	</p>
	<pre class="language-javascript"><code>
		let p1 = {
			"x-coordinate" : 0,
			"y-coordinate" : 0,
			"point label" : "Point 1"
		};
	</code></pre>
	<p>We can then access the values with square-bracket syntax:</p>
	<pre class="language-javascript"><code>
		let p1 = {
			"x-coordinate" : 0,
			"y-coordinate" : 0,
			"point label" : "Point 1"
		};
		console.log(p1["x-coordinate"]);
		console.log(p1["y-coordinate"]);
		console.log(p1["point label"]);
	</code></pre>
	<pre class="language-bash"><code>
		0
		0
		Point 1
	</code></pre>
	<p>
		Object-literals can also store arrays (and even other object literals).
		Returning to our previous data table example:
	</p>
	<pre class="language-javascript"><code>
		let experiment = {
			velocity: [1.14, 1.26],
			acceleration: [1.09, 1.05],
			momentum: [2.33, 2.43],
			weight: [13.4, 13.9]
		}
	</code></pre>
	<p>
		Compared to object-literals, arrays are strict and sharp &mdash; they order
		data strictly by index. Object-literals, on the other hand, are more
		fluid-like. As a data structure, they morph into whatever we put into the
		object.
	</p>
	<p>
		As can be seen above, just like an array, when an object-literal is assigned
		to a variable, the variable does not store the object itself &mdash; it
		stores the object's reference. There are many different kinds of objects.
		For this section, we focus on how to create
		<b>object literals</b>. The <i>object literal</i> takes the following form:
	</p>
	<figure class="math-display">
		<ul class="syntax">
			<li>${obj_n}$ = {</li>
			<ul>
				<li>${k_0}$ : ${v_0}$,</li>
				<li>${\vdots}$</li>
				<li>${k_n}$ : ${v_n}$</li>
			</ul>
			<li>}</li>
		</ul>
		<figcaption>
			where ${obj_n}$ is the name of the object, ${k}$ is a key, and ${v}$ is a
			value or collection
		</figcaption>
	</figure>
	<p>
		When an object literal is created, the keys are automatically converted into
		strings (except for symbols). Just like arrays, when a variable is assigned
		an object, the variable does not actually store the object; it stores the
		object's reference. Thus, if you assign
		<i>object $w$</i> to a variable $x$, then also assign $x$ to another
		variable $y$, you can make changes to <i>object $w$</i> with both variables
		$x$ and $y$. This is because both variables are pointing to the same object.
	</p>

	<section id="numbers_as_key_values">
		<p>
			<span class="topic">Numbers as Keys.</span> Alongside strings, number
			values can also be used as keys. Specifically, the number must a positive
			number, but it can be float. For example:
		</p>
		<pre class="language-javascript"><code>
			const topCities = {
				0: "Chicago",
				1: "New York City",
				2: "Los Angeles",
				3: "London"
			};
		</code></pre>
		<p>Accessing the values, we must use square-bracket syntax:</p>
		<pre class="language-javascript"><code>
			const topCities = {
				0: "Chicago",
				1: "New York City",
				2: "Los Angeles",
				3: "London"
			};
			console.log(topCities[0]);
		</code></pre>
		<pre class="language-bash"><code>
			Chicago
		</code></pre>
		<p>
			Notice the syntax for accessing the value. Look familiar? Arrays are, in
			fact, object-literals in JavaScript. The syntax we use to initialize
			arrays is really just syntactic sugar for writing something like the
			above.
		</p>
	</section>

	<section id="the_ordering_of_properties">
		<h3>The Ordering of an Object-literal's Properties</h3>
		<p>
			If an object-literal contains only numbers, as keys, the keys (and their
			paired values) are ordered numerically from least to greatest. If,
			however, the keys contain either (a) only strings or (b) strings and
			numbers, then the keys (and their paired values) are ordered by insertion:
			The first item we inserted is first, and the last item we inserted is
			last.
		</p>
	</section>

	<section id="accessing_an_objects_data">
		<h3>Accessing an Object-literal's Data</h3>
		<p>
			There are two ways to access an object-literal's data. One is through dot
			notation:
		</p>
		<ul class="syntax">
			<li>${object}$.${key}$</li>
		</ul>
		<p>The other is through square-bracket-notation:</p>
		<ul class="syntax">
			<li>${object}$[${key}$]</li>
		</ul>
		<p>For example:</p>
		<pre class="language-javascript"><code>
			let experiment = {
				velocity: [1.14, 1.26],
				acceleration: [1.09, 1.05],
				momentum: [2.33, 2.43],
				weight: [13.4, 13.9]
			}
			console.log(experiment.velocity);
			console.log(experiment["momentum"]);
		</code></pre>
		<pre class="language-bash"><code>
			[1.14, 1.26]
			[2.33, 2.43]
		</code></pre>
		<p>
			The form <var>${object}$[${key}$]</var> (square bracket syntax), is
			necessary if the field name is not a simple identifier or if the name is
			computed by the program.
		</p>
		<section id="dynamically_accessing_properties">
			<p>
				<span class="topic">Dynamically Accessing Properties.</span> Because we
				can place expressions inside the brackets for square-bracket syntax, we
				can dynamically access properties in objects. For example:
			</p>
			<pre class="language-javascript"><code>
				function parity(n) { 
					if (n % 2 == 0) { return "a"; }
					else { return "b" };
				};
				const obj = {
					a: "Even",
					b: "Odd"
				}
				console.log(obj[parity(2)]);
				console.log(obj[parity(3)]);
			</code></pre>
			<pre class="language-bash"><code>
				Even
				Odd
			</code></pre>
			<p>
				Above, we passed a function call into the square brackets to access the
				properties of the object <var>obj</var>. With this idiom, we can write
				functions that take user inputs and return object properties.
			</p>
		</section>
	</section>

	<section id="modifying_objects">
		<h3>Modifying an Object-literal</h3>
		<p>
			Because a variable assigned with an object-literal only stores the
			object's reference, we can change an object's properties by simply
			assigning new values to the properties:
		</p>
		<pre class="language-javascript"><code>
			let experiment = {
				velocity: [1.14, 1.26],
				acceleration: [1.09, 1.05],
				momentum: [2.33, 2.43],
				weight: [13.4, 13.9]
			}
			console.log(experiment.velocity);
			
			experiment.velocity[0] = 0.76;
			
			console.log(experiment.velocity);
		</code></pre>
		<pre class="language-bash"><code>
			[1.14, 1.26]
			[0.76, 1.26]
		</code></pre>
		<p>To add a property, we write the following:</p>
		<pre class="language-javascript">
			<code>
				let experiment = {
					velocity: [1.14, 1.26],
					acceleration: [1.09, 1.05],
					momentum: [2.33, 2.43],
					weight: [13.4, 13.9]
				}
				console.log(experiment);
				experiment.temperatureIncreasing = true;
				console.log(experiment);
			</code>
		</pre>
		<pre class="language-bash"><code>
			{velocity: Array(2), acceleration: Array(2), momentum: Array(2), weight: Array(2)}

			{velocity: Array(2), acceleration: Array(2), momentum: Array(2), weight: Array(2), temperatureIncreasing: true}
		</code></pre>
		<p>
			To remove a property in the object-literal, we use the keyword
			<span class="monoText"><mark>delete</mark></span
			>:
		</p>
		<pre class="language-javascript">
			<code>
				let experiment = {
					velocity: [1.14, 1.26],
					acceleration: [1.09, 1.05],
					momentum: [2.33, 2.43],
					weight: [13.4, 13.9]
				};
				console.log(experiment);
				delete experiment.weight;
				console.log(experiment);
			</code>
		</pre>
		<pre class="language-bash"><code>
			{velocity: Array(2), acceleration: Array(2), momentum: Array(2), weight: Array(2)}

			{velocity: Array(2), acceleration: Array(2), momentum: Array(2)}
		</code></pre>
	</section>

	<section id="object_array_equality">
		<h3>Object-array Equality</h3>
		<p>
			Recall that the
			<i>strict equality operator</i>
			<var>===</var> tests whether two values are strictly equal in both value
			and type.
		</p>
		<p>
			Because of the way objects and arrays are stored (i.e., only their
			references are stored), neophytes are often surprised when two arrays or
			objects, consisting of entirely the same values, value types, and keys,
			are not strictly equal.
		</p>
		<pre class="language-javascript">
			<code>
				let primes = [1, 3, 5, 7];
				let morePrimes = [1, 3, 5, 7];
				primes === morePrimes // This returns false
				primes == morePrimes // Still false
	
				/*
				This is happening because the arrays <i>primes</i> and <i>morePrimes</i> have different references. The strict equality operator is not checking the actual arrays, it's only checking the references, and those references are different.
				*/
	
				// To check whether the arrays are strictly equal, we must ensure that both <i>primes</i> and <i>morePrimes</i> are storing the same reference:
				let morePrimes2 = primes;
				morePrimes2 === primes; // This returns true
				morePrimes2 == primes; // This returns true
	
				// From the above, if we make changes to morePrimes2, we change the array assigned to primes, since both variables are pointing to the same array:
				morePrimes2.push(11);
				/*
				Now the array looks like: 
				primes = [1, 3, 5, 7, 11]
				*/
			</code>
		</pre>
	</section>

	<section id="factory_functions">
		<p>
			<span class="topic">Factories.</span> JSON notation is compact and easy to
			read, but we can do better. We can write functions that create object
			literals. We call such functions <b>factories</b>. By convention, these
			functions have names beginning with an uppercase initial letter to
			distinguish them from other functions. For example, here's a function that
			returns a 3-dimensional point, with a default point of <var>(0,0,0)</var>:
		</p>
		<pre class="language-javascript"><code>
			function Point3d(x, y, z) {
				if (x === undefined) {
					x = 0;
					y = 0;
					z = 0;
				}
				return { x: x, y: y, z: z };
			}
			let point1 = Point3d(1, -4, 9);
			console.log(point1);
		</code></pre>
		<pre class="language-bash"><code>
			{x: 1, y: -4, z: 9}
		</code></pre>
	</section>

	<section id="object_shorthand_properties">
		<h3>Shorthand Properties of Objects</h3>
		<p>
			Suppose we have variables declared and initialized with values. In many
			situations, we might want to create an object where the key name is the
			name of the variable, and the key's assigned property is the value
			assigned to the variable.
			<b>Shorthand properties</b>
			provide a concise way of creating such an object. For example, one common
			idiom is to collect all of the results from a function in an object. Say
			we have an array of voltage values from an experiment. We then create a
			function computing various statistics from the the values:
		</p>
		<pre class="language-javascript"><code>
			const experiment1 = [0.53, 0.58, 0.59, 0.53, 0.61, 0.51, 0.53];
			const experimentStats = (arr) => {
				const voltageQuantity = arr.length;
				const maxVoltage = math.max(...arr);
				const minVoltage = math.min(...arr);
				const sumVoltages = arr.reduce(
					(sumVoltages, r) => sumVoltages + r
				);
				const averageVoltage = sumVoltages / voltageQuantity;
				const sortVoltageAscending = arr.sort((a, b) => a - b);

				return {
					maximumVoltage: maxVoltage,
					minimumVoltage: minVoltage,
					averageVoltage: averageVoltage,
					voltagesAscending: sortVoltageascending,
				};
			};
			console.log(experimentstats(experiment1));
		</code></pre>
		<pre class="language-bash"><code>
			{
				maximumVoltage: 0.61,
				minimumVoltage: 0.51,
				averageVoltage: 0.5542857142857143,
				voltagesAscending: [ 0.51, 0.53, 0.53, 0.53, 0.58, 0.59, 0.61 ]
			}
		</code></pre>
		<p>
			But, with
			<i>shorthand properties</i>, we can shorten the return statement in the
			example above:
		</p>
		<pre class="language-javascript"><code>
			const experiment1 = [0.53, 0.58, 0.59, 0.53, 0.61, 0.51, 0.53];
			const experimentStats = (arr) => {
				const voltageQuantity = arr.length;
				const maxVoltage = math.max(...arr);
				const minVoltage = math.min(...arr);
				const sumVoltages = arr.reduce(
					(sumVoltages, r) => sumVoltages + r
				);
				const averageVoltage = sumVoltages / voltageQuantity;
				const sortVoltageAscending = arr.sort((a, b) => a - b);

				return {
					maxVoltage,
					minVoltage,
					averageVoltage,
					sortVoltageascending,
				};
			};
			console.log(experimentstats(experiment1));
		</code></pre>
		<pre class="language-bash"><code>
			{
				maximumVoltage: 0.61,
				minimumVoltage: 0.51,
				averageVoltage: 0.5542857142857143,
				voltagesAscending: [ 0.51, 0.53, 0.53, 0.53, 0.58, 0.59, 0.61 ]
			}
		</code></pre>
		<p>
			The catch, of course, is that we cannot use unique variable names (of
			course, we can get around that by assigning those names as keys in the
			first place).
		</p>
	</section>

	<section id="computed_properties">
		<h3>Computed Properties</h3>
		<p>
			<i>Computed properties</i> allow us to write properties of an object
			literal with a <i>dynamic key</i>. Recall that when use a variable name as
			a property name in an object, javascript does not check whether the name
			is actually a variable&mdash;it simply treats it as a string:
		</p>

		<pre class="language-javascript"><code>
				const negativeCharge = -1;
				const negParticle = 'electron';

				// if we tried to use the variable name as a property:

				const particleDetails = {
					negParticle: negativeCharge
				};
				console.log(particleDetails);
		</code></pre>
		<pre class="language-bash"><code>
			{ negParticle: -1 }
		</code></pre>
		<p>
			We see the output above because JavaScript does not check if
			<var>negParticle</var> is a variable; it's simply a string. To use a
			variable name as a property name while making sure that javascript
			evaluates it, we need to use the <var>object[key]</var> syntax
			<i>after</i> we initialize the object:
		</p>

		<pre class="language-javascript"><code>
				const negativecharge = -1;
				const negparticle = 'electron';
				const particledetails = {};
				particledetails[negparticle] = negativecharge;
	
				// test: 
				console.log(particledetails);
				// output: { electron: -1 }
			</code></pre>

		<p>
			But, the
			<i>computed properties syntax</i>
			provides a more a concise way of accomplishing the same task:
		</p>

		<pre class="language-javascript"><code>
				const negativecharge = -1;
				const negparticle = 'electron';
				const particledetails = { [negparticle]: negativecharge };
				// test:
				console.log(particledetails); // output: { electron: -1 }
			</code></pre>

		<p>
			Notice the syntax we used,
			<var>[]</var>:
		</p>

		<pre class="language-javascript"><code>
				const variablea = 'value1';
				const variableb = 'value2';
				const objectc = { [variablea]: variableb }
				// we used the value of variablea as the key name for the value of variableb
			</code></pre>

		<p>
			We can use the
			<i>computed properties syntax</i> to more concisely write a function that
			adds a property. Without using the <i>computed properties syntax</i>, the
			function looks like:
		</p>

		<pre class="language-javascript"><code>
				// this function accepts an object, and returns a copy of that object with a new property inserted:
				function propadder(obj, ky, val) {
					const objcopy = { ...obj };
					objcopy[ky] = val;
					return objcopy
				};
				// let's test it on an object:
				const objsample = { str: 'val', num: 2 };
				let objsamplenew = propadder(objsample, 'bool', true);
		
				console.log(objsamplenew); // output: { str: 'val', num: 2, bool: true }
			</code></pre>

		<p>
			Above, we used the <var>object[key]</var> syntax to add the new property.
			We can write the same statements with less characters with the
			<i>computed properties syntax</i>:
		</p>

		<pre class="language-javascript"><code>
				const propadder = (obj, ky, val) => { return { ...obj, [ky]: val }; };
				// test:
				const objsample = { str: "val", num: 2 };
				let objsamplenew = propadder(objsample, "bool", true);
		
				console.log(objsamplenew); // output: { str: 'val', num: 2, bool: true }
			</code></pre>

		<p>Or, even shorter with an implicit return:</p>

		<pre class="language-javascript"><code>
				const propadder = (obj, ky, val) => ({ ...obj, [ky]: val });
				// test:
				const objsample = { str: "val", num: 2 };
				let objsamplenew = propadder(objsample, "bool", true);
	
				console.log(objsamplenew); // output: { str: 'val', num: 2, bool: true }	
			</code></pre>
	</section>

	<section id="methods_and_objects">
		<h3>Methods: Functions in Objects</h3>
		<p>
			We can add functions as properties on objects. Once we add a function to
			an object, it becomes a
			<b>method</b>. The simplest reason for why we would want to put functions
			into objects is that doing so is conducive to better organized programs,
			which in turn leads to more efficient and elegant code. Recall that a
			function, at it is core, is just data, so it can be assigned to variables.
			Likewise, it can be assigned to a key:
		</p>

		<pre class="language-javascript"><code>
				// here's a function that computes the circumference of a circle:
				const circumference = (r) => 2 * r * math.pi;
				// we can place this in an object:
				const mathfuncs = {
					circumference: circumference
				};
				// once placed inside an object, we can call it with the method syntax:
				console.log(mathfuncs.circumference(3)); // output: 18.84955592153876
			</code></pre>

		<p>
			In the example above, the function is written outside the object, then
			later placed in the object. This is not how methods are typically written.
			instead, we usually write the functions directly inside the object:
		</p>

		<pre class="language-javascript"><code>
				// we can place this in an object:
				const mathfuncs = {
					circumference: circumference = (r) => (2 * r * math.pi),
					circlearea: circlearea = (r) => (math.pi * r * r)
				};
				// once placed inside an object, we can call it with the method syntax:
				console.log(mathfuncs.circumference(4)); // output: 25.132741228718345
				console.log(mathfuncs.circlearea(4)); // output: 50.26548245743669
			</code></pre>

		<p>
			Note that in the examples, we used the
			<i>arrow function</i> syntax. This is not a common way of writing
			functions inside objects.
		</p>

		<section id="shorthand_methods">
			<h4>Shorthand Methods Syntax</h4>
			<p>
				Instead of using the key value pairs syntax, we can use the
				<i>shorthand method syntax</i>:
			</p>
			<pre class="language-javascript"><code>
					// we can place this in an object:
					const mathfuncs = {
						circumference(r) {
							return 2 * r * math.pi;
						},
						circlearea(r) {
							return math.pi * r * r;
						}
					};
					// once placed inside an object, we can call it with the method syntax:
					console.log(mathfuncs.circumference(4)); // output: 25.132741228718345
					console.log(mathfuncs.circlearea(4)); // output: 50.26548245743669
				</code></pre>
		</section>

		<section id="why_use_methods">
			<h4>Why Should We Use Methods?</h4>
			<p>The best way to see why methods are extremely useful is by example:</p>

			<pre class="language-javascript"><code>
					/*
					I want a function that draws a card out of the deck (and makes sure that the deck is 1 card fewer for each draw)
					*/
					// first, let's make the deck
					function makeDeck() {
						const deck = []; // Make an empty deck
						const suits = ['hearts', 'diamonds', 'spades', 'clubs']; // The array of suits
						const values = '2,3,4,5,6,7,8,9,10,J,Q,K,A'; // A string of values
						// Turn the string of values into an array
						for (let value of values.split(',')) {
							// For each array element, do this:
							for (let suit of suits) {
								// For each suit, do this: 
								deck.push({value, suit})
							}
						}
						return deck;
					};
		
					// Suppose I want to draw a card from the deck
					// We need to write a function that draws the card:
					function drawCard(deck) {
						return deck.pop() // Take a card out of the deck
					};
					// Set the deck to a variable:
					const deck = makeDeck();
					console.log(drawCard(deck)); // Output: { value: 'A', suit: 'clubs' }
		
					// To draw another card, we need to pass the argument again:
					console.log(drawCard(deck)); // Output: { value: 'A', suit: 'spades }
					// The problem with writing the program this way is that we have to keep passing an argument over and over again.
					// And what if we need to shuffle the deck? (The pop method is just taking a card from the deck in order)							
				</code></pre>

			<p>
				The above example shows a common phenomenon in programming: repetitious
				code. Where there is repetitious code, there are methods laying in
				ambush. The above code written inside an object:
			</p>

			<pre class="language-javascript"><code>
					const deck = {
						deck: [],
						suits: ["hearts", "diamonds", "spades", "clubs"],
						values: "2,3,4,5,6,7,8,9,10,J,Q,K,A",
		
						makeDeck() {
							const { suits, values, deck} = this;
							for (let value of values.split(",")) {
								for (let suit of suits) {
									deck.push({ value, suit });
								}
							}
						},
						
						drawCard() {
							return this.deck.pop()
						}
					};
					deck.makeDeck(); // Make the deck
					// Then draw a card:
					console.log(deck.drawCard()); // Output: { value: 'A', suit: 'clubs' }							
				</code></pre>

			<p>
				By storing the functions in an object, we've created methods, which can
				be called upon over and over without having to pass repeatedly pass
				arguments. By using methods, we can do even more things:
			</p>

			<pre class="language-javascript"><code>
					const theDeck = { // create the object
						deck: [], // Variable stores deck
						drawnCards: [], // Variable stores drawn cards
						suits: ["hearts", "diamonds", "spades", "clubs"], // the suits
						values: "2,3,4,5,6,7,8,9,10,J,Q,K,A", // the ranks
						// Method: make deck
						makeDeck() {
							const { suits, values, deck} = this; // stop writing 'this' repeatedly
							// loop through 'values' string turned into array
							for (let value of values.split(",")) {
								// for each element in 'values', loop through 'suits'
								for (let suit of suits) {
									// for each suit, push this object into 'deck'
									deck.push({ value, suit });
								}
							}
						},
						// Method: draw card
						drawCard() {
							const card = this.deck.pop(); // Store drawn card in variable
							this.drawnCards.push(card); // Store drawn card in the drawnCards array
							return card; // Output card
						},
						// Method: draw multiple cards
						drawCards(numCards) {
							const cards = []; // Store drawn cards in variable
							// run drawCard this many times
							for (let i = 0; i < numCards; i++) {
								cards.push(this.drawCard()); // Put drawn cards in cards variable
							}
							return cards; // Output cards
						},
						// Method: shuffle cards
						shuffle() {
							const { deck } = this;
							// Loop through the array backwards
							for (let i = deck.length - 1; i > 0; i--) {
								// Pick a random index before the current element
								let j = Math.floor(Math.random() * [i + 1]);
								// Swap elements with destructuring
								[deck[i], deck[j] = deck[j], deck[i]];
							}
						}
					};
		
					// Let's test.
					theDeck.makeDeck(); // Make the deck. 
					console.log(theDeck.drawCard()); // Draw card:
					// Output: { value: 'A', suit: 'clubs' } 
					console.log(theDeck.drawnCards); // Check drawn cards array:
					// Output: [ { value: 'A', suit: 'clubs' } ]
					console.log(theDeck.drawCards(3)); // Draw multiple cards
					/*
					Output: 
					[
					{ value: 'A', suit: 'spades' },
					{ value: 'A', suit: 'diamonds' },
					{ value: 'A', suit: 'hearts' }
					]
					*/
					theDeck.shuffle(); // Shuffle the deck
					console.log(theDeck.drawCard()); // Draw card
					// Output: { value: 'K', suit: 'clubs' }							
				</code></pre>
		</section>
	</section>

	<section id="objects_in_memory">
		<h3>Objects in Memory</h3>
		<p>Suppose we wrote the following code:</p>
		<pre class="language-javascript"><code>
			const taxpayer1 = {
				name: "Al Capone",
				age: 48,
				married: true
			}
		</code></pre>
		<p>
			Question: How is this object stored in memory? First, it's helpful to
			identify the different parts of the expression above:
		</p>
		<figure>
			<ul>
				<li>There's an identifier, <var>user1</var>.</li>
				<li>There's a collection of properties:</li>
				<ul>
					<li>
						The key <var>taxpayer1</var> is paired with the string value
						<var>"Al Capone"</var>.
					</li>
					<li>
						The key <var>age</var> is paired with the number value
						<var>48</var>.
					</li>
					<li>
						The key <var>married</var> is paired with the Boolean value
						<var>false</var>.
					</li>
				</ul>
			</ul>
		</figure>
		<p>
			Earlier, we said that we can think of the object as a collection of
			shelves. Accordingly, from a higher-level view, we can visualize the
			object above as such:
		</p>
		<figure>
			<img
				src="{% static 'images/js_object.svg' %}"
				alt="JavaScript object as a shelf"
				loading="lazy"
				class="fifty-p"
			/>
		</figure>
		<p>
			A lower-level view, however, would show that the variable
			<var>taxpayer1</var> is actually bound to a reference to the object, and
			the object itself is a collection of references to the properties:
		</p>
		<figure>
			<img
				src="{% static 'images/js_object_ref.svg' %}"
				alt="JavaScript object as a shelf"
				loading="lazy"
				class="seventy-p"
			/>
		</figure>
	</section>

	<section id="the_ubiquity_of_objects">
		<h3>The Ubiquity of Objects in JavaScript</h3>
		<p>
			Part of the reason why JavaScript falls into the problem of using the word
			&#8220;object&#8221; confusingly is because everything boils down to the
			mechanics behind object-literals. The exception to this general rule is
			the primitive data types:
		</p>
		<figure>
			<ul>
				<li>
					<span class="monoText">
						<mark>String</mark>
					</span>
				</li>
				<li>
					<span class="monoText">
						<mark>Number</mark>
					</span>
				</li>
				<li>
					<span class="monoText">
						<mark>Boolean</mark>
					</span>
				</li>
				<li>
					<span class="monoText">
						<mark>Undefined</mark>
					</span>
				</li>
				<li>
					<span class="monoText">
						<mark>null</mark>
					</span>
				</li>
				<li>
					<span class="monoText">
						<mark>Symbol</mark>
					</span>
				</li>
			</ul>
		</figure>
		<p>
			There is, however, an exception to the exception: Some of the primitive
			data types have <b>object wrapper</b> that makes them behave like an
			object-literal in certain situations. For example, the
			<var>String</var> data type has an object wrapper, which includes the
			<var>length</var> property.
		</p>
	</section>
</section>

<section id="keyword_this">
	<h2>The Keyword 'This"</h2>
	<p>
		A variable declared with
		<var>var</var> in the global scope will be included in the
		<var>window</var> object as a property. But, variables declared with
		<var>let</var> and <var>const</var> will not be included. The
		<var>this</var> keyword is a keyword that references the current
		<i>execution scope</i>, and gives an <i>object</i> back as its output. Thus,
		the returned object changes depending on the current execution's scope. The
		execution might have a global scope, or it might have some other
		scope&mdash;expression scope, block scope, function scope, etc. For example,
		consider the code below:
	</p>
	<pre class="language-javascript"><code>
		function helloWorld() {
			console.log("Hi")
			console.log(this);
		};
		helloWorld();	
		/*
		Output:
		WindowÂ {window: Window, self: Window, document: document, name: "", location: Location,Â â€¦}
		*/
	</code></pre>
	<p>
		In the code above, our function contains the statement,
		<var>console.log(this);</var>. This statement says, "JavaScript, display in
		the console this function's scope." In doing so, we get back an object
		called the <var>Window</var>. The window is the global scope in the browser.
		When we wrote the function <var>helloworld</var>, we wrote directly into the
		program, not under any other block. When we write functions like this, the
		functions are written in the <i>global scope</i>. When a function is written
		in the <i>global scope</i>, it becomes a property in the
		<i>global scope object</i> (in this case, the browser's global scope), and
		as such, we can call it with the usual object syntax:
		<var>window.functionName()</var>. The same goes for variables declared with
		<var>var</var> directly into the program (not inside any other block scope).
	</p>
	<pre class="language-javascript"><code>
		var vector = 3;
	</code></pre>
	<p>
		By declaring the variable <var>vector</var> with the keyword
		<var>var</var> above, the name <var>vector</var> now becomes a property of
		the <var>Window</var> object, which we can call with
		<var>window.vector</var>. <b>BUT</b> this rule does not apply to variables
		declared with the keywords <var>let</var> and <var>const</var>.
	</p>

	<section id="using_this_">
		<p>
			<span class="topic">Why is 'this' so useful?</span>
			Consider the code below, where we write a function using the
			<var>this</var> keyword inside an object:
		</p>
		<pre class="language-javascript"><code>
			// An object containing the properties of tree ferns
			const treeFern = {
				scientificName: 'Dicksonia antarctica',
				genus: 'Dicksonia',
				family: 'Dicksoniaceae',
				Order: 'Cyatheales',
				Class: 'Polypodiopsida',
				Division: 'Polypodiophyta',
				Kingdom: 'Plantae',
				allDetails() {
					console.log(this);
				}
			};
			treeFern.allDetails();
			/*
			Output:
			{
				scientificName: 'Dicksonia antarctica',
				genus: 'Dicksonia',
				family: 'Dicksoniaceae',
				Order: 'Cyatheales',
				Class: 'Polypodiopsida',
				Division: 'Polypodiophyta',
				Kingdom: 'Plantae',
				allDetails: [Function: allDetails]
			}
			*/
		</code></pre>
		<p>
			In the example above, we wrote the function
			<var>allDetails()</var> inside the object <var>treeFern</var>. That
			function contains the statement <var>console.log(this);</var>, which tells
			JavaScript, "Display in the console this function's scope." When we call
			the function with object syntax, <var>treeFern.allDetails()</var>, we get
			back that the entire scope of that function, the object
			<var>treefern</var>.
		</p>
		<p>
			An astute observer might notice the immediate utility of the
			<var>this</var> keyword: It allows us to use the properties inside an
			object while writing statements inside said object.
		</p>
		<pre class="language-javascript"><code>
			// Here is an object of some mathematical functions:
			const mathematician = {
				firstName: 'Renee',
				lastName: 'Descartes',
				firstNameDisplay() {
					console.log(this.firstName);
				}
			};
			mathematician.firstNameDisplay(); // Output: Renee
		</code></pre>
		<p>A more elaborate example:</p>
		<pre class="language-javascript"><code>
			const RD = {
				firstName: 'Renee',
				lastName: 'Descartes',
				notable: 'Cartesian plane',
				details() {
					console.log(`${this.firstName} ${this.lastName}, notable for the ${this.notable}.`);
				}
			};
			RD.details(); // Output: Renee Descartes, notable for the Cartesian plane.
		</code></pre>
	</section>

	<section id="destructuring_and_this">
		<p>
			<span class="topic"> Using Destructuring Syntax with 'this'. </span>
			In the example above, we constantly had to write the
			<var>this</var> keyword. We can cut all of that out with the
			<i>destructuring syntax</i>:
		</p>
		<pre class="language-javascript"><code>
			const rD = {
				firstName: 'Renee',
				lastName: 'Descartes',
				notable: 'Cartesian plane',
				details() {
					const {
						firstName,
						lastName,
						notable
					} = this;
					console.log(`${firstName} ${lastName}, notable for the ${notable}.`);
				}
			};
			rD.details(); // Output: Renee Descartes, notable for the Cartesian plane.	
		</code></pre>
		<p>
			The <var>this</var> keyword allows us to write methods that can "see" the
			other properties inside the object.
		</p>
	</section>

	<section id="using_this_to_reference_methods">
		<p>
			<span class="topic"> Using the 'this' Keyword to Reference Methods.</span>
			We can use <var>this</var> to reference other methods inside an object:
		</p>
		<pre class="language-javascript"><code>
			const sR = {
				first: "Srinivasa",
				last: "Ramanujan",
				country: "India",
				fullName() {
					return `${this.first} ${this.last}`
				},
				summary() {
					const fullName = this.fullName();
					return `${fullName} is a mathematician from ${this.country}.`
				}
			};
			console.log(sR.summary()); // Output: Srinivasa Ramanujan is a mathematician from India.								
		</code></pre>
	</section>

	<section id="value_of_this">
		<h2>The Value of 'This'</h2>
		<p>
			The value of the <var>this</var> keyword depends on how we invoke the
			function that uses it. Put simply, the value of the
			<var>this</var> keyword depends on <i>where we write it</i> and
			<i>how we write it</i>. To see this crucial point, consider the code
			below:
		</p>
		<pre class="language-javascript"><code>
			// Same object from the preceding example.
			const sR = {
				first: "Srinivasa",
				last: "Ramanujan",
				country: "India",
				fullName() {
					return `${this.first} ${this.last}`
				},
				summary() {
					const fullName = this.fullName();
					return `${fullName} is mathematician from ${this.country}.`
				}
			};
			// Suppose we assign the method SR.summary() to a variable: 
			const summary = sR.summary;
			// Now suppose we call that function:
			console.log(summary());
			/*
			Output: 
			TypeError: this.fullName is not a function
			*/								
		</code></pre>
		<p>Compare the error above with the following code:</p>
		<pre class="language-javascript"><code>
			// Same object from the preceding example.
			const sR = {
				first: "Srinivasa",
				last: "Ramanujan",
				country: "India",
				fullName() {
					return `${this.first} ${this.last}`
				},
				summary() {
					console.log(this); // Let's see what the object is
					const fullName = this.fullName();
					return `${fullName} is mathematician from ${this.country}.`
				}
			};
			const summary = sR.summary;
			console.log(summary());
			/*
			Output: 
			WindowÂ {window: Window, self: Window, document: document, name: "", location: Location,Â â€¦}
			Uncaught TypeError: this.fullName is not a function at summary
			*/								
		</code></pre>
		<p>
			In the second example, we see that
			<var>this</var> is referencing the object <var>window</var>, the browser's
			global scope. If we instead just used the typical object key syntax rather
			than the variable:
		</p>
		<pre class="language-javascript"><code>
			// Same object from the preceding example.
			const sR = {
				first: "Srinivasa",
				last: "Ramanujan",
				country: "India",
				fullName() {
					return `${this.first} ${this.last}`
				},
				summary() {
					console.log(this); // Let's see what the object is
					const fullName = this.fullName();
					return `${fullName} is mathematician from ${this.country}.`
				}
			};
			console.log(sR.summary());
			/*
			Output: 
			{first: "Srinivasa", last: "Ramanujan", country: "India", fullName: Æ’, summary: Æ’}
			Srinivasa Ramanujan is mathematician from India.
			*/								
		</code></pre>
		<p>
			Now we see that the value of <var>this</var> is the object it's contained
			in, <var>sR</var>, rather than the <var>window</var> object, the global
			scope.This shows that the value of <var>this</var> is determined by the
			way we invoke the function that uses the <var>this</var> keyword. One way
			to think about this: When we explicitly call the function with the object
			syntax, <var>object.function</var>, the value of <var>this</var> is the
			object itself. But, when we simply just call the function without
			explicitly stating the object, the value of <var>this</var> is the global
			scope object (which, in the browser, is the <var>window</var> object).
		</p>
	</section>
</section>

<section id="for_loop">
	<h2>Iterative Statements</h2>
	<p>
		Having discussed objects and arrays, we can now proceed to
		<b>iterative statements</b> &mdash; statements that repeat statements.
	</p>
	<h3>The For-loop</h3>
	<p>
		The first iterative statement we encounter is the
		<b>for-statement</b>, or <b>for-loop</b> tells JavaScript to loop through a
		code block a number of times (or infinitely). The for-loop takes the
		following form:
	</p>
	<figure class="math-display">
		<div>
			<ul class="syntax">
				<li>for (${e_i}$, ${c}$, ${s_f}$) {</li>
				<ul>
					<li>${s_0}$</li>
					<li>${\vdots}$</li>
					<li>${s_n}$</li>
				</ul>
				<li>};</li>
			</ul>
		</div>
		<figcaption>
			where ${e_i}$ is the initial expression, ${c}$ is a Boolean expression
			(the test case), ${e_f}$ is the final statement executed after each
			iteration, and ${s_0 \ldots s_n}$ are the satements to execute on each
			iteration
		</figcaption>
	</figure>
	<p>
		The <b>initial expression</b> is the statement that JavaScript executes
		exactly once before entering the for-loop. E.g., declaring a variable to be
		used in the condition and final expression. Most often, the initial
		expression is used to create a for-loop's counter. The <b>condition</b>, or
		<b>test statement</b>, is a boolean expression that determines whether
		JavaScript should proceed with the loop. The condition is checked before
		each execution of the loop. If the condition is true, JavaScript continues
		(the loop executes). If the condition is false, JavaScript stops, and goes
		to the next statement in the program (the loop terminates). The
		<b>final expression</b> is the expression that JavaScript evaluates after
		each loop iteration. Usually, the final expression contains code to update
		the counter variable declared in the initial expression. The for-loop's
		<b>statement</b> is the code that the loop executes, or, more generally, the
		code we want repeated.
	</p>
	<section id="incrementing_counter">
		<p>For example, here's a simple incrementing counter in JavaScript.</p>
		<pre class="language-javascript">
			<code>
				for (let i = 0; i < 3; i++) {
					console.log("execution");
				}
			</code>
		</pre>
		<pre class="language-bash"><code>
			execution
			execution
			execution
		</code></pre>
		<p>The loop above executes in the following manner:</p>
		<ol>
			<li>Initial Expression: Declare a variable i, and assign it 0.</li>
			<li>
				Check condition: Is i less than 3? Yes, 0 < 3. Update counter (i is now
				1), and run the loop.
			</li>
			<li>Console output: "execution"</li>
			<li>
				Check condition: Is i less than 3? Yes, 1 < 3. Update counter (i is now
				2), and run the loop.
			</li>
			<li>Console output: "execution"</li>
			<li>
				Check condition: Is i less than 3? Yes, 2 < 3. Update counter (i is now
				3), and run the loop.
			</li>
			<li>Console output: "execution"</li>
			<li>
				Check condition: is i less than 3? No, 3 ${\nless}$ 3. Terminate loop.
			</li>
		</ol>
		<p>
			Here's another example. Suppose we were asked to merge one array to
			another array without use <var>concat().</var> We can do so with a
			for-loop:
		</p>
		<pre class="language-javascript"><code>
			function mergeArray(array1, array2) {
				for (let i = 0; i < array2.length; i++) {
					array1[array1.length] = array2[i];
				}
			}
			let list1 = ["banana", "apple", "kiwi"];
			let list2 = ["mango", "durian", "peach"];
			mergeArray(list1, list2);
			console.log(list1);
		</code></pre>
		<pre class="language-bash"><code>
			['banana', 'apple', 'kiwi', 'mango', 'durian', 'peach']
		</code></pre>
		<p>
			The function above uses a for-loop to simulate the behavior of
			<var>concate()</var>. This function, however, mutates existing values, so
			let's rewrite it to avoid mutation. To do so, we'll write another
			function, <var>copyArray()</var>, which simulates the
			<var>slice()</var> method.
		</p>
		<pre class="language-javascript"><code>
			function copyArray(arr, begin, end) {
				let outputArray = [];
				if (end === undefined || end > arr.length) {
					end = arr.length;
				}
				for (let i = begin; i < end; i++) {
					outputArray[i] = arr[i];
				}
				return outputArray;
			}
			
			function arrayMerge(array1, array2) {
				let array1Copy = copyArray(array1, 0);
				let array2Copy = copyArray(array2, 0);
				for (let i = 0; i < array2Copy.length; i++) {
					array1Copy[array1Copy.length] = array2Copy[i];
				}
				return array1Copy;
			}
			
			let list1 = ["banana", "apple", "kiwi"];
			let list2 = ["strawberry", "rambutan", "peach"];
			let lists1And2 = arrayMerge(list1, list2);
			console.log(list1);
			console.log(list2);
			console.log(lists1And2);
		</code></pre>
		<pre class="language-bash"><code>
			['banana', 'apple', 'kiwi']
			['strawberry', 'rambutan', 'peach']
			['banana', 'apple', 'kiwi', 'strawberry', 'rambutan', 'peach']
		</code></pre>
		<p>
			The above code simulates the behavior of
			<var>push()</var> and <var>concat()</var>. The difference, however, is
			that we do not mutate the arguments passed. As an aside, here's a common
			for-loop mistake to be aware of: If a variable is declared with
			<var>let</var> in a for-loop's initial expression, the variable is scoped
			to the loopâ€”it is destroyed once the loop has finished executing. If a
			for-loop's condition is left out, JavaScript will interpret the loop's
			"condition" as always true, resulting in an infinite loop.
		</p>
	</section>
</section>

<section id="for_loops_and_arrays">
	<h3>For-loops & Arrays</h3>
	<p>
		We can use a for-loop to iterate over an array. For example, iterating over
		an array of strings:
	</p>
	<pre class="language-javascript">
		<code>
			const vectors = ['velocity', 'acceleration', 'weight'];
			for (let i = 0; i < vectors.length; i++) {
				console.log(i, vectors[i]);
			}
			/*
			The above code outputs the following to the console:
			0 velocity
			1 acceleration
			2 weight
			*/
		</code>
	</pre>
	<p>Here is another example, iterating over an array of numbers:</p>
	<pre class="language-javascript">
		<code>
			/*
			Here is a program that adds pairs of primes, one after another, and (1) divides by them two, and (2) returns the distance between the two primes.
			*/
			let primes = [1, 3, 5, 7, 11];
			for (let i = 0; i < primes.length - 1; i++) {
				console.log(`Pair of primes: ${primes[i]} and ${primes[i + 1]}`)
				console.log(`Half of the sum: ${(primes[i] + primes[i + 1]) / 2}`)
				console.log(`Distance: ${primes[i + 1] - primes[i]}`);
			}
			/*
			The above code outputs the following to the console:
			Pair of primes: 1 and 3
			Half of the sum: 2
			Distance: 2
			Pair of primes: 3 and 5
			Half of the sum: 4
			Distance: 2
			Pair of primes: 5 and 7
			Half of the sum: 6
			Distance: 2
			Pair of primes: 7 and 11
			Half of the sum: 9
			Distance: 4
			*/
		</code>
	</pre>
	<p>
		It is a common convention to use i for a for-loop's incrementing variable,
		then j and k for inner loops.
	</p>
	<p>
		This convention originates in mathematics, where $i$ is used for the first
		index in summation notation, $j$ for the second, etc.:
	</p>
	<figure>
		<p>$$\sum_{i=1}^{n}i = \frac{n^2+n}{2}$$</p>
	</figure>

	<section id="nested_for_loops">
		<p>
			<span class="topic">Nested For-loops</span>
			We can nest a for-loop inside another for-loop:
		</p>
		<pre class="language-javascript">
			<code>
				for (let i = 1; i <= 3; i++) {
					console.log('Outer Loop:', i);
	
					for (let j = 1; j <= 2; j++) {
						console.log(' Inner Loop:', j);
					}
				}
				/*
				The above code will out put to the console:
				Outer Loop: 1
				Inner Loop: 1
				Inner Loop: 2
				Outer Loop: 2
				Inner Loop: 1
				Inner Loop: 2
				Outer Loop: 3
				Inner Loop: 1
				Inner Loop: 2
				*/
			</code>
		</pre>
		<p>Nested for-loops are useful for targeting nested arrays:</p>
		<pre class="language-javascript">
			<code>
				/*
				Here is an array of number arrays. Suppose we want to find the sum of the numbers in each of the array.
				*/
				let arrNum = [
					[4, 32, 8, 4],
					[64, 8, 32, 2],
					[8, 32, 16, 4],
					[2, 8, 4, 2]
				];
				// First, we need to declare a variable that will store the sums we want.
				let sumNum = 0;
				// Next, we need to loop through the outer array (by targeting each of the individual arrays)
				for (let i = 0; i < arrNum.length; i++) {
				/*
				The outer loop loops through each of the nested arrays. There are 4 arrays (represented by arrNum.length), so the loop first looks at array of index 0, then 1, then 2, then 3, then 4. Now we need to loop through each of the elements in the nested array. First, we declare a variable named nestedArrNum, which will store each of the targeted nested arrays.
				*/
					let nestedArrNum = arrNum[i];
				/* 
				For the targeted nested array with index 0, loop through each of the elements, then continue until i is less than arrNum.length (all nested arrays have been looped through):
				*/
					for (let j = 0; j < nestedArrNum.length; j++) {
						// Then add to sumNum each element of the targeted nested array.
						sumNum += nestedArrSum[j]; 
					}
					console.log(sumNum);
				}
				/*
				The above will output to the console:
				48
				154
				214
				230
				*/
			</code>
		</pre>
	</section>
</section>

<section id="while_loop">
	<h2>The while-loop</h2>
	<p>
		The while-loop, in some situations, is a more efficient version of a
		for-loop. The while-loop takes the following form:
	</p>
	<figure class="math-display">
		<div>
			<ul class="syntax">
				<li>while (${c}$) {</li>
				<ul>
					<li>${s_0}$</li>
					<li>${\vdots}$</li>
					<li>${s_n}$</li>
				</ul>
				<li>}</li>
			</ul>
		</div>
		<figcaption>
			where ${c}$ is some Boolean expression, and ${s_0 \ldots s_n}$ is the
			block of code to execute.
		</figcaption>
	</figure>
	<p>
		When should we use a while-loop instead of a for-loop? The while-loop is
		best used when we do not know how many times the loop should run. And in
		some cases, a while-loop may be more efficient than a for-loop:
	</p>
	<pre class="language-javascript">
		<code>
			// Here is a for loop:
			for (let i = 0; i < 3; i++) {
				console.log(`for loop: ${i}`);
			}
			// The same structure, with a while loop:
			let j = 0;
			while (j < 3) {
				console.log(`while loop: ${j}`);
				j++
			}
			/*
			This outputs the following to the console:
			for loop: 0
			for loop: 1
			for loop: 2

			while loop: 0
			while loop: 1
			while loop: 2
			*/
		</code>
	</pre>
	<section id="break_keyword">
		<p>
			<span class="topic">The Break Keyword</span>
			The <var><mark>break</mark></var> keyword is a special keyword in
			JavaScript that tells JavaScript to break out of a loop (i.e., terminate
			the loop). This is often used to terminate infinite loops or loops at risk
			of infinite iteration. The keyword is often used in the following form:
		</p>
		<figure>
			<ul class="syntax">
				<li>while (${c}$) {</li>
				<ul>
					<li>if (${d}$) { break; }</li>
					<li>${s_0 \ldots s_n}$</li>
				</ul>
				<li>}</li>
			</ul>
		</figure>
		<p>
			Where ${c}$ and ${d}$ are Boolean expressions, and ${s_0 \ldots s_n}$ are
			statement(s) to execute.
		</p>
	</section>
</section>

<section id="infinite_loops">
	<h2>Infinite Loops</h2>
	<p>
		An <b>infinite loop</b> is a loop that never ends. Infinite loops have their
		place in programming, but before writing an infinite loop, we need to always
		check why we're using an infinite loop in the first place. Here is an
		example:
	</p>
	<pre class="language-javascript">
		<code>
			for (let i = 5; i >= 0; i++) {
				<span class="greyText italicsText">code block</span>
			}
			/* This is an infinite loop. i is assigned the value 5, the condition checks if i is greater than or equal to 0, and if it is, i is incremented by 1. An infinite loop occurs because i will always be greater than 0 (the condition is always true), so JavaScript never escapes the loop, and the code block is executed an infinite amount of times (or, more realistically, however long the machine can handle).
			*/
		</code>
	</pre>
</section>

<section id="for_of_loop">
	<h2>The For-of Loop</h2>
	<p>
		The for-of loop is a more efficient way to loop through an
		<b>iterable</b>. An <b>iterable</b> is an object that has properties and can
		be looped through or iterated (e.g., an
		<a href="#arrays_introduction">array</a>). The for-of loop takes the
		following form:
	</p>
	<figure>
		<ul class="syntax">
			<li>for (${v}$ of ${obj}$) { ${s_0 \ldots s_n}$ }</li>
		</ul>
	</figure>
	<p>
		In the syntax above, ${v}$ is some element in an iterable object ${obj,}$
		and ${s_0 \ldots s_n}$ are statements to execute. For example, suppose we
		want to log to the console each of the elements in the array
		<var>arr</var>. We can do so with a regular for-loop:
	</p>
	<pre class="language-javascript">
			<code>
				let arr = ['A', 'B', 'C', 'D'];
				for (let i = 0; i < arr.length; i++) {
					console.log(arr[i]);
				}
			</code>
		</pre>
	<pre class="language-bash"><code>
			A
			B
			C
			D
		</code></pre>
	<p>With the for-of-loop:</p>
	<pre class="language-javascript"><code>
			let arr = ['A', 'B', 'C', 'D'];
			for (let element of arr) {
				console.log(arr);
			}
		</code></pre>
	<pre class="language-bash"><code>
			A
			B
			C
			D
		</code></pre>
	<p>
		A warning: We cannot use a for-of loop with an object-literal directly. This
		is because object-literals are
		<span class="underlineText">not iterable</span>. For example, say we wanted
		to display to the console each of the key-value pairs in an object called
		<var>vectors</var>:
	</p>
	<pre class="language-javascript">
		<code>
			const vectors = {
				velocity: 9.5,
				acceleration: 8.2,
				weight: 44.4,
				momentum: 52.3
			};
			for (let values of vectors) {
				console.log(values);
			}
		</code>
	</pre>
	<p>
		The code above returns a TypeError: 'vectors' is not iterable. To iterate
		over an object's keys, we need to use
		<var>${obj}$.keys</var> and <var>${obj}$.values</var>.
	</p>
	<pre class="language-javascript">
		<code>
			const vectors = {
				velocity: 9.5,
				acceleration: 8.2,
				weight: 44.4,
				momentum: 52.3
			};
			for (let prop of Object.keys(vectors)) {
				console.log(elements);
			}
			for (let values of Object.values(vectors)) {
				console.log(values);
			}
		</code>
	</pre>
	<pre class="language-bash"><code>
		velocity
		acceleration
		weight
		momentum
		9.5
		8.2
		44.4
		52.3
	</code></pre>
	<p>
		We see the output above because we can only iterate through either the
		object's values or the object's keys. Alternatively, we can iterate over an
		object without with a for-in-loop.
	</p>
	<section id="for_in_loop">
		<p>
			<span class="topic">The For-in Loop</span>
			The for-in loop allows us to loop through the properties of an
			object-literal. It takes the following form:
		</p>
		<figure>
			<ul class="syntax">
				<li>for (${p}$ in ${obj}$) {${s_0 \ldots s_n}$}</li>
			</ul>
		</figure>
		<p>
			Where ${p}$ is a variable identifying each key-value pair, ${obj}$ is the
			name of the object-literal, and ${s_0 \ldots s_n}$ are statements to
			execute for each ${p.}$ Illustrating:
		</p>
		<pre class="language-javascript">
			<code>
				let mathConstants = {
					tau: 6.28,
					aperys: 1.20,
					euler_mascheroni: 0.57,
					gauss: 0.83
				};
				for (let prop in mathConstants) {
					console.log(prop + ': ' + mathConstants[prop]);
				}
			</code>
		</pre>
		<pre class="language-bash"><code>
			tau: 6.28
			aperys: 1.2
			euler_mascheroni: 0.57
			gauss: 0.83
		</code></pre>
		<p>
			It is best practice to avoid using a for-in loop for arrays. This is
			because the for-in loop is implemented in JavaScript specifically for
			iterating through an object's properties. That iteration is not guaranteed
			to be done in order (and order matters for iterables like arrays). In sum:
			Do not use a for-in loop for iterables &mdash; use a for-of loop.
		</p>
	</section>
</section>

<section id="sets">
	<h2>Sets</h2>
	<p>
		Arrays are iterables, but they aren't the only ones. There's another kind of
		iterable: <b>sets</b>. Like the array, the set stores nested data of any
		kind and length. They're also iterable, with some special set methods, but
		not all of the array methods. The biggest difference between sets and
		arrays: With sets, (1) order is
		<span class="underlineText">not</span> guaranteed, (2) duplicates are
		<span class="underlineText">not</span> allowed, (3) and there is
		<span class="underlineText">no</span> index-based accessing. This makes sets
		a great, lightweight structure for storing data where we do not want
		duplicates.
	</p>
	<p>To instantiate a set, we write the following:</p>
	<pre class="language-javascript"><code>
		const ids = new Set();
	</code></pre>
	<p>
		This results in an empty set. We can initialize the set by passing an
		<i>iterable</i> into the constructor's parameter list:
	</p>
	<pre class="language-javascript"><code>
		const ids = new Set([1, 2, 3]);
	</code></pre>
	<p>If we log to the console the set above, we see:</p>
	<pre class="language-bash"><code>
		Set(3) {1, 2, 3}
			[[Entries]]
				0: 1 
				1: 1
				2: 3
				size: 3
				[[Prototype]]: Set
	</code></pre>
	<p>
		Although it appears that there are indices we can access, this is not the
		case. We <span class="underlineText">cannot</span> access elements in a set
		through indexing. Keeping this in mind, here are some of the set specific
		methods we can use (suppose ${S}$ is some set identifier):
	</p>
	<ul class="ruled">
		<li><var>const ${S}$ = new Set()</var></li>
		<ul>
			<li>Creates a new set object.</li>
		</ul>
		<li><var>${S}$.size</var></li>
		<ul>
			<li>Returns the number of values in the set object.</li>
		</ul>
		<li><var>${S}$.add(${v}$)</var></li>
		<ul>
			<li>
				Appends some value ${v}$ to the set object ${S}$. The return is the set
				object ${S}$ with the new, appended value ${v.}$
			</li>
		</ul>
		<li><var>${S}$.clear()</var></li>
		<ul>
			<li>Removes all elements from the set object ${S.}$</li>
		</ul>
		<li><var>${S}$.delete(${v}$)</var></li>
		<ul>
			<li>
				Removes the element ${v}$ from the set object ${S.}$ If the element was
				successfully removed, returns <var>true</var>, otherwise
				<var>false</var>.
			</li>
		</ul>
		<li><var>${S}$.has(${v}$)</var></li>
		<ul>
			<li>
				If the set object ${S}$ contains the element ${v,}$ returns
				<var>true</var>; otherwise <var>false</var>.
			</li>
		</ul>
		<li>
			<span class="monoText"
				>${S}$.forEach( ${f}$(${v}$) {${s_0 \ldots s_n}$} )</span
			>
		</li>
		<ul>
			<li>
				Iterates over the values ${v}$ in the set object ${S,}$ applying the
				function ${f,}$ which executes the statements ${s_0 \ldots s_n.}$
			</li>
		</ul>
		<li><var>${S}$.entries()</var></li>
		<ul>
			<li>
				Returns the elements of ${S}$ as an iterable. The resulting iterable can
				then be used in a for-loop.
			</li>
			<li>
				For example:
				<pre class="language-javascript"><code>
					const S = new Set(['a', 'b', 'c']);
					for (const entry of S.entries()) {
						console.log(entry);
					}
				</code></pre>
				<pre class="language-bash"><code>
					(2) ['a', 'a']
					(2) ['b', 'b']
					(2) ['c', 'c']
				</code></pre>
				Notice that this returns three arrays with two elements. This is because
				the <var>.entries()</var> method is shared with the
				<var><mark>map</mark></var> data structure, and with maps, entries are
				key-value pairs. If we want an iterable consisting of only the values
				once, use <span class="monoText"><mark>.values()</mark></span
				>.
			</li>
		</ul>
		<li><var>${S}$.values()</var></li>
		<ul>
			<li>
				Returns an iterable containing only the values of the set object ${S,}$
				in the order the elements were inserted.
			</li>
		</ul>
	</ul>
	<p>
		Although sets aren't as commonly used as arrays, they can be particularly
		useful for a wide variety of situations.
	</p>
	<p>
		<span class="topic">Decomposing Strings.</span> If we pass a string as an
		argument to the <var><mark>Set()</mark></var> constructor, we get back a set
		with all the characters as separate elements:
	</p>
	<pre class="language-javascript"><code>
		const userName = 'Aiden';
		const userNameChars = new Set(userName);
		for (const char of userNameChars.values()) {
			console.log(char);
		}
	</code></pre>
	<pre class="language-bash"><code>
		A
		i
		d
		e
		n
	</code></pre>
	<p>
		<span class="topic">Removing Duplicates from an Array.</span> Sets can be
		used to remove duplicates from an array. This is done with both the
		<var><mark>Set()</mark></var> constructor and spread syntax:
	</p>
	<pre class="language-javascript"><code>
		const userNames = ['Carl', 'Kento', 'Suji', 'Kento', 'Suji'];
		const uniqueUserNames = [...new Set(userNames)];
		console.log(uniqueUserNames);
	</code></pre>
	<pre class="language-bash"><code>
		(3) ['Carl', 'Kento', 'Suji']
	</code></pre>
	<section id="weak_set">
		<h3>Weak Sets</h3>
		<p>
			JavaScript provides a &#8220;weaker&#8221; version of
			<var>Set</var> called <span class="monoText"><mark>WeakSet</mark></span
			>. Recall that with sets, we can store any kind of data. Weak sets,
			however, can only store objects (i.e., arrays, object-literals, maps,
			sets, etc.). We cannot store <i>literals</i>. The API for
			<var>WeakSet</var> is similar to the <var>Set</var> API, with the most
			noticeable difference being the constructor:
		</p>
		<pre class="language-javascript"><code>
			const wSet = new WeakSet();
		</code></pre>
		<p>
			The other differences is that the weak set's API is substantially smaller:
			It only has the methods <var>add()</var>, <var>delete()</var>, and
			<var>has()</var>. The key benefit to using weak sets is that the data
			stored within it will be garbage-collected (i.e., destroyed) if we do not
			use it. This benefit arises because the <var>Set</var> object has an
			inherent safeguard. Consider the following code:
		</p>
		<pre class="language-javascript"><code>
			let user = {name: "Yuri"};
			const users = new Set();
			users.add(user);
			user = null;
			console.log(users);
		</code></pre>
		<pre class="language-bash"><code>
			Set(1) {{...}}
				[[Entries]]
					0: Object
					size: 1
		</code></pre>
		<p>
			We might write the last line in the code above if we no longer need the
			object-literal <var>user</var>. However, simply writing
			<var>user = null</var> does not clear the object-literal from memory. This
			is because it continues to exist in the <var>Set users</var>. With
			<var>WeakSet</var>, writing the last line ensures that the object-literal
			is, in fact, cleared from memory:
		</p>
		<pre class="language-javascript"><code>
			let user = {name: "Yuri"};
			const users = new WeakSet();
			users.add(user);
			user = null;
			console.log(users);
		</code></pre>
		<pre class="language-bash"><code>
			WeakSet {{...}}
				[[Entries]]
					No properties
		</code></pre>
		<p>
			Weak sets are essentially JavaScript's way of giving us greater control
			over memory management. This is particularly useful if we're working with
			large data structures that really only need to be used momentarily.
		</p>
	</section>
</section>

<section id="maps">
	<h2>Maps</h2>
	<p>
		The <var><mark>Map</mark></var> data structure is similar to
		<span class="monoText"><mark>Object</mark></span
		>, in that it's a collection of key-value pairs. There are, however, several
		differences:
	</p>
	<ul>
		<li>
			With maps, we can use any value as a key. With object-literals, keys must
			be either a <var><mark>String</mark></var> or
			<span class="monoText"><mark>Symbol</mark></span
			>.
		</li>
		<li>
			Object-literals have no inherent order. Maps have an inherent
			<i>insertion order</i>.
		</li>
		<li>
			There is a built-in method to retrieve the
			<var><mark>size</mark></var> of a map, but not for an object-literal.
		</li>
		<li>Maps are iterable by default, but not object-literals.</li>
		<li>Maps have better performance in handling large quantities of data.</li>
		<li>
			Maps have better performance when adding and removing data frequently.
		</li>
		<li>Object-literals are ideal for small- to medium-sized sets of data.</li>
		<li>
			Objects are easier and quicker to create (which typically leads to better
			initialization performance).
		</li>
	</ul>
	<p>
		The Map is also distinguished from the object-literal by methods unique to
		its API. Where ${M}$ is the map's identifier:
	</p>
	<ul class="ruled">
		<li><var>const ${M}$ = new Map()</var></li>
		<ul>
			<li>Creates a new <var>Map</var> object.</li>
		</ul>
		<li><var>${M}$.size</var></li>
		<ul>
			<li>
				Returns the number of key-value pairs in the
				<var>Map</var> object ${M.}$
			</li>
		</ul>
		<li><var>${M}$.clear()</var></li>
		<ul>
			<li>
				Removes all of the key-value pairs in the
				<var>Map</var> object ${M.}$
			</li>
		</ul>
		<li><var>${M}$.delete(${k}$)</var></li>
		<ul>
			<li>
				Where ${k}$ is some key, removes the key-value pair with the matching
				key ${k.}$ Returns <var>true</var> if the pair was successfully removed;
				otherwise <var>false</var>.
			</li>
		</ul>
		<li><var>${M}$.get(${k}$)</var></li>
		<ul>
			<li>
				Where ${k}$ is some key, returns the value associated with ${k,}$
				otherwise <var>undefined</var>.
			</li>
		</ul>
		<li><var>${M}$.has(${k}$)</var></li>
		<ul>
			<li>
				Where ${k}$ is some key, returns <var>true</var> if there is a value
				associated with the ${k,}$ otherwise <var>false</var>.
			</li>
		</ul>
		<li><var>${M}$.set(${k}$, ${v}$)</var></li>
		<ul>
			<li>
				Where ${k}$ is some key and ${v}$ is some value, sets the value for the
				key ${k}$ in the map object ${M.}$ Returns the map object ${M.}$
			</li>
		</ul>
		<li><var>${M}$.keys()</var></li>
		<ul>
			<li>
				Returns a new iterable containing the
				<i>keys</i> for each element in the map object ${M.}$ The keys are
				ordered in <span class="underlineText">insertion order</span>.
			</li>
		</ul>
		<li><var>${M}$.values()</var></li>
		<ul>
			<li>
				Returns a new iterable containing the
				<i>values</i> for each element in the map object ${M.}$ The values are
				ordered in <span class="underlineText">insertion order</span>.
			</li>
		</ul>
		<li>
			<span class="monoText"
				>${M}$.forEach(${f}$(${v}$) {${s_0 \ldots s_n}$})</span
			>
		</li>
		<ul>
			<li>
				Iterates over each key-value pair in the map object ${M,}$ evaluating
				the function ${f}$ with the argument ${v,}$ where ${f}$ is some function
				defined as the statements ${e_0 \ldots e_n.}$
			</li>
		</ul>
	</ul>
	<p>
		There are several ways to create maps. One way is to use the
		<var><mark>set()</mark></var> method, creating key-value pairs as needed:
	</p>
	<pre class="language-javascript"><code>
		const kanjiToEnglish = new Map();
		kanjiToEnglish.set("æž—æªŽ", "apple");
		kanjiToEnglish.set("æ¡ƒ", "peach");
		kanjiToEnglish.set("æŸ¿", "persimmon");
	</code></pre>
	<p>Alternatively, we can pass the mappings to the constructor as arrays:</p>
	<pre class="language-javascript"><code>
		const kanjiToEnglish = new Map(
			["æž—æªŽ", "apple"], 
			["æ¡ƒ", "peach"], 
			["æŸ¿", "persimmon"]
		);
	</code></pre>
	<p>
		A particularly useful aspect of maps is that they allow us to modularize
		&mdash; and thereby simplify &mdash; objects and other data structures. For
		example, suppose we have a list of students, and each student is an object.
		Each of the students have several properties, some of which are also fairly
		complex. Rather than writing the complex student properties directly, we can
		write those properties as a separate object, then map the student object's
		property to them.
	</p>
	<pre class="language-javascript"><code>
		const danielBoone = {
			firstName: "Daniel",
			lastName: "Boone"
		};
		const physicsMajor = {
			numCoreCourses: 16,
			numOptionalCourses: 20
		};
		const studentDB = new Map(
			[danielBoone, physicsMajor]
		);
	</code></pre>
	<section id="weak_map">
		<h3>Weak Maps</h3>
		<p>
			Just as we saw with sets, there is a &#8220;weaker&#8221; version of the
			map called a <span class="monoText"><mark>WeakMap</mark></span
			>. If we know that map will only be used briefly, we can instead create a
			<var>new WeakMap()</var> to gain better control over garbage collection.
			Like weak sets, weak maps have a limited API: <var>delete()</var>,
			<var>set()</var>, <var>get()</var>, and <var>has()</var>. Unlike the weak
			set, however, the weak map can contain both objects or literals for
			values. But, the keys themselves must be objects.
		</p>
	</section>
</section>

<section id="collection_comparison">
	<h3>Comparative Analysis</h3>
	<p>
		In this section, we examined three simple data structures: the array, set,
		and map. Below is a summary of the key differences between the data
		structures:
	</p>
	<ul class="ruled">
		<li>Arrays</li>
		<ul>
			<li>Can store data (including nested data) of any kind and length.</li>
			<li>Iterable.</li>
			<li>Many native methods available.</li>
			<li>Order is guaranteed.</li>
			<li>Duplicates <span class="underlineText">permissible</span>.</li>
			<li>Zero-based indexing to access elements.</li>
		</ul>
		<li>Sets</li>
		<ul>
			<li>Can store data (including nested data) of any kind and length.</li>
			<li>Iterable.</li>
			<li>Some native methods available (not as many as the array's).</li>
			<li>Order is <span class="underlineText">not</span> guaranteed.</li>
			<li>Duplicates <span class="underlineText">impermissible</span></li>
			<li>No index-based accessing.</li>
		</ul>
		<li>Maps</li>
		<ul>
			<li>
				Storing key-value data of any kind and length; any key values
				permissible (e.g., some other data structure as a key, like an array,
				set, map, or a more complicated data structure). Compare this with
				<i>objects</i>, which only allow strings, numbers, or symbols as keys.
			</li>
			<li>Some native methods available.</li>
			<li>Order is guaranteed.</li>
			<li>Duplicate keys <span class="underlineText">impermissible</span>.</li>
			<li>No index-based accessing; key-based accessing is used instead.</li>
		</ul>
	</ul>
</section>

<section id="object_complexity">
	<h2>Complexity Analysis: Objects</h2>
	<p>As we know, objects are an unordered collection of key-value pairs:</p>
	<pre class="language-javascript"><code>
		const product = {
			id         : 312592,
			isAvailable: true
		}
	</code></pre>
	<p>
		Objects work well if: (1) We do not need order, and (2) we want fast access
		for insertion and removal. In particular, we have the following time
		complexities for objects:
	</p>
	<table class="api">
		<thead>
			<th>Operation</th>
			<th>Time Complexity</th>
		</thead>
		<tbody>
			<tr>
				<td>Insertion</td>
				<td>${O(1)}$</td>
			</tr>
			<tr>
				<td>Removal</td>
				<td>${O(1)}$</td>
			</tr>
			<tr>
				<td>Searching</td>
				<td>${O(n)}$</td>
			</tr>
			<tr>
				<td>Access</td>
				<td>${O(1)}$</td>
			</tr>
		</tbody>
	</table>
	<p>
		From the table above, inserting, removing, and accessing an object runs in
		constant time. The exception, however, is searching. Searching an object
		takes linear time. By searching, we do not mean checking if a key is present
		in a given object. That merely requires checking if we can access a
		particular key, and that takes constant time. Instead, the use of search in
		this context is checking if a given value exists in the object.
	</p>
	<p>The time complexity for object methods are as follows:</p>
	<table class="api">
		<thead>
			<th>Method</th>
			<th>Operation</th>
			<th>Time Complexity</th>
		</thead>
		<tbody>
			<tr>
				<td><var>${Obj}$.keys</var></td>
				<td>
					Returns an array containing the names of ${obj}$'s string properties.
				</td>
				<td>${O(n)}$</td>
			</tr>
			<tr>
				<td><var>${Obj}$.values</var></td>
				<td>
					Returns an array containing the values of ${obj}$'s string properties.
				</td>
				<td>${O(n)}$</td>
			</tr>
			<tr>
				<td><var>${Obj}$.entries</var></td>
				<td>
					Returns an array containing the <var>[key, value]</var> pairs of
					${obj}$'s string properties.
				</td>
				<td>${O(n)}$</td>
			</tr>
			<tr>
				<td><var>${Obj}$.hasOwnProperty(${p}$)</var></td>
				<td>
					Returns <var>true</var> if ${obj}$ has the property name ${p.}$
					Otherwise, <var>false</var>.
				</td>
				<td>${O(1)}$</td>
			</tr>
		</tbody>
	</table>
</section>

<section id="array_complexity">
	<h2>Complexity Analysis: Arrays</h2>
	<p>
		In contrast to objects, arrays have an inherent order. As such, arrays
		should be our first consideration whenever we need order. For specific use
		cases like insertion and removal, however, we have to think twice.
	</p>
	<p>The time complexity for arrays is as follows:</p>
	<table class="api">
		<thead>
			<th>Operation</th>
			<th>Time Complexity</th>
		</thead>
		<tbody>
			<tr>
				<td>Accessing</td>
				<td>${O(1)}$</td>
			</tr>
			<tr>
				<td>Searching</td>
				<td>Generally ${O(n)}$</td>
			</tr>
			<tr>
				<td>Insertion</td>
				<td>Varies</td>
			</tr>
			<tr>
				<td>Removal</td>
				<td>Varies</td>
			</tr>
		</tbody>
	</table>
	<p>
		There are a few uninformative cells in the table above. Let's address them.
	</p>
	<p>
		<span class="topic">Insertion.</span> Each element in an array has an index.
		And because there are indices, the amount of basic steps JavaScript must
		take to complete the operation of insertion varies. Consider the following
		array:
	</p>
	<pre class="language-javascript"><code>
		let arr = ['a', 'b', 'c'];
	</code></pre>
	<p>In memory, this array appears as:</p>
	<table class="array">
		<tbody>
			<tr>
				<td>${\texttt{arr}}$</td>
				<td>a</td>
				<td>b</td>
				<td>c</td>
			</tr>
			<tr>
				<td>${i}$</td>
				<td>0</td>
				<td>1</td>
				<td>2</td>
			</tr>
		</tbody>
	</table>
	<p>
		If we insert an element to the end of this array with
		<var>arr.push('d')</var>, JavaScript would simply create a new space:
	</p>
	<table class="array">
		<tbody>
			<tr>
				<td>${\texttt{arr}}$</td>
				<td>a</td>
				<td>b</td>
				<td>c</td>
				<td></td>
			</tr>
			<tr>
				<td>${i}$</td>
				<td>0</td>
				<td>1</td>
				<td>2</td>
				<td>3</td>
			</tr>
		</tbody>
	</table>
	<p>And add the new element:</p>
	<table class="array">
		<tbody>
			<tr>
				<td>${\texttt{arr}}$</td>
				<td>a</td>
				<td>b</td>
				<td>c</td>
				<td>d</td>
			</tr>
			<tr>
				<td>${i}$</td>
				<td>0</td>
				<td>1</td>
				<td>2</td>
				<td>3</td>
			</tr>
		</tbody>
	</table>
	<p>
		The more challenging insertion is attempting to insert at the
		<em>beginning</em> of the array. For example, if we wrote
		<var>arr.unshift('z')</var>, JavaScript would add the element to the
		beginning of the array:
	</p>
	<table class="array">
		<tbody>
			<tr>
				<td>${\texttt{arr}}$</td>
				<td>z</td>
				<td>a</td>
				<td>b</td>
				<td>c</td>
				<td>d</td>
			</tr>
			<tr>
				<td>${i}$</td>
				<td>0</td>
				<td>0</td>
				<td>1</td>
				<td>2</td>
				<td>3</td>
			</tr>
		</tbody>
	</table>
	<p>
		Notice, however, that the indices are broken. As a result, JavaScript must
		perform the additional step of <i>re-indexing</i> all of the elements in the
		array &mdash; it must increment all of the elements' indices before the
		insertion occured:
	</p>
	<table class="array">
		<tbody>
			<tr>
				<td>${\texttt{arr}}$</td>
				<td>z</td>
				<td>a</td>
				<td>b</td>
				<td>c</td>
				<td>d</td>
			</tr>
			<tr>
				<td>${i}$</td>
				<td>0</td>
				<td>1</td>
				<td>2</td>
				<td>3</td>
				<td>4</td>
			</tr>
		</tbody>
	</table>
	<p>
		Given an array of ${n}$ elements, this operation would take ${O(n)}$ time.
		Accordingly, inserting at the beginning of the array runs on linear time.
	</p>
	<p>
		<span class="topic">Removing.</span> The same analysis above extends to
		removing elements. Removing an element from the end of the array takes
		${O(1)}$ time. JavaScript does not have to perform additional computations
		for removing the last element. It simply goes to the last element &mdash; a
		constant time operation &mdash; and removes it &mdash; another constant time
		operation.
	</p>
	<p>
		If we remove from the beginning, however, then we're back at ${O(n)}$ time.
		For example, with our earlier array, we start with:
	</p>
	<table class="array">
		<tbody>
			<tr>
				<td>${\texttt{arr}}$</td>
				<td>a</td>
				<td>b</td>
				<td>c</td>
			</tr>
			<tr>
				<td>${i}$</td>
				<td>0</td>
				<td>1</td>
				<td>2</td>
			</tr>
		</tbody>
	</table>
	<p>Then, we call <var>arr.unshift()</var>:</p>
	<table class="array">
		<tbody>
			<tr>
				<td>${\texttt{arr}}$</td>
				<td></td>
				<td>b</td>
				<td>c</td>
			</tr>
			<tr>
				<td>${i}$</td>
				<td></td>
				<td>1</td>
				<td>2</td>
			</tr>
		</tbody>
	</table>
	<p>
		Because of the broken indices, JavaScript must decrement all of the elements
		before <var>unshift()</var> was called:
	</p>
	<table class="array">
		<tbody>
			<tr>
				<td>${\texttt{arr}}$</td>
				<td>b</td>
				<td>c</td>
			</tr>
			<tr>
				<td>${i}$</td>
				<td>0</td>
				<td>1</td>
			</tr>
		</tbody>
	</table>
	<p>
		Given ${n}$ elements, this would take ${O(n)}$ time. Thus, based on our
		analysis, we have the following table of runtimes:
	</p>
	<table class="api">
		<thead>
			<th>Method</th>
			<th>Operation</th>
			<th>Time Complexity</th>
		</thead>
		<tbody>
			<tr>
				<td><var>${A}$.push(${v}$)</var></td>
				<td>Insert the element ${v}$ the end of the array ${A.}$</td>
				<td>${O(1)}$</td>
			</tr>
			<tr>
				<td><var>${A}$.pop()</var></td>
				<td>Remove the last element in the array ${v.}$</td>
				<td>${O(1)}$</td>
			</tr>
			<tr>
				<td><var>${A}$.shift()</var></td>
				<td>Remove the first element in the array ${v.}$</td>
				<td>${O(n)}$</td>
			</tr>
			<tr>
				<td><var>${A}$.unshift(${v}$)</var></td>
				<td>Insert the element ${v}$ at the beginning of the array ${v.}$</td>
				<td>${O(n)}$</td>
			</tr>
			<tr>
				<td><var>${A_1}$.concat(${A_2}$)</var></td>
				<td>Return a new array with ${A_2}$ appended to ${A_1.}$</td>
				<td>${O(n)}$</td>
			</tr>
			<tr>
				<td><var>${A}$.slice(${\large s}$, ${\large e}$)</var></td>
				<td>
					Return a new array consisting of the elements of ${A,}$ from index
					${\large s}$ through index ${\large e.}$
				</td>
				<td>${O(n)}$</td>
			</tr>
			<tr>
				<td>
					<var>${A}$.splice(${\large s}$, ${\large d}$, ${\large v}$)</var>
				</td>
				<td>
					Starting at index ${\large s,}$ replace (or insert) all elements
					${\large s}$ through ${\large s+d}$ with the value ${\large v.}$
				</td>
				<td>${O(n)}$</td>
			</tr>
			<tr>
				<td><var>${A}$.sort</var></td>
				<td>Sort the elements of ${A}$ in place.</td>
				<td>${O(n \lg n)}$ &mdash; depends on the implementation</td>
			</tr>
			<tr>
				<td>
					<var>forEach()</var>, <var>map()</var>, <var>filter()</var>,
					<var>reduc()</var>, etc.
				</td>
				<td>These methods all require iterating through the array.</td>
				<td>${O(n)}$</td>
			</tr>
		</tbody>
	</table>
</section>

<section id="strategies">
	<h2>Problem Solving Strategies</h2>
	<p>
		When programming, we're going to run into algorithmic problems constantly.
		Accordingly, this section serves as a small aside for some tips to problem
		solving. The steps are as follows:
	</p>
	<p>
		<span class="topic">Step 1: Understand the problem.</span> We must always
		start with understanding the problem. To do so, we should perform the
		following:
	</p>
	<ul>
		<li>Restate the problem in our own words.</li>
		<li>What are the problem's inputs?</li>
		<li>What are the problem's outputs?</li>
		<li>
			Can the outputs be determined from the inputs? In other words, do we have
			enough information to solve the problem?
		</li>
		<li>How should the important pieces of data be labeled?</li>
	</ul>
	<p><span class="topic">Step 2: Consider concrete examples.</span></p>
	<p><span class="topic">Step 3: Break the problem down.</span></p>
	<p><span class="topic">Step 4: Simplify the Problem.</span></p>
	<p><span class="topic">Step 5: Refactor.</span></p>
	<p></p>
</section>

{% endblock %}
