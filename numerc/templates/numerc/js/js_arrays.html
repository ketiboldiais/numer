{% extends '../layout.html' %} {% load static %} {% block description %}
<meta
	name="description"
	content="Collections in JavaScript: Arrays, objects, and loops."
/>
{% endblock %} {% block title %}
<title>Collections & Loops</title>
{% endblock %} {% block content %}
<h1>Collections & Loops</h1>
<section id="intro">
	<p>
		<span class="drop">C</span>ollections are groups of related data. In this
		section, we explore two collections provided natively by JavaScript: Arrays
		and objects. Because JavaScript provides special looping constructs for
		arrays and objects, we will investigate iteration once we've established
		familiarity with the basic collections.
	</p>
</section>

<section id="arrays">
	<h2>Arrays</h2>
	<p>
		Arrays are the simplest
		<span class="italicsText">data structure</span>; they are a collection of
		values, where <span class="italicsText">order matters</span>. Examples of an
		array include: list of comments on a post, a collection of levels in a game,
		or a playlist of songs. Every value can be collected and placed in an order.
		The resulting ordered collection is called an
		<span class="italicsText">array</span>. Arrays can also collect and order
		other arrays.
	</p>
	<p>
		To create an array in JavaScript, we use square brackets
		<span class="monoText">[]</span>. Here is an empty array:
	</p>
	<pre class="language-javascript">
		<code>
			let special_numbers = [];
		</code>
	</pre>
	<p>An array of strings:</p>
	<pre class="language-javascript">
		<code>
			let colors = ['red', 'orange', 'blue', 'green'];
		</code>
	</pre>
	<p>An array of numbers:</p>
	<pre class="language-javascript">
		<code>
			let primes = [1, 3, 5, 7, 11];
		</code>
	</pre>
	<p>A mixed array:</p>
	<pre class="language-javascript">
		<code>
			let randomStuff = [true, 68, "bird", null];
		</code>
	</pre>

	<section id="array_indices">
		<p>
			<span class="topic">Indices in an Array</span>
			The values in an array are <span class="term">indexed</span>, meaning that
			each value in the array has an <span class="term">index</span>, or
			position within the array, starting from 0. So, for example:
		</p>
		<pre class="language-javascript">
			<code>
				let colors = ['red', 'orange', 'yellow', 'blue'];
				colors[0] // returns 'red'
				colors[1] // returns 'orange'
				colors[2] // returns 'yellow'
				colors[3] // returns 'blue'
			</code>
		</pre>
	</section>

	<section id="array_length">
		<p>
			<span class="topic">Array Length</span>
			Much like how they can be applied to strings and variables, we can find
			the length of an array (how many values it holds) with the
			<span class="monoText">.length</span> method.
		</p>
		<pre class="language-javascript">
			<code>
				let colors = ['red', 'orange', 'yellow', 'blue'];
				colors.length; // Returns 4, the array named <span class="italicsText">colors</span> contains 4 values.
			</code>
		</pre>
		<p>If we want to get the last value in an array:</p>
		<pre class="language-javascript">
			<code>
				let colors = ['red', 'orange', 'yellow', 'blue'];
				colors[colors.length - 1] // returns 'blue';
				/*
				This works because colors.length returns a number value. That number value is 4, the number of values in the array. Subtract 1, and you have the number 3. So, the code is telling JavaScript, get the value with index of 3 in the array of colors (the index of 3 is the last item in the array.)
				*/
			</code>
		</pre>
	</section>

	<section id="modifying_arrays">
		<h3>Modifying Arrays</h3>
		<p>
			Say that we've set an array. We can change the values inside that array by
			going back and manually changing them, but that would be horribly
			inefficient (and you likely do no want to do that for a very large
			program). Instead of manually changing the values in the array, we can use
			their indices:
		</p>
		<pre class="language-javascript">
			<code>
				let colors = ['red', 'blue', 'green'];
				colors[0] = 'purple';
				colors[1] = 'violet';
				colors[2] = 'black';
				// The above will change the array <span class="italicsText">colors</span> to the following:
				colors = ['purple', 'violet', 'black'];
			</code>
		</pre>
		<p>We can also use methods to change the values in an array:</p>
		<pre class="language-javascript">
			<code>
				// Here is our initial shopping list
				shoppingList = ['Bud Light', 'Merlot', 'Vodka', 'Tequila'];
	
				// Guest called, wants Cabernet, not Merlot: 
				shoppingList[1] = 'Cabernet';
	
				// Another guest called, wants Rum, not Tequila:
				shoppingList[shoppingList.length - 1] = 'Rum';
	
				// Yet another guest called, requesting Tequila to be added
				shoppingList[shoppingList.length] = 'Tequila';
	
				console.log(shoppingList);
			</code>
		</pre>
		<pre class="language-bash"><code>
			['Bud Light', 'Cabernet', 'Vodka', 'Rum', 'Tequila']
		</code></pre>

		<section id="push()_method">
			<p>
				<span class="topic">Appending.</span>
				The <span class="monoText">push()</span> method adds one or more
				elements to the end of an array, and returns the new length of the
				array.
			</p>
			<pre class="language-javascript">
				<code>
					let vectors = ['w', 'x', 'y'];
					vectors.push('z');
					console.log(vectors);
				</code>
			</pre>
			<pre class="language-bash"><code>
				['w', 'x', 'y', 'z']
			</code></pre>
		</section>

		<section id="pop()_method">
			<p>
				<span class="topic">Removing.</span>
				The <span class="monoText">pop()</span> method removes a value at the
				end of an array.
			</p>
			<pre class="language-javascript">
				<code>
					let procedures = ['w', 'x', 'y', 'z'];
					procedures.pop('z');
					console.log(procedures);
				</code>
			</pre>
			<pre class="language-bash"><code>
				['w', 'x', 'y']
			</code></pre>
		</section>

		<section id="shift()_method">
			<p>
				<span class="topic">Shifting</span>
				The <span class="monoText">shift()</span> method removes a value from
				the start of an array:
			</p>
			<pre class="language-javascript">
				<code>
					let procedures = ['w', 'x', 'y', 'z'];
					procedures.shift('w');
					console.log(procedures);
				</code>
			</pre>
			<pre class="language-bash"><code>
				['x', 'y', 'z']
			</code></pre>
		</section>

		<section id="unshift()_method">
			<p>
				<span class="topic">Unshifting.</span>
				The <span class="monoText">unshift()</span> method adds a value to the
				start of an array:
			</p>
			<pre class="language-javascript">
				<code>
					let procedures = ['w', 'x', 'y', 'z'];
					procedures.unshift('v');
					console.log(procedures);
				</code>
			</pre>
			<pre class="language-bash"><code>
				['v', 'w', 'x', 'y', 'z']
			</code></pre>
		</section>

		<section id="concat()_method">
			<p>
				<span class="topic">Concatenating.</span>
				The <span class="monoText">concat()</span> method
				<span class="underlineText">creates a new array</span>
				from merging two arrays; there is no change to the original.
			</p>
			<pre class="language-javascript">
				<code>
					let x = ['a', 'b', 'c'];
					let y = ['d', 'e', 'f'];
					let xAndy = x.concat(y);
					console.log(xAndy);
					
				</code>
			</pre>
			<pre class="language-bash"><code>
				['a', 'b', 'c', 'd', 'e', 'f']
			</code></pre>
			<p>
				When using the <span class="monoText">concat()</span> method,
				<span class="underlineText">order matters</span>. So, for example,
				suppose you have the following:
			</p>
			<pre class="language-javascript"><code>
				array1.concat(array2).concat(array3)
			</code></pre>
			<p>The new array is:</p>
			<figure class="math-display">
				<div>
					<p>
						<!-- prettier-ignore -->
						<span class="monoText">[${array1}$-${values}$ ${array2}$-${values}$ ${array3}$-${values}$]</span>
					</p>
				</div>
			</figure>
		</section>

		<section id="includes()_method">
			<p>
				<span class="topic">Does it include?</span>
				The <span class="monoText">includes()</span> method is a Boolean
				methodâ€”it returns either <span class="greenText">true</span> or
				<span class="redText">false</span>. If the value is found in the array,
				the method returns <span class="greenText">true</span>. If the value is
				not found in the array, the method returns
				<span class="redText">false</span>.
			</p>
			<pre class="language-javascript">
				<code>
					let subjects = ['math', 'physics', 'cs', 'chemistry'];
					subjects.includes('physics');  // true
				</code>
			</pre>
			<p>
				The <span class="monoText">includes()</span> method can also take a
				number as a second argument. The number passed in represents the
				<span class="italicsText">starting index</span> for JavaScript's search.
				By passing in a number $x$, we essentially ask JavaScript: "Is the value
				contained in the part of the array starting from index $x$? For example:
			</p>
			<pre class="language-javascript">
				<code>
					let var_Array = ['w', 'x', 'y', 'z'];
					var_Array.includes('w', var.Array.length / 2); // false
				</code>
			</pre>
			<p>
				In the code above, we are actually asking: JavaScript, is this true or
				false: The value <span class="monoText">'w'</span> is inside the array,
				and, more specifically, in the part of the array starting from
				<span class="monoText">i = 2</span>. This returns false, since
				<span class="monoText">'w'</span> is in the first half of the array,
				starting from <span class="monoText">i = 0</span>.
			</p>
		</section>

		<section id="indexOf()_array_method">
			<p>
				<span class="topic">What's the index of?</span>
				The <span class="monoText">indexOf()</span> method works in the same way
				with arrays as it does with strings. In other words, the
				<span class="monoText">indexOf()</span> method finds the index of a
				value in the array. If the method finds the value, it returns its index
				(an integer $x$, where $x \geq 0$). If the method does not find the
				value, it returns -1. Like the
				<span class="monoText">includes()</span> method, we can pass through a
				second argument, an integer, into the method's arguments, to specify
				where the method should operate.
			</p>
			<pre class="language-javascript">
				<code>
					let frequencies = ['1Mhz', '3Mhz', '7Mhz', '15Mhz'];
		
					frequencies.indexOf('1Mhz'); 
					// This returns 0, the index of '1Mhz'
					
					frequencies.indexOf('3Mhz', frequencies.length / 2);
					// This returns -1, because we told JavaScript to only search for '3Mhz' in the part of the array starting from index = 2, and there is no such value in that part of the array.
		
					frequencies.indexOf('7Mhz', frequencies.length / 2); 
					// This returns 2. We told JavaScript, "Search for '7Mhz' in the part of the array starting from index = 2. JavaScript found the value, and returned its index, 2."
				</code>
			</pre>
		</section>

		<section id="reverse()_method_arrays">
			<p>
				<span class="topic">Reversing.</span>
				The <span class="monoText">reverse()</span> method changes the original
				array by reversing the order of its values. Note that the
				<span class="monoText">reverse()</span> method changes the original
				array; once applied, the original array is replaced by the new array
				resulting from the method.
			</p>
			<pre class="language-javascript">
				<code>
					let arr = [1, 2, 3, 4, 5];
					arr.reverse();
					/*
					This changes the original array into:
					arr = [5, 4, 3, 2, 1]
					*/
				</code>
			</pre>
		</section>

		<section id="join()_method_arrays">
			<p>
				<span class="topic">Joining.</span>
				The <span class="monoText">join()</span> method takes all the values in
				an array, and combines them into a single string, as originally ordered.
				Remember, the return from a <span class="monoText">join()</span> method
				is a string. Thus, if you us the
				<span class="monoText">join()</span> method with an array of numbers,
				the result is a string of those numbers.
			</p>
			<pre class="language-javascript">
				<code>
					let letters = ['q', 'u', 'a', 'd', 'r', 'a', 't', 'i', 'c'];
					
					letters.join('');
					// This returns a single string, joined with an empty string: 'quadratic'
					
					letters.join('-');
					// This returns a single string, joined with the string '-': 'q-u-a-d-r-a-t-i-c'
	
					letters.reverse().join('');
					// This reverses the array <span class="italicsText">letters</span>, and returns a single string, joined with an empty string: 'citardauq'
				</code>
			</pre>
		</section>

		<section id="slice()_method_arrays">
			<p>
				<span class="topic">Sub-arrays.</span>
				Like the <span class="monoText">slice()</span> method applied to
				strings, the <span class="monoText">slice()</span> method applied to
				arrays takes a portion of an array, and creates a new array with that
				portion, without changing or affecting the original array. The
				<span class="monoText">slice()</span> method usually takes two
				arguments:
			</p>
			<ol>
				<li>
					The starting index in the original array to start the slice; and
				</li>
				<li>
					The end index in the original array (but, in the slice, it does not
					include the value with the end index).
				</li>
			</ol>
			<p>
				If no numbers are passed into the
				<span class="monoText">.slice()</span> method, then an entire copy of
				the array is made. So, for example:
			</p>
			<pre class="language-javascript">
				<code>
					let sets = ['A', 'B', 'C', 'D', 'E'];
					let slicedSets = sets.slice(1, 3);
					/* We've created a new array called <span class="italicsText">slicedSets</span>:
					slicedSets = ['B', 'C']
					*/
				</code>
			</pre>
			<p>
				By passing a negative number, say $-x$ into the
				<span class="monoText">slice()</span> method, we essentially tell
				JavaScript: "For this array, slice the portion starting $x$ from the
				last index." For example:
			</p>
			<pre class="language-javascript">
				<code>
					let sets = ['A', 'B', 'C', 'D', 'E'];
					let subSet = sets.slice(-2);
					/*
					This code says, make a slice starting 2 from the last index (here, the last index is 5, so the slice starts at 3). This will include the last index.
					
					So, the resulting array:
					subset = ['C', 'D', 'E']
					*/
				</code>
			</pre>
			<p>
				If 2 negative numbers are passed as arguments into the
				<span class="monoText">slice()</span> method, say $-x$ and $-y$, then
				the slice starts at $x$ index from the last index of the array, and the
				slice ends at $y$ index from the last index of the array. Illustration:
			</p>
			<pre class="language-javascript">
				<code>
					let sets = ["A", "B", "C", "D", "E"];
					let subSet = sets.slice(-3, -1);
					/*
					Here, we tell JavaScript, start the slice at the index 3 units from the last index (in this case, index = 2), and end the slice 1 unit from the last index (index = 4).
	
					Thus:
					subSet = ['C', 'D']
					*/
				</code>
			</pre>
		</section>

		<section id="splice()_method">
			<p>
				<span class="topic">Splicing.</span>
				The <span class="monoText">splice()</span> method can either remove,
				replace, or add new values in an array.
				<span class="monoText">splice()</span> is primarily used for changes to
				the middle of an array, since changes to the beginning or end of an
				array are usually handled with <span class="monoText">push()</span>,
				<span class="monoText">pop()</span>,
				<span class="monoText">shift()</span>, and
				<span class="monoText">unshift()</span>. Splice can take at least three
				different values:
			</p>
			<ol>
				<li>the start index (an integer)</li>
				<li>the specific value we want to delete</li>
				<li>the specific value we want to insert</li>
			</ol>
			<p>So, for example:</p>
			<pre class="language-javascript">
				<code>
					let vectors = ['velocity', 'acceleration', 'momentum'];
					vectors.splice(1, 0, 'weight');
					/*
					In the above code, we changed the original array vectors to the following: 
					vectors = ['velocity', 'weight', 'acceleration', 'momentum']
					*/
				</code>
			</pre>
			<p>
				The <span class="monoText">splice()</span> method changes the original
				array. I.e., once applied, the original array is no more---it is now the
				modified, spliced array.
			</p>
		</section>

		<section id="sort()_method">
			<p>
				<span class="topic">Sorting.</span>
				The <span class="monoText">sort()</span> method sorts the elements of an
				array in place, and returns the sorted array. The sort order can be
				alphabetic, numeric, ascending, or descending. By default,
				<span class="monoText">sort()</span> sorts an array's elements as
				strings in alphabetic and ascending order. To sort the string elements
				of an array alphabetically:
			</p>

			<pre class="language-javascript">
				<code>
					let shapes = ['square', 'circle', 'triangle', 'pentagon', 'rhombus'];
					shapes.sort();
					/* 
					This returns a sorted array: 
					['circle', 'pentagon', 'rhombus', 'square', 'triangle']
					*/
				</code>
			</pre>
		</section>
	</section>

	<section id="arrays_reference_type">
		<h3>Reference Types</h3>
		<p>
			When a variable is declared and assigned a primitive type value, a
			<span class="term">value type variable</span> is created. Once a
			<span class="italicsText">value type variable</span> is created,
			JavaScript stores it in memory, and more specifically, JavaScript
			<span class="italicsText">stores the variable's assigned value</span>.
			This is <span class="underlineText">not</span> the case for variables
			declared and assigned an array.
		</p>
		<p>
			Arrays are too large and take up memory unnecessarily. Instead of storing
			the array, JavaScript stores the array's
			<span class="term">reference</span>. An array's
			<span class="italicsText">reference</span> is a string of numbers, akin to
			a memory address. This has a significant impact on the way
			<code>const</code> works with arrays.
		</p>
		<p>
			Because assigning an array to a variable does not actually store the array
			in the variable (it stores the array's reference), we can change the
			elements within an array, even if we assign the array to a variable
			declared with
			<span class="monoText">const</span>.This is because once an array is
			created and stored in a variable, its reference
			<span class="underlineText">never</span> changes.
		</p>
		<p>
			As such, because the variable declared and assigned with
			<span class="monoText">const</span> is storing a reference (which never
			changes), rather than the actual array itself, the array can be changed
			later down the program.
		</p>
		<p>
			This also means that if you declare a variable with
			<span class="monoText">const</span> and assign an array to it, you cannot
			change that reference later (i.e., assigning to the variable an entirely
			new array). Because of this behavior, it is almost always the case that
			<span class="monoText">const</span> should be used for arrays, unless
			there is a reason for needing a variable to point to different arrays (in
			which case, <span class="monoText">let</span> should be used).
		</p>
	</section>

	<section id="nested_arrays">
		<h3>Nested Arrays</h3>
		<p>
			It is perfectly fine to have arrays containing arrays (but, before nesting
			an array, consider whether there is an alternative or better data
			structure).
		</p>

		<pre class="language-javascript">
			<code>
				/*
				Here is an array containing three arrays.
				*/
				const courses = [
					['mechanics', 'E & M', 'thermodynamics'],
					['calculus', 'differential equations', 'real analysis'],
					['algorithms', 'data structures', 'operating systems']
				]
			</code>
		</pre>

		<p>
			To access the elements of a nested array, we can perform the following:
		</p>

		<pre class="language-javascript"><code>
			const arr1 = [
				[1, 3, 5, 9],
				[3, 2, 9, 10],
				[11, 3, 6, 9]
			]
			// Suppose we want the third element of the second array:
			arr1[1][2];
			/*
			This returns 9.
			[1] tells JavaScript, look at the element with index of 1---in this case, the second array.
			[2] tells JavaScript, inside that array, look at the element with index of 2---in this case, the number 9.
			*/
		</code></pre>
	</section>

	<section id="array_objects">
		<h3>Other Ways to Implement Arrays</h3>
		<p>
			Recall that arrays are an
			<span class="italicsText">ordered collection</span> data structure. In
			terms of datatype, arrays are objects. Now we're adding another trait: As
			objects, arrays behave like iterables &mdash; a particular kind of object.
			But, not every iterable is an array. For example, NodeList, String, Map,
			and Set are all iterables. Objects of these types are iterables, and we
			can iterate through them with a for-of loop. But, objects of type NodeList
			are <span class="underlineText">not</span> arrays. They are
			<span class="italicsText">array-like objects</span>, in that they have a
			length property, and use indices for accessing.
		</p>
		<p>
			To better understand the differences between an array and an array-like
			object, let's revisit arrays. Recall the method for creating arrays we're
			familiar with:
		</p>
		<pre class="language-javascript"><code>
			const arr = [1]
		</code></pre>
		<p>
			No surprises here. This statement creates a singleton, an array with only
			one element. It's also the most common way to create an array. But it
			turns out the above statement isn't the only way:
		</p>
		<pre class="language-javascript"><code>
			const arr = Array(1);
			const arr = new Array(1);
			const arr = Array.of(1);
			const arr = Array.from(1);
		</code></pre>
		<p>
			Although each of the statements above creates an array, they all do so
			differently. To see these differences, we revisit the
			<span class="monoText">length</span> property of an array. We know that
			when we create an array in JavaScript the way we usually do (with square
			brackets) we create an array whose length can grow and shrink:
		</p>
		<pre class="language-javascript"><code>
			let arr = [1, 2, 3];
			console.log(arr);
			console.log(arr.length);
		</code></pre>
		<pre class="language-bash"><code>
			[1, 2, 3]
			3
		</code></pre>
		<p>
			When use the <span class="monoText">Array()</span> function, we get the
			same result:
		</p>
		<pre class="language-javascript"><code>
			let arr = Array(1, 2, 3);
			console.log(arr);
			console.log(arr.length);
		</code></pre>
		<pre class="language-bash"><code>
			[1, 2, 3]
			3
		</code></pre>
		<p>The same goes for <span class="monoText">new Array()</span>:</p>
		<pre class="language-javascript"><code>
			let arr = new Array(1, 2, 3);
			console.log(arr);
			console.log(arr.length);
		</code></pre>
		<pre class="language-bash"><code>
			[1, 2, 3]
			3
		</code></pre>
		<p>Now notice what happens when we pass a single argument:</p>
		<pre class="language-javascript"><code>
			let arr1 = [1];
			let arr2 = Array(1);
			let arr3 = new Array(1);
			console.log(arr1);
			console.log(arr1.length);
			console.log(arr2);
			console.log(arr2.length);
			console.log(arr3);
			console.log(arr3.length);
		</code></pre>
		<pre class="language-bash"><code>
			[1]
			1
			[empty]
			1
			[empty]
			1
		</code></pre>
		<p>
			When we use the square bracket syntax for initialization (<span
				class="monoText"
				>arr1</span
			>), we get an array as expected. But, using
			<span class="monoText">Array()</span> or
			<span class="monoText">new Array()</span>, we get an empty array with a
			length of <span class="monoText">1</span>. What's happening here?
		</p>
		<p>
			We're seeing this behavior because
			<span class="monoText">Array()</span> is a function that returns a static
			array if only one argument is passed to it. Both
			<span class="monoText">Array()</span> and
			<span class="monoText">new Array()</span> are essentially the same. The
			only difference is that <span class="monoText">Array()</span> is a
			function, while <span class="monoText">new Array()</span> is a
			constructor. Either or, passing only one argument is interpreted as the
			resulting array's length. Passing multiple arguments, the values are
			interpeted as the resulting array's elements.
		</p>
	</section>
</section>

<section id="object_literals">
	<h2>Object-literals</h2>
	<p>
		If there's anything about JavaScript that merits slander, it's the way it
		uses the word &#8220;object.&#8221; Across most languages, the word
		&#8220;object&#8221; refers to an instance of an abstract data type (e.g.,
		in languages like Java and Python, an instance of a particular class).
		JavaScript also uses this semantic, but confusingly uses the word
		&#8220;object&#8221; to refer to any collection of individual data items. In
		other programming languages, the JavaScript object data structure would be
		given one of many specific names: <span class="monoText">struct</span>,
		<span class="monoText">record</span>, or
		<span class="monoText">aggregate</span>. The JavaScript object data
		structure is more broadly referred to as a
		<span class="italicsText">record data type</span>, or simply a
		<span class="italicsText">record</span>.
	</p>
	<p>
		Recognizing this ambiguity, some JavaScript developers use the term
		&#8220;object-literal&#8221;. This doesn't fix the issue entirely, but we'll
		use this terminology to resolve ambiguities between the object data
		structure and the broader notion of an object: An
		<span class="term">object-literal</span> is a record-type data structure. We
		raise this issue now because many JavaScript newcomers, especially those
		with previous OOP experience, mistakenly adopt a notion that JavaScript's
		object-literal is an instance of some class. It is not. It is a record data
		type like a <span class="monoText">struct</span>.
	</p>
	<p>
		That said, an object-literal is a collection of
		<span class="term">properties</span> or
		<span class="term">methods</span>.<label
			for="methodOOP"
			class="margin-toggle"
			><sup></sup
		></label>
		<input
			type="checkbox"
			id="methodOOP"
			class="margin-toggle sidenote-number"
		/>
		<span class="marginnote"
			>For those coming from Java: The object is
			<span class="underlineText">not</span> a
			<span class="italicsText">class</span>. It is more like a
			<span class="monoText">struct</span> in C++.</span
		>The object-literal is analogous to the Python
		<span class="italicsText">dictionary</span>. An object-literal's property
		consists of a <span class="term">key-value pair</span> &mdash; a key (think
		of it as a label, or identifier), and the data paired with it. We call the
		key's name the <span class="term">property name</span>. The value paired to
		the key is called the <span class="term">property value</span>. With
		object-literals, the name of a key is always a value of one of three types:
	</p>
	<figure>
		<ul>
			<li>
				<span class="monoText"><mark>String</mark></span>
			</li>
			<li>
				<span class="monoText"><mark>Number</mark></span>
			</li>
			<li>
				<span class="monoText"><mark>Symbol</mark></span>
			</li>
		</ul>
	</figure>
	<p>
		We will use string value keys first, and later examine number and symbol.
		Importantly, records like the object-literal are distinct from classes in
		OOP. They're an older type of data structure, tracing their origins to C. We
		use object-literals to represent situations in the real world where
		independent pieces of data are all part of single, unified structure. Unlike
		the array, records are often of different types and are identified by name
		rather than index.
	</p>
	<p>
		For example, suppose we have some data for velocity, acceleration, momentum,
		and weight. Now suppose that we have the same exact kind of data for another
		event. If we modeled the data, we might generate the following table:
	</p>
	<figure class="math-display">
		<table class="dataTable">
			<thead>
				<td></td>
				<th>First Reading</th>
				<th>Second Reading</th>
			</thead>
			<tr>
				<td>Velocity</td>
				<td>1.14</td>
				<td>1.26</td>
			</tr>
			<tr>
				<td>Acceleration</td>
				<td>1.09</td>
				<td>1.05</td>
			</tr>
			<tr>
				<td>Momentum</td>
				<td>2.33</td>
				<td>2.43</td>
			</tr>
			<tr>
				<td>Weight</td>
				<td>13.4</td>
				<td>13.9</td>
			</tr>
		</table>
	</figure>
	<p>
		How do we store this data? One option is to store each of the values
		individually with their own variables. The problem: While that may work for
		a handful of data values, it would quickly become cumbersome, even
		infeasible, for thousands of data values.
	</p>
	<p>
		Another option is to use an array. We still have a problem: This would still
		be tedious. We would need some sort of key (with comments), distinguishing
		between the data and distinguishing between the events.
	</p>
	<p>
		The solution to this problem is to use an object literal. Object literals
		allow us to group data together, but more importantly, rather than relying
		on each of the data value's index, we can
		<span class="term">label</span> the data. By labeling the data, we can
		access the assigned values with custom keys, rather than with an index.
	</p>
	<div class="mainIdea">
		<p>
			Object-literals contain a
			<span class="term">key-value pair</span>. A
			<span class="term">key</span> is an identifier mapped to a unique
			<span class="term">value</span>. That key can be defined more than once,
			but it can only have <span class="underlineText">one</span> value in any
			given <span class="italicsText">execution context</span>. That value
			itself can be numeric data, textual data, an array, or more key-value
			pairs. The object literal is a <span class="term">collection</span> of
			these key-value pairs.
		</p>
	</div>
	<p>
		JavaScript's object-literal syntax is more broadly referred to as
		<span class="term">JavaScript Object Notation (JSON)</span>. In JSON, we
		specify objects simply by listing its contents in a sequence of name-value
		pairs. The name and the value are separated by a colon, the name-value pairs
		are separated by commas, and the entire list of name-value pairs is enclosed
		in curly braces. Here's a simple, but very useful object-literal &mdash; the
		abstract data type of a <span class="term">point</span>:
	</p>
	<pre class="language-javascript"><code>
		let p1 = { x: 0, y: 0 };
	</code></pre>
	<p>
		Notice that we didn't actually surround the keys with double quotes. While
		keys must be strings, we do not have to explicitly declare them as strings.
		JavaScript will coerce these values into strings. We can, however,
		explicitly declare them as strings. This in turn allows us to have
		&#8220;identifiers&#8221; with spaces and other characters we typically
		aren't permitted:
	</p>
	<pre class="language-javascript"><code>
		let p1 = {
			"x-coordinate" : 0,
			"y-coordinate" : 0,
			"point label" : "Point 1"
		};
	</code></pre>
	<p>We can then access the values with square-bracket syntax:</p>
	<pre class="language-javascript"><code>
		let p1 = {
			"x-coordinate" : 0,
			"y-coordinate" : 0,
			"point label" : "Point 1"
		};
		console.log(p1["x-coordinate"]);
		console.log(p1["y-coordinate"]);
		console.log(p1["point label"]);
	</code></pre>
	<pre class="language-bash"><code>
		0
		0
		Point 1
	</code></pre>
	<p>
		Object-literals can also store arrays (and even other object literals).
		Returning to our previous data table example:
	</p>
	<pre class="language-javascript"><code>
		let experiment = {
			velocity: [1.14, 1.26],
			acceleration: [1.09, 1.05],
			momentum: [2.33, 2.43],
			weight: [13.4, 13.9]
		}
	</code></pre>
	<p>
		Compared to object-literals, arrays are strict and sharp &mdash; they order
		data strictly by index. Object-literals, on the other hand, are more
		fluid-like. As a data structure, they morph into whatever we put into the
		object.
	</p>
	<p>
		As can be seen above, just like an array, when an object-literal is assigned
		to a variable, the variable does not store the object itself &mdash; it
		stores the object's reference. There are many different kinds of objects.
		For this section, we focus on how to create
		<span class="term">object literals</span>. The
		<span class="italicsText">object literal</span> takes the following form:
	</p>
	<figure class="math-display">
		<ul class="syntax">
			<li>${obj_n}$ = {</li>
			<ul>
				<li>${k_0}$ : ${v_0}$,</li>
				<li>${\vdots}$</li>
				<li>${k_n}$ : ${v_n}$</li>
			</ul>
			<li>}</li>
		</ul>
		<figcaption>
			where ${obj_n}$ is the name of the object, ${k}$ is a key, and ${v}$ is a
			value or collection
		</figcaption>
	</figure>
	<p>
		When an object literal is created, the keys are automatically converted into
		strings (except for symbols). Just like arrays, when a variable is assigned
		an object, the variable does not actually store the object; it stores the
		object's reference. Thus, if you assign
		<span class="italicsText">object $w$</span> to a variable $x$, then also
		assign $x$ to another variable $y$, you can make changes to
		<span class="italicsText">object $w$</span> with both variables $x$ and $y$.
		This is because both variables are pointing to the same object.
	</p>

	<section id="numbers_as_key_values">
		<p>
			<span class="topic">Numbers as Keys.</span> Alongside strings, number
			values can also be used as keys. Specifically, the number must a positive
			number, but it can be float. For example:
		</p>
		<pre class="language-javascript"><code>
			const topCities = {
				0: "Chicago",
				1: "New York City",
				2: "Los Angeles",
				3: "London"
			};
		</code></pre>
		<p>Accessing the values, we must use square-bracket syntax:</p>
		<pre class="language-javascript"><code>
			const topCities = {
				0: "Chicago",
				1: "New York City",
				2: "Los Angeles",
				3: "London"
			};
			console.log(topCities[0]);
		</code></pre>
		<pre class="language-bash"><code>
			Chicago
		</code></pre>
		<p>
			Notice the syntax for accessing the value. Look familiar? Arrays are, in
			fact, object-literals in JavaScript. The syntax we use to initialize
			arrays is really just syntactic sugar for writing something like the
			above.
		</p>
	</section>

	<section id="the_ordering_of_properties">
		<h3>The Ordering of an Object-literal's Properties</h3>
		<p>
			If an object-literal contains only numbers, as keys, the keys (and their
			paired values) are ordered numerically from least to greatest. If,
			however, the keys contain either (a) only strings or (b) strings and
			numbers, then the keys (and their paired values) are ordered by insertion:
			The first item we inserted is first, and the last item we inserted is
			last.
		</p>
	</section>

	<section id="accessing_an_objects_data">
		<h3>Accessing an Object-literal's Data</h3>
		<p>There are two ways to access an object-literal's data:</p>
		<figure class="math-display">
			<div>
				<ul class="syntax">
					<li>${object}$.${key}$</li>
				</ul>
				<ul class="syntax">
					<li>${object}$[${key}$]</li>
				</ul>
			</div>
		</figure>
		<p>For example:</p>
		<pre class="language-javascript"><code>
			let experiment = {
				velocity: [1.14, 1.26],
				acceleration: [1.09, 1.05],
				momentum: [2.33, 2.43],
				weight: [13.4, 13.9]
			}
			console.log(experiment.velocity);
			console.log(experiment["momentum"]);
		</code></pre>
		<pre class="language-bash"><code>
			[1.14, 1.26]
			[2.33, 2.43]
		</code></pre>
		<p>
			The form <span class="monoText">${object}$[${key}$]</span> (square bracket
			syntax), is necessary if the field name is not a simple identifier or if
			the name is computed by the program.
		</p>
	</section>

	<section id="modifying_objects">
		<h3>Modifying an Object-literal</h3>
		<p>
			Because a variable assigned with an object-literal only stores the
			object's reference, we can change an object's properties by simply
			assigning new values to the properties:
		</p>
		<pre class="language-javascript"><code>
			let experiment = {
				velocity: [1.14, 1.26],
				acceleration: [1.09, 1.05],
				momentum: [2.33, 2.43],
				weight: [13.4, 13.9]
			}
			console.log(experiment.velocity);
			
			experiment.velocity[0] = 0.76;
			
			console.log(experiment.velocity);
		</code></pre>
		<pre class="language-bash"><code>
			[1.14, 1.26]
			[0.76, 1.26]
		</code></pre>
		<p>To add a property, we write the following:</p>
		<pre class="language-javascript">
			<code>
				let experiment = {
					velocity: [1.14, 1.26],
					acceleration: [1.09, 1.05],
					momentum: [2.33, 2.43],
					weight: [13.4, 13.9]
				}
				console.log(experiment);
				experiment.temperatureIncreasing = true;
				console.log(experiment);
			</code>
		</pre>
		<pre class="language-bash"><code>
			{velocity: Array(2), acceleration: Array(2), momentum: Array(2), weight: Array(2)}

			{velocity: Array(2), acceleration: Array(2), momentum: Array(2), weight: Array(2), temperatureIncreasing: true}
		</code></pre>
		<p>
			To remove a property in the object-literal, we use the keyword
			<span class="monoText"><mark>delete</mark></span
			>:
		</p>
		<pre class="language-javascript">
			<code>
				let experiment = {
					velocity: [1.14, 1.26],
					acceleration: [1.09, 1.05],
					momentum: [2.33, 2.43],
					weight: [13.4, 13.9]
				};
				console.log(experiment);
				delete experiment.weight;
				console.log(experiment);
			</code>
		</pre>
		<pre class="language-bash"><code>
			{velocity: Array(2), acceleration: Array(2), momentum: Array(2), weight: Array(2)}

			{velocity: Array(2), acceleration: Array(2), momentum: Array(2)}
		</code></pre>
	</section>

	<section id="object_array_equality">
		<h3>Object-array Equality</h3>
		<p>
			Recall that the
			<span class="italicsText">strict equality operator</span>
			<span class="monoText">===</span> tests whether two values are strictly
			equal in both value and type.
		</p>
		<p>
			Because of the way objects and arrays are stored (i.e., only their
			references are stored), neophytes are often surprised when two arrays or
			objects, consisting of entirely the same values, value types, and keys,
			are not strictly equal.
		</p>
		<pre class="language-javascript">
			<code>
				let primes = [1, 3, 5, 7];
				let morePrimes = [1, 3, 5, 7];
				primes === morePrimes // This returns false
				primes == morePrimes // Still false
	
				/*
				This is happening because the arrays <span class="italicsText">primes</span> and <span class="italicsText">morePrimes</span> have different references. The strict equality operator is not checking the actual arrays, it's only checking the references, and those references are different.
				*/
	
				// To check whether the arrays are strictly equal, we must ensure that both <span class="italicsText">primes</span> and <span class="italicsText">morePrimes</span> are storing the same reference:
				let morePrimes2 = primes;
				morePrimes2 === primes; // This returns true
				morePrimes2 == primes; // This returns true
	
				// From the above, if we make changes to morePrimes2, we change the array assigned to primes, since both variables are pointing to the same array:
				morePrimes2.push(11);
				/*
				Now the array looks like: 
				primes = [1, 3, 5, 7, 11]
				*/
			</code>
		</pre>
	</section>

	<section id="factory_functions">
		<p>
			<span class="topic">Factories.</span> JSON notation is compact and easy to
			read, but we can do better. We can write functions that create object
			literals. We call such functions <span class="term">factories</span>. By
			convention, these functions have names beginning with an uppercase initial
			letter to distinguish them from other functions. For example, here's a
			function that returns a 3-dimensional point, with a default point of
			<span class="monoText">(0,0,0)</span>:
		</p>
		<pre class="language-javascript"><code>
			function Point3d(x, y, z) {
				if (x === undefined) {
					x = 0;
					y = 0;
					z = 0;
				}
				return { x: x, y: y, z: z };
			}
			let point1 = Point3d(1, -4, 9);
			console.log(point1);
		</code></pre>
		<pre class="language-bash"><code>
			{x: 1, y: -4, z: 9}
		</code></pre>
	</section>

	<section id="object_shorthand_properties">
		<h3>Shorthand Properties of Objects</h3>
		<p>
			Suppose we have variables declared and initialized with values. In many
			situations, we might want to create an object where the key name is the
			name of the variable, and the key's assigned property is the value
			assigned to the variable.
			<span class="italicstext">Shorthand properties</span>
			provide a concise way of creating such an object. For example, if we
			wanted to collect all of the results from a function in an object, the
			usual way would be:
		</p>
		<pre class="language-javascript"><code>
					// suppose we have an array of voltage values from running an experiment:
					const experiment1 = [0.53, 0.58, 0.59, 0.53, 0.61, 0.51, 0.53];
					// now suppose that we create a function that computes a variety of statistics from these values:
					const experimentstats = (arr) => {
						const voltagequantity = arr.length;
						const maxvoltage = math.max(...arr);
						const minvoltage = math.min(...arr);
						const sumvoltages = arr.reduce((sumvoltages, r) => sumvoltages + r);
						const averagevoltage = sumvoltages / voltagequantity;
						const sortvoltageascending = arr.sort((a, b) => a - b);
		
						return {
							maximum_voltage: maxvoltage,
							minimum_voltage: minvoltage,
							average_voltage: averagevoltage,
							voltages_ascending: sortvoltageascending,
						};
					};
					console.log(experimentstats(experiment1));
					/*
					output:
					{
						maximum_voltage: 0.61,
						minimum_voltage: 0.51,
						average_voltage: 0.5542857142857143,
						voltages_ascending: [ 0.51, 0.53, 0.53, 0.53, 0.58, 0.59, 0.61 ]
					}
					*/	
					</code></pre>
		<p>
			But, with
			<span class="italicstext">shorthand properties</span>, we can shorten the
			return statement in the example above:
		</p>
		<pre class="language-javascript"><code>
						// suppose we have an array of voltage values from running an experiment:
						const experiment1 = [0.53, 0.58, 0.59, 0.53, 0.61, 0.51, 0.53];
						// now suppose that we create a function that computes a variety of statistics from these values:
						const experimentstats = (arr) => {
							const voltagequantity = arr.length;
							const maxvoltage = math.max(...arr);
							const minvoltage = math.min(...arr);
							const sumvoltages = arr.reduce((sumvoltages, r) => sumvoltages + r);
							const averagevoltage = sumvoltages / voltagequantity;
							const sortvoltageascending = arr.sort((a, b) => a - b);
		
							return {
								voltagequantity,
								maxvoltage,
								minvoltage,
								sumvoltages,
								averagevoltage,
								sortvoltageascending
							};
						};
						
						console.log(experimentstats(experiment1));
						/*
						output:
						{
							voltagequantity: 7,
							maxvoltage: 0.61,
							minvoltage: 0.51,
							sumvoltages: 3.88,
							averagevoltage: 0.5542857142857143,
							sortvoltageascending: [ 0.51, 0.53, 0.53, 0.53, 0.58, 0.59, 0.61 ]
						}
						*/							
					</code></pre>
		<p>
			The catch, of course, is that we cannot use unique variable names (of
			course, we can get around that by assigning those names as keys in the
			first place).
		</p>
	</section>

	<section id="computed_properties">
		<h2>Computed Properties</h2>
		<p>
			<span class="italicstext">Computed properties</span> allow us to write
			properties of an object literal with a
			<span class="italicstext">dynamic key</span>. Recall that when use a
			variable name as a property name in an object, javascript does not check
			whether the name is actually a variable&mdash;it simply treats it as a
			string:
		</p>

		<pre class="language-javascript"><code>
					const negativecharge = -1;
					const negparticle = 'electron';
					// if we tried to use the variable name as a property:
					const particledetails = {
						negparticle: negativecharge
					};
					console.log(particledetails); // output: { negparticle: -1 }
					// javascript is not checking if 'negparticle' is a variable; it's a string.			
			</code></pre>

		<p>
			To use a variable name as a property name while making sure that
			javascript evaluates it, we need to use the
			<span class="monotext">object[key]</span> syntax
			<span class="italicstext">after</span> we initialize the object:
		</p>

		<pre class="language-javascript"><code>
				const negativecharge = -1;
				const negparticle = 'electron';
				const particledetails = {};
				particledetails[negparticle] = negativecharge;
	
				// test: 
				console.log(particledetails);
				// output: { electron: -1 }
			</code></pre>

		<p>
			But, the
			<span class="italicstext">computed properties syntax</span>
			provides a more a concise way of accomplishing the same task:
		</p>

		<pre class="language-javascript"><code>
				const negativecharge = -1;
				const negparticle = 'electron';
				const particledetails = { [negparticle]: negativecharge };
				// test:
				console.log(particledetails); // output: { electron: -1 }
			</code></pre>

		<p>
			Notice the syntax we used,
			<span class="monotext">[]</span>:
		</p>

		<pre class="language-javascript"><code>
				const variablea = 'value1';
				const variableb = 'value2';
				const objectc = { [variablea]: variableb }
				// we used the value of variablea as the key name for the value of variableb
			</code></pre>

		<p>
			We can use the
			<span class="italicstext">computed properties syntax</span> to more
			concisely write a function that adds a property. Without using the
			<span class="italicstext">computed properties syntax</span>, the function
			looks like:
		</p>

		<pre class="language-javascript"><code>
				// this function accepts an object, and returns a copy of that object with a new property inserted:
				function propadder(obj, ky, val) {
					const objcopy = { ...obj };
					objcopy[ky] = val;
					return objcopy
				};
				// let's test it on an object:
				const objsample = { str: 'val', num: 2 };
				let objsamplenew = propadder(objsample, 'bool', true);
		
				console.log(objsamplenew); // output: { str: 'val', num: 2, bool: true }
			</code></pre>

		<p>
			Above, we used the <span class="monotext">object[key]</span> syntax to add
			the new property. We can write the same statements with less characters
			with the <span class="italicstext">computed properties syntax</span>:
		</p>

		<pre class="language-javascript"><code>
				const propadder = (obj, ky, val) => { return { ...obj, [ky]: val }; };
				// test:
				const objsample = { str: "val", num: 2 };
				let objsamplenew = propadder(objsample, "bool", true);
		
				console.log(objsamplenew); // output: { str: 'val', num: 2, bool: true }
			</code></pre>

		<p>Or, even shorter with an implicit return:</p>

		<pre class="language-javascript"><code>
				const propadder = (obj, ky, val) => ({ ...obj, [ky]: val });
				// test:
				const objsample = { str: "val", num: 2 };
				let objsamplenew = propadder(objsample, "bool", true);
	
				console.log(objsamplenew); // output: { str: 'val', num: 2, bool: true }	
			</code></pre>
	</section>

	<section id="methods_and_objects">
		<h3>Methods: Functions in Objects</h3>
		<p>
			We can add functions as properties on objects. Once we add a function to
			an object, it becomes a
			<span class="term">method</span>. The simplest reason for why we would
			want to put functions into objects is that doing so is conducive to better
			organized programs, which in turn leads to more efficient and elegant
			code. Recall that a function, at it is core, is just data, so it can be
			assigned to variables. Likewise, it can be assigned to a key:
		</p>

		<pre class="language-javascript"><code>
				// here's a function that computes the circumference of a circle:
				const circumference = (r) => 2 * r * math.pi;
				// we can place this in an object:
				const mathfuncs = {
					circumference: circumference
				};
				// once placed inside an object, we can call it with the method syntax:
				console.log(mathfuncs.circumference(3)); // output: 18.84955592153876
			</code></pre>

		<p>
			In the example above, the function is written outside the object, then
			later placed in the object. This is not how methods are typically written.
			instead, we usually write the functions directly inside the object:
		</p>

		<pre class="language-javascript"><code>
				// we can place this in an object:
				const mathfuncs = {
					circumference: circumference = (r) => (2 * r * math.pi),
					circlearea: circlearea = (r) => (math.pi * r * r)
				};
				// once placed inside an object, we can call it with the method syntax:
				console.log(mathfuncs.circumference(4)); // output: 25.132741228718345
				console.log(mathfuncs.circlearea(4)); // output: 50.26548245743669
			</code></pre>

		<p>
			Note that in the examples, we used the
			<span class="italicstext">arrow function</span> syntax. This is not a
			common way of writing functions inside objects.
		</p>

		<section id="shorthand_methods">
			<h4>Shorthand Methods Syntax</h4>
			<p>
				Instead of using the key value pairs syntax, we can use the
				<span class="italicstext">shorthand method syntax</span>:
			</p>
			<pre class="language-javascript"><code>
					// we can place this in an object:
					const mathfuncs = {
						circumference(r) {
							return 2 * r * math.pi;
						},
						circlearea(r) {
							return math.pi * r * r;
						}
					};
					// once placed inside an object, we can call it with the method syntax:
					console.log(mathfuncs.circumference(4)); // output: 25.132741228718345
					console.log(mathfuncs.circlearea(4)); // output: 50.26548245743669
				</code></pre>
		</section>

		<section id="why_use_methods">
			<h4>Why Should We Use Methods?</h4>
			<p>The best way to see why methods are extremely useful is by example:</p>

			<pre class="language-javascript"><code>
					/*
					I want a function that draws a card out of the deck (and makes sure that the deck is 1 card fewer for each draw)
					*/
					// first, let's make the deck
					function makeDeck() {
						const deck = []; // Make an empty deck
						const suits = ['hearts', 'diamonds', 'spades', 'clubs']; // The array of suits
						const values = '2,3,4,5,6,7,8,9,10,J,Q,K,A'; // A string of values
						// Turn the string of values into an array
						for (let value of values.split(',')) {
							// For each array element, do this:
							for (let suit of suits) {
								// For each suit, do this: 
								deck.push({value, suit})
							}
						}
						return deck;
					};
		
					// Suppose I want to draw a card from the deck
					// We need to write a function that draws the card:
					function drawCard(deck) {
						return deck.pop() // Take a card out of the deck
					};
					// Set the deck to a variable:
					const deck = makeDeck();
					console.log(drawCard(deck)); // Output: { value: 'A', suit: 'clubs' }
		
					// To draw another card, we need to pass the argument again:
					console.log(drawCard(deck)); // Output: { value: 'A', suit: 'spades }
					// The problem with writing the program this way is that we have to keep passing an argument over and over again.
					// And what if we need to shuffle the deck? (The pop method is just taking a card from the deck in order)							
				</code></pre>

			<p>
				The above example shows a common phenomenon in programming: repetitious
				code. Where there is repetitious code, there are methods laying in
				ambush. The above code written inside an object:
			</p>

			<pre class="language-javascript"><code>
					const deck = {
						deck: [],
						suits: ["hearts", "diamonds", "spades", "clubs"],
						values: "2,3,4,5,6,7,8,9,10,J,Q,K,A",
		
						makeDeck() {
							const { suits, values, deck} = this;
							for (let value of values.split(",")) {
								for (let suit of suits) {
									deck.push({ value, suit });
								}
							}
						},
						
						drawCard() {
							return this.deck.pop()
						}
					};
					deck.makeDeck(); // Make the deck
					// Then draw a card:
					console.log(deck.drawCard()); // Output: { value: 'A', suit: 'clubs' }							
				</code></pre>

			<p>
				By storing the functions in an object, we've created methods, which can
				be called upon over and over without having to pass repeatedly pass
				arguments. By using methods, we can do even more things:
			</p>

			<pre class="language-javascript"><code>
					const theDeck = { // create the object
						deck: [], // Variable stores deck
						drawnCards: [], // Variable stores drawn cards
						suits: ["hearts", "diamonds", "spades", "clubs"], // the suits
						values: "2,3,4,5,6,7,8,9,10,J,Q,K,A", // the ranks
						// Method: make deck
						makeDeck() {
							const { suits, values, deck} = this; // stop writing 'this' repeatedly
							// loop through 'values' string turned into array
							for (let value of values.split(",")) {
								// for each element in 'values', loop through 'suits'
								for (let suit of suits) {
									// for each suit, push this object into 'deck'
									deck.push({ value, suit });
								}
							}
						},
						// Method: draw card
						drawCard() {
							const card = this.deck.pop(); // Store drawn card in variable
							this.drawnCards.push(card); // Store drawn card in the drawnCards array
							return card; // Output card
						},
						// Method: draw multiple cards
						drawCards(numCards) {
							const cards = []; // Store drawn cards in variable
							// run drawCard this many times
							for (let i = 0; i < numCards; i++) {
								cards.push(this.drawCard()); // Put drawn cards in cards variable
							}
							return cards; // Output cards
						},
						// Method: shuffle cards
						shuffle() {
							const { deck } = this;
							// Loop through the array backwards
							for (let i = deck.length - 1; i > 0; i--) {
								// Pick a random index before the current element
								let j = Math.floor(Math.random() * [i + 1]);
								// Swap elements with destructuring
								[deck[i], deck[j] = deck[j], deck[i]];
							}
						}
					};
		
					// Let's test.
					theDeck.makeDeck(); // Make the deck. 
					console.log(theDeck.drawCard()); // Draw card:
					// Output: { value: 'A', suit: 'clubs' } 
					console.log(theDeck.drawnCards); // Check drawn cards array:
					// Output: [ { value: 'A', suit: 'clubs' } ]
					console.log(theDeck.drawCards(3)); // Draw multiple cards
					/*
					Output: 
					[
					{ value: 'A', suit: 'spades' },
					{ value: 'A', suit: 'diamonds' },
					{ value: 'A', suit: 'hearts' }
					]
					*/
					theDeck.shuffle(); // Shuffle the deck
					console.log(theDeck.drawCard()); // Draw card
					// Output: { value: 'K', suit: 'clubs' }							
				</code></pre>
		</section>
	</section>
</section>

<section id="for_loop">
	<h2>Iterative Statements</h2>
	<p>
		Having discussed objects and arrays, we can now proceed to
		<span class="term">iterative statements</span> &mdash; statements that
		repeat statements.
	</p>
	<h3>The For-loop</h3>
	<p>
		The first iterative statement we encounter is the
		<span class="term">for-statement</span>, or
		<span class="term">for-loop</span> tells JavaScript to loop through a code
		block a number of times (or infinitely). The for-loop takes the following
		form:
	</p>
	<figure class="math-display">
		<div>
			<ul class="syntax">
				<li>for (${e_i}$, ${c}$, ${s_f}$) {</li>
				<ul>
					<li>${s_0}$</li>
					<li>${\vdots}$</li>
					<li>${s_n}$</li>
				</ul>
				<li>};</li>
			</ul>
		</div>
		<figcaption>
			where ${e_i}$ is the initial expression, ${c}$ is a Boolean expression
			(the test case), ${e_f}$ is the final statement executed after each
			iteration, and ${s_0 \ldots s_n}$ are the satements to execute on each
			iteration
		</figcaption>
	</figure>
	<p>
		The <span class="term">initial expression</span> is the statement that
		JavaScript executes exactly once before entering the for-loop. E.g.,
		declaring a variable to be used in the condition and final expression. Most
		often, the initial expression is used to create a for-loop's counter. The
		<span class="term">condition</span>, or
		<span class="term">test statement</span>, is a boolean expression that
		determines whether JavaScript should proceed with the loop. The condition is
		checked before each execution of the loop. If the condition is true,
		JavaScript continues (the loop executes). If the condition is false,
		JavaScript stops, and goes to the next statement in the program (the loop
		terminates). The <span class="term">final expression</span> is the
		expression that JavaScript evaluates after each loop iteration. Usually, the
		final expression contains code to update the counter variable declared in
		the initial expression. The for-loop's
		<span class="term">statement</span> is the code that the loop executes, or,
		more generally, the code we want repeated.
	</p>
	<section id="incrementing_counter">
		<p>For example, here's is a simple incrementing counter in JavaScript.</p>
		<pre class="language-javascript">
			<code>
				for (let i = 0; i < 3; i++) {
					console.log("execution");
				}
				/*
				This loop works as such:
	
				Initial Expression: Declare a variable i, and assign it 0.
				Check condition: Is i less than 3? Yes, 0 < 3. Update counter (i is now 1), and run the loop. 
				Console output: "execution"
	
				Check condition: Is i less than 3? Yes, 1 < 3. Update counter (i is now 2), and run the loop. 
				Console output: "execution"
	
				Check condition: Is i less than 3? Yes, 2 < 3. 
				Update counter (i is now 3), and run the loop. 
				Console output: "execution"
	
				Check condition: is i less than 3? No, 3 â‰® 3. 
				Terminate loop. 
	
				The console should display:
				"execution"
				"execution"
				"execution"
				*/
			</code>
		</pre>
		<p>
			Here's another example. Suppose we were asked to merge one array to
			another array without use <span class="monoText">concat().</span> We can
			do so with a for-loop:
		</p>
		<pre class="language-javascript"><code>
			function mergeArray(array1, array2) {
				for (let i = 0; i < array2.length; i++) {
					array1[array1.length] = array2[i];
				}
			}
			let list1 = ["banana", "apple", "kiwi"];
			let list2 = ["mango", "durian", "peach"];
			mergeArray(list1, list2);
			console.log(list1);
		</code></pre>
		<pre class="language-bash"><code>
			['banana', 'apple', 'kiwi', 'mango', 'durian', 'peach']
		</code></pre>
		<p>
			The function above uses a for-loop to simulate the behavior of
			<span class="monoText">concate()</span>. This function, however, mutates
			existing values, so let's rewrite it to avoid mutation. To do so, we'll
			write another function, <span class="monoText">copyArray()</span>, which
			simulates the <span class="monoText">slice()</span> method.
		</p>
		<pre class="language-javascript"><code>
			function copyArray(arr, begin, end) {
				let outputArray = [];
				if (end === undefined || end > arr.length) {
					end = arr.length;
				}
				for (let i = begin; i < end; i++) {
					outputArray[i] = arr[i];
				}
				return outputArray;
			}
			
			function arrayMerge(array1, array2) {
				let array1Copy = copyArray(array1, 0);
				let array2Copy = copyArray(array2, 0);
				for (let i = 0; i < array2Copy.length; i++) {
					array1Copy[array1Copy.length] = array2Copy[i];
				}
				return array1Copy;
			}
			
			let list1 = ["banana", "apple", "kiwi"];
			let list2 = ["strawberry", "rambutan", "peach"];
			let lists1And2 = arrayMerge(list1, list2);
			console.log(list1);
			console.log(list2);
			console.log(lists1And2);
		</code></pre>
		<pre class="language-bash"><code>
			['banana', 'apple', 'kiwi']
			['strawberry', 'rambutan', 'peach']
			['banana', 'apple', 'kiwi', 'strawberry', 'rambutan', 'peach']
		</code></pre>
		<p>
			The above code simulates the behavior of
			<span class="monoText">push()</span> and
			<span class="monoText">concat()</span>. The difference, however, is that
			we do not mutate the arguments passed. As an aside, here's a common
			for-loop mistake to be aware of: If a variable is declared with
			<span class="monoText">let</span> in a for-loop's initial expression, the
			variable is scoped to the loopâ€”it is destroyed once the loop has finished
			executing. If a for-loop's condition is left out, JavaScript will
			interpret the loop's "condition" as always true, resulting in an infinite
			loop.
		</p>
	</section>
</section>

<section id="for_loops_and_arrays">
	<h3>For-loops & Arrays</h3>
	<p>
		We can use a for-loop to iterate over an array. For example, iterating over
		an array of strings:
	</p>
	<pre class="language-javascript">
		<code>
			const vectors = ['velocity', 'acceleration', 'weight'];
			for (let i = 0; i < vectors.length; i++) {
				console.log(i, vectors[i]);
			}
			/*
			The above code outputs the following to the console:
			0 velocity
			1 acceleration
			2 weight
			*/
		</code>
	</pre>
	<p>Here is another example, iterating over an array of numbers:</p>
	<pre class="language-javascript">
		<code>
			/*
			Here is a program that adds pairs of primes, one after another, and (1) divides by them two, and (2) returns the distance between the two primes.
			*/
			let primes = [1, 3, 5, 7, 11];
			for (let i = 0; i < primes.length - 1; i++) {
				console.log(`Pair of primes: ${primes[i]} and ${primes[i + 1]}`)
				console.log(`Half of the sum: ${(primes[i] + primes[i + 1]) / 2}`)
				console.log(`Distance: ${primes[i + 1] - primes[i]}`);
			}
			/*
			The above code outputs the following to the console:
			Pair of primes: 1 and 3
			Half of the sum: 2
			Distance: 2
			Pair of primes: 3 and 5
			Half of the sum: 4
			Distance: 2
			Pair of primes: 5 and 7
			Half of the sum: 6
			Distance: 2
			Pair of primes: 7 and 11
			Half of the sum: 9
			Distance: 4
			*/
		</code>
	</pre>
	<p>
		It is a common convention to use i for a for-loop's incrementing variable,
		then j and k for inner loops.
	</p>
	<p>
		This convention originates in mathematics, where $i$ is used for the first
		index in summation notation, $j$ for the second, etc.:
	</p>
	<figure>
		<p>$$\sum_{i=1}^{n}i = \frac{n^2+n}{2}$$</p>
	</figure>

	<section id="nested_for_loops">
		<p>
			<span class="topic">Nested For-loops</span>
			We can nest a for-loop inside another for-loop:
		</p>
		<pre class="language-javascript">
			<code>
				for (let i = 1; i <= 3; i++) {
					console.log('Outer Loop:', i);
	
					for (let j = 1; j <= 2; j++) {
						console.log(' Inner Loop:', j);
					}
				}
				/*
				The above code will out put to the console:
				Outer Loop: 1
				Inner Loop: 1
				Inner Loop: 2
				Outer Loop: 2
				Inner Loop: 1
				Inner Loop: 2
				Outer Loop: 3
				Inner Loop: 1
				Inner Loop: 2
				*/
			</code>
		</pre>
		<p>Nested for-loops are useful for targeting nested arrays:</p>
		<pre class="language-javascript">
			<code>
				/*
				Here is an array of number arrays. Suppose we want to find the sum of the numbers in each of the array.
				*/
				let arrNum = [
					[4, 32, 8, 4],
					[64, 8, 32, 2],
					[8, 32, 16, 4],
					[2, 8, 4, 2]
				];
				// First, we need to declare a variable that will store the sums we want.
				let sumNum = 0;
				// Next, we need to loop through the outer array (by targeting each of the individual arrays)
				for (let i = 0; i < arrNum.length; i++) {
				/*
				The outer loop loops through each of the nested arrays. There are 4 arrays (represented by arrNum.length), so the loop first looks at array of index 0, then 1, then 2, then 3, then 4. Now we need to loop through each of the elements in the nested array. First, we declare a variable named nestedArrNum, which will store each of the targeted nested arrays.
				*/
					let nestedArrNum = arrNum[i];
				/* 
				For the targeted nested array with index 0, loop through each of the elements, then continue until i is less than arrNum.length (all nested arrays have been looped through):
				*/
					for (let j = 0; j < nestedArrNum.length; j++) {
						// Then add to sumNum each element of the targeted nested array.
						sumNum += nestedArrSum[j]; 
					}
					console.log(sumNum);
				}
				/*
				The above will output to the console:
				48
				154
				214
				230
				*/
			</code>
		</pre>
	</section>
</section>

<section id="while_loop">
	<h2>The while-loop</h2>
	<p>
		The while-loop, in some situations, is a more efficient version of a
		for-loop. The while-loop takes the following form:
	</p>
	<figure class="math-display">
		<div>
			<ul class="syntax">
				<li>while (${c}$) {</li>
				<ul>
					<li>${s_0}$</li>
					<li>${\vdots}$</li>
					<li>${s_n}$</li>
				</ul>
				<li>}</li>
			</ul>
		</div>
		<figcaption>
			where ${c}$ is some Boolean expression, and ${s_0 \ldots s_n}$ is the
			block of code to execute.
		</figcaption>
	</figure>
	<p>
		When should we use a while-loop instead of a for-loop? The while-loop is
		best used when we do not know how many times the loop should run. And in
		some cases, a while-loop may be more efficient than a for-loop:
	</p>
	<pre class="language-javascript">
		<code>
			// Here is a for loop:
			for (let i = 0; i < 3; i++) {
				console.log(`for loop: ${i}`);
			}
			// The same structure, with a while loop:
			let j = 0;
			while (j < 3) {
				console.log(`while loop: ${j}`);
				j++
			}
			/*
			This outputs the following to the console:
			for loop: 0
			for loop: 1
			for loop: 2

			while loop: 0
			while loop: 1
			while loop: 2
			*/
		</code>
	</pre>
	<section id="break_keyword">
		<p>
			<span class="topic">The Break Keyword</span>
			The <span class="monoText"><mark>break</mark></span> keyword is a special
			keyword in JavaScript that tells JavaScript to break out of a loop (i.e.,
			terminate the loop). This is often used to terminate infinite loops or
			loops at risk of infinite iteration. The keyword is often used in the
			following form:
		</p>
		<figure>
			<ul class="syntax">
				<li>while (${c}$) {</li>
				<ul>
					<li>if (${d}$) { break; }</li>
					<li>${s_0 \ldots s_n}$</li>
				</ul>
				<li>}</li>
			</ul>
		</figure>
		<p>
			Where ${c}$ and ${d}$ are Boolean expressions, and ${s_0 \ldots s_n}$ are
			statement(s) to execute.
		</p>
	</section>
</section>

<section id="infinite_loops">
	<h2>Infinite Loops</h2>
	<p>
		An <span class="term">infinite loop</span> is a loop that never ends.
		Infinite loops have their place in programming, but before writing an
		infinite loop, we need to always check why we're using an infinite loop in
		the first place. Here is an example:
	</p>
	<pre class="language-javascript">
		<code>
			for (let i = 5; i >= 0; i++) {
				<span class="greyText italicsText">code block</span>
			}
			/* This is an infinite loop. i is assigned the value 5, the condition checks if i is greater than or equal to 0, and if it is, i is incremented by 1. An infinite loop occurs because i will always be greater than 0 (the condition is always true), so JavaScript never escapes the loop, and the code block is executed an infinite amount of times (or, more realistically, however long the machine can handle).
			*/
		</code>
	</pre>
</section>

<section id="for_of_loop">
	<h2>The For-of Loop</h2>
	<p>
		The for-of loop is a more efficient way to loop through an
		<span class="term">iterable</span>. An <span class="term">iterable</span> is
		an object that has properties and can be looped through or iterated (e.g.,
		an <a href="#arrays_introduction">array</a>). The for-of loop takes the
		following form:
	</p>
	<figure>
		<ul class="syntax">
			<li>for (${v}$ of ${obj}$) { ${s_0 \ldots s_n}$ }</li>
		</ul>
	</figure>
	<p>
		In the syntax above, ${v}$ is some element in an iterable object ${obj,}$
		and ${s_0 \ldots s_n}$ are statements to execute. For example, suppose we
		want to log to the console each of the elements in the array
		<span class="monoText">arr</span>. We can do so with a regular for-loop:
	</p>
	<pre class="language-javascript">
			<code>
				let arr = ['A', 'B', 'C', 'D'];
				for (let i = 0; i < arr.length; i++) {
					console.log(arr[i]);
				}
			</code>
		</pre>
	<pre class="language-bash"><code>
			A
			B
			C
			D
		</code></pre>
	<p>With the for-of-loop:</p>
	<pre class="language-javascript"><code>
			let arr = ['A', 'B', 'C', 'D'];
			for (let element of arr) {
				console.log(arr);
			}
		</code></pre>
	<pre class="language-bash"><code>
			A
			B
			C
			D
		</code></pre>
	<p>
		A warning: We cannot use a
		<span class="monoText">for<span class="greyText">...</span>of</span>
		loop with an object-literal directly. This is because object-literals are
		<span class="underlineText">not iterable</span>. For example, say we wanted
		to display to the console each of the key-value pairs in an object called
		<span class="monoText">vectors</span>:
	</p>
	<pre class="language-javascript">
		<code>
			const vectors = {
				velocity: 9.5,
				acceleration: 8.2,
				weight: 44.4,
				momentum: 52.3
			};
			for (let values of vectors) {
				console.log(values);
			}
		</code>
	</pre>
	<p>
		The code above returns a TypeError: 'vectors' is not iterable. To iterate
		over an object's keys, we need to use
		<span class="monoText">${obj}$.keys</span> and
		<span class="monoText">${obj}$.values</span>.
	</p>
	<pre class="language-javascript">
		<code>
			const vectors = {
				velocity: 9.5,
				acceleration: 8.2,
				weight: 44.4,
				momentum: 52.3
			};
			for (let prop of Object.keys(vectors)) {
				console.log(elements);
			}
			for (let values of Object.values(vectors)) {
				console.log(values);
			}
		</code>
	</pre>
	<pre class="language-bash"><code>
		velocity
		acceleration
		weight
		momentum
		9.5
		8.2
		44.4
		52.3
	</code></pre>
	<p>
		We see the output above because we can only iterate through either the
		object's values or the object's keys. Alternatively, we can iterate over an
		object without with a for-in-loop.
	</p>
	<section id="for_in_loop">
		<p>
			<span class="topic">The For-in Loop</span>
			The for-in loop allows us to loop through the properties of an
			object-literal. It takes the following form:
		</p>
		<figure>
			<ul class="syntax">
				<li>for (${p}$ in ${obj}$) {${s_0 \ldots s_n}$}</li>
			</ul>
		</figure>
		<p>
			Where ${p}$ is a variable identifying each key-value pair, ${obj}$ is the
			name of the object-literal, and ${s_0 \ldots s_n}$ are statements to
			execute for each ${p.}$ Illustrating:
		</p>
		<pre class="language-javascript">
			<code>
				let mathConstants = {
					tau: 6.28,
					aperys: 1.20,
					euler_mascheroni: 0.57,
					gauss: 0.83
				};
				for (let prop in mathConstants) {
					console.log(prop + ': ' + mathConstants[prop]);
				}
			</code>
		</pre>
		<pre class="language-bash"><code>
			tau: 6.28
			aperys: 1.2
			euler_mascheroni: 0.57
			gauss: 0.83
		</code></pre>
		<p>
			It is best practice to avoid using a for-in loop for arrays. This is
			because the for-in loop is implemented in JavaScript specifically for
			iterating through an object's properties. That iteration is not guaranteed
			to be done in order (and order matters for iterables like arrays). In sum:
			Do not use a for-in loop for iterables &mdash; use a for-of loop.
		</p>
	</section>
</section>

<section id="sets">
	<h2>Sets</h2>
	<p>
		Arrays are iterables, but they aren't the only ones. There's another kind of
		iterable: <span class="term">sets</span>. Like the array, the set stores
		nested data of any kind and length. They're also iterable, with some special
		set methods, but not all of the array methods. The biggest difference
		between sets and arrays: With sets, (1) order is
		<span class="underlineText">not</span> guaranteed, (2) duplicates are
		<span class="underlineText">not</span> allowed, (3) and there is
		<span class="underlineText">no</span> index-based accessing. This makes sets
		a great, lightweight structure for storing data where we do not want
		duplicates.
	</p>
	<p>To instantiate a set, we write the following:</p>
	<pre class="language-javascript"><code>
		const ids = new Set();
	</code></pre>
	<p>
		This results in an empty set. We can initialize the set by passing an
		<span class="italicsText">iterable</span> into the constructor's parameter
		list:
	</p>
	<pre class="language-javascript"><code>
		const ids = new Set([1, 2, 3]);
	</code></pre>
	<p>If we log to the console the set above, we see:</p>
	<pre class="language-bash"><code>
		Set(3) {1, 2, 3}
			[[Entries]]
				0: 1 
				1: 1
				2: 3
				size: 3
				[[Prototype]]: Set
	</code></pre>
	<p>
		Although it appears that there are indices we can access, this is not the
		case. We <span class="underlineText">cannot</span> access elements in a set
		through indexing. Keeping this in mind, here are some of the set specific
		methods we can use (suppose ${S}$ is some set identifier):
	</p>
	<ul class="ruled">
		<li><span class="monoText">const ${S}$ = new Set()</span></li>
		<ul>
			<li>Creates a new set object.</li>
		</ul>
		<li><span class="monoText">${S}$.size</span></li>
		<ul>
			<li>Returns the number of values in the set object.</li>
		</ul>
		<li><span class="monoText">${S}$.add(${v}$)</span></li>
		<ul>
			<li>
				Appends some value ${v}$ to the set object ${S}$. The return is the set
				object ${S}$ with the new, appended value ${v.}$
			</li>
		</ul>
		<li><span class="monoText">${S}$.clear()</span></li>
		<ul>
			<li>Removes all elements from the set object ${S.}$</li>
		</ul>
		<li><span class="monoText">${S}$.delete(${v}$)</span></li>
		<ul>
			<li>
				Removes the element ${v}$ from the set object ${S.}$ If the element was
				successfully removed, returns <span class="monoText">true</span>,
				otherwise <span class="monoText">false</span>.
			</li>
		</ul>
		<li><span class="monoText">${S}$.has(${v}$)</span></li>
		<ul>
			<li>
				If the set object ${S}$ contains the element ${v,}$ returns
				<span class="monoText">true</span>; otherwise
				<span class="monoText">false</span>.
			</li>
		</ul>
		<li>
			<span class="monoText"
				>${S}$.forEach( ${f}$(${v}$) {${s_0 \ldots s_n}$} )</span
			>
		</li>
		<ul>
			<li>
				Iterates over the values ${v}$ in the set object ${S,}$ applying the
				function ${f,}$ which executes the statements ${s_0 \ldots s_n.}$
			</li>
		</ul>
		<li><span class="monoText">${S}$.entries()</span></li>
		<ul>
			<li>
				Returns the elements of ${S}$ as an iterable. The resulting iterable can
				then be used in a for-loop.
			</li>
			<li>
				For example:
				<pre class="language-javascript"><code>
					const S = new Set(['a', 'b', 'c']);
					for (const entry of S.entries()) {
						console.log(entry);
					}
				</code></pre>
				<pre class="language-bash"><code>
					(2) ['a', 'a']
					(2) ['b', 'b']
					(2) ['c', 'c']
				</code></pre>
				Notice that this returns three arrays with two elements. This is because
				the <span class="monoText">.entries()</span> method is shared with the
				<span class="monoText"><mark>map</mark></span> data structure, and with
				maps, entries are key-value pairs. If we want an iterable consisting of
				only the values once, use
				<span class="monoText"><mark>.values()</mark></span
				>.
			</li>
		</ul>
		<li><span class="monoText">${S}$.values()</span></li>
		<ul>
			<li>
				Returns an iterable containing only the values of the set object ${S,}$
				in the order the elements were inserted.
			</li>
		</ul>
	</ul>
	<p>
		Although sets aren't as commonly used as arrays, they can be particularly
		useful for a wide variety of situations.
	</p>
	<p>
		<span class="topic">Decomposing Strings.</span> If we pass a string as an
		argument to the
		<span class="monoText"><mark>Set()</mark></span> constructor, we get back a
		set with all the characters as separate elements:
	</p>
	<pre class="language-javascript"><code>
		const userName = 'Aiden';
		const userNameChars = new Set(userName);
		for (const char of userNameChars.values()) {
			console.log(char);
		}
	</code></pre>
	<pre class="language-bash"><code>
		A
		i
		d
		e
		n
	</code></pre>
	<p>
		<span class="topic">Removing Duplicates from an Array.</span> Sets can be
		used to remove duplicates from an array. This is done with both the
		<span class="monoText"><mark>Set()</mark></span> constructor and spread
		syntax:
	</p>
	<pre class="language-javascript"><code>
		const userNames = ['Carl', 'Kento', 'Suji', 'Kento', 'Suji'];
		const uniqueUserNames = [...new Set(userNames)];
		console.log(uniqueUserNames);
	</code></pre>
	<pre class="language-bash"><code>
		(3) ['Carl', 'Kento', 'Suji']
	</code></pre>
	<section id="weak_set">
		<h3>Weak Sets</h3>
		<p>
			JavaScript provides a &#8220;weaker&#8221; version of
			<span class="monoText">Set</span> called
			<span class="monoText"><mark>WeakSet</mark></span
			>. Recall that with sets, we can store any kind of data. Weak sets,
			however, can only store objects (i.e., arrays, object-literals, maps,
			sets, etc.). We cannot store <span class="italicsText">literals</span>.
			The API for <span class="monoText">WeakSet</span> is similar to the
			<span class="monoText">Set</span> API, with the most noticeable difference
			being the constructor:
		</p>
		<pre class="language-javascript"><code>
			const wSet = new WeakSet();
		</code></pre>
		<p>
			The other differences is that the weak set's API is substantially smaller:
			It only has the methods <span class="monoText">add()</span>,
			<span class="monoText">delete()</span>, and
			<span class="monoText">has()</span>. The key benefit to using weak sets is
			that the data stored within it will be garbage-collected (i.e., destroyed)
			if we do not use it. This benefit arises because the
			<span class="monoText">Set</span> object has an inherent safeguard.
			Consider the following code:
		</p>
		<pre class="language-javascript"><code>
			let user = {name: "Yuri"};
			const users = new Set();
			users.add(user);
			user = null;
			console.log(users);
		</code></pre>
		<pre class="language-bash"><code>
			Set(1) {{...}}
				[[Entries]]
					0: Object
					size: 1
		</code></pre>
		<p>
			We might write the last line in the code above if we no longer need the
			object-literal <span class="monoText">user</span>. However, simply writing
			<span class="monoText">user = null</span> does not clear the
			object-literal from memory. This is because it continues to exist in the
			<span class="monoText">Set users</span>. With
			<span class="monoText">WeakSet</span>, writing the last line ensures that
			the object-literal is, in fact, cleared from memory:
		</p>
		<pre class="language-javascript"><code>
			let user = {name: "Yuri"};
			const users = new WeakSet();
			users.add(user);
			user = null;
			console.log(users);
		</code></pre>
		<pre class="language-bash"><code>
			WeakSet {{...}}
				[[Entries]]
					No properties
		</code></pre>
		<p>
			Weak sets are essentially JavaScript's way of giving us greater control
			over memory management. This is particularly useful if we're working with
			large data structures that really only need to be used momentarily.
		</p>
	</section>
</section>

<section id="maps">
	<h2>Maps</h2>
	<p>
		The <span class="monoText"><mark>Map</mark></span> data structure is similar
		to <span class="monoText"><mark>Object</mark></span
		>, in that it's a collection of key-value pairs. There are, however, several
		differences:
	</p>
	<ul>
		<li>
			With maps, we can use any value as a key. With object-literals, keys must
			be either a <span class="monoText"><mark>String</mark></span> or
			<span class="monoText"><mark>Symbol</mark></span
			>.
		</li>
		<li>
			Object-literals have no inherent order. Maps have an inherent
			<span class="italicsText">insertion order</span>.
		</li>
		<li>
			There is a built-in method to retrieve the
			<span class="monoText"><mark>size</mark></span> of a map, but not for an
			object-literal.
		</li>
		<li>Maps are iterable by default, but not object-literals.</li>
		<li>Maps have better performance in handling large quantities of data.</li>
		<li>
			Maps have better performance when adding and removing data frequently.
		</li>
		<li>Object-literals are ideal for small- to medium-sized sets of data.</li>
		<li>
			Objects are easier and quicker to create (which typically leads to better
			initialization performance).
		</li>
	</ul>
	<p>
		The Map is also distinguished from the object-literal by methods unique to
		its API. Where ${M}$ is the map's identifier:
	</p>
	<ul class="ruled">
		<li><span class="monoText">const ${M}$ = new Map()</span></li>
		<ul>
			<li>Creates a new <span class="monoText">Map</span> object.</li>
		</ul>
		<li><span class="monoText">${M}$.size</span></li>
		<ul>
			<li>
				Returns the number of key-value pairs in the
				<span class="monoText">Map</span> object ${M.}$
			</li>
		</ul>
		<li><span class="monoText">${M}$.clear()</span></li>
		<ul>
			<li>
				Removes all of the key-value pairs in the
				<span class="monoText">Map</span> object ${M.}$
			</li>
		</ul>
		<li><span class="monoText">${M}$.delete(${k}$)</span></li>
		<ul>
			<li>
				Where ${k}$ is some key, removes the key-value pair with the matching
				key ${k.}$ Returns <span class="monoText">true</span> if the pair was
				successfully removed; otherwise <span class="monoText">false</span>.
			</li>
		</ul>
		<li><span class="monoText">${M}$.get(${k}$)</span></li>
		<ul>
			<li>
				Where ${k}$ is some key, returns the value associated with ${k,}$
				otherwise <span class="monoText">undefined</span>.
			</li>
		</ul>
		<li><span class="monoText">${M}$.has(${k}$)</span></li>
		<ul>
			<li>
				Where ${k}$ is some key, returns <span class="monoText">true</span> if
				there is a value associated with the ${k,}$ otherwise
				<span class="monoText">false</span>.
			</li>
		</ul>
		<li><span class="monoText">${M}$.set(${k}$, ${v}$)</span></li>
		<ul>
			<li>
				Where ${k}$ is some key and ${v}$ is some value, sets the value for the
				key ${k}$ in the map object ${M.}$ Returns the map object ${M.}$
			</li>
		</ul>
		<li><span class="monoText">${M}$.keys()</span></li>
		<ul>
			<li>
				Returns a new iterable containing the
				<span class="italicsText">keys</span> for each element in the map object
				${M.}$ The keys are ordered in
				<span class="underlineText">insertion order</span>.
			</li>
		</ul>
		<li><span class="monoText">${M}$.values()</span></li>
		<ul>
			<li>
				Returns a new iterable containing the
				<span class="italicsText">values</span> for each element in the map
				object ${M.}$ The values are ordered in
				<span class="underlineText">insertion order</span>.
			</li>
		</ul>
		<li>
			<span class="monoText"
				>${M}$.forEach(${f}$(${v}$) {${s_0 \ldots s_n}$})</span
			>
		</li>
		<ul>
			<li>
				Iterates over each key-value pair in the map object ${M,}$ evaluating
				the function ${f}$ with the argument ${v,}$ where ${f}$ is some function
				defined as the statements ${e_0 \ldots e_n.}$
			</li>
		</ul>
	</ul>
	<p>
		There are several ways to create maps. One way is to use the
		<span class="monoText"><mark>set()</mark></span> method, creating key-value
		pairs as needed:
	</p>
	<pre class="language-javascript"><code>
		const kanjiToEnglish = new Map();
		kanjiToEnglish.set("æž—æªŽ", "apple");
		kanjiToEnglish.set("æ¡ƒ", "peach");
		kanjiToEnglish.set("æŸ¿", "persimmon");
	</code></pre>
	<p>Alternatively, we can pass the mappings to the constructor as arrays:</p>
	<pre class="language-javascript"><code>
		const kanjiToEnglish = new Map(
			["æž—æªŽ", "apple"], 
			["æ¡ƒ", "peach"], 
			["æŸ¿", "persimmon"]
		);
	</code></pre>
	<p>
		A particularly useful aspect of maps is that they allow us to modularize
		&mdash; and thereby simplify &mdash; objects and other data structures. For
		example, suppose we have a list of students, and each student is an object.
		Each of the students have several properties, some of which are also fairly
		complex. Rather than writing the complex student properties directly, we can
		write those properties as a separate object, then map the student object's
		property to them.
	</p>
	<pre class="language-javascript"><code>
		const danielBoone = {
			firstName: "Daniel",
			lastName: "Boone"
		};
		const physicsMajor = {
			numCoreCourses: 16,
			numOptionalCourses: 20
		};
		const studentDB = new Map(
			[danielBoone, physicsMajor]
		);
	</code></pre>
	<section id="weak_map">
		<h3>Weak Maps</h3>
		<p>
			Just as we saw with sets, there is a &#8220;weaker&#8221; version of the
			map called a <span class="monoText"><mark>WeakMap</mark></span
			>. If we know that map will only be used briefly, we can instead create a
			<span class="monoText">new WeakMap()</span> to gain better control over
			garbage collection. Like weak sets, weak maps have a limited API:
			<span class="monoText">delete()</span>,
			<span class="monoText">set()</span>, <span class="monoText">get()</span>,
			and <span class="monoText">has()</span>. Unlike the weak set, however, the
			weak map can contain both objects or literals for values. But, the keys
			themselves must be objects.
		</p>
	</section>
</section>

<section id="collection_comparison">
	<h3>Comparative Analysis</h3>
	<p>
		In this section, we examined three simple data structures: the array, set,
		and map. Below is a summary of the key differences between the data
		structures:
	</p>
	<ul class="ruled">
		<li>Arrays</li>
		<ul>
			<li>Can store data (including nested data) of any kind and length.</li>
			<li>Iterable.</li>
			<li>Many native methods available.</li>
			<li>Order is guaranteed.</li>
			<li>Duplicates <span class="underlineText">permissible</span>.</li>
			<li>Zero-based indexing to access elements.</li>
		</ul>
		<li>Sets</li>
		<ul>
			<li>Can store data (including nested data) of any kind and length.</li>
			<li>Iterable.</li>
			<li>Some native methods available (not as many as the array's).</li>
			<li>Order is <span class="underlineText">not</span> guaranteed.</li>
			<li>Duplicates <span class="underlineText">impermissible</span></li>
			<li>No index-based accessing.</li>
		</ul>
		<li>Maps</li>
		<ul>
			<li>
				Storing key-value data of any kind and length; any key values
				permissible (e.g., some other data structure as a key, like an array,
				set, map, or a more complicated data structure). Compare this with
				<span class="italicsText">objects</span>, which only allow strings,
				numbers, or symbols as keys.
			</li>
			<li>Some native methods available.</li>
			<li>Order is guaranteed.</li>
			<li>Duplicate keys <span class="underlineText">impermissible</span>.</li>
			<li>No index-based accessing; key-based accessing is used instead.</li>
		</ul>
	</ul>
</section>

{% endblock %}
