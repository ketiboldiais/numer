{% extends '../layout.html' %} {% load static %} {% block description %}
<meta
	name="description"
	content="Collections in JavaScript: Arrays, objects, and loops."
/>
{% endblock %} {% block title %}
<title>Collections & Loops</title>
{% endblock %} {% block content %}
<h1>Collections & Loops</h1>
<section id="intro">
	<p>
		<span class="drop">C</span>ollections are groups of related data. In this
		section, we explore two collections provided natively by JavaScript: Arrays
		and objects. Because JavaScript provides special looping constructs for
		arrays and objects, we will investigate iteration once we've established
		familiarity with the basic collections.
	</p>
</section>
<section id="arrays_introduction">
	<h2>Arrays</h2>
	<p>
		Arrays are the simplest
		<span class="italicsText">data structure</span>; they are a collection of
		values, where <span class="italicsText">order matters</span>. Examples of an
		array include: list of comments on a post, a collection of levels in a game,
		or a playlist of songs. Every value can be collected and placed in an order.
		The resulting ordered collection is called an
		<span class="italicsText">array</span>. Arrays can also collect and order
		other arrays.
	</p>
	<p>
		To create an array in JavaScript, we use square brackets
		<span class="monoText">[]</span>. Here is an empty array:
	</p>
	<pre class="language-javascript">
		<code>
			let special_numbers = [];
		</code>
	</pre>
	<p>An array of strings:</p>
	<pre class="language-javascript">
		<code>
			let colors = ['red', 'orange', 'blue', 'green'];
		</code>
	</pre>
	<p>An array of numbers:</p>
	<pre class="language-javascript">
		<code>
			let primes = [1, 3, 5, 7, 11];
		</code>
	</pre>
	<p>A mixed array:</p>
	<pre class="language-javascript">
		<code>
			let randomStuff = [true, 68, "bird", null];
		</code>
	</pre>

	<section id="array_indices">
		<p>
			<span class="topic">Indices in an Array</span>
			The values in an array are <span class="term">indexed</span>, meaning that
			each value in the array has an <span class="term">index</span>, or
			position within the array, starting from 0. So, for example:
		</p>
		<pre class="language-javascript">
			<code>
				let colors = ['red', 'orange', 'yellow', 'blue'];
				colors[0] // returns 'red'
				colors[1] // returns 'orange'
				colors[2] // returns 'yellow'
				colors[3] // returns 'blue'
			</code>
		</pre>
	</section>

	<section id="array_length">
		<p>
			<span class="topic">Array Length</span>
			Much like how they can be applied to strings and variables, we can find
			the length of an array (how many values it holds) with the
			<span class="monoText">.length</span> method.
		</p>
		<pre class="language-javascript">
			<code>
				let colors = ['red', 'orange', 'yellow', 'blue'];
				colors.length; // Returns 4, the array named <span class="italicsText">colors</span> contains 4 values.
			</code>
		</pre>
		<p>If we want to get the last value in an array:</p>
		<pre class="language-javascript">
			<code>
				let colors = ['red', 'orange', 'yellow', 'blue'];
				colors[colors.length - 1] // returns 'blue';
				/*
				This works because colors.length returns a number value. That number value is 4, the number of values in the array. Subtract 1, and you have the number 3. So, the code is telling JavaScript, get the value with index of 3 in the array of colors (the index of 3 is the last item in the array.)
				*/
			</code>
		</pre>
	</section>
</section>

<section id="modifying_arrays">
	<h2>Modifying Arrays</h2>
	<p>
		Say that we've set an array. We can change the values inside that array by
		going back and manually changing them, but that would be horribly
		inefficient (and you likely do no want to do that for a very large program).
		Instead of manually changing the values in the array, we can use their
		indices:
	</p>
	<pre class="language-javascript">
		<code>
			let colors = ['red', 'blue', 'green'];
			colors[0] = 'purple';
			colors[1] = 'violet';
			colors[2] = 'black';
			// The above will change the array <span class="italicsText">colors</span> to the following:
			colors = ['purple', 'violet', 'black'];
		</code>
	</pre>
	<p>We can also use methods to change the values in an array:</p>
	<pre class="language-javascript">
		<code>
			// Here is our initial shopping list
			shoppingList = ['Bud Light', 'Merlot', 'Vodka', 'Tequila'];

			// Guest called, wants Cabernet, not Merlot: 
			shoppingList[1] = 'Cabernet';
			// Another guest called, wants Rum, not Tequila:
			shoppingList[shoppingList.length - 1] = 'Rum';
			// Yet another guest called, requesting Tequila to be added
			shoppingList[shoppingList.length] = 'Tequila';

			/* From the above changes, the array <span class="italicsText">shoppingList</span> now looks like:
			shoppingList = ['Bud Light', 'Cabernet', 'Vodka', 'Rum', 'Tequila']
			*/
		</code>
	</pre>

	<section id="push()_method">
		<p>
			<span class="topic"><span class="monoText">push()</span></span>
			The <span class="monoText">push()</span> method adds one or more elements
			to the end of an array, and returns the new length of the array.
		</p>
		<pre class="language-javascript">
			<code>
				let vectors = ['w', 'x', 'y'];
				vectors.push('z');

				/* Vectors is now changed:
				vectors = ['w', 'x', 'y', 'z']
				*/
			</code>
		</pre>
	</section>

	<section id="pop()_method">
		<p>
			<span class="topic"><span class="monoText">pop()</span></span>
			The <span class="monoText">pop()</span> method removes a value at the end
			of an array.
		</p>
		<pre class="language-javascript">
			<code>
				let procedures = ['w', 'x', 'y', 'z'];
				procedures.pop('z');
				/*
				The array <span class="italicsText">procedures</span> has changed to:
				procedures = ['w', 'x', 'y']
				*/
			</code>
		</pre>
	</section>

	<section id="shift()_method">
		<p>
			<span class="topic"><span class="monoText">shift()</span></span>
			The <span class="monoText">shift()</span> method removes a value from the
			start of an array:
		</p>
		<pre class="language-javascript">
			<code>
				let procedures = ['w', 'x', 'y', 'z'];
				procedures.shift('w');
				/*
				The array <span class="italicsText">procedures</span> has now changed to:
				procedures = ['x', 'y', 'z']
				*/
			</code>
		</pre>
	</section>

	<section id="unshift()_method">
		<p>
			<span class="topic"><span class="monoText">unshift()</span></span>
			The <span class="monoText">unshift()</span> method adds a value to the
			start of an array:
		</p>
		<pre class="language-javascript">
			<code>
				let procedures = ['w', 'x', 'y', 'z'];
				procedures.unshift('v');
				/*
				The <span class="italicsText">procedures</span> array has now changed to:
				procedures = ['v', 'w', 'x', 'y', 'z']
				*/
			</code>
		</pre>
	</section>

	<section id="concat()_method">
		<p>
			<span class="topic"><span class="monoText">concat()</span></span>
			The <span class="monoText">concat()</span> method
			<span class="underlineText">creates a new array</span>
			from merging two arrays; there is no change to the original.
		</p>
		<pre class="language-javascript">
			<code>
				let x = ['a', 'b', 'c'];
				let y = ['d', 'e', 'f'];
				let x_and_y = x.concat(y);
				console.log(x_and_y);
				/*
				The above code creates a new array called <span class="italicsText">x_and_y</span>, from the arrays <span class="italicsText">x</span> and <span class="italicsText">y</span>:
				x_and_y = ['a', 'b', 'c', 'd', 'e', 'f']
				*/
			</code>
		</pre>
		<p>
			When using the <span class="monoText">concat()</span> method,
			<span class="underlineText">order matters</span>. So, for example, suppose
			you have the following:
		</p>
		<pre class="language-javascript"><code>
			array1.concat(array2).concat(array3)
		</code></pre>
		<p>The new array is:</p>
		<pre class="language-pseudo"><code>
			merged_array = [ array1-values --> array2-values --> array3-values]
		</code></pre>
	</section>

	<section id="includes()_method">
		<p>
			<span class="topic"><span class="monoText">includes()</span></span>
			The <span class="monoText">includes()</span> method is a Boolean methodâ€”it
			returns either <span class="greenText">true</span> or
			<span class="redText">false</span>. If the value is found in the array,
			the method returns <span class="greenText">true</span>. If the value is
			not found in the array, the method returns
			<span class="redText">false</span>.
		</p>
		<pre class="language-javascript">
			<code>
				let subjects = ['math', 'physics', 'cs', 'chemistry'];
				subjects.includes('physics'); 
				// This returns true, because the value 'physics' is inside the array <span class="italicsText">subjects</span>.
			</code>
		</pre>
		<p>
			The <span class="monoText">includes()</span> method can also take a number
			as a second argument. The number passed in represents the
			<span class="italicsText">starting index</span> for JavaScript's search.
			By passing in a number $x$, we essentially ask JavaScript: "Is the value
			contained in the part of the array starting from index $x$? For example:
		</p>
		<pre class="language-javascript">
			<code>
				let var_Array = ['w', 'x', 'y', 'z'];
				var_Array.includes('w', var.Array.length / 2);
				/*
				The above code essentially asks JavaScript:

				"JavaScript, is this true or false:
				The value 'w' is inside the array, and, 
				more specifically, in the part of the array starting from index = 2."

				This returns false, since 'w' is in the first half of the array, starting from index = 0.
				*/
			</code>
		</pre>
	</section>

	<section id="indexOf()_array_method">
		<p>
			<span class="topic"><span class="monoText">indexOf()</span></span>
			The <span class="monoText">indexOf()</span> method works in the same way
			with arrays as it does with strings. In other words, the
			<span class="monoText">indexOf()</span> method finds the index of a value
			in the array. If the method finds the value, it returns its index (an
			integer $x$, where $x \geq 0$). If the method does not find the value, it
			returns -1. Like the <span class="monoText">includes()</span> method, we
			can pass through a second argument, an integer, into the method's
			arguments, to specify where the method should operate.
		</p>
		<pre class="language-javascript">
			<code>
				let frequencies = ['1Mhz', '3Mhz', '7Mhz', '15Mhz'];
	
				frequencies.indexOf('1Mhz'); 
				// This returns 0, the index of '1Mhz'
				
				frequencies.indexOf('3Mhz', frequencies.length / 2);
				// This returns -1, because we told JavaScript to only search for '3Mhz' in the part of the array starting from index = 2, and there is no such value in that part of the array.
	
				frequencies.indexOf('7Mhz', frequencies.length / 2); 
				// This returns 2. We told JavaScript, "Search for '7Mhz' in the part of the array starting from index = 2. JavaScript found the value, and returned its index, 2."
			</code>
		</pre>
	</section>

	<section id="reverse()_method_arrays">
		<p>
			<span class="topic"><span class="monoText">reverse()</span></span>
			The <span class="monoText">reverse()</span> method changes the original
			array by reversing the order of its values. Note that the
			<span class="monoText">reverse()</span> method changes the original array;
			once applied, the original array is replaced by the new array resulting
			from the method.
		</p>
		<pre class="language-javascript">
			<code>
				let arr = [1, 2, 3, 4, 5];
				arr.reverse();
				/*
				This changes the original array into:
				arr = [5, 4, 3, 2, 1]
				*/
			</code>
		</pre>
	</section>

	<section id="join()_method_arrays">
		<p>
			<span class="topic"><span class="monoText">join()</span></span>
			The <span class="monoText">join()</span> method takes all the values in an
			array, and combines them into a single string, as originally ordered.
			Remember, the return from a <span class="monoText">join()</span> method is
			a string. Thus, if you us the <span class="monoText">join()</span> method
			with an array of numbers, the result is a string of those numbers.
		</p>
		<pre class="language-javascript">
			<code>
				let letters = ['q', 'u', 'a', 'd', 'r', 'a', 't', 'i', 'c'];
				
				letters.join('');
				// This returns a single string, joined with an empty string: 'quadratic'
				
				letters.join('-');
				// This returns a single string, joined with the string '-': 'q-u-a-d-r-a-t-i-c'

				letters.reverse().join('');
				// This reverses the array <span class="italicsText">letters</span>, and returns a single string, joined with an empty string: 'citardauq'
			</code>
		</pre>
	</section>

	<section id="slice()_method_arrays">
		<p>
			<span class="topic"><span class="monoText">slice()</span></span>
			Like the <span class="monoText">slice()</span> method applied to strings,
			the <span class="monoText">slice()</span> method applied to arrays takes a
			portion of an array, and creates a new array with that portion, without
			changing or affecting the original array. The
			<span class="monoText">slice()</span> method usually takes two arguments:
		</p>
		<ol>
			<li>The starting index in the original array to start the slice; and</li>
			<li>
				The end index in the original array (but, in the slice, it does not
				include the value with the end index).
			</li>
		</ol>
		<p>
			If no numbers are passed into the
			<span class="monoText">.slice()</span> method, then an entire copy of the
			array is made. So, for example:
		</p>
		<pre class="language-javascript">
			<code>
				let sets = ['A', 'B', 'C', 'D', 'E'];
				let slicedSets = sets.slice(1, 3);
				/* We've created a new array called <span class="italicsText">slicedSets</span>:
				slicedSets = ['B', 'C']
				*/
			</code>
		</pre>
		<p>
			By passing a negative number, say $-x$ into the
			<span class="monoText">slice()</span> method, we essentially tell
			JavaScript: "For this array, slice the portion starting $x$ from the last
			index." For example:
		</p>
		<pre class="language-javascript">
			<code>
				let sets = ['A', 'B', 'C', 'D', 'E'];
				let subSet = sets.slice(-2);
				/*
				This code says, make a slice starting 2 from the last index (here, the last index is 5, so the slice starts at 3). This will include the last index.
				
				So, the resulting array:
				subset = ['C', 'D', 'E']
				*/
			</code>
		</pre>
		<p>
			If 2 negative numbers are passed as arguments into the
			<span class="monoText">slice()</span> method, say $-x$ and $-y$, then the
			slice starts at $x$ index from the last index of the array, and the slice
			ends at $y$ index from the last index of the array. Illustration:
		</p>
		<pre class="language-javascript">
			<code>
				let sets = ["A", "B", "C", "D", "E"];
				let subSet = sets.slice(-3, -1);
				/*
				Here, we tell JavaScript, start the slice at the index 3 units from the last index (in this case, index = 2), and end the slice 1 unit from the last index (index = 4).

				Thus:
				subSet = ['C', 'D']
				*/
			</code>
		</pre>
	</section>

	<section id="splice()_method">
		<p>
			<span class="topic"><span class="monoText">splice()</span></span>
			The <span class="monoText">splice()</span> method can either remove,
			replace, or add new values in an array.
			<span class="monoText">splice()</span> is primarily used for changes to
			the middle of an array, since changes to the beginning or end of an array
			are usually handled with <span class="monoText">push()</span>,
			<span class="monoText">pop()</span>,
			<span class="monoText">shift()</span>, and
			<span class="monoText">unshift()</span>. Splice can take at least three
			different values:
		</p>
		<ol>
			<li>the start index (an integer)</li>
			<li>the specific value we want to delete</li>
			<li>the specific value we want to insert</li>
		</ol>
		<p>So, for example:</p>
		<pre class="language-javascript">
			<code>
				let vectors = ['velocity', 'acceleration', 'momentum'];
				vectors.splice(1, 0, 'weight');
				/*
				In the above code, we changed the original array vectors to the following: 
				vectors = ['velocity', 'weight', 'acceleration', 'momentum']
				*/
			</code>
		</pre>
		<p>
			The <span class="monoText">splice()</span> method changes the original
			array. I.e., once applied, the original array is no more---it is now the
			modified, spliced array.
		</p>
	</section>

	<section id="sort()_method">
		<p>
			<span class="topic"><span class="monoText">sort()</span></span>
			The <span class="monoText">sort()</span> method sorts the elements of an
			array in place, and returns the sorted array. The sort order can be
			alphabetic, numeric, ascending, or descending. By default,
			<span class="monoText">sort()</span> sorts an array's elements as strings
			in alphabetic and ascending order. To sort the string elements of an array
			alphabetically:
		</p>

		<pre class="language-javascript">
			<code>
				let shapes = ['square', 'circle', 'triangle', 'pentagon', 'rhombus'];
				shapes.sort();
				/* 
				This returns a sorted array: 
				['circle', 'pentagon', 'rhombus', 'square', 'triangle']
				*/
			</code>
		</pre>
	</section>
</section>

<section id="arrays_reference_type">
	<h3>Reference Types</h3>
	<p>
		When a variable is declared and assigned a primitive type value, a
		<span class="term">value type variable</span> is created. Once a
		<span class="italicsText">value type variable</span> is created, JavaScript
		stores it in memory, and more specifically, JavaScript
		<span class="italicsText">stores the variable's assigned value</span>. This
		is <span class="underlineText">not</span> the case for variables declared
		and assigned an array.
	</p>
	<p>
		Arrays are too large and take up memory unnecessarily. Instead of storing
		the array, JavaScript stores the array's
		<span class="term">reference</span>. An array's
		<span class="italicsText">reference</span> is a string of numbers, akin to a
		memory address. This has a significant impact on the way
		<code>const</code> works with arrays.
	</p>
	<p>
		Because assigning an array to a variable does not actually store the array
		in the variable (it stores the array's reference), we can change the
		elements within an array, even if we assign the array to a variable declared
		with
		<span class="monoText">const</span>.This is because once an array is created
		and stored in a variable, its reference
		<span class="underlineText">never</span> changes.
	</p>
	<p>
		As such, because the variable declared and assigned with
		<span class="monoText">const</span> is storing a reference (which never
		changes), rather than the actual array itself, the array can be changed
		later down the program.
	</p>
	<p>
		This also means that if you declare a variable with
		<span class="monoText">const</span> and assign an array to it, you cannot
		change that reference later (i.e., assigning to the variable an entirely new
		array). Because of this behavior, it is almost always the case that
		<span class="monoText">const</span> should be used for arrays, unless there
		is a reason for needing a variable to point to different arrays (in which
		case, <span class="monoText">let</span> should be used).
	</p>
</section>

<section id="nested_arrays">
	<h3>Nested Arrays</h3>
	<p>
		It is perfectly fine to have arrays containing arrays (but, before nesting
		an array, consider whether there is an alternative or better data
		structure).
	</p>

	<pre class="language-javascript">
		<code>
			/*
			Here is an array containing three arrays.
			*/
			const courses = [
				['mechanics', 'E & M', 'thermodynamics'],
				['calculus', 'differential equations', 'real analysis'],
				['algorithms', 'data structures', 'operating systems']
			]
		</code>
	</pre>

	<p>To access the elements of a nested array, we can perform the following:</p>

	<pre class="language-javascript"><code>
		const arr1 = [
			[1, 3, 5, 9],
			[3, 2, 9, 10],
			[11, 3, 6, 9]
		]
		// Suppose we want the third element of the second array:
		arr1[1][2];
		/*
		This returns 9.
		[1] tells JavaScript, look at the element with index of 1---in this case, the second array.
		[2] tells JavaScript, inside that array, look at the element with index of 2---in this case, the number 9.
		*/
	</code></pre>
</section>

<section id="objects_as_records">
	<h2>The JavaScript Object: A Record</h2>
	<p>
		If there's anything about JavaScript that merits slander, it's the way it
		uses the word &#8220;object.&#8221; By and large, the word
		&#8220;object&#8221; is an instance of a data type (e.g., in languages like
		Java and Python, an instance of a class), as used in most languages.
		JavaScript also uses this semantic, but where the language really blunders
		is using the word &#8220;object&#8221; to refer to any collection of
		individual data items. In other programming languages, this collection is
		called a
		<span class="monoText">struct</span>, <span class="monoText">record</span>,
		or <span class="monoText">aggregate</span>. More generally, it is a
		<span class="italicsText">record data type</span>.
	</p>
	<p>
		Recognizing this ambiguity, some JavaScript developers and communities
		recognize this confusion and use the term
		<span class="term">object literal</span>. This doesn't really fix the issue,
		but we'll use this terminology to resolve ambiguities between the
		&#8220;object&#8221; collection and the broader notion of an
		&#8220;object&#8221; in OOP. We raise this issue now because many JavaScript
		newcomers, especially those with previous OOP experience, mistakenly adopt a
		notion that the JavaScript &#8220;object&#8221; is an instance of some
		class. It is not. It is a record data type like a
		<span class="monoText">struct</span>.
	</p>
	<p>
		That said, an object is a collection of
		<span class="term">properties</span> and
		<span class="term">methods</span>.<label
			for="methodOOP"
			class="margin-toggle"
			><sup></sup
		></label>
		<input
			type="checkbox"
			id="methodOOP"
			class="margin-toggle sidenote-number"
		/>
		<span class="marginnote"
			>For those coming from Java: The object is
			<span class="underlineText">not</span> a
			<span class="italicsText">class</span>. It is more like a
			<span class="monoText">struct</span> in C++.</span
		>The JavaScript object is analogous to the Python
		<span class="italicsText">dictionary</span>. An object's property consists
		of a <span class="term">key value pair</span> &mdash; a key (think of it as
		a label), and the data stored in it. The name of a key is a string, and that
		name is referred to as a <span class="term">property name</span>. The value
		stored to a key is called the <span class="term">property value</span>.
	</p>
	<p>
		Records like the object literal are distinct from classes in OOP. They're an
		older type of data structure, tracing their origins to C. We use aggregates
		to represent situations in the real world where independent pieces of data
		are all part of single, unified structure. Unlike the array, records are
		often of different types and are identified by name rather than index.
	</p>
	<p>
		For example, suppose we have some data for velocity, acceleration, momentum,
		and weight. Now suppose that we have the same exact kind of data for another
		event. If we modeled the data, we might generate the following table:
	</p>
	<figure class="math-display">
		<table class="dataTable">
			<thead>
				<td></td>
				<th>First Reading</th>
				<th>Second Reading</th>
			</thead>
			<tr>
				<td>Velocity</td>
				<td>1.14</td>
				<td>1.26</td>
			</tr>
			<tr>
				<td>Acceleration</td>
				<td>1.09</td>
				<td>1.05</td>
			</tr>
			<tr>
				<td>Momentum</td>
				<td>2.33</td>
				<td>2.43</td>
			</tr>
			<tr>
				<td>Weight</td>
				<td>13.4</td>
				<td>13.9</td>
			</tr>
		</table>
	</figure>
	<p>
		How do we store this data? One option is to store each of the values
		individually with their own variables. The problem: While that may work for
		a handful of data values, it would quickly become cumbersome, even
		infeasible, for thousands of data values.
	</p>
	<p>
		Another option is to use an array. We still have a problem: This would still
		be tedious. We would need some sort of key (with comments), distinguishing
		between the data and distinguishing between the events.
	</p>
	<p>
		The solution to this problem is to use an object literal. Object literals
		allow us to group data together, but more importantly, rather than relying
		on each of the data value's index, we can
		<span class="term">label</span> the data. By labeling the data, we can
		access the assigned values with custom keys, rather than with an index.
	</p>
	<p>
		JavaScript objects contain a
		<span class="term">name/value pair</span>. A
		<span class="term">name</span> is an identifier mapped to a unique
		<span class="term">value</span>. That name can be defined more than once,
		but it can only have <span class="underlineText">one</span> value in any
		given <span class="italicsText">execution context</span>. That value itself
		can be numeric data, textual data, an array, or more name/value pairs. The
		object literal is a <span class="term">collection</span> of these name value
		pairs. An object can contain name/value pairs, names paired with other
		name/value pairs, or names paired with names paired with other name/valur
		pairs. For example:
	</p>
	<p>
		JavaScript's object literal syntax can be more broadly referred to as
		<span class="term">JavaScript Object Notation (JSON)</span>. In JSON, we
		specify objects simply by listing its contents in a sequence of name-value
		pairs. The name and the value are separated by a colon, the name-value pairs
		are separated by commas, and the entire list of name-value pairs is enclosed
		in curly braces. For example, using our previous table:
	</p>
	<p>
		Here's a simple, but very useful object literal &mdash; the abstract data
		type of a <span class="term">point</span>:
	</p>
	<pre class="language-javascript"><code>
		let p1 = { x: 0, y: 0 };
	</code></pre>
	<p>
		Object literals can also store arrays (and even other object literals).
		Returning to our previous data table example:
	</p>
	<pre class="language-javascript"><code>
		let experiment = {
			velocity: [1.14, 1.26],
			acceleration: [1.09, 1.05],
			momentum: [2.33, 2.43],
			weight: [13.4, 13.9]
		}
	</code></pre>
	<p>
		Compared to <span class="italicsText">object literals</span>,
		<span class="italicsText">arrays</span> are strict and sharp &mdash; they
		order data strictly by index. <span class="italicsText">Objects</span>, on
		the other hand, are more fluid-like. As a data structure, they morph into
		whatever we put into the object.
	</p>
	<p>
		Assigning an Object to a Variable As can be seen above, just like an array,
		when an object is assigned to a variable, the variable does not store the
		object itself &mdash; it stores the object's reference. There are many
		different kinds of objects. For this section, we focus on how to create
		<span class="term">object literals</span>. The
		<span class="italicsText">object literal</span> takes the following form:
	</p>
	<figure class="math-display">
		<div>
			<ul class="syntax">
				<li>${obj_n}$ = {</li>
				<ul>
					<li>${k_0}$ : ${v_0}$</li>
					<li>${\vdots}$</li>
					<li>${k_n}$ : ${v_n}$</li>
				</ul>
				<li>}</li>
			</ul>
		</div>
		<figcaption>
			where ${obj_n}$ is the name of the object, ${k}$ is a key, and ${v}$ is a
			value or collection
		</figcaption>
	</figure>
	<p>
		When an object literal is created, the keys are automatically converted into
		strings (except for symbols). Just like arrays, when a variable is assigned
		an object, the variable does not actually store the object; it stores the
		object's reference. Thus, if you assign
		<span class="italicsText">object $w$</span> to a variable $x$, then also
		assign $x$ to another variable $y$, you can make changes to
		<span class="italicsText">object $w$</span> with both variables $x$ and $y$.
		This is because both variables are pointing to the same object.
	</p>
	<section id="accessing_an_objects_data">
		<p>
			<span class="topic">Accessing an Object Literal's Data</span> There are
			two ways to access an object literal's data:
		</p>
		<figure class="math-display">
			<div>
				<ul class="syntax">
					<li>${object}$.${key}$</li>
				</ul>
				<ul class="syntax">
					<li>${object}$[${key}$]</li>
				</ul>
			</div>
		</figure>
		<p>For example:</p>
		<pre class="language-javascript"><code>
			let experiment = {
				velocity: [1.14, 1.26],
				acceleration: [1.09, 1.05],
				momentum: [2.33, 2.43],
				weight: [13.4, 13.9]
			}
			console.log(experiment.velocity);
			console.log(experiment["momentum"]);
		</code></pre>
		<pre class="language-bash"><code>
			[1.14, 1.26]
			[2.33, 2.43]
		</code></pre>
		<p>
			The form <span class="monoText">${object}$[${key}$]</span> (square bracket
			syntax), is necessary if the field name is not a simple identifier or if
			the name is computed by the program.
		</p>
	</section>
	<section id="modifying_objects">
		<p>
			<span class="topic">Modifying an Object Literal.</span>
			Because a variable assigned with an object only stores the object's
			reference, we can change an object's properties by simply assigning new
			values to the properties:
		</p>
		<pre class="language-javascript"><code>
			let experiment = {
				velocity: [1.14, 1.26],
				acceleration: [1.09, 1.05],
				momentum: [2.33, 2.43],
				weight: [13.4, 13.9]
			}
			console.log(experiment.velocity);
			
			experiment.velocity[0] = 0.76;
			
			console.log(experiment.velocity);
		</code></pre>
		<pre class="language-bash"><code>
			[1.14, 1.26]
			[0.76, 1.26]
		</code></pre>
		<p>To add a property, we write the following:</p>
		<pre class="language-javascript">
			<code>
				let experiment = {
					velocity: [1.14, 1.26],
					acceleration: [1.09, 1.05],
					momentum: [2.33, 2.43],
					weight: [13.4, 13.9]
				}
				console.log(experiment.velocity);
				
				experiment.temperatureIncreasing = true;
				console.log(experiment);
			</code>
		</pre>
		<pre class="language-bash"><code>
			{velocity: Array(2), acceleration: Array(2), momentum: Array(2), weight: Array(2), temperatureIncreasing: true}
		</code></pre>
	</section>
	<section id="object_array_equality">
		<p>
			<span class="topic">Object/Array Equality</span>
			Recall that the
			<span class="italicsText">strict equality operator</span>
			<span class="monoText">===</span> tests whether two values are strictly
			equal in both value and type.
		</p>
		<p>
			Because of the way objects and arrays are stored (i.e., only their
			references are stored), neophytes are often surprised when two arrays or
			objects, consisting of entirely the same values, value types, and keys,
			are not strictly equal.
		</p>
		<pre class="language-javascript">
			<code>
				let primes = [1, 3, 5, 7];
				let morePrimes = [1, 3, 5, 7];
				primes === morePrimes // This returns false
				primes == morePrimes // Still false
	
				/*
				This is happening because the arrays <span class="italicsText">primes</span> and <span class="italicsText">morePrimes</span> have different references. The strict equality operator is not checking the actual arrays, it's only checking the references, and those references are different.
				*/
	
				// To check whether the arrays are strictly equal, we must ensure that both <span class="italicsText">primes</span> and <span class="italicsText">morePrimes</span> are storing the same reference:
				let morePrimes2 = primes;
				morePrimes2 === primes; // This returns true
				morePrimes2 == primes; // This returns true
	
				// From the above, if we make changes to morePrimes2, we change the array assigned to primes, since both variables are pointing to the same array:
				morePrimes2.push(11);
				/*
				Now the array looks like: 
				primes = [1, 3, 5, 7, 11]
				*/
			</code>
		</pre>
	</section>
	<section id="factory_functions">
		<p>
			<span class="topic">Factories.</span> JSON notation is compact and easy to
			read, but we can do better. We can write functions that create object
			literals. We call such functions <span class="term">factories</span>. By
			convention, these functions have names beginning with an uppercase initial
			letter to distinguish them from other functions. For example, here's a
			function that returns a 3-dimensional point, with a default point of
			<span class="monoText">(0,0,0)</span>:
		</p>
		<pre class="language-javascript"><code>
			function Point3d(x, y, z) {
				if (x === undefined) {
					x = 0;
					y = 0;
					z = 0;
				}
				return { x: x, y: y, z: z };
			}
			let point1 = Point3d(1, -4, 9);
			console.log(point1);
		</code></pre>
		<pre class="language-bash"><code>
			{x: 1, y: -4, z: 9}
		</code></pre>
	</section>
</section>

<section id="for_loop">
	<h2>Iterative Statements</h2>
	<p>
		Having discussed objects and arrays, we can now proceed to
		<span class="term">iterative statements</span> &mdash; statements that
		repeat statements.
	</p>
	<h3>The For-loop</h3>
	<p>
		The first iterative statement we encounter is the
		<span class="term">for-statement</span>, or
		<span class="term">for-loop</span> tells JavaScript to loop through a code
		block a number of times (or infinitely). The for-loop takes the following
		form:
	</p>
	<figure class="math-display">
		<div>
			<ul class="syntax">
				<li>for (${e_i}$, ${c}$, ${s_f}$) {</li>
				<ul>
					<li>${s_0}$</li>
					<li>${\vdots}$</li>
					<li>${s_n}$</li>
				</ul>
				<li>};</li>
			</ul>
		</div>
		<figcaption>
			where ${e_i}$ is the initial expression, ${c}$ is a Boolean expression
			(the test case), ${e_f}$ is the final statement executed after each
			iteration, and ${s_0 \ldots s_n}$ are the satements to execute on each
			iteration
		</figcaption>
	</figure>
	<p>
		The <span class="term">initial expression</span> is the statement that
		JavaScript executes exactly once before entering the for-loop. E.g.,
		declaring a variable to be used in the condition and final expression. Most
		often, the initial expression is used to create a for-loop's counter. The
		<span class="term">condition</span>, or
		<span class="term">test statement</span>, is a boolean expression that
		determines whether JavaScript should proceed with the loop. The condition is
		checked before each execution of the loop. If the condition is true,
		JavaScript continues (the loop executes). If the condition is false,
		JavaScript stops, and goes to the next statement in the program (the loop
		terminates). The <span class="term">final expression</span> is the
		expression that JavaScript evaluates after each loop iteration. Usually, the
		final expression contains code to update the counter variable declared in
		the initial expression. The for-loop's
		<span class="term">statement</span> is the code that the loop executes, or,
		more generally, the code we want repeated.
	</p>
	<section id="incrementing_counter">
		<p>For example, here's is a simple incrementing counter in JavaScript.</p>
		<pre class="language-javascript">
			<code>
				for (let i = 0; i < 3; i++) {
					console.log("execution");
				}
				/*
				This loop works as such:
	
				Initial Expression: Declare a variable i, and assign it 0.
				Check condition: Is i less than 3? Yes, 0 < 3. Update counter (i is now 1), and run the loop. 
				Console output: "execution"
	
				Check condition: Is i less than 3? Yes, 1 < 3. Update counter (i is now 2), and run the loop. 
				Console output: "execution"
	
				Check condition: Is i less than 3? Yes, 2 < 3. 
				Update counter (i is now 3), and run the loop. 
				Console output: "execution"
	
				Check condition: is i less than 3? No, 3 â‰® 3. 
				Terminate loop. 
	
				The console should display:
				"execution"
				"execution"
				"execution"
				*/
			</code>
		</pre>
		<p>
			Here's another example. Suppose we were asked to merge one array to
			another array without use <span class="monoText">concat().</span> We can
			do so with a for-loop:
		</p>
		<pre class="language-javascript"><code>
			function mergeArray(array1, array2) {
				for (let i = 0; i < array2.length; i++) {
					array1[array1.length] = array2[i];
				}
			}
			let list1 = ["banana", "apple", "kiwi"];
			let list2 = ["mango", "durian", "peach"];
			mergeArray(list1, list2);
			console.log(list1);
		</code></pre>
		<pre class="language-bash"><code>
			['banana', 'apple', 'kiwi', 'mango', 'durian', 'peach']
		</code></pre>
		<p>
			The function above uses a for-loop to simulate the behavior of
			<span class="monoText">concate()</span>. This function, however, mutates
			existing values, so let's rewrite it to avoid mutation. To do so, we'll
			write another function, <span class="monoText">copyArray()</span>, which
			simulates the <span class="monoText">slice()</span> method.
		</p>
		<pre class="language-javascript"><code>
			function copyArray(arr, begin, end) {
				let outputArray = [];
				if (end === undefined || end > arr.length) {
					end = arr.length;
				}
				for (let i = begin; i < end; i++) {
					outputArray[i] = arr[i];
				}
				return outputArray;
			}
			
			function arrayMerge(array1, array2) {
				let array1Copy = copyArray(array1, 0);
				let array2Copy = copyArray(array2, 0);
				for (let i = 0; i < array2Copy.length; i++) {
					array1Copy[array1Copy.length] = array2Copy[i];
				}
				return array1Copy;
			}
			
			let list1 = ["banana", "apple", "kiwi"];
			let list2 = ["strawberry", "rambutan", "peach"];
			let lists1And2 = arrayMerge(list1, list2);
			console.log(list1);
			console.log(list2);
			console.log(lists1And2);
		</code></pre>
		<pre class="language-bash"><code>
			['banana', 'apple', 'kiwi']
			['strawberry', 'rambutan', 'peach']
			['banana', 'apple', 'kiwi', 'strawberry', 'rambutan', 'peach']
		</code></pre>
		<p>
			The above code simulates the behavior of
			<span class="monoText">push()</span> and
			<span class="monoText">concat()</span>. The difference, however, is that
			we do not mutate the arguments passed. As an aside, here's a common
			for-loop mistake to be aware of: If a variable is declared with
			<span class="monoText">let</span> in a for-loop's initial expression, the
			variable is scoped to the loopâ€”it is destroyed once the loop has finished
			executing. If a for-loop's condition is left out, JavaScript will
			interpret the loop's "condition" as always true, resulting in an infinite
			loop.
		</p>
	</section>
</section>

<section id="for_loops_and_arrays">
	<h3>For-loops & Arrays</h3>
	<p>
		We can use a for-loop to iterate over an array. For example, iterating over
		an array of strings:
	</p>
	<pre class="language-javascript">
		<code>
			const vectors = ['velocity', 'acceleration', 'weight'];
			for (let i = 0; i < vectors.length; i++) {
				console.log(i, vectors[i]);
			}
			/*
			The above code outputs the following to the console:
			0 velocity
			1 acceleration
			2 weight
			*/
		</code>
	</pre>
	<p>Here is another example, iterating over an array of numbers:</p>
	<pre class="language-javascript">
		<code>
			/*
			Here is a program that adds pairs of primes, one after another, and (1) divides by them two, and (2) returns the distance between the two primes.
			*/
			let primes = [1, 3, 5, 7, 11];
			for (let i = 0; i < primes.length - 1; i++) {
				console.log(`Pair of primes: ${primes[i]} and ${primes[i + 1]}`)
				console.log(`Half of the sum: ${(primes[i] + primes[i + 1]) / 2}`)
				console.log(`Distance: ${primes[i + 1] - primes[i]}`);
			}
			/*
			The above code outputs the following to the console:
			Pair of primes: 1 and 3
			Half of the sum: 2
			Distance: 2
			Pair of primes: 3 and 5
			Half of the sum: 4
			Distance: 2
			Pair of primes: 5 and 7
			Half of the sum: 6
			Distance: 2
			Pair of primes: 7 and 11
			Half of the sum: 9
			Distance: 4
			*/
		</code>
	</pre>
	<p>
		It is a common convention to use i for a for-loop's incrementing variable,
		then j and k for inner loops.
	</p>
	<p>
		This convention originates in mathematics, where $i$ is used for the first
		index in summation notation, $j$ for the second, etc.:
	</p>
	<figure>
		<p>$$\sum_{i=1}^{n}i = \frac{n^2+n}{2}$$</p>
	</figure>

	<section id="nested_for_loops">
		<p>
			<span class="topic">Nested For-loops</span>
			We can nest a for-loop inside another for-loop:
		</p>
		<pre class="language-javascript">
			<code>
				for (let i = 1; i <= 3; i++) {
					console.log('Outer Loop:', i);
	
					for (let j = 1; j <= 2; j++) {
						console.log(' Inner Loop:', j);
					}
				}
				/*
				The above code will out put to the console:
				Outer Loop: 1
				Inner Loop: 1
				Inner Loop: 2
				Outer Loop: 2
				Inner Loop: 1
				Inner Loop: 2
				Outer Loop: 3
				Inner Loop: 1
				Inner Loop: 2
				*/
			</code>
		</pre>
		<p>Nested for-loops are useful for targeting nested arrays:</p>
		<pre class="language-javascript">
			<code>
				/*
				Here is an array of number arrays. Suppose we want to find the sum of the numbers in each of the array.
				*/
				let arrNum = [
					[4, 32, 8, 4],
					[64, 8, 32, 2],
					[8, 32, 16, 4],
					[2, 8, 4, 2]
				];
				// First, we need to declare a variable that will store the sums we want.
				let sumNum = 0;
				// Next, we need to loop through the outer array (by targeting each of the individual arrays)
				for (let i = 0; i < arrNum.length; i++) {
				/*
				The outer loop loops through each of the nested arrays. There are 4 arrays (represented by arrNum.length), so the loop first looks at array of index 0, then 1, then 2, then 3, then 4. Now we need to loop through each of the elements in the nested array. First, we declare a variable named nestedArrNum, which will store each of the targeted nested arrays.
				*/
					let nestedArrNum = arrNum[i];
				/* 
				For the targeted nested array with index 0, loop through each of the elements, then continue until i is less than arrNum.length (all nested arrays have been looped through):
				*/
					for (let j = 0; j < nestedArrNum.length; j++) {
						// Then add to sumNum each element of the targeted nested array.
						sumNum += nestedArrSum[j]; 
					}
					console.log(sumNum);
				}
				/*
				The above will output to the console:
				48
				154
				214
				230
				*/
			</code>
		</pre>
	</section>
</section>

<section id="while_loop">
	<h2>The while-loop</h2>
	<p>
		The while-loop, in some situations, is a more efficient version of a
		for-loop. The while-loop takes the following form:
	</p>
	<figure class="math-display">
		<div>
			<ul class="syntax">
				<li>while (${c}$) {</li>
				<ul>
					<li>${s_0}$</li>
					<li>${\vdots}$</li>
					<li>${s_n}$</li>
				</ul>
				<li>}</li>
			</ul>
		</div>
		<figcaption>
			where ${c}$ is some Boolean expression, and ${s_0 \ldots s_n}$ is the
			block of code to execute.
		</figcaption>
	</figure>
	<p>
		When should we use a while-loop instead of a for-loop? The while-loop is
		best used when we do not know how many times the loop should run. And in
		some cases, a while-loop may be more efficient than a for-loop:
	</p>
	<pre class="language-javascript">
		<code>
			// Here is a for loop:
			for (let i = 0; i < 3; i++) {
				console.log(`for loop: ${i}`);
			}
			// The same structure, with a while loop:
			let j = 0;
			while (j < 3) {
				console.log(`while loop: ${j}`);
				j++
			}
			/*
			This outputs the following to the console:
			for loop: 0
			for loop: 1
			for loop: 2

			while loop: 0
			while loop: 1
			while loop: 2
			*/
		</code>
	</pre>
</section>

<section id="break_keyword">
	<p>
		<span class="topic">The <span class="monoText">break</span> Keyword</span>
		The <span class="monoText">break</span> keyword is a special keyword in
		JavaScript that tells JavaScript to break out of a loop (i.e., terminate the
		loop). This is often used to terminate infinite loops or loops at risk of
		infinite iteration. The keyword is often used in the following form:
	</p>
	<figure class="math-display">
		<div>
			<ul class="syntax">
				<li>while (${c}$) {</li>
				<ul>
					<li>if (${d}$) { break; }</li>
					<li>${s}$</li>
				</ul>
				<li>}</li>
			</ul>
		</div>
		<figcaption>
			where ${c}$ and ${d}$ are Boolean expressions, and ${s}$ is the statement,
			or block of statements, to execute.
		</figcaption>
	</figure>
</section>

<section id="infinite_loops">
	<h2>Infinite Loops</h2>
	<p>
		An <span class="term">infinite loop</span> is a loop that never ends.
		Infinite loops have their place in programming, but before writing an
		infinite loop, we need to always check why we're using an infinite loop in
		the first place. Here is an example:
	</p>
	<pre class="language-javascript">
		<code>
			for (let i = 5; i >= 0; i++) {
				<span class="greyText italicsText">code block</span>
			}
			/* This is an infinite loop. i is assigned the value 5, the condition checks if i is greater than or equal to 0, and if it is, i is incremented by 1. An infinite loop occurs because i will always be greater than 0 (the condition is always true), so JavaScript never escapes the loop, and the code block is executed an infinite amount of times (or, more realistically, however long the machine can handle).
			*/
		</code>
	</pre>
</section>

<section id="objects_as_maps">
	<h2>The Map Object</h2>
	<section id="for_of_loop">
		<p>
			<span class="topic">The For-of Loop</span>
			The
			<span class="monoText"
				>for<span class="greyText italicsText">...</span>of</span
			>
			loop is a more efficient way to loop through an
			<span class="term">iterable</span>. An
			<span class="term">iterable</span> is an object that has properties and
			can be looped through or iterated (e.g., an
			<a href="#arrays_introduction">array</a>). The
			<span class="monoText"
				>for<span class="greyText italicsText">...</span>of</span
			>
			loop takes the following form:
		</p>
		<pre class="language-javascript">
					<code>
						for (<span class="greyText italicsText">variable-name</span> of <span class="greyText italicsText">iterable</span>) {
							<span class="greyText italicsText">code block</span>;
						}
					</code>
				</pre>
		<p>Here is an example:</p>
		<pre class="language-javascript">
			<code>
				/*
				We want to display in the console each of the elements in the array <span class="italicsText">iterable</span>. One way to do this is with a regular for loop.
				*/
				let iterable = ['A', 'B', 'C', 'D'];
				for (let i = 0; i < iterable.length; i++) {
					console.log(iterable[i]);
				}
				/*
				We can do this more efficient (i.e., with less code) with a for of loop.
				*/
				for (let element of iterable) {
					console.log(element);
				}
				/*
				The word "element" is simply the variable name we use to store the value or property in the iterable. It can be anything, but the most common names are "element", "value", or "i".
				*/
			</code>
		</pre>
		<section id="warning_for_of_loop">
			<p>
				<span class="topic"
					><span class="monoText">for...of</span> Loops and Objects</span
				>
				You cannot use a
				<span class="monoText">for<span class="greyText">...</span>of</span>
				loop with an
				<a href="#objects_introduction">object</a> directly. This is because
				objects are <span class="underlineText">not iterable</span>.
			</p>
			<pre class="language-javascript">
				<code>
					/*
					Say we want to display in the console each of the key value pairs in an object called <span class="italicsText">vectors</span>:
					*/
					const vectors = {
						velocity: 9.5,
						acceleration: 8.2,
						weight: 44.4,
						momentum: 52.3
					};
					for (let values of vectors) {
						console.log(values);
					}
					// This displays a TypeError in the console: vectors is not iterable
				</code>
			</pre>
			<p>
				To iterate over an object's keys, we need to use the
				<span class="monoText"
					>object.keys(<span class="greyText italicsText">object-name</span
					>)</span
				>
				and the
				<span class="monoText"
					>object.values(<span class="greyText italicsText">object-name</span
					>)</span
				>
				methods:
			</p>
			<pre class="language-javascript">
				<code>
					const vectors = {
						velocity: 9.5,
						acceleration: 8.2,
						weight: 44.4,
						momentum: 52.3
					};
					for (let prop of Object.keys(vectors)) {
						console.log(elements);
					}
					for (let values of Object.values(vectors)) {
						console.log(values);
					}
					/*
					The above outputs the following: 
		
					velocity
					acceleration
					weight
					momentum
					9.5
					8.2
					44.4
					52.3
					*/
				</code>
			</pre>
			<p>
				The problem: We can only iterate through either the object's values or
				the object's keys. Alternatively, we can iterate over an object without
				with a for...in-loop.
			</p>
		</section>

		<section id="for_in_loop">
			<p>
				<span class="topic">The For-in Loop</span>
				The for-in loop allows us to loop through the properties of an object.
				It takes the following form:
			</p>
			<pre class="language-javascript">
				<code>
					for (<span class="greyText italicsText">variable-name</span> in <span class="greyText italicsText">object-name</span>) {
						<span class="greyText italicsText">code block</span>;
					}
				</code>
			</pre>
			<p>Here is an example:</p>
			<pre class="language-javascript">
				<code>
					/*
					Here is an object with some common mathematical constants. We want to output in the console both the object's properties (i.e., the keys and their assigned values).
					*/
					let mathConstants = {
						tau: 6.28,
						aperys: 1.20,
						euler_mascheroni: 0.57,
						gauss: 0.83
					};
					// Using a for...in loop:
					for (let prop in mathConstants) {
						console.log(prop + ': ' + mathConstants[prop]);
					}
					/*
					This outputs to the console:
					tau: 6.28
					aperys: 1.2
					euler_mascheroni: 0.57
					gauss: 0.83
					*/
				</code>
			</pre>
			<p>
				It is best practice not to use a for-in loop for arrays. This is because
				the for-in loop is implemented in JavaScript specifically to loop
				through an object's properties, and that iteration is not guaranteed to
				be in order (and order matters for iterables like arrays). In sum: Do
				not use a for-in loop for iterablesâ€”use a for-of loop.
			</p>
		</section>
	</section>
</section>

{% endblock %}
