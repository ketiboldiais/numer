{% extends '../layout.html' %} {% load static %} {% block description %}
<meta name="description" content="Introductin to compilers" />
{% endblock %} {% block title %}
<title>Compilers</title>
{% endblock %} {% block content %}
<h1>Compilers</h1>
<section id="intro">
	<p>
		This volume explores compilers. In our exploration of computer science, much
		of what we have seen appears to be magic. We don't have a very good idea of
		what's going on beneath the surface. If this is the case when we're working
		with a particular language, then the language has implemented its
		abstractions well. The very purpose of a programming language is to hide
		away those details.
	</p>
	<p>
		Now that we have stronger foundations, it's time to exhume the details for
		analysis. They've been buried long enough. We will investigate compiler
		mechanics, implementations, and design choices. As we study compilers, we
		will realize that much of our previous, abstract discussions about subjects
		like algebraic data types, recursion, and software design isn't all that
		abstract. There is a a physical, real process going on beneath the surface.
		Such is the study of compilers &mdash; it reveals the magician's tricks.
	</p>
	<p>
		We've already seen numerous compilers: <span class="monoText">gcc</span>,
		<span class="monoText">ghc</span>, <span class="monoText">clang</span>,
		<span class="monoText">javac</span>, <span class="monoText">chicken</span>,
		<span class="monoText">pypy</span>, <span class="monoText">sml/nj</span>,
		and many others. Let's recall what each of these compilers do.
	</p>
	<p>
		Start with <span class="monoText">javac</span>.
		<span class="monoText">javac</span> takes Java source code as input, and
		outputs <span class="term">bytecode</span>. It also outputs things like
		<span class="monoText">.class</span> files and
		<span class="monoText">.jar</span> files. (Let's not worry about the
		distinctions for now; we're merely trying to recall all the messy details
		and terms we've come across). Next, let's consider
		<span class="monoText">clang</span>. This compiler takes C or C++ code, and
		outputs a <span class="italicsText">binary</span>, or more broadly, an
		<span class="italicsText">executable</span>. The same goes for
		<span class="monoText">gcc</span>. <span class="monoText">ghc</span> is a
		Haskell compiler, so it takes Haskell source code, and outputs again, an
		executable or binary. Looking at what we have so far, it looks like
		<span class="monoText">clang</span>, <span class="monoText">gcc</span>, and
		<span class="monoText">ghc</span> have something in common. They take source
		code as input, and output an executable.
		<span class="monoText">javac</span> looks off. It takes Java source code,
		and returns this other thing called &#8220;bytecode.&#8221; Interesting.
	</p>
	<p>
		When most people hear &#8220;compiler&#8221; they immediately think of
		<span class="italicsText">compiled languages</span>, those &#8220;heavy
		duty&#8221; languages we use for large programs mandating efficiency and
		programmer control: C, C++, Swift, Erlang, Haskell, Rust, Go, and many
		others. What most do not think of are the
		<span class="italicsText">interpreted languages</span>: Python, JavaScript,
		PHP, Ruby, and everything else not compiled; the languages that just
		&#8220;run.&#8221; Indeed, in the earlier volumes &mdash; and in most
		introductory programming courses &mdash; we introduced these distinctions
		between compiled, interpreted, and somewhere-in-between languages. We're now
		in a position to backpedal slightly and say that those distinctions are
		largely meaningless. They're introduced for the sake of simplicity, to hide
		away the details, so the novice can focus on first principles.
	</p>
	<p>
		Take for example the TypeScript, what is, in fact, a compiled language. The
		TypeScript compiler, <span class="monoText">tsc</span>, takes TypeScript
		code and outputs JavaScript code. That JavaScript code is then
		<span class="italicsText">interpreted</span> by the browser. This looks an
		awful lot like Java, where source code inputs result in some other medium.
	</p>
	<p>
		It turns out that this idea extends to some implementations of Python as
		well. If we're ever working with CPython &mdash; just one of the many Python
		implementations &mdash; we might notice our directory littered with
		<span class="monoText">.pyc</span> files. What are those files? Well, it
		turns out that CPython works much like Java. The CPython source code is
		taken as input, and some form of bytecode is returned as output.
	</p>
	<p>
		It should now steadily dawn on us that the distinction between interpreted
		and compiled languages is a little more complicated than we initially
		thought. What is it that warrants the classification
		&#8220;interpreted&#8221; or &#8220;compiled?&#8221; Where are the grey
		areas? Are there grey areas? These questions turn out to be remarkably
		useful in guiding our study of compilers.
	</p>
</section>
{% endblock %}
