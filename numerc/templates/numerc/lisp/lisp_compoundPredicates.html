{% extends '../layout.html' %} {% load static %} {% block content %}
<section id="compound_predicates">
	<p>
		<span class="topic">Constructing Compound Predicates.</span> We can
		construct more complex compound predicates with the symbols
		<span class="monoText">and</span>, <span class="monoText">or</span>, and
		<span class="monoText">not</span>. Of these three,
		<span class="monoText">and</span> and <span class="monoText">or</span> are
		special forms, while <span class="monoText">not</span> is an ordinary
		procedure. For all compound predicates, the interpreter evaluates from left
		to right.
	</p>
	<p>
		<span class="topic"><span class="monoText">and</span>.</span> The symbol
		<span class="monoText">and</span> denotes logical conjunction. It takes the
		general form:
	</p>
	<figure class="math-display">
		<pre class="language-pseudo"><code>
			(and ⟨expression-1⟩ ... ⟨expression-n⟩)
		</code></pre>
	</figure>
	<p>
		The compound predicate
		<span class="monoText">(and ⟨expression-1⟩ ... ⟨expression-n⟩)</span>
		evaluates to true if, and only if, all of its expressions evaluate to true.
		If, as the interpreter evaluates from left to right, it reaches an
		expression that evaluates to false, the entire compound predicate evaluates
		to false.
	</p>
	<p>
		<span class="topic"><span class="monoText">or</span>.</span> The symbol
		<span class="monoText">or</span> denotes inclusive disjunction. The general
		form:
	</p>
	<figure class="math-display">
		<pre class="language-pseudo"><code>
			(or ⟨expression-1⟩ ... ⟨expression-n⟩)
		</code></pre>
	</figure>
	<p>
		The <span class="monoText">or</span> predicate evaluates to true as soon as
		the interpreter evaluates one of its expressions to true. If the interpreter
		evaluates all of its expressions and none of the expressions evaluate to
		true (i.e., all of the predicates expressions evaluate to false), then the
		entire predicate is false.
	</p>
	<p>
		<span class="topic"><span class="monoText">not</span>.</span> The symbol
		<span class="monoText">not</span> executes logical negation. General form:
	</p>
	<figure class="math-display">
		<pre class="language-pseudo"><code>
			(not ⟨expression⟩)
		</code></pre>
	</figure>
	<p>
		The <span class="monoText">not</span> operation &#8220;reverses&#8221; the
		evaluated value of its expression. If
		<span class="monoText">⟨expression⟩</span> evaluates to true, then the
		predicate evaluates to false. Inversely, if the
		<span class="monoText">⟨expression⟩</span> evaluates to false, then the
		predicate evaluates to true.
	</p>
	<p>
		Compound predicates are critical for case analysis. Often, a particular case
		requires multiple conditions. For example, consider the open sentence ${5 <
		x < 10.}$ This sentence consists of two smaller open sentences: ${x > 5,}$
		and ${x < 10.}$ Thus, to express the propositional function in Lisp, we
		write:
	</p>
	<pre class="language-scheme"><code>
		(and (> x 5) (< x 10))
	</code></pre>
	<p>
		Accordingly, the code above represents the compound inequality ${5 < x <
		10.}$ Another example: How might we test for whether one number is greater
		than or equal to another number? Suppose the numbers are ${x}$ and ${y.}$
		Thus, what we want to test is whether ${x \geq y.}$ Like the previous
		example, this open sentence is a compound predicate. It consists of two
		smaller open sentences, ${x > y}$ and ${x = y.}$ Hence:
	</p>
	<pre class="language-scheme"><code>
		(define (>= x y) (or (> x y) (= x y)))
	</code></pre>
	<p>
		However, if ${x > y}$ or ${x = y,}$ then it must be true that ${x \nless
		y.}$ Thus, a simpler case analysis would be to just test whether ${x \nless
		y:}$
	</p>
	<pre class="language-scheme"><code>
		(define (>= x y) (not (< x y)))
	</code></pre>
	<p>
		This rewriting evidences a helpful tactic in case analysis. If we know that
		a case we want to test for always rules out some other case(s), one way to
		test whether our case is true is to test for the negative of the ruled out
		case(s). For if a ruled out case is true, then our actual case cannot be
		true.
	</p>
</section>
{% endblock %}
