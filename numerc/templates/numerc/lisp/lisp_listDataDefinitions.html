{% extends '../layout.html' %} {% load static %} {% block content %}
<section id="list_data_definitions">
	<p>
		<span class="topic">List Data Definition.</span> As with all data
		structures, we want to have a data definition for the lists we create.
		Suppose the following problem:
	</p>
	<figure class="math-display">
		<div class="rule">
			<p>
				We are designing a program that keeps track of different invasive plant
				species in the Republic of Palau: kasoring, nila grass, tearthumb.
				Design a data definition to represent a list of these pests.
			</p>
		</div>
	</figure>
	<p>
		Because we are dealing with a more complex data structure, we want to layout
		the information we seek to represent:
	</p>
	<pre class="language-scheme"><code>
		;; Information
		;;  kasoring
		;;  nila grass
		;;  tearthumb
	</code></pre>
	<p>
		Now we want to write out the data we might use to represent that
		information.
	</p>
	<pre class="language-scheme"><code>
		;; Information
		;;  kasoring
		;;  nila grass
		;;  tearthumb

		;; Data
		;;  "kasoring"
		;;  "nila grass"
		;;  "tearthumb"
	</code></pre>
	<p>
		We're going to represent the data as a string, so we will want to write the
		type comment as <span class="monoText">ListOfString</span>.
	</p>
	<pre class="language-scheme"><code>
		;; Information
		;;  kasoring
		;;  nila grass
		;;  tearthumb

		;; Data
		;;  "kasoring"
		;;  "nila grass"
		;;  "tearthumb"

		;; ListOfString is one of:
		;;  empty
		;;  (cons String ListOfString)
	</code></pre>
	<p>
		Notice that in our type comment, we used
		<span class="monoText">ListOfString</span> in defining
		<span class="monoText">ListOfString</span>. This is a self-reference. Next,
		we write an interpretation:
	</p>
	<pre class="language-scheme"><code>
		;; Information
		;;  kasoring
		;;  nila grass
		;;  tearthumb

		;; Data
		;;  "kasoring"
		;;  "nila grass"
		;;  "tearthumb"

		;; ListOfString is one of:
		;;  empty
		;;  (cons String ListOfString)

		;; interp. a list of strings
	</code></pre>
	<p>Next, the examples:</p>
	<pre class="language-scheme"><code>
		;; Information
		;;  kasoring
		;;  nila grass
		;;  tearthumb

		;; Data
		;;  "kasoring"
		;;  "nila grass"
		;;  "tearthumb"

		;; ListOfString is one of:
		;;  empty
		;;  (cons String ListOfString)

		;; interp. a list of strings
		
		(define ListOfString1 empty)
		(define ListOfString2 (cons "kasoring" empty))
		(define ListOfString2 (cons "tearthumb" ("kasoring" empty)))
		(define ListOfString2 (cons "nila grass" ("tearthumb" ("kasoring" empty))))
	</code></pre>
	<p>Now we write a template for a function that might use the data:</p>
	<pre class="language-scheme"><code>
		;; Information
		;;  kasoring
		;;  nila grass
		;;  tearthumb

		;; Data
		;;  "kasoring"
		;;  "nila grass"
		;;  "tearthumb"

		;; ListOfString is one of:
		;;  empty
		;;  (cons String ListOfString)

		;; interp. a list of strings
		
		(define ListOfString1 empty)
		(define ListOfString2 (cons "kasoring" empty))
		(define ListOfString2 (cons "tearthumb" 
										(cons "kasoring" empty)))
		(define ListOfString2 (cons "nila grass" 
										(cons "tearthumb" 
											(cons "kasoring" empty))))

		;; function template
		(define (func-for-ListOfString ListOfString)
			(cond [(empty? ListOfString) (...)]
					[else
						(... (first ListOfString)) ; String
						(func-for-ListOfString (rest ListOfString))])) ;ListOfString
	</code></pre>
	<p>
		Notice that we commented two self-references in the code above. Before we
		explain why those self-references are there, let's first look at a problem
		requiring a function:
	</p>
	<figure class="math-display">
		<div class="rule">
			<p>
				We want to know whether the list of invasive plants includes
				&#8220;tearthumb,&#8221; a highly invasive plant taking over the
				Pacific.
			</p>
		</div>
	</figure>
	<p>First, the signature, purpose, and stub:</p>
	<pre class="language-scheme"><code>
		;; ListOfString --> Boolean
		;; produce True if ListOfString includes "tearthumb"
		;; (define (contains-tearthumb? ListOfString) false)
	</code></pre>
	<p>Next, the tests:</p>
	<pre class="language-scheme"><code>
		;; ListOfString --> Boolean
		;;   produce True if ListOfString includes "tearthumb"
		;; (define (contains-tearthumb? ListOfString) false)
		;; examples
		(check-expect (contains-tearthumb? empty) false)
		(check-expect (contains-tearthumb? 
								(cons "kasoring" empty)) false)
		(check-expect (contains-tearthumb? 
								(cons "tearthumb" 
									(cons "kasoring" empty))) true)
		(check-expect (contains-tearthumb? 
								(cons "nila grass" 
									(cons "tearthumb" 
										(cons "kasoring" empty)))) true)
	</code></pre>
	<p>The tests all run fine. Now we code the body:</p>
	<pre class="language-scheme"><code>
		;; ListOfString --> Boolean
		;;   produce True if ListOfString includes "tearthumb"
		;; (define (contains-tearthumb? ListOfString) false)
		;; examples
		(check-expect (contains-tearthumb? empty) false)
		(check-expect (contains-tearthumb? 
								(cons "kasoring" empty)) false)
		(check-expect (contains-tearthumb? 
								(cons "tearthumb" 
									(cons "kasoring" empty))) true)
		(check-expect (contains-tearthumb? 
								(cons "nila grass" 
									(cons "tearthumb" 
										(cons "kasoring" empty)))) true)
		
		(define (contains-tearthumb? ListOfString)
			(cond [(empty? ListOfString) false]
					[else
					(if (string=? (first ListOfString) "tearthumb")
						true
						(contains-tearthumb? (rest ListOfString)))]))
	</code></pre>
	<p>
		The above is an example of <span class="term">recursion</span>, and it is
		closely tied to the idea of self-reference.
	</p>
	<p>
		Whenever we are handling data of arbitrary size, we want to see
		self-referencing in our type comments. Additionally, data definitions
		incorporating self-reference should be
		<span class="italicsText">well-formed data definitions</span>. Recall the
		data definition:
	</p>
	<pre class="language-scheme"><code>
		;; ListOfString is one of:
		;;   - empty
		;;   - (cons String ListOfString)
	</code></pre>
	<p>
		There are two components to a well-formed data definition incorporating
		self-reference: (1) at least one self-reference, and (2) at least one
		<span class="term">base case</span>. The base case in the data definition
		above is <span class="monoText">empty</span>. We say &#8220;at least
		one&#8221; because a self-referencing data definition can incorporate more
		than one base case or more than one self-reference. Because of these two
		requirements, examples and tests
		<span class="underlineText">must</span> include use of the base case, and
		use of the self-referential cases.
	</p>
	<p>
		We call the type of recursion incorporated above
		<span class="term">natural recursion</span> &mdash; the recursion occurs
		precisely where in the type comment we have a self-reference. When we test
		or debug the cases, we should always target the base case first. This is
		because all of the other cases depend on the base case.
	</p>
	<p>
		<span class="exh">Exercise.</span> Several donors have donated money for a
		large charity project. We want to know how many donors there are, and the
		total amount of money donated.
	</p>
	<details class="answer">
		<summary>Solution</summary>
		<pre class="language-scheme"><code>
			;; Information
			;; $400
			;; $500
			;; $600

			;; Data
			;; 400
			;; 500
			;; 600

			;; ListOfNumber is one of:
			;;  empty
			;;  (cons Number ListOfNumber)

			;; Interp. a list of numbers

			; (define ListOfNumber empty)
			; (define ListOfNumber (cons 400 empty))
			; (define ListOfNumber (cons 500 (cons 400 empty)))
			; (define ListOfNumber (cons 600 (cons 500 (cons 400 empty))))

			;(define (func-for-ListOfNumber ListOfNumber)
			;  (cond [(empty? ListOfNumber) (...)]
			;        [else
			;         (... (first ListOfNumber) ...)
			;         (func-for-ListofNumber ListOfNumber)]))

			;; Functions

			;; ListOfNumber --> Number
			;; Consumes ListOfNumber, returns amount donated
			(check-expect (amountDonated? empty) 0)
			(check-expect (amountDonated? (cons 400 empty)) 400)
			(check-expect (amountDonated? (cons 500 (cons 400 empty))) 900)
			(check-expect (amountDonated? (cons 600 (cons 500 (cons 400 empty)))) 1500)

			;(define (amountDonated? ListOfNumber) 0)

			(define (amountDonated? ListOfNumber)
			(cond [(empty? ListOfNumber) 0]
					[else
						(+ (first ListOfNumber)
							(amountDonated? (rest ListOfNumber)))]))


			;; ListOfNumber --> Number
			;; Consumes ListOfNumber, number of donors
			(check-expect (donorCount? empty) 0)
			(check-expect (donorCount? (cons 400 empty)) 1)
			(check-expect (donorCount? (cons 500 (cons 400 empty))) 2)
			(check-expect (donorCount? (cons 600 (cons 500 (cons 400 empty)))) 3)

			; (define (donorCount? ListOfNumber) 0)

			(define (donorCount? ListOfNumber)
			(cond [(empty? ListOfNumber) 0]
					[else
						(+ 1 (donorCount? (rest ListOfNumber)))]))
		</code></pre>
	</details>
	<p>
		When writing functions employing natural recursion, there are two questions
		we should ask:
	</p>
	<ol>
		<li>
			How do we break down the computation so that each caller hires another
			caller who hires another caller ... all the way down to the base case?
		</li>
		<li>
			When we reach the base case, what should the previous caller do with the
			results from the base case?
		</li>
	</ol>
	<p>
		We ask these questions to ensure we have a
		<span class="italicsText">combination</span> &mdash; how the contribution of
		the first caller combines with the result of the natural recursion. In other
		words: Luke (the first caller) hires John who hires Mary who hires Yuri (the
		last call; the base case). How does Mary combine the results from Yuri? How
		does John combine the results from Mary? How does Luke combine the results
		from John?
	</p>
</section>
{% endblock %}
