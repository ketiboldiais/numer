{% extends '../layout.html' %} {% load static %} {% block description %}
<meta name="description" content="Introduction to Racket" />
{% endblock %} {% block title %}
<title>Racket Basics</title>
{% endblock %} {% block content %}

<h1>Racket Basics</h1>

<section id="intro">
	<p>
		<span class="drop">R</span>acket is the modern successor to Scheme, and
		further up, Common racket. It's a dialect of racket, preserving much of
		Scheme's distinctive features while adding several twists of its own.
		In these materials, we will use Racket for the most part, but will
		occassionally use Scheme. This will be made apparent by the first line
		of our code demos. For Racket programs, we begin every program with the
		line:
	</p>
	<pre class="language-scheme"><code>
		#lang racket
	</code></pre>
	<p>
		If that line isn't shown, it's assumed to be a Racket program. In
		contrast, we will begin every Scheme program with the line:
	</p>
	<pre class="language-scheme"><code>
		#lang scheme
	</code></pre>
	<p>
		Moreover, every Racket file &mdash; also called a Racket
		<i>module</i> &mdash; ends with the extension <var>.rkt</var>, while
		every Scheme module ends with the extension <var>.scm</var>. With these
		basics out of the way, we can proceed to the core constructs.
	</p>
</section>

<section id="basics">
	<h2>Expressions</h2>
	<p>
		In investigating Racket &mdash; and really any other language for that
		matter &mdash; it's helpful to identify how the language forms the
		following constructs: (1)
		<b>primitive expressions</b>: the language's simplest entities, (2)
		<b>compound expressions</b>: expressions formed by combining other
		expressions, and (3) <b>abstractions</b>: how expressions, primitive or
		compound, can be named and manipulated as units. As we've seen with
		other languages, each of these constructs are named and implemented in
		various ways. We turn our attention to how Racket approaches these
		constructs.
	</p>
	<section id="expressions">
		<h3>Simple Expressions</h3>
		<p>
			In Racket, the simplest data is the
			<b>primitive expression</b>. The following are all examples:
		</p>
		<pre class="language-scheme"><code>
			134        ; an integer
			#b111      ; a binary number 
			#o111      ; an octal number
			#x111      ; a hexadecimal number
			3.14       ; a real number
			6.42e+10   ; a real number in scientific notation
			1/2        ; a rational
			1+4i       ; complex numbers
		</code></pre>
		<p>
			Notice that in Racket, comments are denoted with a semicolon. Each of
			these expressions have a <b>type</b>. In Racket, there are several
			built-in datatypes. We address each in turn.
		</p>
	</section>

	<section id="number_type">
		<p>
			As we saw above, Racket provides an extensive and formidable number
			type system. Unlike many other languages, Racket's number types
			resemble mathematics very closely. First, Racket provides a broad
			type called <var>number</var>. All values of type
			<var>number</var> are <b>complex</b>. Next, some values of type
			<var>complex</var> are values of type <var>real</var>. Among the
			reals, there are the types <var>zero</var>, <var>positive</var>, and
			<var>negative</var>. The one deviation from mathematics is that all
			values of type <var>real</var> can be represented as type
			<var>rational</var>, with a few key exceptions:
		</p>
		<ol>
			<li><var>+inf.0</var>, representing ${\texttt{+} \infty}$</li>
			<li><var>-inf.0</var>, representing ${\texttt{-} \infty}$</li>
			<li>
				<var>+nan.0</var>, representing not-a-number (i.e., a value that is
				undefined or unrepresentable)
			</li>
		</ol>
		<p>
			We say &#8220;deviation&#8221; because Racket does have what might
			strike some as pecularities. For example, Racket provides a default
			value of
			<var>pi</var>, which is considered a <var>rational</var> type.
			Obviously, the constant ${\pi \notin \mathbb{Q}.}$ Just as well,
			however, we cannot represent all of an irrational number's fractional
			components. Racket's designers went with the more convenient
			approach, where everything that is not under one of the exceptions
			above is considered <var>rational</var>. The other approach would be
			to have gone the Julia and Clojure routes, where the
			<var>rational</var> datatype much more closely resembles mathematics
			(i.e., a subset of the reals).
		</p>
		<p>
			Within the <var>rational</var> type, some values can be represented
			as values of type <var>integer</var>. And among the integers, there
			are the types <var>odd</var> and <var>even</var>. And within all of
			these types, or orthogonal to these types, each value of a number
			type can be <var>exact</var> or <var>inexact</var>. These types do
			exactly what they sound like. <var>inexact</var> number types are
			implemented as flonums (the equivalent of a <var>double</var> in
			languages like Java) or as single-flonums (the equivalent of a
			<var>float</var>). Everything else falls under
			<var>exact</var> (except for the NaN and infinity types listed
			earlier). Moreover, all <var>inexact</var> number values can be
			coerced to <var>exact</var> values.
		</p>
		<p>
			One additional number type is the
			<var>byte</var> datatype, which represents an exact integer between 0
			and 255 inclusive. We will not be seeing much of this type in the
			materials, but we present it here for comprehensiveness.
		</p>
	</section>

	<section id="boolean_type">
		<p>
			Racket provides a
			<var>boolean</var> datatype. In Racket, values of type
			<var>boolean</var> are represented as <var>#t</var> (true) and
			<var>#f</var> (false). This syntax directly follows from Scheme.
			Scheme itself deviates from racket. In racket, true is represented
			with <var>T</var> and false with <var>NIL</var>.
		</p>
		<pre class="language-scheme"><code>
			#T     ; another way to write true
			#t     ; true, the preferred way
			#F     ; another way to write false
			#f     ; false, the preferred way
		</code></pre>
	</section>

	<section id="characters_and_strings">
		<p>
			Racket provides the data type
			<var>char</var>, which is equivalent to the <var>char</var> datatype
			in languages like Java and C++. In Racket, a <var>char</var> value is
			a Unicode scalar value. This means that every value of type
			<var>char</var> is inherently an unsigned integer. In Racket, values
			of type <var>char</var> are indicated with the syntax
			<var>#\${v}$</var>, where ${v}$ is some unicode character.
		</p>
		<pre class="language-scheme"><code>
			#\A         ; the character 'A'
			#\1         ; the character '1'
			#\space     ; the whitespace character
			#\newline   ; the new line character
		</code></pre>
	</section>

	<section id="strings">
		<p>
			As is the case with languages like Java, the datatype
			<var>string</var> in Racket is a static, or fixed-length, array of
			<var>char</var> values (characters), delimited with double quotes.
			And because they are arrays of <var>char</var> values, Racket strings
			support Unicode. Importantly, strings, when written directly as
			expressions, are immutable by default. There are other strings,
			however, that are mutable. We will see these strings later, but for
			now, assume that strings are immutable by default in Racket.
		</p>
		<pre class="language-scheme"><code>
			"3.14"     ; the string "3.14"
			"Racket"   ; the string "Racket" 
		</code></pre>
		<p>
			Like the <var>byte</var> type with numbers, there is a
			<var>byte string</var> datatype. This datatype is similar to
			<var>string</var>, with a few key differences: (1) the string is an
			array of <i>bytes</i> rather than characters, and (2) the strings
			employ ASCII encoding rather than Unicode.
		</p>
		<p>
			There are a few more datatypes to be addressed, but for now, the
			datatypes presented above more than suffice for the next few
			sections. We now turn to several other basic constructs necessary for
			our future demonstrations.
		</p>
	</section>
</section>

<section id="naming">
	<h2>Variables and Environment</h2>
	<p>
		Any useful programming language will provide a way for us to
		<i>name</i> data objects, allowing us to refer to such objects. In
		programming, a <i>name</i> identifies a <i>variable</i>. A variable has
		a <i>value</i>, and that value is the object assigned to that variable.
		In Scheme, we name things with the keyword <var>define</var>:
	</p>
	<pre class="language-scheme"><code>
		(define num 7)
	</code></pre>
	<p>
		Above, we defined a variable named <var>num</var>, and assigned to it
		the data object <var>7</var>. If we enter <var>num</var>:
	</p>
	<pre class="language-scheme"><code>
		(define num 7)
		num
	</code></pre>
	<pre class="language-bash"><code>
		7
	</code></pre>
	<p>
		The ability to name data objects is a language's simplest
		<i>means of abstraction</i>. With ability to name data objects, we can
		begin writing more complex expressions:
	</p>
	<pre class="language-scheme"><code>
		(define pi 3.14)
		(define radius 2)
		(define height 5)
		(define cylinder-volume (* pi (* radius radius) height))

		cylinder-volume
	</code></pre>
	<pre class="language-bash"><code>
		62.8
	</code></pre>
	<p>
		In racket, there are no set conventions for how variables should be
		named. A common convention, however, is to use dashes to indicate
		spaces. As an aside, racket programmers generally do not care much for
		syntax. Accordingly, compared to other languages, racket generally has
		few instances of
		<i>syntactic sugar</i>. There is an argument to be made that syntactic
		sugar complicates, rather than simplifies, languages. Quoting Alan
		Perlis, &#8220;Syntactic sugar causes cancer of the semicolon.&#8221;
	</p>
	<p>
		<span class="exh">Exercise.</span> Add the following definitions in
		racket:
	</p>
	<pre class="language-scheme"><code>
		(define x 3)
		(define y 4)
	</code></pre>
	<details class="answer">
		<summary>Solution</summary>
		<pre class="language-scheme"><code>
			(define x 3)
			(define y 4)
			(+ x y)
		</code></pre>
		<pre class="language-bash"><code>
			7
		</code></pre>
	</details>
	<p>
		<span class="exh">Exercise.</span> Suppose <var>x</var> and
		<var>y</var> are the coordinates of a Cartesian point, ${(3, 4).}$
		Write an expression computing the distance of this point from the point
		${(0,0).}$
	</p>
	<details class="answer">
		<summary>Solution</summary>
		<p>Recall that the distance formula is:</p>
		<figure>
			<div>
				<p>
					${d = \sqrt{(\Delta x)^2 + (\Delta y)^2} = \sqrt{(x_2 - x_1)^2 +
					(y_2 - y_1)^2}}$
				</p>
			</div>
		</figure>
		<pre class="language-scheme"><code>
			(define x1 3)
			(define y1 4)
			(define x2 0)
			(define y2 0)
			(define delta_x (- x2 x1))
			(define delta_y (- y2 y1))

			(define dist 
				(sqrt (+ (sqr delta_x) 
							(sqr delta_y))))
			
			dist
		</code></pre>
		<pre class="language-bash"><code>
			5
		</code></pre>
	</details>
</section>

<section id="definitions">
	<h2>Definitions</h2>
	<p>
		Every Racket file contains a collection of
		<b>definitions</b>. These are akin to <i>bindings</i> in other
		languages. They are essentially extensions of the top-level
		environment. For example:
	</p>
	<pre class="language-scheme"><code>
		(define x 17)
	</code></pre>
	<p>
		binds an identifier <var>x</var> to the value <var>17</var>. The
		general syntax:
	</p>
	<figure>
		<ul class="syntax">
			<li>(define ${x}$ ${e}$)</li>
		</ul>
	</figure>
	<p>
		Where ${x}$ is a variable and ${e}$ is an expression, the procedure
		goes: (1) Evaluate ${e}$ to some value ${v.}$ (2) Change the
		environment so that ${x}$ is bound to ${v.}$
	</p>
</section>

<section id="functions">
	<h2>Functions</h2>
	<p>We can define functions in Racket with the following syntax:</p>

	<ul class="syntax">
		<li>(define ${f}$</li>
		<ul>
			<li>(lambda (${x}$)</li>
			<ul>
				<li>(${e_1 \ldots e_n}$)))</li>
			</ul>
		</ul>
	</ul>

	<p>
		Above, ${f}$ is an identifier bound to the anonymous function, ${x}$ is
		a parameter, and ${e_1 \ldots e_n}$ are the expressions to be evaluated
		when ${f}$ is evaluated. For example, here's a function that computes
		the cube of a number:
	</p>
	<pre class="language-scheme"><code>
		(define cube
			(lambda (n)
					(* n n n)))
	</code></pre>
	<p>
		Note that unlike ML, functions in Racket are differentiated by the
		number of arguments they take. Calling a function with the wrong number
		of arguments results in a runtime error.
	</p>
	<p>Alternatively, we can simply omit the lambda expression:</p>
	<pre class="language-scheme"><code>
		(define (cube n)
			(* n n n))
	</code></pre>
</section>

<section id="conditional_expressions">
	<h2>Conditional Expressions</h2>
	<p>
		Our ability to use procedures is significantly limited without the
		ability to only execute them under certain conditions. For example,
		consider the mathematical definition of absolute value:
	</p>
	<figure>
		<div>
			$$ \lvert x \rvert = \begin{cases} x &\text{if } x > 0 \\ 0 &\text{if
			} x = 0 \\ -x &\text{if } x < 0 \end{cases} $$
		</div>
	</figure>
	<p>
		This is an example of
		<i>case analysis</i>. Case analysis in Racket is performed with the
		following syntax:
	</p>
	<ul class="syntax">
		<li>(cond (<i>⟨predicate 1⟩</i> <i>⟨consequent 1⟩</i>)</li>
		<ol>
			<li>(<i>⟨predicate 2⟩</i> <i>⟨consequent 2⟩</i>)</li>
			<li>(<i>⟨predicate 3⟩</i> <i>⟨consequent 3⟩</i>)</li>
			<li>&vellip;</li>
			<li>(<i>⟨predicate n⟩</i> <i>⟨consequent n⟩</i>))</li>
		</ol>
	</ul>
	<p>For example, here's the absolute value function:</p>
	<pre class="language-scheme"><code>
		(define (abs x)
			(cond ((> x 0) x)
					((= x 0) 0)
					((&lt; x 0) (- x))))
	</code></pre>

	<p>
		In the code above, the if predicate is <var>(= y 0)</var>. If that
		predicate is true, return <var>1</var>. Otherwise, go to the next
		block, <var>(* x (power x (- y 1)))</var>.
	</p>
	<p>
		The symbol <var>cond</var> is followed by parentheses containing a
		<i>clause</i> &mdash; the pair of expressions
		<var>⟨predicate n⟩</var> and <var>⟨consequent n⟩</var>. The
		<var>⟨predicate⟩</var> is an expression that evaluates to one of two
		values: true (in racket, <var>#t</var>) or false (<span
			class="monoText"
			>#f</span
		>). If <var>⟨predicate n⟩</var> evaluates to <var>#f</var>, then the
		interpreter next evaluates <var>⟨predicate n+1⟩</var>. The moment the
		interpreter reaches a <var>⟨predicate⟩</var> that evaluates to
		<var>#t</var>, the interpreter returns the value of the corresponding
		<var>⟨consequent⟩</var>. If none of the predicates are true, then the
		value of <var>cond</var> is <var>undefined</var>.
	</p>
	<p>
		A predicate can be a procedure or an expression. The only requirement
		is that the the predicate evaluates to true or false. In the
		conditional expression above, the symbols
		<var>&lt;, >, = </var> were used to denote less than, greater than, and
		equal to. These symbols are <i>primitive predicates</i>.
	</p>
	<p>
		A common convention in racket is to use square brackets,
		<var>[]</var> for <var>cond</var> structures. For example, the two
		function definitions below are equivalent:
	</p>
	<pre class="language-scheme"><code>
		(define (checker x)
			(if (> x 10) "yes"
					(if (< x 10) "no" "maybe")))

		;; This^ is equivalent to:

		(define (checker x)
			(cond [(> x 10) "yes"] 
					[(< x 10) "no"]
					[else "maybe"]))
	</code></pre>
	<p>
		To evaluate <var>cond</var>, racket follows the following procedure:
	</p>
	<ol>
		<li>
			If there are no question-answer pairs (the expressions inside the
			square brackets <var>[]</var>), then return an error.
		</li>
		<li>
			Else, evaluate the first <var>[Q A]</var>. Replace the entire
			<var>cond</var> with a new <var>cond</var> where the first question
			has been replaced by its value.
		</li>
		<li>
			If the value of the first <var>[Q A]</var> is <var>true</var>,
			replace the entire <var>cond</var> expression with the
			<var>A</var> in the <var>[Q A]</var>.
		</li>
		<li>
			If the value of the first <var>[Q A]</var> is <var>false</var>, then
			replace the first <var>[Q A]</var> with a new <var>cond</var> that
			does not have the first <var>[Q A]</var>.
		</li>
		<li>Repeat the process.</li>
		<li>
			Else, if the first <var>[Q A]</var> evaluates to neither
			<var>true</var> nor <var>false</var>, return an error.
		</li>
	</ol>
	<p>Visually:</p>
	<figure>
		<pre class="language-pseudo"><code>
			(cond
				[(> 1 2) "bigger"]
				[(= 1 2) "equal"]
				[(< 1 2) "smaller"])
				
			(cond
				[#false "bigger"]
				[(= 1 2) "equal"]
				[(< 1 2) "smaller"])

			(cond
				[(= 1 2) "equal"]
				[(< 1 2) "smaller"])

			(cond
				[#false "equal"]
				[(< 1 2) "smaller"])

			(cond
				[(< 1 2) "smaller"])

			(cond
				[#true "smaller"])
			
			"smaller"
		</code></pre>
	</figure>
	<p>The absolute value procedure above can be rewritten as:</p>
	<pre class="language-scheme"><code>
		(define (abs x)
			(cond ((< x 0) (- x))
					(else x)))
	</code></pre>
	<p>
		The code commands the interpreter: If $x$ is less than zero, return
		${-x;}$ otherwise, return ${x.}$ The
		<var>else</var> symbol is akin to a <i>default consequence</i>. If none
		of the preceding predicates returns true, the
		<var>else</var> consequence will execute.
	</p>
	<p>The same procedure can be written in another way:</p>
	<pre class="language-scheme"><code>
		(define (abs x)
			(if (< x 0)
					(- x)
					x))
	</code></pre>
	<p>
		Here, we see the symbol <var>if</var>. This symbol tells the
		interpreter to evaluate the predicate following the symbol,
		<var>(< x 0)</var>.
	</p>
	<p>
		Like <var>def</var>, <var>if</var> is a special form. We use
		<var>if</var> when we have exactly two cases in a case analysis.
	</p>
	<p>
		With an <var>if</var> conditional, the interpreter first evaluates the
		<var>⟨predicate⟩</var>. If the predicate evaluates to true, then the
		interpreter evaluates the <var>⟨consequent⟩</var> and returns its
		value. We call this the <b>truth block</b> &mdash; the expressions
		therein execute if the predicate is true. If the
		<var>⟨predicate⟩</var> evaluates to false, then the interpreter
		evaluates the <var>⟨alternative⟩</var> and returns its value. We call
		this the <b>false block</b> &mdash; the expressions therein execute if
		the predicate is false.
	</p>
	<p>
		For <var>if</var> expressions, the interpreter first evaluates the
		predicate, and returns its value &mdash; either <var>#true</var> or
		<var>#false</var>. If the value is <var>#true</var>, then the
		interpreter replaces the entire expression with the consequent, and
		evaluates. If the value is <var>#false</var>, then the interpreter
		replaces the entire expression with the alternative and evaluates. If
		the value is neither <var>#true</var> nor <var>#false</var>, then the
		interpreter returns an error.
	</p>
	<p>
		Here's another example, a recursive function for computing the power of
		a number:
	</p>
	<pre class="language-scheme"><code>
		(define (power x y)
			(if (= y 0) 1
						(* x (power x (- y 1)))))
	</code></pre>

	<section id="compound_predicates">
		<h3>Constructing Compound Predicates</h3>
		<p>
			We can construct more complex compound predicates with the symbols
			<var>and</var>, <var>or</var>, and <var>not</var>. Of these three,
			<var>and</var> and <var>or</var> are special forms, while
			<var>not</var> is an ordinary procedure. For all compound predicates,
			the interpreter evaluates from left to right.
		</p>
		<p>
			The symbol
			<var>and</var> denotes logical conjunction. It takes the general
			form:
		</p>
		<figure>
			<pre class="language-pseudo"><code>
				(and ⟨expression-1⟩ ... ⟨expression-n⟩)
			</code></pre>
		</figure>
		<p>
			The compound predicate
			<var>(and ⟨expression-1⟩ ... ⟨expression-n⟩)</var>
			evaluates to true if, and only if, all of its expressions evaluate to
			true. If, as the interpreter evaluates from left to right, it reaches
			an expression that evaluates to false, the entire compound predicate
			evaluates to false.
		</p>
		<p>
			The symbol
			<var>or</var> denotes inclusive disjunction. The general form:
		</p>
		<figure>
			<pre class="language-pseudo"><code>
				(or ⟨expression-1⟩ ... ⟨expression-n⟩)
			</code></pre>
		</figure>
		<p>
			The <var>or</var> predicate evaluates to true as soon as the
			interpreter evaluates one of its expressions to true. If the
			interpreter evaluates all of its expressions and none of the
			expressions evaluate to true (i.e., all of the predicates expressions
			evaluate to false), then the entire predicate is false.
		</p>
		<p>
			The symbol
			<var>not</var> executes logical negation. General form:
		</p>
		<figure>
			<pre class="language-pseudo"><code>
				(not ⟨expression⟩)
			</code></pre>
		</figure>
		<p>
			The <var>not</var> operation &#8220;reverses&#8221; the evaluated
			value of its expression. If <var>⟨expression⟩</var> evaluates to
			true, then the predicate evaluates to false. Inversely, if the
			<var>⟨expression⟩</var> evaluates to false, then the predicate
			evaluates to true.
		</p>
		<p>
			Compound predicates are critical for case analysis. Often, a
			particular case requires multiple conditions. For example, consider
			the open sentence ${5 < x < 10.}$ This sentence consists of two
			smaller open sentences: ${x > 5,}$ and ${x < 10.}$ Thus, to express
			the propositional function in racket, we write:
		</p>
		<pre class="language-scheme"><code>
			(and (> x 5) (< x 10))
		</code></pre>
		<p>
			Accordingly, the code above represents the compound inequality ${5 <
			x < 10.}$ Another example: How might we test for whether one number
			is greater than or equal to another number? Suppose the numbers are
			${x}$ and ${y.}$ Thus, what we want to test is whether ${x \geq y.}$
			Like the previous example, this open sentence is a compound
			predicate. It consists of two smaller open sentences, ${x > y}$ and
			${x = y.}$ Hence:
		</p>
		<pre class="language-scheme"><code>
			(define (>= x y) (or (> x y) (= x y)))
		</code></pre>
		<p>
			However, if ${x > y}$ or ${x = y,}$ then it must be true that ${x
			\nless y.}$ Thus, a simpler case analysis would be to just test
			whether ${x \nless y:}$
		</p>
		<pre class="language-scheme"><code>
			(define (>= x y) (not (< x y)))
		</code></pre>
		<p>
			This rewriting evidences a helpful tactic in case analysis. If we
			know that a case we want to test for always rules out some other
			case(s), one way to test whether our case is true is to test for the
			negative of the ruled out case(s). For if a ruled out case is true,
			then our actual case cannot be true.
		</p>
	</section>
</section>

<section id="evaluating_combinations">
	<h4>The Evaluation Rule</h4>
	<p>Consider the following expression:</p>
	<pre class="language-scheme"><code>
		(+ 2 (* 3 4) (- (+ 1 2) 3))
	</code></pre>
	<p>
		This expression begins with a primitive operator,
		<var>+</var>. Because it starts with a primitive operators, we call
		this expression a <b>primitive call</b>. Inside the expression above,
		we have several operands:
	</p>
	<figure>
		<div>
			<p><var>2</var></p>
			<p><var>(* 3 4)</var></p>
			<p><var>(- (+ 1 2) 3)</var></p>
		</div>
	</figure>
	<p>
		These are all subexpressions. The second and third subexpressions
		themselves contain further subexpressions. How does racket interpret
		the overall expression?
	</p>
	<p>
		The first key point is that the interpreter reads the expression from
		left to right. From left to right, the interpreter itself follows a
		procedure: (1) First evaluate the
		<i>subexpressions</i> (reduce the operands to values); (2) Second,
		apply the procedure that is the value of the most leftmost
		subexpression (the operator) to the arguments that are the values of
		other subexpressions (the operands). In other words:
	</p>
	<figure>
		<ol>
			<li>Reduce the operands to values;</li>
			<li>then apply the left-most operator to the values.</li>
		</ol>
	</figure>
	<p>
		Thus, in the expression above, racket first looks at
		<var>2</var>. It evaluates <var>2</var> to <var>2</var> and moves to
		next subexpression. It sees <var>(* 3 2)</var>. racket evalues this
		subexpression to a value. It evaluates <var>3</var> to <var>3</var>,
		and <var>2</var> to <var>2</var>, and applies the the value of the
		left-most operator, <var>*</var>, evaluating the subexpression to
		<var>6</var>. Then goes to the next subexpression:
		<var>(- (+ 1 3) 3)</var>. It sees the first operand,
		<var>(+ 1 2)</var>, and begins evaluating. It evaluates <var>1</var> to
		<var>1</var> and <var>2</var> to <var>2</var>, and applies the value of
		the left-most operator, <var>+</var>. The subexpression reduces to
		<var>3</var>. Then it goes to the next subexpression, <var>3</var>, and
		evaluates it to <var>3</var>. Then it applies the left-most operator,
		<var>-</var>. Thus, the overall subexpression evaluates to
		<var>0</var>. racket now has the all the operands evaluated:
		<var>2</var>, <var>12</var>, and <var>0</var>. It applies the value of
		the left most operator, <var>+</var>. Therefore, the entire expression
		returns <var>14</var>. Putting it all together:
	</p>
	<pre class="language-scheme"><code>
		(+ 2 (* 3 4) (- (+ 1 2) 3))
		(+ 2 12 (- (+ 1 2) 3))
		(+ 2 12 (- 3 3))
		(+ 2 12 0)
		14
	</code></pre>
	<p>The general intuition: Left to right, inside to outside.</p>
	<p>
		What does this imply? To evaluate a combination, the interpreter must
		first evaluate each <i>element</i> in the combination. This shows us
		that evaluation is a <i>recursive</i> process &mdash; one of its steps
		requires invoking itself. To illustrate, the following code:
	</p>
	<pre class="language-scheme"><code>
		(* (+ 9 (* 4 6))
			(+ 1 3 6))
	</code></pre>
	<pre class="language-bash"><code>
		330
	</code></pre>
	<p>can be written as an <i>expression tree</i>:</p>
	<figure>
		<img
			src="{% static 'images/expression_tree.svg' %}"
			alt="expression tree"
			loading="lazy"
			class="eighty-p"
		/>
	</figure>
	<p>
		From the diagram, we can see that in each node, there is an operator or
		operand. Each node is one of two kinds: either (a) a
		<i>branch node</i> &mdash; a node with branches stemming; or (b) a
		<i>leaf node</i> &mdash; a node with no branches stemming. The leaf
		nodes are either operators or numbers. The values of each combination
		of operators and operands flow upwards, <i>combining</i> at higher and
		higher levels. This phenomenon is called <i>tree accumulation</i>.
	</p>
	<p>
		But what about the leaf nodes? Even if their primitive types, aren't
		they also evaluated? Yes, they are. To be precise, the tree above is
		incomplete. Further down the leaf nodes, there are additional
		evaluations. But, we, as the programmers, do not worry about those
		evaluations. They are only handled by the interpreter. The values of
		the numerals we typed are the numbers they name; the values of the
		primitive operators are the machine instruction sequences carrying out
		the operation; and the values of other names are the objects associated
		with those names in the environment.
	</p>
</section>

<section id="exception_to_the_evaluation_rule">
	<p>
		The evaluation rule does not apply to <var>define</var>. When we write
		<var>(define pi 3.14)</var>, <var>define</var> does not apply to two
		separate objects, <var>pi</var> and <var>3.14</var>. The very purpose
		of <var>define</var> is to bind <var>3.14</var> to <var>pi</var>. Thus,
		<var>define</var> is an exception to the evaluation rule.
	</p>
	<p>
		Such exceptions are called
		<i>special forms</i>. Each special form has an evaluation rule unique
		to that special form. The set of all the different kinds of expressions
		a language provides is called the language's <i>syntax</i>.
	</p>
</section>

<section id="exercises_evaluations">
	<p>
		<span class="exh">Exercise.</span> For each expression in the sequence
		below, what is the result printed by the interpreter in response to
		each expression? Assume the sequence is evaluated in the order
		presented:
	</p>
	<pre class="language-scheme"><code>
		10
		(+ 5 3 4)
		(- 9 1)
		(/ 6 2)
		(+ (* 2 4) (- 4 6))
		(define a 3)
		(define b (+ a 1))
		(+ a b (* a b))
		(= a b)
		(if (and (> b a) (< b (* a b)))
			b
			a)
		(cond ((= a 4) 6)
				((= b 4) (+ 6 7 a))
				(else 25))
		(+ 2 (if (> b a) b a))
		(* (cond ((> ab) a)
					((< a b) b)
					(else -1))
			(+ a 1))
	</code></pre>
	<details class="answer">
		<summary>Solution</summary>
		<pre class="language-scheme"><code>
			10 ;; print 10

			(+ 5 3 4) ;; print 12

			(- 9 1) ;; print 8

			(/ 6 2) ;; print 3

			(+ (* 2 4) (- 4 6)) ;; print 6
			
			(define a 3)

			(define b (+ a 1))

			;; a = 3, b = 3 + 1 = 4
			;; (3) + (4) + (12) = 19
			;; print 19
			(+ a b (* a b))

			;; a = 3, b = 4
			;; 3 is not equal to 4
			;; print #false
			(= a b)

			;; a = 3, b = 4
			;; 4 > 3 and 4 < 12? true
			;; print b (the consequent):
				;; print 4
			(if (and (> b a) (< b (* a b)))
				b
				a)

			;; a = 3, b = 4
			;; a = 4? false
			;; b = 4? true
			;; print 6 + 7 + 3:
				;; print 16
			(cond ((= a 4) 6)
					((= b 4) (+ 6 7 a))
					(else 25))
			
			;; a = 3, b = 4
			;; 4 > 3? true
			;; return 4
			;; print 2 + 4:
				;; print 6
			(+ 2 (if (> b a) b a))

			;; a = 3, b = 4
			;; 3 > 4? false
			;; 3 < 4? true
			;; return 4
			;; print 4 * (3 + 1) = 4 * 4:
				;; print 16
			(* (cond ((> a b) a)
						((< a b) b)
						(else -1))
				(+ a 1))
		</code></pre>
	</details>
	<p>
		<span class="exh">Exercise.</span> Translate the following into prefix
		form:
	</p>
	<figure>
		<div>
			<p>
				${\dfrac{5 + 4 + (2 - (3 - (6 + \frac{4}{5})))}{3(6 - 2)(2 - 7)}}$
			</p>
		</div>
	</figure>
	<details class="answer">
		<summary>Solution</summary>
		<pre class="language-scheme"><code>
			(/ (+ 5 
					4 
					(- 2 
						(- 3 
							(+ 6 
								(/ 4 5)))))
				(* 3 
					(- 6 2) 
					(- 2 7)))
		</code></pre>
		<pre class="language-bash"><code>
			-0.246
		</code></pre>
	</details>
	<p>
		<span class="exh">Exercise.</span> Define a procedure that takes three
		numbers as arguments and returns the sum of the squares of the two
		larger numbers.
	</p>
	<details class="answer">
		<summary>Solution</summary>
		<pre class="language-scheme"><code>
			(define (square num) 
				(* num num))
			(define (sum-of-squares x y z)
				(+ (square x) (square y) (square z)))
		</code></pre>
	</details>
	<p>
		<span class="exh">Exercise.</span> The model of evaluation allows us to
		write combinations whose operators are compound expressions. How does
		this procedure behave:
	</p>
	<pre class="language-scheme"><code>
		(define (a-plus-abs-b a b)
			((if (> b 0) + -) a b))
	</code></pre>
	<details class="answer">
		<summary>Solution</summary>
		<p>
			If ${b}$ is positive, then the expression
			<var>(if (> b 0) + -)</var> evaluates to <var>+</var>. I.e., ${a +
			b.}$ Otherwise, the expression evaluates to ${a - b.}$ This
			effectively computes ${a + \lvert b \rvert.}$
		</p>
	</details>
	<p>
		<span class="exh">Exercise.</span> Ben attempts to determine whether
		his interpreter uses applicative order or normal order evaluation. To
		do so, he writes the following procedures:
	</p>
	<pre class="language-scheme"><code>
		(define (p) (p))
		(define (test x y)
			(if (= x 0) 0 y))
	</code></pre>
	<p>What behavior will Ben observe when he evaluates the following:</p>
	<pre class="language-scheme"><code>
		(test 0 (p))
	</code></pre>
	<details class="answer">
		<summary>Solution</summary>
		<p>
			In applicative-order evaluation, we evaluate all of the arguments
			entirely then apply:
		</p>
		<pre class="language-pseudo"><code>
			(test 0 (p))
			(if (= 0 0) 0 (p))
			(if (= 0 0) 0 (p))
		</code></pre>
		<p>
			Here, the evaluation will never terminate because
			<var>(p)</var> will always keep expanding to itself.
		</p>
		<p>In normal-order evaluation, we evaluate as we go.</p>
		<pre class="language-pseudo"><code>
			(test 0 (p))
			(if (= x 0) 0 (p))
			(if (#true) 0 (p))
			0
		</code></pre>
		<p>
			With normal-order evaluation, Ben will see an output of
			<var>0</var>.
		</p>
	</details>
</section>

<section id="strings_in_racket">
	<h4>Strings</h4>
	<p>
		In racket, strings are delimited with double quotes. Strings themselves
		are expressions with values, just as numbers are expressions with
		values:
	</p>
	<pre class="language-scheme"><code>
		"Hello world!"
	</code></pre>
	<pre class="language-bash"><code>
		"Hello world!"
	</code></pre>
	<p>
		Like other programming languages, we can
		<i>concatenate</i> strings; i.e., put them together:
	</p>
	<pre class="language-scheme"><code>
		(string-append "Goodbye" " " "world!")
	</code></pre>
	<pre class="language-bash"><code>
		"Goodbye world!"
	</code></pre>
	<p>
		We can also obtain the length of a string with
		<var>string-length</var>:
	</p>
	<pre class="language-scheme"><code>
		(string-length "ney")
	</code></pre>
	<pre class="language-bash"><code>
		3
	</code></pre>
	<p>If we want to isolate a substring inside the string:</p>
	<pre class="language-scheme"><code>
		(substring "Goodbye" 0 4)
	</code></pre>
	<pre class="language-bash"><code>
		"Good"
	</code></pre>
	<p>
		<var>substring</var> isolates the substring defined the string's index
		of first number (in this case <var>0</var>) and the index at the second
		number minus 1 (in this case <var>4</var>, so the substring's last
		character is the the character at the string's index 3). We minus one
		because the first index starts at <var>0</var>:
	</p>
	<pre class="language-scheme"><code>
		(substring "01234" 0 3)
	</code></pre>
	<pre class="language-bash"><code>
		"012"
	</code></pre>
	<p>
		Zero-based indexing is the most common source of
		<i>off-by-one errors</i> &mdash; failing to take account for an
		additional element in the sequence.
	</p>
	<p>
		<span class="exh">Exercise.</span> Concatenate the strings defined
		below with a space separating them:
	</p>
	<pre class="language-scheme"><code>
		(define prefix "Mr.")
		(define suffix "Holmes")
	</code></pre>
	<details class="answer">
		<summary>Solution</summary>
		<pre class="language-scheme"><code>
			(define prefix "Mr.")
			(define suffix "Holmes")
			(string-append prefix " " suffix)
		</code></pre>
		<pre class="language-bash"><code>
			"Mr. Holmes"
		</code></pre>
	</details>
</section>

<section id="substitution_model">
	<h2>How does the interpreter evaluate compound procedures?</h2>
	<p>
		The interpreter evaluates compound procedures the same way it evaluates
		primitive procedures. Recall that with primitive procedures, the
		interpreter evaluates the elements of the combination, then applies the
		procedure (the value of the combination's operator) to the arguments
		(the values of the combination's operands). The same process applies to
		compound procedures: The interpreter evaluates the
		<var>⟨body⟩</var> with each <var>⟨formal parameter⟩</var> replaced by
		the argument passed.
	</p>
	<p>Consider, for example, this compound procedure:</p>
	<pre class="language-scheme"><code>
		(define (square x)
			(* x x))
		(define (sum-of-squares x y) 
			(+ (square x) (square y)))
		(define (func n) 
			(sum-of-squares (+ n 1) (* n 2)))
		
		(func 3)
	</code></pre>
	<pre class="language-bash"><code>
		52
	</code></pre>
	<p>
		Like primitive procedures, we can see how the compound procedure
		<var>(func 3)</var> with the <i>substitution model</i>:
	</p>
	<figure>
		<pre class="language-pseudo"><code>
			(f 3)
			(sum-of-squares (+ n 1) (+ n 2))
			(sum-of-squares (+ 3 1) (* 3 2))
			(+ (square 4) (square 6))
			(+ (* 4 4) (* 6 6))
			(+ (16) (36))
			52
		</code></pre>
	</figure>
	<p>
		Thus, the single statement
		<var>(func 3)</var> represents this entire expression tree:
	</p>
	<figure>
		<img
			src="{% static 'images/func_3.svg' %}"
			alt="func 3"
			loading="lazy"
			class="eighty-p"
		/>
	</figure>
	<p>
		Putting it all together, the substitution model for evaluating
		functions is the following:
	</p>
	<figure>
		<ol>
			<li>
				First reduce the operands to their respective values (the arguments
				passed in).
			</li>
			<li>
				Second, replace the function call with the body of the function
				where every occurence of a parameter is replaced by its
				corresponding argument.
			</li>
		</ol>
	</figure>
	<p>One more example for clarity:</p>
	<figure>
		<pre class="language-pseudo"><code>
			(define (summate a b)
				(+ a b))
			
			(summate (+ 1 3) 5)
			(summate 4 5)
			(+ a b)
			(+ 4 5)
			9
		</code></pre>
	</figure>
</section>

<section id="applicative_v_normal_order">
	<h4>Order: Applicative v. Normal</h4>
	<p>There are two ways to evaluate combinations:</p>
	<div class="col2">
		<ol>
			<p><b>Applicative-Order Evaluation</b></p>
			<li>Evaluate the combination's subexpressions.</li>
			<li>
				Apply the procedure that is the value of the leftmost subexpression
				(the operator) to the arguments that are the values of the other
				subexpressions (the operands).
			</li>
		</ol>
		<ol>
			<p><b>Normal-Order Evaluation</b></p>
			<li>
				Substitute operand expressions for paramters until only primitive
				operators remain.
			</li>
			<li>Then perform the evaluation.</li>
		</ol>
	</div>
	<p>
		The <i>applicative-order evaluation</i>, or &#8220;evaluate the
		arguments and then apply,&#8221; is the evaluation method we've seen so
		far, and is what racket uses when evaluating combinations.
		<i>Normal-order evaluation</i>, or &#8220;fully expand and then
		reduce,&#8221; is an alternative method used by other languages. We can
		see how these two evaluation methods are different by comparing their
		applications:
	</p>
	<pre class="language-pseudo"><code>
		;; normal-order evaluation

		(double (average 2 4))
		(plus (average 2 4) (average 2 4))
		(plus (divide (plus 2 4) 2) (average 2 4))
		(plus 3 (average 2 4))
		(plus 3 (divide (plus 2 4) 2))
		(plus 3 (divide 6 2))
		(plus 3 3)
		6
	</code></pre>
	<pre class="language-pseudo"><code>
		applicative-order evaluation

		double (average 2 4)
		double (divide (plus 2 4) 2)
		double (divide 6 2)
		double 3
		plus 3 3
		6
	</code></pre>
	<p>
		Notice that in
		<i>normal-order evaluation</i>, all of the operand expressions are
		expanded first, and only after everything is expanded does the
		interpreter evaluate. Contrast this with
		<i>applicative-order evaluation</i>, where the interpreter
		evaluates-then-applies.
	</p>
</section>

<section id="square_roots_newtons_method">
	<h4>Example Procedure: Newton's Method</h4>
	<p>
		Newton's Method provides that we can compute square roots by using
		successive approximations. We start with some guess ${g}$ as the value
		of ${\sqrt{r}.}$ Then, by averaging ${g}$ with ${r/g,}$ we can obtain
		better guesses. For example, ${\sqrt{2}}$ would compute as follows
		(where ${g}$ is the guess, ${r}$ is the radicand, and ${\text{avg}}$ is
		the average).
	</p>
	<figure class="table">
		<table class="computation">
			<thead>
				<th>${g}$</th>
				<th>${r/g}$</th>
				<th>${\text{avg}}$</th>
			</thead>
			<tbody>
				<tr>
					<td>${1}$</td>
					<td>${\dfrac{2}{1} = 2}$</td>
					<td>${\dfrac{2 + 1}{2} = 1.5}$</td>
				</tr>
				<tr>
					<td>${1.5}$</td>
					<td>${\dfrac{2}{1.5} = 1.3333}$</td>
					<td>${\dfrac{1.3333 + 1.5}{2} = 1.4167}$</td>
				</tr>
				<tr>
					<td>${1.4167}$</td>
					<td>${\dfrac{2}{1.4167} = 1.4118}$</td>
					<td>${\dfrac{1.4167 + 1.4118}{2} = 1.4142}$</td>
				</tr>
				<tr>
					<td>${\vdots}$</td>
					<td>${\vdots}$</td>
					<td>${\vdots}$</td>
				</tr>
			</tbody>
		</table>
	</figure>
	<p>
		We can see that approximations get better with each successive average.
		We can encapsulate this algorithm with a procedure. First, we need two
		values: ${r,}$ the radicand, and ${g,}$ the guess. Second, we must
		think about how this algorithm works. If ${g}$ is good enough, then we
		are done. Otherwise, we repeat the process with the improved ${g}$.
	</p>
	<pre class="language-scheme"><code>
		(define (sqrt-iter guess r)
			(if (good-enough? guess r)
				guess
				(sqrt-iter (improve guess x) x)))
	</code></pre>
	<p>
		Now, we have to define what
		<var>good-enough?</var> and <var>improve</var> mean. Again, we can
		define these as procedures:
	</p>
	<pre class="language-scheme"><code>
		(define (improve guess x)
			(average guess (/ x guess)))
	</code></pre>
	<p>Now we need to define <var>average</var>, again as a procedure:</p>
	<pre class="language-scheme"><code>
		(define (average x y)
			(/ (+ x y) 2))
	</code></pre>
	<p>
		Next, we must define <var>good-enough?</var>. Once more, a procedure.
		Here, we improve our answer, ${g,}$ to the point where ${g^2 - r^2,}$
		where ${r}$ is the radicand, evaluates to less a predetermined
		<b>tolerance value</b>:
	</p>
	<pre class="language-scheme"><code>
		(define (good-enough? guess x)
			(< (abs (- (square guess) x)) 0.001))
	</code></pre>
	<p>And of course, we should define <var>square</var>:</p>
	<pre class="language-scheme"><code>
		(define (square x) (* x x))
	</code></pre>
	<p>Finally, we need a way to get started:</p>
	<pre class="language-scheme"><code>
		(define (sqrt x)
			(sqrt-iter 1.0 x))
	</code></pre>
	<p>Putting it all together, we can begin testing:</p>
	<pre class="language-scheme"><code>
		(define (sqrt-iter guess x)
			(if (good-enough? guess x)
				guess
				(sqrt-iter (improve guess x) x)))

		(define (improve guess x)
			(average guess (/ x guess)))

		(define (average x y)
			(/ (+ x y) 2))							

		(define (good-enough? guess x)
			(< (abs (- (square guess) x)) 0.001))

		(define (square x) 
			(* x x))

		(define (sqrt x)
			(sqrt-iter 1.0 x))
		
		(sqrt 9)
		(sqrt (+ 80 1))
		(sqrt (+ (sqrt 25) (sqrt 16)))
		(square (sqrt 1000))
	</code></pre>
	<pre class="language-bash"><code>
		3.0000915541313801785305561...
		9.0000112987902160615926759...
		3.0000955248613037789308087...
		1000.0003699243660294780560755...
	</code></pre>
	<p>
		This implementation of Newton's Method is a perfect example of
		<b>abstraction</b> &mdash; breaking a problem into smaller pieces;
		constructing solutions to the smaller pieces; then bundling them up
		into a larger solution that abstracts away the technical details.
	</p>
	<figure>
		<img
			src="{% static 'images/square_root_procedure_tree.svg' %}"
			alt="expression tree"
			class="forty-p"
			loading="lazy"
		/>
	</figure>
	<p>
		A detail that should not matter to the procedure user is the
		implementer's choice of names for the procedure's formal parameters.
		For example, thse two procedures should not be distinguishable:
	</p>
	<pre class="language-scheme"><code>
		(define (square x) (* x x))
		(define (square y) (* y y))
	</code></pre>
	<p>
		As a consequence, parameter names in procedures must be local to the
		procedure's body. Otherwise, the interpreter would be confused when a
		parameter name <var>x</var> is used in one function, and another
		parameter name <var>x</var> is used in another function.
	</p>
	<p>
		Because parameters names are local to the procedure's body, they are
		called
		<b>bound variables</b> &mdash; the procedure definition
		<i>binds</i> the formal parameters. If a variable is not bound, we call
		<i>free</i> (a <b>free variable</b>). The set of expressions where a
		binding defines a name is called the <b>scope</b> of that name. For
		example, in procedures, the formal parameter's scope is the procedure's
		body. When change a free variable to a bound variable, we are said to
		have <i>captured</i> the free variable.
	</p>
</section>

<section id="block_structuring">
	<h4>Block Structure</h4>
	<p>So far, the square root procedure appears as such:</p>
	<pre class="language-scheme"><code>
		(define (sqrt x)
			(sqrt-iter 1.0 x))

		(define (sqrt-iter guess x)
			(if (good-enough? guess x)
				guess
				(sqrt-iter (improve guess x) x)))

		(define (improve guess x)
			(average guess (/ x guess)))

		(define (average x y)
			(/ (+ x y) 2))							

		(define (good-enough? guess x)
			(< (abs (- (square guess) x)) 0.001))

		(define (square x) 
			(* x x))
	</code></pre>
	<p>
		All that really matters here, however, is the square root procedure.
		The lower level details simply clutter the program. A better structure
		would be to <i>localize</i> all of the procedures that
		<var>sqrt</var> needs, called <i>auxiliary procedures</i>. Thus:
	</p>
	<pre class="language-scheme"><code>
	(define (sqrt x)
		(define (sqrt-iter guess x)
			(if (good-enough? guess x)
				guess
				(sqrt-iter (improve guess x) x)))
		(define (improve guess x)
			(average guess (/ x guess)))
		(define (average x y)
			(/ (+ x y) 2))							
		(define (good-enough? guess x)
			(< (abs (- (square guess) x)) 0.001))
		(define (square x) 
			(* x x))	
		(sqrt-iter 1.0 x))
	</code></pre>
	<p>
		Nesting definitions in this manner is called
		<b>block structure</b>. We can, however improve the structure. Notice
		that <var>x</var> is bound to <var>sqrt</var>, <var>good-enough?</var>,
		<var>improve</var>, and <var>sqrt-iter</var>. Because <var>x</var> is
		bound to <var>sqrt</var>, it is a free variable for the other internal
		definitions, so we do not need to pass it explicitly as a parameter for
		the internal definitions:
	</p>
	<pre class="language-scheme"><code>
		(define (sqrt x)
			(define (sqrt-iter guess)
				(if (good-enough? guess)
					guess
					(sqrt-iter (improve guess))))
			(define (improve guess)
				(average guess (/ x guess)))
			(define (average x guess)
				(/ (+ x guess) 2))
			(define (good-enough? guess)
				(< (abs (- (square guess) x)) 0.001))
			(define (square x)
				(* x x))
			(sqrt-iter 1.0))
		</code></pre>
</section>

<section id="higher_order_functions">
	<h3>Higher-Order Functions</h3>
	<p>
		A good programming ability allows us to take an abstraction like a
		function, name the abstraction, and use that name as if it were an
		operator to perform other computations or build other abstractions.
		Functions provide that ability.
	</p>
	<p>
		The functions we have seen so far have used primarily existing numbers
		or other primitve data types. Functions, however, can take a function
		as input or return functions as output. This is a powerful tool.
	</p>
	<p>Here are three functions:</p>
	<pre class="language-scheme"><code>
		(define (sum-integers a b)
			(if (> a b) 
				0 
				(+ a (sum-integers (+ a 1) b))))
	</code></pre>
	<p>
		The function above simply computes integers in the range ${[a, b].}$
	</p>
	<p>
		This function computes the cubes of the integers in the range ${[a,
		b].}$
	</p>
	<pre class="language-scheme"><code>
		(define (sum-cubes a b)
			(if (> a b) 
				0 
				(+ (cube a) (sum-cubes (+a 1) b))))
	</code></pre>
	<p>
		Finally, this function computes the sum of a sequence of terms in the
		series ${\dfrac{1}{1 \cdot 3} + \dfrac{1}{5 \cdot 7} + \dfrac{1}{9
		\cdot 11} + \ldots }$ (this converges to ${\dfrac{\pi}{8}}$).
	</p>
	<pre class="language-scheme"><code>
		(define (pi-sum a b)
			(if (> a b) 
				0
				(+ (/ 1.0 (* a (+ a 2))) 
					(pi-sum (+ a 4) b))))
	</code></pre>
	<p>Notice that all three functions above have a common structure:</p>
	<figure>
		<pre class="language-pseudo"><code>
			(define (⟨name⟩ a b)
				(if (> a b)
					0
					(+ (⟨term⟩ a)
						(⟨name⟩ (⟨next⟩ a) b))))
		</code></pre>
	</figure>
	<p>
		Anytime we see a repetitious pattern like this, that is our cue:
		There's an abstraction lurking. Here, it is a simple mathematical
		summation of a series:
	</p>
	<figure>
		<div>
			<p>${\displaystyle\sum_{n=a}^{b} f(n) = f(a) + \ldots + f(b)}$</p>
		</div>
	</figure>
	<p>
		Summation notation allows us to focus purely on how the terms summate,
		rather than on the individual terms themselves. Similarly, we can write
		a function that provides the same type of abstraction:
	</p>
	<pre class="language-scheme"><code>
		(define (sum term a next b)
			(if (> a b)
				0
				(+ (term a)
					(sum term (next a) next b))))
	</code></pre>
</section>

{% endblock %}
