{% extends '../layout.html' %} {% load static %} {% block description %}
<meta name="description" content="Introduction to Racket" />
{% endblock %} {% block title %}
<title>Racket Basics</title>
{% endblock %} {% block content %}
<h1>Racket Basics</h1>
<section id="intro">
	<p>
		<span class="drop">R</span>acket is the modern successor to Scheme, and
		further up, Common Lisp. It's a dialect of Lisp, preserving much of Scheme's
		distinctive features while adding several twists of its own. In these
		materials, we will use Racket for the most part, but will occassionally use
		Scheme. This will be made apparent by the first line of our code demos. For
		Racket programs, we begin every program with the line:
	</p>
	<pre class="language-scheme"><code>
		#lang racket
	</code></pre>
	<p>
		If that line isn't shown, it's assumed to be a Racket program. In contrast,
		we will begin every Scheme program with the line:
	</p>
	<pre class="language-scheme"><code>
		#lang scheme
	</code></pre>
	<p>
		Moreover, every Racket file &mdash; also called a Racket
		<span class="italicsText">module</span> &mdash; ends with the extension
		<span class="monoText">.rkt</span>, while every Scheme module ends with the
		extension <span class="monoText">.scm</span>. With these basics out of the
		way, we can proceed to the core constructs.
	</p>
</section>

<section id="basics">
	<h2>Expressions</h2>
	<p>
		In investigating Racket &mdash; and really any other language for that
		matter &mdash; it's helpful to identify how the language forms the following
		constructs: (1) <span class="term">primitive expressions</span>: the
		language's simplest entities, (2)
		<span class="term">compound expressions</span>: expressions formed by
		combining other expressions, and (3) <span class="term">abstractions</span>:
		how expressions, primitive or compound, can be named and manipulated as
		units. As we've seen with other languages, each of these constructs are
		named and implemented in various ways. We turn our attention to how Racket
		approaches these constructs.
	</p>
	<section id="expressions">
		<h3>Simple Expressions</h3>
		<p>
			In Racket, the simplest data is the
			<span class="term">primitive expression</span>. The following are all
			examples:
		</p>
		<pre class="language-scheme"><code>
			134        ; an integer
			#b111      ; a binary number 
			#o111      ; an octal number
			#x111      ; a hexadecimal number
			3.14       ; a real number
			6.42e+10   ; a real number in scientific notation
			1/2        ; a rational
			1+4i       ; complex numbers
		</code></pre>
		<p>
			Notice that in Racket, comments are denoted with a semicolon. Each of
			these expressions have a <span class="term">type</span>. In Racket, there
			are several built-in datatypes. We address each in turn.
		</p>
	</section>

	<section id="number_type">
		<p>
			<span class="topic">Numbers.</span> As we saw above, Racket provides an
			extensive and formidable number type system. Unlike many other languages,
			Racket's number types resemble mathematics very closely. First, Racket
			provides a broad type called <span class="monoText">number</span>. All
			values of type <span class="monoText">number</span> are
			<span class="term">complex</span>. Next, some values of type
			<span class="monoText">complex</span> are values of type
			<span class="monoText">real</span>. Among the reals, there are the types
			<span class="monoText">zero</span>,
			<span class="monoText">positive</span>, and
			<span class="monoText">negative</span>. The one deviation from mathematics
			is that all values of type <span class="monoText">real</span> can be
			represented as type <span class="monoText">rational</span>, with a few key
			exceptions:
		</p>
		<ol>
			<li>
				<span class="monoText">+inf.0</span>, representing ${\texttt{+} \infty}$
			</li>
			<li>
				<span class="monoText">-inf.0</span>, representing ${\texttt{-} \infty}$
			</li>
			<li>
				<span class="monoText">+nan.0</span>, representing not-a-number (i.e., a
				value that is undefined or unrepresentable)
			</li>
		</ol>
		<p>
			We say &#8220;deviation&#8221; because Racket does have what might strike
			some as pecularities. For example, Racket provides a default value of
			<span class="monoText">pi</span>, which is considered a
			<span class="monoText">rational</span> type. Obviously, the constant ${\pi
			\notin \mathbb{Q}.}$ Just as well, however, we cannot represent all of an
			irrational number's fractional components. Racket's designers went with
			the more convenient approach, where everything that is not under one of
			the exceptions above is considered <span class="monoText">rational</span>.
			The other approach would be to have gone the Julia and Clojure routes,
			where the <span class="monoText">rational</span> datatype much more
			closely resembles mathematics (i.e., a subset of the reals).
		</p>
		<p>
			Within the <span class="monoText">rational</span> type, some values can be
			represented as values of type <span class="monoText">integer</span>. And
			among the integers, there are the types
			<span class="monoText">odd</span> and <span class="monoText">even</span>.
			And within all of these types, or orthogonal to these types, each value of
			a number type can be <span class="monoText">exact</span> or
			<span class="monoText">inexact</span>. These types do exactly what they
			sound like. <span class="monoText">inexact</span> number types are
			implemented as flonums (the equivalent of a
			<span class="monoText">double</span> in languages like Java) or as
			single-flonums (the equivalent of a <span class="monoText">float</span>).
			Everything else falls under <span class="monoText">exact</span> (except
			for the NaN and infinity types listed earlier). Moreover, all
			<span class="monoText">inexact</span> number values can be coerced to
			<span class="monoText">exact</span> values.
		</p>
		<p>
			<span class="topic">Bytes.</span> One additional number type is the
			<span class="monoText">byte</span> datatype, which represents an exact
			integer between 0 and 255 inclusive. We will not be seeing much of this
			type in the materials, but we present it here for comprehensiveness.
		</p>
	</section>

	<section id="boolean_type">
		<p>
			<span class="topic">Booleans.</span> Racket provides a
			<span class="monoText">boolean</span> datatype. In Racket, values of type
			<span class="monoText">boolean</span> are represented as
			<span class="monoText">#t</span> (true) and
			<span class="monoText">#f</span> (false). This syntax directly follows
			from Scheme. Scheme itself deviates from Lisp. In Lisp, true is
			represented with <span class="monoText">T</span> and false with
			<span class="monoText">NIL</span>.
		</p>
		<pre class="language-scheme"><code>
			#T     ; another way to write true
			#t     ; true, the preferred way
			#F     ; another way to write false
			#f     ; false, the preferred way
		</code></pre>
	</section>

	<section id="characters_and_strings">
		<p>
			<span class="topic">Characters.</span> Racket provides the data type
			<span class="monoText">char</span>, which is equivalent to the
			<span class="monoText">char</span> datatype in languages like Java and
			C++. In Racket, a <span class="monoText">char</span> value is a Unicode
			scalar value. This means that every value of type
			<span class="monoText">char</span> is inherently an unsigned integer. In
			Racket, values of type <span class="monoText">char</span> are indicated
			with the syntax <span class="monoText">#\${v}$</span>, where ${v}$ is some
			unicode character.
		</p>
		<pre class="language-scheme"><code>
			#\A         ; the character 'A'
			#\1         ; the character '1'
			#\space     ; the whitespace character
			#\newline   ; the new line character
		</code></pre>
	</section>

	<section id="strings">
		<p>
			<span class="topic">Strings.</span> As is the case with languages like
			Java, the datatype <span class="monoText">string</span> in Racket is a
			static, or fixed-length, array of
			<span class="monoText">char</span> values (characters), delimited with
			double quotes. And because they are arrays of
			<span class="monoText">char</span> values, Racket strings support Unicode.
			Importantly, strings, when written directly as expressions, are immutable
			by default. There are other strings, however, that are mutable. We will
			see these strings later, but for now, assume that strings are immutable by
			default in Racket.
		</p>
		<pre class="language-scheme"><code>
			"3.14"     ; the string "3.14"
			"Racket"   ; the string "Racket" 
		</code></pre>
		<p>
			Like the <span class="monoText">byte</span> type with numbers, there is a
			<span class="monoText">byte string</span> datatype. This datatype is
			similar to <span class="monoText">string</span>, with a few key
			differences: (1) the string is an array of
			<span class="italicsText">bytes</span> rather than characters, and (2) the
			strings employ ASCII encoding rather than Unicode.
		</p>
		<p>
			There are a few more datatypes to be addressed, but for now, the datatypes
			presented above more than suffice for the next few sections. We now turn
			to several other basic constructs necessary for our future demonstrations.
		</p>
	</section>

	<section id="compound_expressions">
		<h3>Compound Expressions</h3>
	</section>
</section>

<section id="definitions">
	<h2>Definitions</h2>
	<p>
		Every Racket file contains a collection of
		<span class="term">definitions</span>. These are akin to
		<span class="italicsText">bindings</span> in other languages. They are
		essentially extensions of the top-level environment. For example:
	</p>
	<pre class="language-scheme"><code>
		(define x 17)
	</code></pre>
	<p>
		binds an identifier <span class="monoText">x</span> to the value
		<span class="monoText">17</span>.
	</p>
</section>

{% endblock %}
