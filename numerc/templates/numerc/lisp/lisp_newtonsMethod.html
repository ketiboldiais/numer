{% extends '../layout.html' %} {% load static %} {% block content %}
<section id="square_roots_newtons_method">
	<h4>Example Procedure: Newton's Method</h4>
	<p>
		Newton's Method provides that we can compute square roots by using
		successive approximations. We start with some guess ${g}$ as the value of
		${\sqrt{r}.}$ Then, by averaging ${g}$ with ${r/g,}$ we can obtain better
		guesses. For example, ${\sqrt{2}}$ would compute as follows (where ${g}$ is
		the guess, ${r}$ is the radicand, and ${\text{avg}}$ is the average).
	</p>
	<figure class="table">
		<table class="computation">
			<thead>
				<th>${g}$</th>
				<th>${r/g}$</th>
				<th>${\text{avg}}$</th>
			</thead>
			<tbody>
				<tr>
					<td>${1}$</td>
					<td>${\dfrac{2}{1} = 2}$</td>
					<td>${\dfrac{2 + 1}{2} = 1.5}$</td>
				</tr>
				<tr>
					<td>${1.5}$</td>
					<td>${\dfrac{2}{1.5} = 1.3333}$</td>
					<td>${\dfrac{1.3333 + 1.5}{2} = 1.4167}$</td>
				</tr>
				<tr>
					<td>${1.4167}$</td>
					<td>${\dfrac{2}{1.4167} = 1.4118}$</td>
					<td>${\dfrac{1.4167 + 1.4118}{2} = 1.4142}$</td>
				</tr>
				<tr>
					<td>${\vdots}$</td>
					<td>${\vdots}$</td>
					<td>${\vdots}$</td>
				</tr>
			</tbody>
		</table>
	</figure>
	<p>
		We can see that approximations get better with each successive average. We
		can encapsulate this algorithm with a procedure. First, we need two values:
		${r,}$ the radicand, and ${g,}$ the guess. Second, we must think about how
		this algorithm works. If ${g}$ is good enough, then we are done. Otherwise,
		we repeat the process with the improved ${g}$.
	</p>
	<pre class="language-scheme"><code>
		(define (sqrt-iter guess r)
			(if (good-enough? guess r)
				guess
				(sqrt-iter (improve guess x) x)))
	</code></pre>
	<p>
		Now, we have to define what <span class="monoText">good-enough?</span> and
		<span class="monoText">improve</span> mean. Again, we can define these as
		procedures:
	</p>
	<pre class="language-scheme"><code>
		(define (improve guess x)
			(average guess (/ x guess)))
	</code></pre>
	<p>
		Now we need to define <span class="monoText">average</span>, again as a
		procedure:
	</p>
	<pre class="language-scheme"><code>
		(define (average x y)
			(/ (+ x y) 2))
	</code></pre>
	<p>
		Next, we must define <span class="monoText">good-enough?</span>. Once more,
		a procedure. Here, we improve our answer, ${g,}$ to the point where ${g^2 -
		r^2,}$ where ${r}$ is the radicand, evaluates to less a predetermined
		<span class="term">tolerance value</span>:
	</p>
	<pre class="language-scheme"><code>
		(define (good-enough? guess x)
			(< (abs (- (square guess) x)) 0.001))
	</code></pre>
	<p>And of course, we should define <span class="monoText">square</span>:</p>
	<pre class="language-scheme"><code>
		(define (square x) (* x x))
	</code></pre>
	<p>Finally, we need a way to get started:</p>
	<pre class="language-scheme"><code>
		(define (sqrt x)
			(sqrt-iter 1.0 x))
	</code></pre>
	<p>Putting it all together, we can begin testing:</p>
	<pre class="language-scheme"><code>
		(define (sqrt-iter guess x)
			(if (good-enough? guess x)
				guess
				(sqrt-iter (improve guess x) x)))

		(define (improve guess x)
			(average guess (/ x guess)))

		(define (average x y)
			(/ (+ x y) 2))							

		(define (good-enough? guess x)
			(< (abs (- (square guess) x)) 0.001))

		(define (square x) 
			(* x x))

		(define (sqrt x)
			(sqrt-iter 1.0 x))
		
		(sqrt 9)
		(sqrt (+ 80 1))
		(sqrt (+ (sqrt 25) (sqrt 16)))
		(square (sqrt 1000))
	</code></pre>
	<pre class="language-bash"><code>
		3.0000915541313801785305561...
		9.0000112987902160615926759...
		3.0000955248613037789308087...
		1000.0003699243660294780560755...
	</code></pre>
	<p>
		This implementation of Newton's Method is a perfect example of
		<span class="term">abstraction</span> &mdash; breaking a problem into
		smaller pieces; constructing solutions to the smaller pieces; then bundling
		them up into a larger solution that abstracts away the technical details.
	</p>
	<figure>
		<img
			src="{% static 'images/square_root_procedure_tree.svg' %}"
			alt="expression tree"
			class="forty-p"
			loading="lazy"
		/>
	</figure>
	<p>
		<span class="topic">Local Names.</span> A detail that should not matter to
		the procedure user is the implementer's choice of names for the procedure's
		formal parameters. For example, thse two procedures should not be
		distinguishable:
	</p>
	<pre class="language-scheme"><code>
		(define (square x) (* x x))
		(define (square y) (* y y))
	</code></pre>
	<p>
		As a consequence, parameter names in procedures must be local to the
		procedure's body. Otherwise, the interpreter would be confused when a
		parameter name <span class="monoText">x</span> is used in one function, and
		another parameter name <span class="monoText">x</span> is used in another
		function.
	</p>
	<p>
		Because parameters names are local to the procedure's body, they are called
		<span class="term">bound variables</span> &mdash; the procedure definition
		<span class="italicsText">binds</span> the formal parameters. If a variable
		is not bound, we call <span class="italicsText">free</span> (a
		<span class="term">free variable</span>). The set of expressions where a
		binding defines a name is called the <span class="term">scope</span> of that
		name. For example, in procedures, the formal parameter's scope is the
		procedure's body. When change a free variable to a bound variable, we are
		said to have <span class="italicsText">captured</span> the free variable.
	</p>
</section>
{% endblock %}
