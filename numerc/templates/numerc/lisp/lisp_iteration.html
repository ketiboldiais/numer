{% extends '../layout.html' %} {% load static %} {% block content %}
<section id="linear_recursion_and_iteration">
	<h3>Procedures and their Processes</h3>
	<p>
		In this section, we explore two different procedures aimed at performing the
		same computation. One procedure uses
		<span class="italicsText">linear recursion</span>, the other
		<span class="italicsText">iteration</span>. These processes are broadly
		referred to as <span class="italicsText">local evolutions</span> &mdash; the
		computation evolves as the procedure executes.
	</p>
	<p>
		<span class="topic">Linear Recursion.</span> Recall the factorial function:
	</p>
	<figure class="math-display">
		<div>
			<p>
				${n! = n \cdot (n - 1) \cdot (n - 2) \cdot \ldots \cdot 3 \cdot 2 \cdot
				1}$
			</p>
		</div>
	</figure>
	<p>This definition is equivalent to:</p>
	<figure class="math-display">
		<div>
			<p>
				${n! = n \cdot [(n - 1) \cdot (n - 2) \cdot \ldots \cdot 3 \cdot 2 \cdot
				1]}$
			</p>
			<p>${\phantom{n!} = n \cdot (n-1)! }$</p>
		</div>
	</figure>
	<p>We also know that:</p>
	<figure class="math-display">
		<div>
			<p>1! = 1</p>
		</div>
	</figure>
	<p>
		From this data, we can construct a procedure. To compute the factorial:
		First, check if ${n = 1.}$ If ${n = 1,}$ then return 1. Otherwise, return
		the factorial of ${n - 1.}$ This procedure employs the process of
		<span class="italicsText">linear recursion</span>:
	</p>
	<pre class="language-scheme"><code>
		(define (factorial n)
			(if (= n 1)
				1
				(* n (factorial (- n 1)))))
	</code></pre>
	<p>
		We can use the substitution model to see how this procedure's computation
		evolves &mdash; suppose want to compute
		<span class="monoText">factorial 6</span>:
	</p>
	<figure class="math-display">
		<pre class="language-pseudo"><code>
			(factorial 6)
			(* 6 (factorial 5))
			(* 6 (* 5 (factorial 4)))
			(* 6 (* 5 (* 4 (factorial 3))))
			(* 6 (* 5 (* 4 (* 3 (factorial 2)))))
			(* 6 (* 5 (* 4 (* 3 (* 2 (factorial 1))))))
			(* 6 (* 5 (* 4 (* 3 (* 2 1)))))
			(* 6 (* 5 (* 4 (* 3 2))))
			(* 6 (* 5 (* 4 6)))
			(* 6 (* 5 24))
			(* 6 120)
			720
		</code></pre>
	</figure>
	<p>
		Another way to understand recursion is to envision the computer as a tiny
		dystopia. Inside the computer, there are millions of tiny people, and we
		dictate what jobs they must accomplish. Each person is an expert on a
		particular symbol, or part, of our program. We have experts on
		<span class="monoText">*</span>, experts on
		<span class="monoText">define</span>, experts on
		<span class="monoText">=</span>, experts on
		<span class="monoText">factorial</span>, etc. When we call
		<span class="monoText">(factorial 6)</span>, we called some person named
		Russ, who is an expert on evaluating
		<span class="monoText">(factorial 6)</span>. Now, as part of evaluating
		<span class="monoText">(factorial 6)</span>, Russ has to evaluate
		<span class="monoText">(factorial 5)</span>, but he's only an expert on
		<span class="monoText">(factorial 6)</span>, so he calls Julia, who is an
		expert on evaluating <span class="monoText">(factorial 5)</span>. As part of
		evaluating <span class="monoText">(factorial 5)</span>, Julia must evaluate
		<span class="monoText">(factorial 4)</span>, and to do that, she needs
		another expert, Obi. To evaluate
		<span class="monoText">(factorial 4)</span>, Obi must evaluate
		<span class="monoText">(factorial 3)</span>, and to do that, he has to call
		another expert, Keiko, who can evaluate
		<span class="monoText">(factorial 2)</span>. To evaluate
		<span class="monoText">(factorial 2)</span>, Keiko must call the expert on
		evaluating <span class="monoText">(factorial 1)</span>, Blaise. Blaise
		always knows the answer to <span class="monoText">(factorial 1)</span>: it's
		<span class="monoText">1</span>. Thus, Blaise hands his work product to
		Keiko, Keiko uses that work product and hands her work product to Obi, Obi
		uses that work product and hands his work product to Julia, Julia uses that
		work product to and hands her finished work to Russ, who uses that work
		product and computes <span class="monoText">(factorial 6)</span>.
	</p>
	<p>
		<span class="topic">Iteration.</span> In contrast, here is a procedure
		employing the process of <span class="italicsText">iteration</span> to
		compute ${n!}$: First, multiply 1 by 2, then multiply the result by 3, then
		4, 5, 6, etc. We keep doing so until we reach ${n.}$ This is essentially
		keeping a running product, along with a counter running from 1 to ${n.}$
		Visually, the counter and the product simultaneously change from one step to
		the next:
	</p>
	<figure class="math-display">
		<div>
			<p>
				${\texttt{counter} \times \texttt{product} \implies \texttt{product}}$
			</p>
			<p>${\texttt{counter} + \texttt{1} \implies \texttt{counter}}$</p>
		</div>
	</figure>
	<p>
		The result of ${n!}$ then is the value of
		<span class="monoText">product</span> once
		<span class="monoText">counter > ${n.}$</span>
	</p>
	<pre class="language-scheme"><code>
		(define (factorial n)
			(fact-iter 1 1 n))
		(define (fact-iter product counter max-count)
			(if (> counter max-count)
				product
				(fact-iter (* counter product)
								(+ counter 1)
								max-count)))
	</code></pre>
	<p>
		Once again, we can use the substitution model to think about how the
		computation evolves with the iterative procedure:
	</p>
	<figure class="math-display">
		<pre class="language-pseudo"><code>
			(factorial 6)
			(fact-iter 1 1 6)
			(fact-iter 1 2 6)
			(fact-iter 2 3 6)
			(fact-iter 6 4 6)
			(fact-iter 24 5 6)
			(fact-iter 120 6 6)
			(fact-iter 720 7 6)
			720
		</code></pre>
	</figure>
	<p>
		The procedures compute the same thing, but notice how different their shapes
		are. With linear recursion, the computation expands &mdash; building a chain
		of <span class="italicsText">deferred operations</span> &mdash; then
		contracts &mdash; the operations are performed. This is called a
		<span class="term">recursive process</span>, and it requires the interpreter
		to keep track of of the operations to be performed later down the line. More
		specifically, we call this linear recursion because the length of the chain
		of deferred operations (i.e., the amount of information that must be
		tracked) grows linearly with ${n.}$
	</p>
	<p>
		However, with iteration, the computation does not grow or shrink. At each
		step, the interpreter needs only track
		<span class="monoText">product</span>,
		<span class="monoText">counter</span>, and
		<span class="monoText">max-count</span>. This is an
		<span class="term">iterative process</span> &mdash; generally, a process
		that can be summarized by a fixed number of
		<span class="term">state variables</span> (e.g.,
		<span class="monoText">counter</span>), together with a fixed rule
		describing how the state variables should be updated as the process moves
		from state to state, and an optional
		<span class="term">end test</span> specifying conditions for when the
		process terminates. In this case, the number of steps need to compute ${n!}$
		grows linearly with ${n.}$ As such, we call this particular iterative
		process a <span class="term">linear iterative process</span>.
	</p>
	<p>
		A closer inspection of the iterative approach might lead us to question
		whether it actually is an iterative process. The procedure is calling
		itself! Indeed, it is. But this where we clarify: There is a different
		between an <span class="italicsText">recursive process</span> and an
		<span class="italicsText">recursive procedure</span>. The term
		<span class="italicsText">recursive procedure</span> is a syntactical
		descriptor; the fact that the procedure definition refers to the procedure
		itself. The term <span class="italicsText">recursive process</span>,
		however, refers to <span class="italicsText">process evolution</span>, not
		syntax. Accordingly, the procedure above is, in fact, a recursive procedure.
		But, it is an iterative process.
	</p>
	<p>
		This is a crucial distinction to understand because many languages &mdash;
		Go, C, Pascal, etc. &mdash; treat all recursive procedures as taking up an
		amount of memory that grows with each call, even if the process itself is
		iterative, not recursive. To ensure that iterative processes do not fall
		into this general treatment, the languages require use of
		<span class="term">looping constructs</span> to indicate iterative
		processes. These looping constructs are made with symbols like
		<span class="monoText">while</span>, <span class="monoText">for</span>,
		<span class="monoText">repeat</span>, etc.
	</p>
	<p>
		Lisp (more specifically, Scheme) does not employ the same general rule. In
		particular, languages like Scheme and Lua not only decline using this rule,
		they in fact prohibit it. It executes iterative proceses in constant pace,
		even if the iterative process underlies a recursive procedure.
		Implementations with this process are called
		<span class="term">tail-recursive</span>.
	</p>
	<p>
		<span class="exh">Exercise.</span> Consider the two procedures below. The
		procedure <span class="monoText">inc</span> increments its argument by
		<span class="monoText">1</span>, the procedure
		<span class="monoText">dec</span> decrements its argument by
		<span class="monoText">1</span>. Use the substitution model to illustrate
		the process generated by each procedure in evaluating
		<span class="monoText">(+ 4 5)</span>. Are the processes iterative or
		recursive?
	</p>
	<pre class="language-scheme"><code>
		(define (+ a b)
			(if (= a 0) 
				b 
				(inc (+ (dec a) b))))
		(define (+ a b)
			(if (= a 0) 
				b 
				(+ (dec a) (inc b))))
	</code></pre>
	<details class="answer">
		<summary>Solution</summary>
		<p>The first procedure:</p>
		<pre class="language-scheme"><code>
			(define (+ a b)
			(if (= a 0) b (inc (+ (dec a) b))))
			
			(+ 4 5)
		</code></pre>
		<p>Substitution model:</p>
		<pre class="language-pseudo"><code>
			(+ a b)
			(+ 4 5)
			(inc (+ (dec 4) 5))
			(inc (+ 3 5))
			(inc (inc (+ (dec 3) 5)))
			(inc (inc (+ 2 5)))
			(inc (inc (inc (+ (dec 2) 5))))
			(inc (inc (inc (+ 1 5))))
			(inc (inc (inc (inc (+ (dec 1) 5)))))
			(inc (inc (inc (inc (+ 0 5)))))
			(inc (inc (inc (inc 5))))
			(inc (inc (inc 6)))
			(inc (inc 7))
			(inc 8)
			9
		</code></pre>
		<p>This is a recursive process. Now the second procedure:</p>
		<pre class="language-scheme"><code>
		(define (+ a b)
			(if (= a 0) b (+ (dec a) (inc b))))

		(+ 4 5)
		</code></pre>
		<p>The substitution model:</p>
		<pre class="language-pseudo"><code>
			(+ a b)
			(+ 4 5)
			(+ (dec 4) (inc 5))
			(+ 3 4)
			(+ (dec 3) (inc 6))
			(+ 2 3)
			(+ (dec 2) (inc 7))
			(+ 1 2)
			(+ (dec 1) (inc 8))
			(+ 0 9)
			9
		</code></pre>
		<p>This is an iterative process.</p>
	</details>
	<p>
		<span class="exh">Exercise.</span> The procedure below computes Ackermann's
		function:
	</p>
	<pre class="language-scheme"><code>
		(define (A x y)
			(cond ((= y 0) 0)
				((= x 0) (* 2 y))
				((= y 1) 2)
				(else (A (- x 1) (A x (- y 1))))))
	</code></pre>
	<p>What are the values of the following expressions:</p>
	<ol>
		<li><span class="monoText">(A 1 10)</span></li>
		<details class="answer">
			<summary>Solution</summary>
			<p>Use the substitution model:</p>
			<pre class="language-pseudo"><code>
				(A 1 10)
				(A (- 1 1) (A 1 (- 10 1)))
				(A 0 (A 1 9))
				(A 0 (A (- 1 1) (A 1 (- 9 1))))
				(A 0 (A 0 (A 1 8)))
				(A 0 (A 0 (A (- 1 1) (A 1 (- 8 1)))))
				(A 0 (A 0 (A 0 (A 1 7))))
				(A 0 (A 0 (A 0 (A (- 1 1) (A 1 (- 7 1))))))
				(A 0 (A 0 (A 0 (A 0 (A 1 6)))))
				(A 0 (A 0 (A 0 (A 0 (A (- 1 1) (A 1 (- 6 1)))))))
				(A 0 (A 0 (A 0 (A 0 (A 0 (A 1 5))))))
				(A 0 (A 0 (A 0 (A 0 (A 0 (A (- 1 1) (A 1 (- 5 1))))))))
				(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 4)))))))
				(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A (- 1 1) (A 1 (- 4 1)))))))))
				(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 3))))))))
				(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A (- 1 1) (A 1 (- 3 1))))))))))
				(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 2)))))))))
				(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A (- 1 1) (A 1 (- 2 1)))))))))))
				(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 1))))))))))
				(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 2)))))))))
				(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 4))))))))
				(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 8)))))))
				(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 16))))))
				(A 0 (A 0 (A 0 (A 0 (A 0 32)))))
				(A 0 (A 0 (A 0 (A 0 64))))
				(A 0 (A 0 (A 0 128)))
				(A 0 (A 0 256))
				(A 0 512)
				1024
			</code></pre>
			<p>This result will be used in the next problem.</p>
		</details>
		<li><span class="monoText">(A 2 4)</span></li>
		<details class="answer">
			<summary>Solution</summary>
			<p>Substitution model:</p>
			<pre class="language-pseudo"><code>
					(A 2 4)
					(A (- 2 1) (A 2 (- 4 1)))
					(A 1 (A 2 3))
					(A 1 (A (- 2 1) (A 2 (- 3 1))))
					(A 1 (A 1 (A 2 2)))
					(A 1 (A 1 (A (- 2 1) (A 2 (- 2 1)))))
					(A 1 (A 1 (A 1 (A 2 1))))
					(A 1 (A 1 (A 1 2)))
					(A 1 (A 1 (A (- 1 1) (A 1 (- 2 1)))))
					(A 1 (A 1 (A 0 (A 1 1))))
					(A 1 (A 1 (A 0 2)))
					(A 1 (A 1 4))
					(A 1 (A (- 1 1) (A 1 (- 4 1))))
					(A 1 (A 0 (A 1 3)))
					(A 1 (A 0 (A (- 1 1) (A 1 (- 3 1)))))
					(A 1 (A 0 (A 0 (A 1 2))))
					(A 1 (A 0 (A 0 (A (- 1 1) (A 1 (- 2 1))))))
					(A 1 (A 0 (A 0 (A 0 (A 1 1)))))
					(A 1 (A 0 (A 0 (A 0 2))))
					(A 1 (A 0 (A 0 4)))
					(A 1 (A 0 8))
					(A 1 16)
					(A (- 1 1) (A 1 (- 16 1)))
					(A 0 (A 1 15))
					(A 0 (A (- 1 1) (A 1 (-15 1))))
					(A 0 (A 0 (A 1 14)))
					(A 0 (A 0 (A (- 1 1) (A 1 (- 14 1)))))
					(A 0 (A 0 (A 0 (A 1 13))))
					(A 0 (A 0 (A 0 (A (- 1 1) (A 1 (-13 1))))))
					(A 0 (A 0 (A 0 (A 0 (A 1 12)))))
					(A 0 (A 0 (A 0 (A 0 (A (- 1 1) (A 1 (- 12 1)))))))
					(A 0 (A 0 (A 0 (A 0 (A 0 (A 1 11))))))
					(A 0 (A 0 (A 0 (A 0 (A 0 (A (- 1 1) (A 1 (- 11 1))))))))
					(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 10)))))))
					(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 1024))))))
					(A 0 (A 0 (A 0 (A 0 (A 0 2048)))))
					(A 0 (A 0 (A 0 (A 0 4096))))
					(A 0 (A 0 (A 0 8192)))
					(A 0 (A 0 16384))
					(A 0 32768)
					65536
				</code></pre>
			<p>We will use this result in the next computation.</p>
		</details>
		<li><span class="monoText">(A 3 3)</span></li>
		<details class="answer">
			<summary>Solution</summary>
			<p>The substitution model:</p>
			<pre class="language-pseudo"><code>
				(A 3 3)
				(A (- 3 1) (A 3 (- 3 1)))
				(A 2 (A 3 2))
				(A 2 (A (- 3 1) (A 3 (- 2 1))))
				(A 2 (A 2 (A 3 1)))
				(A 2 (A 2 2))
				(A 2 (A (- 2 1) (A 2 (- 2 1))))
				(A 2 (A 1 (A 2 1)))
				(A 2 (A 1 2))
				(A 2 (A (- 1 1) (A 1 (- 2 1))))
				(A 2 (A 0 (A 1 1)))
				(A 2 (A 0 2))
				(A 2 4)
				65536
			</code></pre>
		</details>
	</ol>
	<p>
		For each of the procedures below, <span class="monoText">A</span> is the
		Ackerman function procedure defined earlier. Provide a mathematical
		definition for each of the procedures:
	</p>
	<ol>
		<li><span class="monoText">(define (f n) (A 0 n))</span></li>
		<details class="answer">
			<summary>Solution</summary>
			<p>Reference:</p>
			<pre class="language-scheme"><code>
				(define (A x y)
					(cond ((= y 0) 0)
						((= x 0) (* 2 y))
						((= y 1) 2)
						(else (A (- x 1) (A x (- y 1))))))

				(define (f n) (A 0 n))
			</code></pre>
			<p>This corresponds to: ${2n.}$</p>
		</details>
		<li><span class="monoText">(define (g n) (A 1 n))</span></li>
		<details class="answer">
			<summary>Solution</summary>
			<pre class="language-scheme"><code>
				(define (A x y)
					(cond ((= y 0) 0)
						((= x 0) (* 2 y))
						((= y 1) 2)
						(else (A (- x 1) (A x (- y 1))))))

				(define (g n) (A 1 n))
			</code></pre>
			<p>
				Here, there are three possibilities: ${n = 1,}$ ${n = 0,}$ or ${n > 1.}$
				If ${n = 0,}$ we meet the first condition, so we get back 0. If ${n =
				1,}$ then we meet the third condition, and get back 2. But what if ${n >
				1?}$ Well, if ${n > 1,}$ then we get back ${g (n - 1).}$ Effectively,
				this means we multiply 2 ${n}$ times. Thus, when ${n > 1,}$ we get back
				${2^n.}$
			</p>
			<p>Mathematically:</p>
			<figure class="math-display">
				$$ g(n) = \begin{cases} 0 &\text{if } n = 0 \\[1em] 2 &\text{if } n = 1
				\\[1em] 2^n &\text{if } n > 1 \end{cases} $$
			</figure>
		</details>
		<li><span class="monoText">(define (h n) (A 2 n))</span></li>
		<details class="answer">
			<summary>Solution</summary>
			<pre class="language-scheme"><code>
				(define (A x y)
					(cond ((= y 0) 0)
						((= x 0) (* 2 y))
						((= y 1) 2)
						(else (A (- x 1) (A x (- y 1))))))

				(define (h n) (A 2 n))
			</code></pre>
			<p>
				We look at the base cases again. When ${n = 0,}$ we get back 0. When ${n
				= 1,}$ we get back 2. Now the tricky part: ${n > 1.}$ Let's try a small
				value, ${n = 2:}$
			</p>
			<pre class="language-pseudo"><code>
				(h 2)
				(A 2 2)
				(A (- 2 1) (A 2 (- 2 1)))
				(A 1 (A 2 1))
				(A 1 2)
			</code></pre>
			<p>
				The final result, <span class="monoText">(A 1 2)</span>, is really
				<span class="monoText">(g 2)</span>. Since ${n > 1}$ we know that
				<span class="monoText">(g 2)</span> computes ${2^n.}$ This means then
				that when ${n = 2,}$ <span class="monoText">(h n)</span> computes
				${2^2.}$ What if ${n = 3?}$
			</p>
			<pre class="language-pseudo"><code>
				(h 3)
				(A 2 3)
				(A (- 2 1) (A 2 (- 3 1)))
				(A 1 (A 2 2))
				(A 1 4)
				(g 4)
				16
			</code></pre>
			<p>
				Thus, when ${n = 3,}$ <span class="monoText">(h n)</span> computes
				${2^4.}$ It seems then that when ${n > 1,}$
				<span class="monoText">(h n)</span> 2 raised to the 2 raised to the 2,
				etc: ${2^{2^{2^{2}}}.}$ In mathematics, this is called
				<span class="term">tetration</span>. We concisely express it as:
			</p>
			<figure class="math-display">
				<div>
					<p>${^{n}2}$</p>
				</div>
			</figure>
		</details>
	</ol>
</section>
{% endblock %}
