{% extends '../layout.html' %} {% load static %} {% block content %}
<h1>Game Development: C#</h1>
<section id="intro">
	<p>
		<span class="drop">H</span>umans have played games for millenia. But
		what is a game? A <span class="term">game</span> is an activity that
		one engages in for amusement. This is a broad definition, especially
		when we consider the predicate &#8220;for amusement.&#8221; That
		predicate expands the definition to cover numerous activities. Sports
		are games. Chess and its cousins checkers, go, shogi, chaturanga,
		xiangqi, janggi, and sittuyin are games. But it doesn't stop there: Tax
		planning; mergers and acquisitions; diplomacy; legal trials; so long as
		the activity is engaged in for amusement, they too would qualify as
		games.<sup></sup>
	</p>
	<div class="note">
		<p>
			One can, and ideally should, find amusement with serious work. Where
			it usually goes wrong is when the work is done purely for amusement.
		</p>
	</div>
	<p>
		Of course, not all games are amusing. Every game has
		<span class="term">players</span> and a
		<span class="term">rule set</span> &mdash; without rules, there is no
		playing field, and without players, there is no game.
	</p>
	<p>
		The players in a game need not be distinct individuals. For example,
		with a Rubiks Cube or kendama, we ourselves are the only players. We
		might try and beat our previous records &mdash; a game where the
		players are distinguished temporally.
	</p>
	<p>
		Regardless of the number or nature of players, every game's rule set
		must ensure <span class="term">fairness</span> among the players, and
		ideally, every rule set should ensure
		<span class="term">amusement</span> among the players. Take, for
		example, the game
		<span class="italicsText">Rock, Paper, Scissors.</span> The rules are
		simple: (1) Rock beats scissors; (2) scissors beats paper; (3) paper
		beats rock; (4) the players must present their choices at the same
		time. The rule set meets the first requirement of fairness. If,
		however, we suddenly introduced a fourth hand that always beats all the
		other three hands &mdash; call it
		<span class="italicsText">gun</span> &mdash; then the game would
		dissolve to unfairness. Every player would use gun. In such a case, we
		never get to the element of amusement. Without fairness, the question
		of amusement is moot.
	</p>
	<p>
		In this volume, we study game development through C#, the language
		behind
		<span class="italicsText">Unity</span>, the world's most popular game
		engine. Our study aims for several goals: (1) applying object-oriented
		programming in more challenging environments; (2) recognizing design
		patterns; (3) practical cost-benefit analyses for data structures,
		algorithms, and functions in the real world; and (4) understanding the
		concepts of fairness and amusement through game theory and mathematics.
	</p>
	<p>
		The four goals above stem directly from the fact that game development
		is one of the best environments for practicing real-world programming.
		In game development, user experience and user interface is front and
		center. There is no way to avoid it. Moreover, game development is a
		field where cost-benefit analyses are clear. We envision aspects to a
		game, and realize just how much it would cost to implement those
		aspects almost immediately. And if not immediately, we will see those
		costs during execution.
	</p>
	<p>
		Notice that learning C# is not listed as one of the goals above,
		despite this volume's title. Learning C# is a mere side-effect of this
		volume. We will examine the language's syntax, semantics, evaluation
		rules, and conventions, but this is just scaffolding for the ultimate
		end goal: Experiencing game development so as to expand our programming
		toolbox.
	</p>
</section>

<section id="csh_intro">
	<h2>Overview of C#</h2>
	<p>
		If C and Java had a child, it would be C#. It's syntax looks very much
		like C, but contains traits often found in Java: Constructs for
		supporting object-oriented programming, an extensive class library,
		exception-handling, interfaces, polymorphism, and so on.
	</p>
	<p>
		Like C and Java, C# is an explicity-typed language. It's largely a
		statically typed language &mdash; with some exceptions, the compiler
		determines facts about expression types before execution.
	</p>
	<p>
		As usual, here's our first C# program, written in a file called
		<var><mark>mod1.cs</mark></var
		>.
	</p>
	<pre class="language-csharp"><code>
		using System;

		class Mod1 {
			static void Main() {
				Console.WriteLine("Hello, world!");
			}
		}
	</code></pre>
	<p>To run this program (on a Mac), we write:</p>
	<pre class="language-bash command-line" data-output="3"><code>
		mcs mod1.cs
		mono mod1.exe
		Hello, world!
	</code></pre>
	<p>Let's break down the program above:</p>
	<pre class="language-csharp"><code>
		using System; // A namespace declaration

		class Mod1 {  // A class declaration
			static void Main() { // A declaration of the Main method
				Console.WriteLine("Hello, world!"); // A statement to execute
			}
		}
	</code></pre>
	<p>
		The keyword <var><mark>using</mark></var> is a <b>directive</b>. It
		tells C# that this file uses the <var>System</var> namespace. We could
		have instead written:
	</p>
	<pre class="language-csharp"><code>
		class Mod1 {
			static void Main() {
				System.Console.WriteLine("Hello, world!");
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		Hello, world!
	</code></pre>
	<p>
		The <var>using</var> keyword essentially cuts down on verbosity,
		allowing us to just write <var>Console.WriteLine()</var>, instead of
		having to write <var>System</var> over and over again.
	</p>
	<p>
		The keyword <var><mark>class</mark></var> indicates a class
		declaration. Inside this class, we have a single
		<i>static method</i> called <var><mark>Main()</mark></var> &mdash; the
		program's entry point. Given that C# is a statically-typed language, we
		must provide some type for <var>Main()</var>. In this case, we used
		<var>void</var>, but for those coming from C, it could also return
		<var>int</var>. We can also place an array of strings into the method
		as a parameter for <i>command line arguments</i> .
	</p>
	<p>
		Inside the <var>Main()</var> method, we the line
		<var><mark>Console.WriteLine()</mark></var
		>. The word <var>Console</var> is the name of a class in the namespace
		<var>System</var>. <var>System</var> is a collection of various classes
		provided natively by C#, containing a variety of useful tools. One of
		those tools is the <var>Console</var> class, which contains the method
		<var>WriteLine()</var> &mdash; a method for printing to the console.
	</p>
	<p>Here's another simple program:</p>
	<pre class="language-csharp"><code>
		using System;

		class Mod2 {
			static void Main() {
				Console.WriteLine("What's your name?");
				string name = Console.ReadLine();
				Console.WriteLine("Hi {0}!", name);
			}
		}
	</code></pre>
	<pre class="language-bash command-line" data-output="3,5"><code>
		mcs mod2.cs
		mono mod2.exe
		What's your name?
		Sam
		Hi Sam!
	</code></pre>
	<p>
		In the last <var>WriteLine()</var> call, we passed a
		<i>format string</i> &mdash; <var>"Hi {0}!"</var>. The syntax
		<var>{0}</var> is similar to format items like <var>%d</var> in C and
		C++, <var>{}</var> in Rust, or <var>${}</var> in JavaScript. We can
		think of format items as small boxes where we place expressions to be
		evaluated, ultimately becoming part of the string.
	</p>
</section>

<section id="basic_syntax">
	<h2>Basic Syntax</h2>
	<p>In this section, we examine some of C#'s basic syntax.</p>
	<section id="variables_and_casting">
		<h3>Naming</h3>
		<p>
			In C#, names must be comprised of characters from any of the
			following sets:
		</p>
		<figure>
			$$ \{ \texttt{a}, \texttt{b}, \ldots, \texttt{y}, \texttt{z} \}
			\\[1em] \{ \texttt{A}, \texttt{B}, \ldots, \texttt{Y}, \texttt{Z} \}
			\\[1em] \{ \texttt{0}, \ldots, \texttt{9} \} $$
		</figure>
		<p>
			Alongside this rule, the C# community employs the following conventions:
		</p>
		<table class="api">
			<thead>
				<th>Entity</th>
				<th>Convention</th>
				<th>Characters</th>
				<th>Underscores Allowed</th>
			</thead>
			<tbody>
				<tr>
					<td>Namespace</td>
					<td>PascalCase</td>
					<td>[a-Z]</td>
					<td>[0-9]</td>
					<td>Underscores Allowed</td>
				</tr>
			</tbody>
		</table>
	</section>
	<section id="operators"></section>
	<section id="conditions"></section>
	<section id="loops"></section>
	<section id="arrays"></section>
	<section id="methods"></section>
	<section id="exception_handling"></section>
</section>

<section id="object_oriented_programming">
	<section id="classes_and_objects"></section>
	<section id="data_hiding"></section>
	<section id="inheritance"></section>
	<section id="polymorphism"></section>
	<section id="abstract_classes_and_inheritance"></section>
	<section id="composition_aggregation_association"></section>
</section>

{% endblock %}
