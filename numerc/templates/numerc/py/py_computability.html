{% extends 'numerc/layout.html' %} {% block content %}

<section>
	<h4>Computability</h4>
	<p>
		Mathematics can be viewed as a
		<span class="boldItalics">formal system</span> &mdash; a set of meaningless
		symbols that can be manipulated according to a set of fixed rules, so as to
		produce meaning. For example, the game of chess is a formal system. The
		symbols are the pieces &mdash; king, rook, bishop, etc. &mdash; and the
		fixed set of rules consists of those governing how the pieces move. These
		pieces and rules do not have any meaning outside of chess. Philsophers and
		mathematicians like David Hilbert argued that mathematics should be viewed
		in this way.
	</p>
	<p>
		Hilbert's arguments responded to a lingering philosophical question at the
		very heart of mathematics &mdash; Is mathematics invented or discovered? By
		viewing mathematics as a formal system, the question could be addressed
		without shaking the foundations of all of mathematics.
	</p>
	<p>
		To construct a formal system, however, Hilbert needed
		<span class="italicsText">foundational axioms</span> &mdash; the rules that
		provide what is allowed and prohibited in creating the formal system. To
		construct these foundational axioms, Hilbert focused on the three things
		most valued in mathematics:
	</p>
	<ol>
		<li>consistency;</li>
		<li>completeness; and</li>
		<li>decidability</li>
	</ol>
</section>
<section>
	<p>
		<span class="topic">Consistency.</span> The property of consistency provides
		that no contradictions can be proven within the system. For example, if you
		prove that ${1 + 1 = 2,}$ you cannot then prove that ${1 + 1 \neq 2.}$
		Without consistency, the entire formal system is useless; we would never be
		certain of our results. This property was largely unchallenged at the time,
		but recent work in logical pluralism has raised some questions.
	</p>
</section>
<section>
	<p>
		<span class="topic">Completeness</span>. The property of completeness
		provides that there is a proof demonstrating that all true statements in the
		formal system can be proven within the system. I.e., for any given true
		statement in the formal system, we do not need to go outside the system to
		prove that it is true. As an aside, Hilbert's work on this particular
		property was largely demolished by the German logician Kurt Gödel (see
		Gödel's <span class="italicsText">incompleteness theorems</span>).
	</p>
</section>
<section>
	<p>
		<span class="topic">Decidability.</span> Decidability provides that there
		exists an <span class="italicsText">effective procedure</span> for deciding
		whether any particulary statement in the formal system is true or false.
	</p>
	<p>
		It is this final property, decidability, that caught the attention of a
		young computer scientist named Alan Turing. Turing's question was
		straightforward in statement: Is there an
		<span class="italicsText">effective procedure</span> for deciding whether
		any mathematical statement is true or false? It was this notion of an
		&#8220;effective procedure&#8221; that Turing was particularly interested
		in.
	</p>
	<p>
		Today, we know these effective procedures as
		<span class="boldItalics">algorithms</span>. During Turing's time, however,
		there was no such parlance. Back then, "computers" were humans, most often
		women, given a set of instructions on what and how to compute a particular
		result. These were mindless, mechanical tasks. Turing saw the process as an
		"effective procedure," consisting of a series of steps:
	</p>
	<ol>
		<li>The human reads the instructions;</li>
		<li>
			the human reads and writes symbols on a piece of paper in response to
			reading the instructions;
		</li>
		<li>
			the human occassionally erases a symbol and replaces it with a new symbol;
			and
		</li>
		<li>the human stops working when the computation is complete.</li>
	</ol>
	<p>
		The breakthrough was Turing's realization that all of the steps above could
		be performed by a theoretical machine. Instead of a human, there's a
		scanner. The scanner sees, erases, and writes one symbol at a time. Instead
		of a piece of paper, the scanner works with an infinitely long piece of tape
		lined with squares, each square containing one symbol (<span
			class="monoText"
			>0</span
		>, <span class="monoText">1</span>, or blank).
	</p>
	<p>
		But what about the instructions? How does the scanner know what to do?
		Indeed, the scanner has no brain. To solve this problem, Turing looked to
		the instructions and what humans were doing. The instructions were largely
		routine, mechanical tasks. As such, if the instructions were reduced to
		conditional statements (i.e., statements that can be ascribed the values
		true or false), we can translate the instructions into a form where the
		machine (a) sees if it's a <span class="monoText">1</span>, a
		<span class="monoText">0</span>, or a blank, and write something in
		response. In doing so, we provide the machine with
		<span class="boldItalics">internal states</span> &mdash; what the machine
		should do when a particular condition (e.g., seeing a
		<span class="monoText">0</span>, <span class="monoText">1</span>, or a
		blank) is true. And if we can provide internal states, we can also provide
		internal states leading to other internal states &mdash; the machine can
		perform much more complex computations.
	</p>
	<p>
		In sum, Turing's machine &mdash; what we now refer to as a
		<span class="boldItalics">Turing Machine</span> &mdash; could accept as
		input <span class="monoText">0</span>s and <span class="monoText">1</span>s
		and output <span class="monoText">0</span>s and
		<span class="monoText">1</span>s to perform computations. Better yet, the
		machine could perform computations endlessly, as it was not subject to the
		same human limitations of physical and mental exhaustion. Turing had
		constructed one definition for an effective procedure &mdash; an effective
		procedure is any procedure that can be computed by a Turing Machine in a
		finite amount of time.
	</p>
	<p>
		Turing machines lead to the
		<span class="boldItalics">Church-Turing thesis</span>: If a function is
		computable, then a Turing Machine can be programmed to compute it.
		Unfortunately for David Hilbert, not all problems have computational
		solutions. Turing proved that it was impossible to write an internal state
		for a Turing Machine that takes any arbitrary program as input, and prints
		<span class="monoText">true</span> if, and only if, the program will run
		forever. This is known as the
		<span class="boldItalics">halting problem</span>.
	</p>
	<p>
		While we lend sympathy to Hilbert's failed project, the Church-Turing thesis
		yields a bedrock principle in computer science:
		<span class="boldItalics">Turing completeness</span>. A programming language
		is said to be Turing complete if it can be used to simulate a Turing
		Machine. And if a programming language is Turing complete, then
		<span class="italicsText">anything</span> that can be programmed in that
		language can be programmed in any other Turing complete programming
		language. Of course, some programs are easier to implement in one language
		over the other; Piet, Brainfuck, CSS3+HTML5, and Whitespace are all Turing
		complete, but it would be odd to choose them over Matlab when implementing
		Fourier transforms. Nevertheless, as a matter of pure theory, all Turing
		complete languages are equal with respect to computational ability.
	</p>
</section>

{% endblock %}
