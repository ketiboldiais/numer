{% extends '../layout.html' %} {% load static %} {% block content %}
<section id="tuples">
	<h4>Tuples</h4>
	<p>
		A <span class="term">tuple</span> is a data structure whose elements are
		<span class="italicsText">ordered</span> in sequence. By
		&#8220;ordered,&#8221; we do not mean that the values are ordered from least
		to greatest or vice versa. We mean that every element in the tuple has an
		<span class="italicsText">index</span>, or position, in the sequence which
		we can refer to so as to retrieve that element.
	</p>
	<p>
		Like strings, tuples are an <span class="term">immutable</span> data
		structure &mdash; once initialized, the values of the tuple's elements
		cannot be changed. Tuples can be <span class="term">homogenous</span> (all
		of its elements are of just one data type), or they can be
		<span class="term">heterogenous</span> (the tuple contains mixed data
		types). In Python, we represent tuples with parentheses:
	</p>
	<pre class="language-python"><code>
		# declare a tuple
		tple = ()

		# initialize a tuple
		tpl = (2, "one", 3)

		# index into tuple; evaluates to 2
		tpl[0];

		# concatenate tuples; evaluates to (2, "one", 3, 5, 6)
		(2, "one", 3) + (5, 6)  

		# slice tuple; evaluates to ("one",)
		tpl[1:2] 

		# slice again; evaluates to ("one", 3)
		tpl[1:3]

		# TypeError; cannot modify a tuple
		tpl[1] = 4
	</code></pre>
	<p>
		Note that we must have commas when initializing tuples. If we fail to
		include commas, Python will assume we are scoping code, rather than
		initializing a tuple:
	</p>
	<pre class="language-python"><code>
		tple = ('name',) # outputs a tuple -- ('name',)
		tple = ('name') # outputs a string -- 'name'
	</code></pre>
	<p>
		<span class="topic">Variable Swapping.</span> Tuples are useful for variable
		swapping. Consider the following variable swaps:
	</p>
	<div class="compare">
		<figure>
			<pre class="language-python"><code>
				# invalid
				x = y
				y = x
			</code></pre>
			<figcaption>Script A</figcaption>
		</figure>
		<figure>
			<pre class="language-python"><code>
				# valid
				temp = x
				x = y
				y = temp
			</code></pre>
			<figcaption>Script B</figcaption>
		</figure>
		<figure>
			<pre class="language-python"><code>
				# valid
				(x, y) = (y, x)
			</code></pre>
			<figcaption>Script C</figcaption>
		</figure>
	</div>
	<p>
		We know that Script A returns an error. In Script B, we used the temporary
		variable method for swapping. Script C provides an alternative way &mdash;
		with tuples. With the tuple method, we created bindings for
		<span class="monoText">x</span> and <span class="monoText">y</span>, then we
		swapped their order in the tuple.
	</p>
	<p>
		<span class="topic">Returning More Than One Value.</span> Tuples also allow
		us to return more than one value from a function:
	</p>
	<pre class="language-python"><code>
		def quotient_and_remainder(x, y):
			q = x // y
			r = x % y 
			return (q, r)

		(quotient, remainder) = quotient_and_remainder(4, 5)
	</code></pre>
	<p>
		<span class="topic">Manipulating Tuples.</span> Tuples are also iterable
		&mdash; we can loop through them:
	</p>
	<pre class="language-python"><code>
		def get_data(aTuple):
			nums = ()
			words = ()
			for element in aTuple:
				nums = nums + (element[0],)
				if element[1] not in words: 
					words = words + (element[1],)
			min_nums = min(nums)
			max_nums = max(nums)
			unique_words = len(words)
			return (min_nums, max_nums, unique_words) 
	</code></pre>
	<p>
		The code above iterates over a tuple containing tuples.
		<span class="monoText">aTuple((), (), ()).</span> At each iteration (each
		tuple inside the tuple), we collect the first element inside the tuple, an
		<span class="monoText">int</span>, and insert it into the empty tuple
		<span class="monoText">num</span> (<span class="monoText"
			>nums = nums + (t[0],)</span
		>). Then, we check the second element in the tuple &mdash; a word &mdash; to
		see if it isn't already inside the empty tuple
		<span class="monoText">word</span>. If it isn't, we collect and insert it
		into <span class="monoText">word</span>. We perform for each tuple inside
		the tuple.
	</p>
	<p>
		<span class="exh">Exercise.</span> Suppose the following tuple is
		initialized:
	</p>
	<pre class="language-python"><code>
		x = (1, 2, (3, 'John', 4), 'Hi')
	</code></pre>
	<p>
		For each of the following expressions, what is its output type and value?
	</p>
	<ol>
		<li><span class="monoText">x[0]</span></li>
		<details class="answer">
			<summary>Solution</summary>
			<p>
				Output: <span class="monoText">1</span>, type
				<span class="monoText">int</span>.
			</p>
		</details>
		<li><span class="monoText">x[2]</span></li>
		<details class="answer">
			<summary>Solution</summary>
			<p>
				Output: <span class="monoText">(3, 'John', 4,)</span>, type
				<span class="monoText">tuple</span>.
			</p>
		</details>
		<li><span class="monoText">x[-1]</span></li>
		<details class="answer">
			<summary>Solution</summary>
			<p>
				Output: <span class="monoText">'Hi'</span>, type
				<span class="monoText">String</span>.
			</p>
		</details>
		<li><span class="monoText">x[2][2]</span></li>
		<details class="answer">
			<summary>Solution</summary>
			<p>
				Output: <span class="monoText">4</span>, type
				<span class="monoText">int</span>.
			</p>
		</details>
		<li><span class="monoText">x[2][-1]</span></li>
		<details class="answer">
			<summary>Solution</summary>
			<p>
				Output: <span class="monoText">4</span>, type
				<span class="monoText">int</span>.
			</p>
		</details>
		<li><span class="monoText">x[-1][-1]</span></li>
		<details class="answer">
			<summary>Solution</summary>
			<p>
				Output: <span class="monoText">'i'</span>, type
				<span class="monoText">String</span>.
			</p>
		</details>
		<li><span class="monoText">x[-1][2]</span></li>
		<details class="answer">
			<summary>Solution</summary>
			<p>
				Output: <span class="monoText">Error</span>; index is out of bounds.
			</p>
		</details>
		<li><span class="monoText">x[0:1]</span></li>
		<details class="answer">
			<summary>Solution</summary>
			<p>
				Output: <span class="monoText">(1, 2, (3, 'John', 4))</span>, type
				<span class="monoText">tuple</span>.
			</p>
		</details>
		<li><span class="monoText">x[0:-1]</span></li>
		<details class="answer">
			<summary>Solution</summary>
			<p>
				Output: <span class="monoText">(1, 2, (3, 'John', 4))</span>, type
				<span class="monoText">tuple</span>.
			</p>
		</details>
		<li><span class="monoText">len(x)</span></li>
		<details class="answer">
			<summary>Solution</summary>
			<p>
				Output: <span class="monoText">4</span>, type
				<span class="monoText">int</span>.
			</p>
		</details>
		<li><span class="monoText">2 in x</span></li>
		<details class="answer">
			<summary>Solution</summary>
			<p>
				Output: <span class="monoText">True</span>, type
				<span class="monoText">Boolean</span>.
			</p>
		</details>
		<li><span class="monoText">3 in x</span></li>
		<details class="answer">
			<summary>Solution</summary>
			<p>
				Output: <span class="monoText">False</span>, type
				<span class="monoText">Boolean</span>.
			</p>
		</details>
		<li><span class="monoText">x[0] = 8</span></li>
		<details class="answer">
			<summary>Solution</summary>
			<p>
				Output: <span class="monoText">TypeError</span>, cannot modify a tuple.
			</p>
		</details>
	</ol>
	<p>
		<span class="exh">Exercise.</span> Write a procedure called
		<span class="monoText">oddTuples</span>, which takes a tuple as input, and
		returns a new tuple as output, where every other element of the input tuple
		is copied, starting with the first one.
	</p>
	<details class="answer">
		<summary>Solution</summary>
		<p>One implementation:</p>
		<pre class="language-python"><code>
				def oddTuples(aTup):
					'''
					input: aTup -- a tuple
					output: a tuple with every other element of aTup
					'''
					newTup = ()
					for element in aTup[::2]:
						newTup = newTup + (element,)
					return newTup
			</code></pre>
		<p>Or, even shorter:</p>
		<pre class="language-python"><code>
				def oddTuples(aTup):
					'''
					input: aTup -- a tuple
					output: a tuple with every other element of aTup
					'''
					return aTup[::2]
			</code></pre>
	</details>
</section>
{% endblock %}
