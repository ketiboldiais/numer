{% extends '../layout.html' %} {% load static %} {% block content %}
<section id="simple_algorithms_in_python">
	<h3>Simple Algorithms in Python</h3>
	<p>
		In our previous square root program, we could only compute the cube root of
		an integer. What if we wanted to compute the ${nth\text{-root}}$ of any
		nonnegative number? Clearly, we cannot generate all possible guesses &mdash;
		there are infinitely many.
	</p>
	<p>
		What we can do, however, is generate an
		<span class="boldItalics">approximate solution</span>. We won't get an exact
		answer, but we will obtain a result that is close enough. The find this
		result, we use exhaustive enumeration. We generate a guess, check, if it's
		not close enough, we repeat over and over until we arrive at something close
		enough.
	</p>
	<p>
		We start with a guess, then we incremenent by a small value. For example, we
		might start with <span class="monoText">1</span>. If it's close enough,
		great. Otherwise, we'll increment by <span class="monoText">0.0001</span>;
		the guess is now <span class="monoText">1.0001</span>.
	</p>
	<p>
		However, we need to define what &#8220;close enough&#8221; means. For cube
		roots, we might use the following definition:
	</p>
	<figure class="math-display">
		<div>
			<p>${\lvert g^3 \rvert - r \leq \varepsilon}$</p>
			<ul class="def">
				<li class="where">${g \coloneqq \text{our guess}}$</li>
				<li>${r \coloneqq \text{the cube root}}$</li>
				<li>${\varepsilon \coloneqq \text{some very small number}}$</li>
			</ul>
		</div>
	</figure>
	<p>
		There are tradeoffs to be cognizant of when we implement the definition
		above. Given an increment ${i,}$ when ${\lim\limits_{i \to 0},}$ (as the
		increment gets very small), the program grows slower. When
		${\lim\limits_{\varepsilon \to +\infty},}$ (the more accepting we are of
		larger differences) the less accurate our answer is. Bearing these costs in
		mind, we can implement the algorithm as such:
	</p>
	<pre class="language-python"><code>
		cube = int(input('Enter integer to cubic root: '))
		epsilon = 0.01
		guess = 0.0
		increment = 0.0001
		guess_count = 0
		while abs(guess**3 - cube) >= epsilon:
			guess += increment
			guess_count += 1 
		print('Number of guesses =', guess_count)
		if abs(guess**3 - cube) >= epsilon:
			print('Failed on cube root of', cube)
		else:
			print(guess, 'is close to the cube root of', cube)
	</code></pre>
	<pre class="command-line language-bash" data-output="2-4"><code>
		Enter integer to cubic root: 27
		Number of guesses = 29997
		2.999700000001906 is close to the cube root of 27
	</code></pre>
	<p>
		Carefully consider what this code is doing. It starts with a
		<span class="monoText">guess</span>, <span class="monoText">0.0</span>, then
		cubes it. Then it subtracts from the result the integer the user entered. If
		that result is greater than or equal to
		<span class="monoText">0.01</span> (<span class="monoText">epsilon</span>),
		it increments the <span class="monoText">guess</span> by
		<span class="monoText">0.0001</span>, counts the iteration, and repeats the
		test again. The code does this over and over again until
		${\left(\texttt{guess}^3 - \texttt{cube}\right) \geq 0.001.}$
	</p>
	<p>
		Other things to note: It took almost 30,000 iterations before Python reached
		the closest guess. This is because we incremented by 0.0001 each time.
		Although this code is slow, it does allow us to compute the cubic root for
		non-perfect cubes:
	</p>
	<pre class="command-line language-bash" data-output="2-3"><code>
		Enter integer to cubic root: 31
		Number of guesses = 31411
		3.1411000000022042 is close to the cube root of 31
	</code></pre>
	<p>
		Suppose we made our <span class="monoText">increment = 0.001</span> instead
		of <span class="monoText">0.0001</span>:
	</p>
	<pre class="command-line language-bash" data-output="2-3"><code>
		Enter integer to cubic root: 29
		Number of guesses = 3072
		3.0719999999997727 is close to the cube root of 29
	</code></pre>
	<p>
		This guess is different, but this time it only took roughly 3,000
		iterations. Let's change it again,
		<span class="monoText">guess = 0.01</span>:
	</p>
	<pre class="command-line language-bash" data-output="2"><code>
		Enter integer to cubic root: 29

	</code></pre>
	<p>
		Why is there no output? Our loop has gone infinite. Our code is only
		checking if our guess is close enough, and our guess has been incremented
		right past the cube root. Python is checking over and over again with no end
		in sight.
	</p>
	<p>
		To avoid this problem, we must ensure that our guess does not go out of
		bounds (i.e., it is not too big). This means we need to make add an
		additional test condition to terminate the
		<span class="monoText">while</span> loop:
	</p>
	<pre class="language-python"><code>
		cube = int(input('Enter integer to cubic root: '))
		epsilon = 0.01
		guess = 0.0
		increment = 0.0001
		guess_count = 0
		while abs(guess**3 - cube) >= epsilon and guess <= cube:
			guess += increment
			guess_count += 1 
		print('Number of guesses =', guess_count)
		if abs(guess**3 - cube) >= epsilon:
			print('Failed on cube root of', cube)
		else:
			print(guess, 'is close to the cube root of', cube)
	</code></pre>
	<p>
		The additional test condition checks to make sure that
		<span class="monoText">guess</span> is not greater than
		<span class="monoText">cube</span>. If it is, the loop terminates.
	</p>
	<pre class="command-line language-bash" data-output="2,3"><code>
		Enter integer to cubic root: 29
		Number of guesses = 2900
		Failed on cube root of 29
	</code></pre>
	<p>
		The output tells us that Python could not find a solution, but at least it
		isn't running an infinite loop. This is a crucial lesson in implementing
		algorithms: We must always consider the tradeoffs. Too large of a step, and
		we miss the answer. Too small of a step, and the program will be too slow.
	</p>
</section>

<section id="bisection_search">
	<h4>Bisection Search</h4>
	<p>
		Our previous algorithm came with tradeoffs: Increase accuracy, and the
		program slows; Increase speed, and the program risks inaccuracy. A possibly
		better solution is to use a
		<span class="boldItalics">bisection search</span>.
	</p>
	<p>
		We know that given ${\texttt{guess} = \sqrt{x},}$ where ${x \in \Z,}$
		<span class="monoText">guess</span> lies somewhere between 1 and ${x.}$ In
		the previous algorithm, we initialized
		<span class="monoText">guess</span> to <span class="monoText">1</span>. But
		if ${1 \leq \texttt{guess} \leq x,}$ why should we start with
		${\texttt{guess} = 1?}$ Indeed, there is nothing stopping us from
		initializing ${\texttt{guess} = n,}$ where ${1 \leq n \leq x.}$ If we're
		lucky, <span class="monoText">guess</span> is close enough. If
		<span class="monoText">guess</span> is not close enough, we ask, Is the
		guess too big or too small?
	</p>
	<p>
		If ${\texttt{guess}^2 > x,}$ then we know it's too big. Let's call that
		guess ${\texttt{guess}_0}$ and the more accurate guess ${\texttt{guess}_1.}$
		If ${\texttt{guess}_0}$ is too big, then it must be the case that ${1 \leq
		\texttt{guess}_1 \leq \texttt{guess}_0.}$ What that means is, we can toss
		out all of the possible guesses where ${\texttt{guess}_0 \leq \text{guess}
		\leq x.}$ By tossing all of those possible guesses out, we do not have to
		bother looking at those values and checking.
	</p>
	<p>
		The beauty of this method is we can do the same thing again for the new
		range. Pick something halfway between, call it ${\texttt{guess}_2.}$ If
		${\texttt{guess}_2}$ is close enough, we're done. If
		${{\texttt{guess}_2}^2 > x,}$ it's too big, so we cut out the upper half. If
		${{\texttt{guess}_2}^2 < x,}$ then we know it's too small, so we toss out
		the lower half. We repeat this process over and over until we arrive at some
		${{\texttt{guess}_n}^2}$ that is close enough. This algorithm is called a
		<span class="boldItalics">bisection search</span>.
	</p>
	<p>Implementing:</p>
	<pre class="language-python"><code>
		radicand = int(input("Enter the integer to square root: "))
		deviation = 0.01
		guess_count = 0
		minGuess = 1.0
		maxGuess = radicand
		square_root = (maxGuess + minGuess)/2.0

		while abs(square_root**2 - radicand) >= deviation:
			print(f'minGuess = {minGuess}; maxGuess = {maxGuess}; square_root = {square_root}')
			guess_count += 1
			if square_root**2 < radicand:
				minGuess = square_root
			else:
				maxGuess = square_root 
			square_root = (maxGuess + minGuess) / 2
		print(f'Number of guesses: {guess_count}')
		print(f'{square_root} is close to square root of {radicand}')
	</code></pre>
	<pre class="language-bash"><code>
		Enter the integer to square root: 25

		minGuess = 1.0; maxGuess = 25; square_root = 13.0
		minGuess = 1.0; maxGuess = 13.0; square_root = 7.0
		minGuess = 1.0; maxGuess = 7.0; square_root = 4.0
		minGuess = 4.0; maxGuess = 7.0; square_root = 5.5
		minGuess = 4.0; maxGuess = 5.5; square_root = 4.75
		minGuess = 4.75; maxGuess = 5.5; square_root = 5.125
		minGuess = 4.75; maxGuess = 5.125; square_root = 4.9375
		minGuess = 4.9375; maxGuess = 5.125; square_root = 5.03125
		minGuess = 4.9375; maxGuess = 5.03125; square_root = 4.984375
		minGuess = 4.984375; maxGuess = 5.03125; square_root = 5.0078125
		minGuess = 4.984375; maxGuess = 5.0078125; square_root = 4.99609375
		minGuess = 4.99609375; maxGuess = 5.0078125; square_root = 5.001953125
		Number of guesses: 12
		4.9990234375 is close to square root of 25
	</code></pre>
	<p>
		The program above computed the square root very very quickly. It computed
		${\sqrt{25}}$ in 13 guesses. Compare that to using our previous method:
	</p>
	<pre class="language-python"><code>
		radicand = int(input('Enter integer to square root: '))
		deviation = 0.01
		square_root = 0.0
		increment = 0.0001
		guess_count = 0
		while abs(square_root**2 - radicand) >= deviation:
			square_root += increment
			guess_count += 1 
		print(f'Number of guesses = {guess_count}')
		print(f'{square_root} is close to the square root of {radicand}')
	</code></pre>
	<pre class="language-bash"><code>
		Enter integer to square root: 25

		Number of guesses = 49990
		4.999000000001688 is close to the square root of 25
	</code></pre>
	<p>
		The previous approach computed ${\sqrt{25}}$ in almost 50,000 guesses. Take
		that in for a moment. 12 guesses versus 50,000. A bisection search for this
		particular computation is over 4,000 times faster. Let's try it with a cube
		root. This time, we'll omit the
		<span class="monoText">print()</span> statement for the individual
		computations.
	</p>
	<pre class="language-python"><code>
		radicand = int(input("Enter the integer to cube root: "))
		deviation = 0.01
		guess_count = 0
		minGuess = 1.0
		maxGuess = radicand
		cube_root = (maxGuess + minGuess)/2.0

		while abs(cube_root**3 - radicand) >= deviation:
			guess_count += 1
			if cube_root**3 < radicand:
				minGuess = cube_root
			else:
				maxGuess = cube_root 
			cube_root = (maxGuess + minGuess) / 2
		print(f'Number of guesses: {guess_count}')
		print(f'{cube_root} is close to cube root of {radicand}')
	</code></pre>
	<pre class="language-bash"><code>
		Enter the integer to cube root: 27

		Number of guesses: 14
		3.00030517578125 is close to cube root of 27
	</code></pre>
	<p>
		The program computed ${\sqrt{27}}$ in 14 guesses. Compare that to our
		previous approach, which took a whopping 30,000 guesses:
	</p>
	<pre class="language-python"><code>
		radicand = int(input('Enter integer to cube root: '))
		deviation = 0.01
		cube_root = 0.0
		increment = 0.0001
		guess_count = 0
		while abs(cube_root**3 - radicand) >= deviation:
			cube_root += increment
			guess_count += 1 
		print(f'Number of guesses = {guess_count}')
		print(f'{cube_root} is close to the cube root of {radicand}')
	</code></pre>
	<pre class="language-bash"><code>
		Enter integer to cube root: 27

		Number of guesses = 29997
		2.999700000001906 is close to the cube root of 27
	</code></pre>
	<p>
		Bisection search is so much faster because we're reducing the number of
		steps it takes to reach the most accurate guess. This is because we're
		tossing out half of the possible guesses at each iteration. In other words,
		where ${n}$ is the number of possible values to check, we're cutting ${n}$
		by half every time.
	</p>
	<figure class="math-display">
		<div>
			<p>${\texttt{guess}_1 = \dfrac{n}{2}}$</p>
			<p>${\texttt{guess}_2 = \dfrac{n}{4}}$</p>
			<p>${\texttt{guess}_3 = \dfrac{n}{8}}$</p>
			<p>$$\vdots$$</p>
			<p>${\texttt{guess}_i = \dfrac{n}{2^i}}$</p>
			<p>${i = \log_{2}n = \log n}$</p>
		</div>
	</figure>
	<p>
		This means it takes ${\log n}$ steps to reach the final
		<span class="monoText">guess</span>. Thus, this algorithm works in
		logarithmic time &mdash; a much faster time, compared to the previous
		algorithm, which took ${n}$ steps to reach the final guess.
	</p>
	<p>
		Importantly, this algorithm will work if, and only if, the relevant problem
		is solvable by checking <span class="italicsText">ordered</span> values.
		More specifically, it only works for
		<span class="boldItalics">monotonic functions</span> &mdash; functions
		where, as their inputs increase in value, the corresponding outputs also
		increase in value. In this case, ${\texttt{guess}^n}$, where ${n \in \N,}$
		grows as ${\texttt{guess}}$ grows.
	</p>
</section>

<section id="bisection_search_exercise">
	<details>
		<summary>Bisection Search Exercise</summary>
		<ol>
			<li>
				Write a program that guesses a user's inputted integer. The program
				should prompt the user to enter an integer between 0 (inclusive) and 100
				(not inclusive). The computer makes a guess, and asks the user if the
				guess is too high or too low. If the guess is too high, prompt the user
				to enter the character <span class="monoText">'h'</span>. If the guess
				is too low, prompt the user to enter the character
				<span class="monoText">'l'</span>. If the guess is correct, prompt the
				user to enter the character <span class="monoText">'c'</span>, upon
				which the user is informed of the guess, along with how many guesses it
				took. Be sure to address the case where the user fails to input a number
				between 0 and 100, along with when the user fails to enter
				<span class="monoText">'c'</span>, <span class="monoText">'h'</span>, or
				<span class="monoText">'l'</span>. Use bisection search!
			</li>
			<details class="answer">
				<summary>Answer</summary>
				<p>Here is one possible implementation:</p>
				<pre class="language-python"><code>
					target_number = int(input("Enter an integer between 0 and 100: "))
					if target_number < 0 or target_number >= 100:
						target_number = int(input("Invalid input. Enter an integer between 0 and 100: "))
					
					min_guess = 1
					max_guess = 100
					guess_count = 0
					guess = (max_guess + min_guess) // 2
					
					while guess < 100:
							guess_count += 1 
							feedback = input(f"Is your number {guess}? If number is lower - enter 'l'; higher - enter 'h'; correct - enter 'c': ")
							while feedback != 'l' and feedback != 'h' and feedback != 'c':
								feedback = input(f"Invalid input. Guess was {guess}. Enter 'l', 'h', or 'c': ")
							if feedback == 'l':
								max_guess = guess
							elif feedback == 'h':
								min_guess = guess
							elif feedback == 'c':
								break
							guess = (max_guess + min_guess) // 2
							
					print(f'Correctly guessed {guess} in {guess_count} guesses.')
				</code></pre>
				<pre class="language-bash"><code>
					Enter an integer between 0 and 100: 120

					Invalid input. Enter an integer between 0 and 100: 12
					
					Is your number 50? If number is lower - enter 'l'; higher - enter 'h'; correct - enter 'c': x
					
					Invalid input. Guess was 50. Enter 'l', 'h', or 'c': n
					
					Invalid input. Guess was 50. Enter 'l', 'h', or 'c': l
					
					Is your number 25? If number is lower - enter 'l'; higher - enter 'h'; correct - enter 'c': l
					
					Is your number 13? If number is lower - enter 'l'; higher - enter 'h'; correct - enter 'c': l
					
					Is your number 7? If number is lower - enter 'l'; higher - enter 'h'; correct - enter 'c': h
					
					Is your number 10? If number is lower - enter 'l'; higher - enter 'h'; correct - enter 'c': h
					
					Is your number 11? If number is lower - enter 'l'; higher - enter 'h'; correct - enter 'c': h
					
					Is your number 12? If number is lower - enter 'l'; higher - enter 'h'; correct - enter 'c': c
					Correctly guessed 12 in 7 guesses.
				</code></pre>
			</details>
		</ol>
	</details>
</section>
{% endblock %}
