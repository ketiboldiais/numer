{% extends '../layout.html' %} {% load static %} 
{% block description %}
<meta name="description" content="Python: Object-oriented programming">
{% endblock %}
{% block title %}
<title>Python OOP</title>
{% endblock %}
{% block content %}
<h1>Object Oriented Programming</h1>
<section id="object_oriented_programming">
	<p>
		The ability to define functions allows us to write procedures and treat them
		as though they were built into the language, just like
		<span class="monoText">+, -, /, *, %</span> operators, or the build in
		methods like <span class="monoText">len()</span>.
	</p>
	<p>
		Now we want to do the same thing with data &mdash; creating
		<span class="italicsText">objects</span> and
		<span class="italicsText">classes of objects</span>. This ability
		drastically increases our ability to write complex and efficient programs.
	</p>
	<p>
		We have already encountered a number of objects:
		<span class="monoText">int</span>, <span class="monoText">string</span>,
		<span class="monoText">boolean</span>, etc. These are all data objects. We
		have also seen data structures, which themselves are data objects: tuples,
		lists, and dictionaries.
	</p>
	<p>
		All of these objects have (1) a <span class="italicsText">type</span>; (2)
		an <span class="italicsText">internal data representation</span> - whether
		the object is primitive or composite; and (3) a set of procedures for
		interacting with that particular object.
	</p>
	<p>
		The following are all <span class="term">instances</span> of a data object
		type: <span class="monoText">8</span> is an instance of
		<span class="monoText">int</span>; <span class="monoText">True</span> is an
		instance of <span class="monoText">boolean</span>;
		<span class="monoText">2.44</span> is an instance of
		<span class="monoText">float</span>;
		<span class="monoText">'hello'</span> is an instance of
		<span class="monoText">string</span>.
	</p>
	<p>
		All of this lends to an underlying principle grounding Python &mdash; nearly
		everything in Python is an object with a type. Objects, more generally, are
		<span class="italicsText">data abstractions</span>. That abstraction
		captures two things: (a) the
		<span class="italicsText">data attributes</span> and (b) it defines the
		data's <span class="italicsText">interface</span> through
		<span class="italicsText">methods</span> (procedures), which has the effect
		of defining the data object's
		<span class="italicsText">behavior</span> while hiding the object's
		implementation.
	</p>
	<p>
		With every data object, we can create new instances of that data object's
		type. Checking that ability, we can also destroy instances of that
		particular data object's type, either explicitly with methods like
		<span class="monoText">del</span>, or implicitly by allowing Python's
		garbage collection to eventually remove them from memory.
	</p>
	<p>
		To repeat, data objects are abstractions, just as functions are
		abstractions. For example, consider the data type
		<span class="monoText">list</span>. How are lists represented internally? It
		turns out lists in Python are
		<span class="italicsText">linked lists</span> &mdash; each list element
		consists of (a) the literal stored (itself a data object), and (b) a pointer
		to the next element in the list. We have many ways of manipulating the list:
		we can index, obtain length, find the max, etc. The data object
		<span class="monoText">list</span> allows us to create, manipulate, and
		destroy lists without worrying about the lower level implementation details
		&mdash; allocating memory, assigning pointers, freeing memory, etc. Data
		objects abstract away the technicalities.
	</p>
</section>

<section id="the_power_of_oop">
	<h4>The Value of Object-Oriented Programming</h4>
	<p>
		Object-oriented programming is a powerful approach to tackling programming
		problems because it bundles together things (objects) that share common
		attributes and procedures that operate on those attributes. Grouping similar
		things together because of their characteristics and what we can do based on
		those characters is something we do frequently not only in programming, but
		in real life as well. We can add two integers together, but it makes no
		sense to add a cat and a dog. We can determine what dry foods to feed a cat
		and what to feed a dog, but it makes no sense to ask what dry foods we
		should feed Booleans.
	</p>
	<p>
		Object-oriented programming abstracts away all of the lower level questions
		we ask: Is this a dog? Is this a cat? Is this a number? What happens when I
		add? What happens if the food is <span class="italicsText">Cereal K9</span>?
		We encapsulate all of these lower level details in a class, so we do not
		have ask them everytime we work with instances of that class. Because of
		<span class="italicsText">inheritance</span>, all of the attributes and
		methods in the class <span class="monoText">dog</span> will work for the
		sub-classes <span class="monoText">shiba inu</span>,
		<span class="monoText">German shephard</span>, and
		<span class="monoText">pitbull</span>. And the cherry on top: We can treat
		these classes as if Python built them in from the very beginning &mdash; we
		are, in a sense, extending the language.
	</p>
	<p>
		The whole concept of classes is based on the idea of classification.
		Persians, Siamese, and British Shorthairs are all cats. Cats, dogs, seals,
		dugongs, rabbits, and cows are all mammals. Mammals, reptiles, amphibians,
		and insects are all animals. Animals, plants, bacteria, and fungi are all
		living organisms. All living organisms contain carbon, so that data
		attribute is inherited by everything below. All living organisms propogate,
		so we might define a method for propogate inherited by everything below, and
		modify it accordingly for each of the subclasses &mdash; some need a mate;
		some have certain gestation periods; some have limits on how much they can
		propogate given a certain amount of time. These are all
		<span class="italicsText">layers of abstraction</span>.
	</p>
	<p>
		<span class="topic">Dangers in Python.</span> Python gives us an enormous
		amount of freedom when creating classes and using instances of those
		classes. That freedom, however, comes at a price &mdash; revealing and
		allowing too much access to information. As we've seen, we can access data
		from outside the class definition easily:
		<span class="monoText">instance.data_attribute</span>. We can also access
		and write to data from outside the class definition:
		<span class="monoText">instance.data_attribute = value</span>. We can also
		create data data attributes for an instance outside the class definition:
		<span class="monoText">instance.new_attribute = value</span>.
		<span class="boldText">Do not do these</span>. It is horrible style and can
		cause an inordinate amount of misery during testing and debugging.
	</p>
</section>

<section id="python_classes">
	<h3>Classes</h3>
	<p>
		There is a distinction between <span class="italicsText">classes</span> and
		an <span class="italicsText">instance</span> of that class. The data object
		<span class="monoText">[1, 2, 3]</span> is an instance of the class
		<span class="monoText">list</span>.
	</p>
	<p>
		As a matter of Python programming, a <span class="term">class</span> is
		essentially a <span class="italicsText">type</span>. The use of
		&#8220;class&#8221; is largely a historic artifact. Originally, Python had
		both types and classes&mdash;separate, distinct, and never the twain shall
		meet. Types were built-in objects defined in C; classes were what the
		programmer built using a <span class="monoText">class</span> statement. The
		distinction existed because you could not legally use the two, type and
		class, together. That distinction has largely gone away.
	</p>
	<p>
		As a matter of type theory, however, there is a distinction between types
		and classes. A <span class="italicsText">type</span> is a collection of all
		the common features of
		<span class="italicsText">a set of objects</span> with the
		<span class="italicsText">same characteristics</span>. A
		<span class="italicsText">class</span>, on the other hand, is a specific
		<span class="italicsText">type</span> &mdash; it defines how a particular
		object is created. In other words, all classes are types, but not all types
		are classes.
	</p>
	<p>
		For example, tuples, lists, dictionaries, functions,
		<span class="monoText">int</span>, <span class="monoText">float</span>, and
		<span class="monoText">boolean</span> are all types. But
		<span class="monoText">int</span>, <span class="monoText">float</span>, and
		<span class="monoText">boolean</span> are not classes; they are are
		primitives. Arrays, tuples, dictionaries, and functions, however, are
		classes.
	</p>
	<p>
		<span class="topic">Object-Oriented Programming.</span> The ability to
		create classes is our forray into
		<span class="italicsText">object-oriented programming</span> &mdash; the
		programming paradigm where data is bundled with procedures into an object
		(in Python, a class), and modularize programs with such objects. There are
		several advantages to object-oriented programming.
	</p>
	<p>
		First, it embodies a
		<span class="italicsText">divide-and-conquer</span> development approach. By
		modularizing our programs into classes, we can implement and test each class
		separately. Not only does this ease testing and debugging, it reduces
		program complexity.
	</p>
	<p>
		Second, by encouraging us to use classes as much as we can, we have more
		pieces of reusable code. Many third-party Python modules (i.e., libraries)
		define new classes. Each of those classes have separate environments
		(avoiding collisions with our own function names), which in turn allows us
		to use pre-existing classes throughout our code. The same idea applies for
		our own modules. Furthermore, <span class="italicsText">inheritance</span>,
		a topic to be discussed in later sections, allows us to create
		<span class="italicsText">subclasses</span>, which in turn redefine or
		extend a selected <span class="italicsText">subset</span> of the
		<span class="italicsText">superclass</span>'s behavior.
	</p>
	<p>
		<span class="topic">Creating Classes.</span> Implementing, or creating, a
		class involves two steps: (1) defining the class name, and (2) defining the
		class attributes. When we use the class, we (a) create instances of objects
		of that class, and (b) perform operations on those instances. All that said,
		let us now turn to examples.
	</p>
	<p>
		To create a class, we use the symbol <span class="monoText">class</span>.
		The general form:
	</p>
	<figure class="math-display">
		<pre class="language-pseudo"><code>
			<span class="blueText">class</span> class_name(<span class="blueText">object</span>):
				⟨attributes⟩
		</code></pre>
	</figure>
	<p>
		Like <span class="monoText">def</span>, we indent code to tell Python which
		statements (the class's <span class="term">attributes</span>) are part of
		the <span class="term">class definition</span>. The symbol
		<span class="monoText">object</span> tells Python that
		<span class="monoText">class_name</span> is a Python object and
		<span class="italicsText">inherits</span> all its attributes. In other
		words, <span class="monoText">class_name</span> is a
		<span class="term">subclass</span> of <span class="monoText">object</span>,
		and <span class="monoText">object</span> is a
		<span class="term">superclass</span> of
		<span class="monoText">class_name</span>. A subclass always inherits from
		its superclass. Thus, the general form of a class definition is really:
	</p>
	<figure class="math-display">
		<pre class="language-pseudo"><code>
			class class_name(class_parent):
				⟨class attributes⟩
		</code></pre>
	</figure>
	<p>
		<span class="topic">Attributes.</span> The data and procedures beloning to a
		class are called the class's <span class="italicsText">attributes</span>.
		Thus, all attributes fall into two kinds: (a)
		<span class="term">data attributes</span> and (b)
		<span class="term">methods</span>. The
		<span class="italicsText">data attributes</span> are the other objects that
		make up the class. For example, suppose we had a class called
		<span class="monoText">coordinates</span>. That class might itself contain
		two objects: an object called <span class="monoText">x_coordinate</span>,
		and another object called <span class="monoText">y_coordinate</span>.
	</p>
	<p>
		The <span class="italicsText">methods</span> are the functions that work
		only within that class (this is where the distinction betwee
		<span class="italicsText">methods</span> and
		<span class="italicsText">functions</span> arises &mdash; all methods are
		functions, but not all functions are methods, but all methods and functions
		are procedures). For example, for the
		<span class="monoText">coordinate</span> class, we might have a method that
		calculates the distance between two
		<span class="monoText">coordinate</span> objects.
	</p>
	<p>
		<span class="topic">Creating Instances of an Class.</span> To use the class,
		we must define how to create an instance of the class. To do so, we use the
		the special method <span class="monoText">__init__()</span>. For example:
	</p>
	<pre class="language-python"><code>
		class Coordinate(object):
			def __init__(self, x, y):
				self.x = y
				self.y = y
	</code></pre>
	<p>
		The <span class="monoText">__init__()</span> method is a built-in method, or
		<span class="term">reserved method</span>, in Python for creating instances
		of a class. This particular kind of method is found in many other languages
		that support object-oriented programming like Java and C++, and is more
		broadly called a <span class="term">constructor</span>.
	</p>
	<p>
		The symbol <span class="monoText">self</span> is a special variable
		parameter, more specifically an object, that refers to an instance of the
		class. This symbol logically follows when we consider the following code:
	</p>
	<pre class="language-python"><code>
		class Coordinate(object):
			def __init__(self, x, y):
				self.x = x
				self.y = y

		origin = Coordinate(0,0) 
		point_A = Coordinate(5,5)
	</code></pre>
	<p>
		In the final line, we have an instance of the
		<span class="monoText">coordinate</span> class called
		<span class="monoText">origin</span>. That instance is passed into the
		<span class="monoText">class</span> definition as a parameter, by virtue of
		the special parameter <span class="monoText">self</span>.
	</p>
	<p>
		Inside the class definition, we have two statements:
		<span class="monoText">self.x = x</span> and
		<span class="monoText">self.y = y</span>. The values passed in the last
		line, <span class="monoText">coordinate(0,0)</span> are passed into the
		definition, and bound to <span class="monoText">self.x</span> and
		<span class="monoText">self.y</span>. The two statements &mdash;
		<span class="monoText">self.x</span> and
		<span class="monoText">self.y</span> &mdash; are examples of
		<span class="italicsText">data attributes</span>. More specifically,
		<span class="monoText">self.x</span> and
		<span class="monoText">self.y</span> are called
		<span class="term">instance variables</span>.
	</p>
	<p>
		Let's see what the value bound to <span class="monoText">origin</span> is:
	</p>
	<pre class="language-python"><code>
		class Coordinate(object):
			def __init__(self, x, y):
				self.x = x
				self.y = y

		origin = Coordinate(0,0) 
		point_A = Coordinate(5,5)

		print(origin)
		print(point_A)
	</code></pre>
	<pre class="language-bash"><code>
		&lt;__main__.Coordinate object at 0x7f5651ac9d00&gt;
		&lt;__main__.Coordinate object at 0x7f5651a947c0&gt;
	</code></pre>
	<p>
		Great. The definition worked just fine; we can see the two instances were
		created successfully. Notice that we did not explicitly pass an argument for
		the <span class="monoText">self</span> parameter. This is because the
		argument for the <span class="monoText">self</span> parameter is the
		instance itself. Python automatically creates a pointer to the instance for
		the definition to use.
	</p>
	<p>
		Now, once we have created an instance of the class, we have instance
		variables we can access:
	</p>
	<pre class="language-python"><code>
		class Coordinate(object):
			def __init__(self, x, y):
				self.x = x
				self.y = y

		origin = Coordinate(0,0) 
		point_A = Coordinate(5,5)

		print(origin.x)
		print(origin.y)
		print(point_A.x, point_A.y)
	</code></pre>
	<pre class="language-bash"><code>
		0
		0
		5 5
	</code></pre>
	<p>
		How does this all work? When we write
		<span class="monoText">origin.x</span>, the symbol
		<span class="monoText">origin</span> points to a
		<span class="italicsText">frame</span>, just like function calls. Within the
		scope of that frame, there are values bound to data attribute variables
		(<span class="monoText">self.x = x</span>). The expression
		<span class="monoText">origin.x</span> is interpreted as getting the value
		of <span class="monoText">origin</span> (a frame) and then looking up the
		value associated with <span class="monoText">x</span> within that frame (the
		specific value ofthat instance).
	</p>
	<p>
		Note what this all means. We can now organize data and use them just as if
		they were literals:
	</p>
	<pre class="language-python"><code>
		class Coordinate(object):
			def __init__(self, x, y):
				self.x = x
				self.y = y

		origin = Coordinate(0,0)
		point_A = Coordinate(5,5)
		point_B = Coordinate(6,6)

		x_coordinates = [origin.x, point_A.x, point_B.x]

		print(x_coordinates)
	</code></pre>
	<pre class="language-bash"><code>
		[0, 5, 6]
	</code></pre>
	<p>Very cool.</p>
	<p>
		<span class="topic">Methods.</span> With classes, we can also include
		functions that work only with a particular class. For example, the
		<span class="monoText">.len()</span> function only works with objects that
		have a length property. Functions that work only for a particular class are
		called <span class="term">methods</span>. In contrast to data attributes,
		methods are a class's <span class="term">procedural attributes</span>.
	</p>
	<p>
		When we define methods, Python will always pass the actual object as the
		first argument. Thus, as we did with data attributes, we include the
		<span class="monoText">self</span> argument as the first argument whenever
		we define a method.
	</p>
	<p>
		Additionally, we use <span class="italicsText">dot notation</span> to access
		procedural data attributes (methods), just as we would data attributes. To
		create methods, we use the same general form employed for data attributes.
		Consider the following:
	</p>
	<pre class="language-python"><code>
		class Coordinate(object):
			def __init__(self, x, y):
				self.x = x
				self.y = y
			def distance(self, other):
				x_diff_sq = (self.x-other.x) ** 2
				y_diff_sq = (self.y-other.y) ** 2
				return (x_diff_sq + y_diff_sq) ** 0.5
	</code></pre>
	<p>
		As we can see, we define methods just as we would functions, with the added
		syntax of <span class="monoText">self</span> and the dot operator. We use
		the dot operator for both arguments because we are accessing data attributes
		for instances of the particular class,
		<span class="monoText">Coordinate</span>. Testing:
	</p>
	<pre class="language-python"><code>
		class Coordinate(object):
			def __init__(self, x, y):
				self.x = x
				self.y = y
			def distance(self, other):
				x_diff_sq = (self.x-other.x) ** 2
				y_diff_sq = (self.y-other.y) ** 2
				return (x_diff_sq + y_diff_sq) ** 0.5
		
		origin = Coordinate(0,0)
		pt_A = Coordinate(3,4) 
		distance_origin_to_A = pt_A.distance(origin)
		print(distance_origin_to_A)
	</code></pre>
	<pre class="language-bash"><code>
		5.0
	</code></pre>
	<p>
		Great, it worked perfectly. Notice how we called it. We wrote
		<span class="monoText">pt_A.distance(origin)</span>. This tells Python, go
		to the instance <span class="monoText">pt_A</span>, access the method
		<span class="monoText">distance</span>, pass
		<span class="monoText">pt_A</span> and
		<span class="monoText">origin</span> as arguments into the method's
		definition, and execute. This is the conventional way of calling the method.
		However, we can also call the method with:
	</p>
	<pre class="language-python"><code>
		class Coordinate(object):
			def __init__(self, x, y):
				self.x = x
				self.y = y
			def distance(self, other):
				x_diff_sq = (self.x-other.x) ** 2
				y_diff_sq = (self.y-other.y) ** 2
				return (x_diff_sq + y_diff_sq) ** 0.5
		
		origin = Coordinate(0,0)
		pt_A = Coordinate(3,4) 
		distance_origin_to_A = Coordinate.distance(pt_A, origin)
		print(distance_origin_to_A)
	</code></pre>
	<pre class="language-bash"><code>
		5.0
	</code></pre>
	<p>
		Both approaches above are correct, but the former is conventional in Python.
	</p>
	<p>
		Earlier, we saw passing an instance of a class on its own to the
		<span class="monoText">print</span> method results in the following output:
	</p>
	<pre class="language-python"><code>
		class Coordinate(object):
			def __init__(self, x, y):
				self.x = x
				self.y = y

		origin = Coordinate(0,0) 
		point_A = Coordinate(5,5)

		print(origin)
		print(point_A)
	</code></pre>
	<pre class="language-bash"><code>
		&lt;__main__.Coordinate object at 0x7f5651ac9d00&gt;
		&lt;__main__.Coordinate object at 0x7f5651a947c0&gt;
	</code></pre>
	<p>
		This is an example of an <span class="term">uninformative</span> print
		representation, and it is the default representation for class instances. We
		can, however, change this with the
		<span class="monoText">__str__</span> method. This allows us to see what the
		object looks like when we use the
		<span class="monoText">print</span> statement. Even better, the
		<span class="monoText">__str__</span> method allows us to dictate what the
		result of a <span class="monoText">print</span> statement should look like
		when we pass the particular instance as an argument:
	</p>
	<pre class="language-python"><code>
		class Coordinate(object):
			def __init__(self, x, y):
				self.x = x
				self.y = y
			def __str__(self):
				return f"<{self.x},{self.y}>"
		
		pt_A = Coordinate(5,5)
		print(pt_A)
	</code></pre>
	<pre class="language-bash"><code>
		&lt;5,5&gt;
	</code></pre>
	<p>
		This is a very useful method to have, partuclarly for debugging. We can also
		check for <span class="monoText">type</span>:
	</p>
	<pre class="language-python"><code>
		class Coordinate(object):
			def __init__(self, x, y):
				self.x = x
				self.y = y
			def __str__(self):
				return f"<{self.x},{self.y}>"
		
		pt_A = Coordinate(5,5)
		print(type(pt_A))
	</code></pre>
	<pre class="language-bash"><code>
		&lt;'__main__.Coordinate'&gt;
	</code></pre>
	<p>
		Another very useful method to have is to check if an instance is an instance
		of a particular class (especially useful for branching programs). To do so,
		we use the <span class="monoText">isinstance()</span> method:
	</p>
	<pre class="language-python"><code>
		class Coordinate(object):
			def __init__(self, x, y):
				self.x = x
				self.y = y
			def __str__(self):
				return f"<{self.x},{self.y}>"
		
		pt_A = Coordinate(5,5)

		test = isinstance(pt_A, Coordinate)

		print(test)
	</code></pre>
	<pre class="language-bash"><code>
		True
	</code></pre>
	<p>
		<span class="topic">Special Operators.</span> We can define what certain
		operators mean for instances of a particular object:
	</p>
	<figure class="table">
		<table class="loop_table">
			<thead>
				<th>Operator</th>
				<th>Description</th>
			</thead>
			<tbody>
				<tr>
					<td><span class="monoText">__add__</span></td>
					<td>
						Define <span class="monoText">self + other</span>. This defines what
						it means when two instances of the class are added.
					</td>
				</tr>
				<tr>
					<td><span class="monoText">__sub__</span></td>
					<td>
						Define <span class="monoText">self - other</span>. This defines what
						it means when two instances of the class are subtracted.
					</td>
				</tr>
				<tr>
					<td><span class="monoText">__eq__</span></td>
					<td>
						Define <span class="monoText">self == other</span>. This defines
						what it means for two instances of the class to be equal.
					</td>
				</tr>
				<tr>
					<td><span class="monoText">__ne__</span></td>
					<td>
						Define <span class="monoText">self != other</span>. This defines
						what it means for two instances of the class to be not equal.
					</td>
				</tr>
				<tr>
					<td><span class="monoText">__lt__</span></td>
					<td>
						Define <span class="monoText">self < other</span>. This defines what
						it means for one instance of the class to be less than another.
					</td>
				</tr>
				<tr>
					<td><span class="monoText">__le__</span></td>
					<td>
						Define <span class="monoText">self <= other</span>. This defines
						what it means for one instance of the class to be less than or equal
						to another.
					</td>
				</tr>
				<tr>
					<td><span class="monoText">__gt__</span></td>
					<td>
						Define <span class="monoText">self > other</span>. This defines what
						it means for one instance of the class to be greater than another.
					</td>
				</tr>
				<tr>
					<td><span class="monoText">__ge__</span></td>
					<td>
						Define <span class="monoText">self >= other</span>. This defines
						what it means for one instance of the class to be greater than or
						equal to another.
					</td>
				</tr>
				<tr>
					<td><span class="monoText">__len__</span></td>
					<td>
						Define <span class="monoText">self < other</span>. This defines what
						the length of an instance of the class is.
					</td>
				</tr>
			</tbody>
		</table>
	</figure>
	<p>
		For example, we might want to define what it means to subtract two
		<span class="monoText">Coordinate</span> objects:
	</p>
	<pre class="language-python"><code>
		class Coordinate(object):
			def __init__(self, x, y):
				self.x = x
				self.y = y
			def __str__(self):
				return f"<{self.x},{self.y}>"
			def __sub__(self, other):
				return Coordinate(self.x - other.x, self.y - other.y)
		
		pt_A = Coordinate(5,5)
		pt_B = Coordinate(1,3)

		test = pt_A - pt_B

		print(test)
	</code></pre>
	<pre class="language-bash"><code>
		&lt;4,2&gt;
	</code></pre>
</section>

<section id="example_class_fractions" class="grid-item">
	<p>
		<span class="topic">Application: Creating a Class for Fractions</span>.
		Let's apply what we know so far and create a new data type to represent
		fractions.
	</p>
	<p>
		Step 1: Internal representation. What do we need to represent this data type
		internally? We need two things: (1) a numerator, and (2) a denominator.
	</p>
	<p>
		Step 2: Interface. What are the methods we need? In other words, how should
		instances of <span class="monoText">fraction</span> interact with one
		another? Let's just start with the most basic things we do with fractions:
		(a) add and subtract, (b) convert to a <span class="monoText">float</span>,
		and (c) a <span class="monoText">print</span> representation.
	</p>
	<pre class="language-python"><code>
		class fraction(object):
			def __init__(self, numer, denom):
				self.numer = numer
				self.denom = denom
			def __str__(self):
				return f"{self.numer}/{self.denom}"
	</code></pre>
	<p>Testing:</p>
	<pre class="language-python"><code>
		class fraction(object):
			def __init__(self, numer, denom):
				self.numer = numer
				self.denom = denom
			def __str__(self):
				return f"{self.numer}/{self.denom}"
			
		half = fraction(1, 2)
		print(half)
	</code></pre>
	<pre class="language-bash"><code>
		1/2
	</code></pre>
	<p>Great, it works.</p>
	<p>
		<span class="topic">Accessing Data Attributes.</span> With classes, we can
		define how to access data attributes with <span class="term">getters</span>.
		Getters are what allow us to quickly access data attributes:
	</p>
	<pre class="language-python"><code>
		class fraction(object):
			def __init__(self, numer, denom):
				self.numer = numer
				self.denom = denom
			def __str__(self):
				return f"{self.numer}/{self.denom}"

			def getNumer(self):
				return self.numer
			def getDenom(self):
				return self.denom
			
		half = fraction(1, 2)

		print( half.getNumer() )
		print( half.getDenom() )
	</code></pre>
	<pre class="language-bash"><code>
		1
		2
	</code></pre>
	<p>
		We can use getters to define more complex methods. For example, adding and
		subtracting fractions:
	</p>
	<pre class="language-python"><code>
		class fraction(object):
			def __init__(self, numer, denom):
				self.numer = numer
				self.denom = denom
			def __str__(self):
				return f'{self.numer}/{self.denom}'
			
			# getters
			def getNumer(self):
				return self.numer
			def getDenom(self):
				return self.denom
			
			# add fractions
			def __add__(self, other):
				numerNew =   (other.getDenom() * self.getNumer()) \ 
								+ ( other.getNumer() * self.getDenom())
				denomNew = other.getDenom() * self.getDenom()
				return fraction(numerNew, denomNew)
			
			# subtract fractions
			def __sub__(self, other):
				numerNew =   (other.getDenom() * self.getNumer()) \
								- (other.getNumber * self.getDenom)
				denomNew = other.getDenom() * self.getDenom()
				return fraction(numerNew, denomNew)
				
		oneHalf = fraction(1,2)
		oneThird = fraction(1,3)
		
		foo = oneHalf + oneThird
		
		print(foo)
	</code></pre>
	<pre class="language-bash"><code>
		5/6
	</code></pre>
	<p>
		Parfait. The getters stand in contrast to
		<span class="term">setters</span> &mdash;
		<span class="monoText">self.numer = numer</span> and
		<span class="monoText">self.denom = denom</span>. Why do we use getters
		instead of setters in the method definitions? Because we never want to
		modify an object's internal representation. Getters ensure that any
		computation or modification is performed on anything but the internal
		representation. That said, we now have the ability to create new instances
		of <span class="monoText">fraction</span> by performing arithmetic operators
		on existing instances. Let's add one more method: Converting the
		<span class="monoText">fraction</span> instances into floats:
	</p>
	<pre class="language-python"><code>
		class fraction(object):
			def __init__(self, numer, denom):
				self.numer = numer
				self.denom = denom
			def __str__(self):
				return f'{self.numer}/{self.denom}'
			
			# getters
			def getNumer(self):
				return self.numer
			def getDenom(self):
				return self.denom

			# add fractions
			def __add__(self, other):
				numerNew =   (other.getDenom() * self.getNumer()) \ 
								+ ( other.getNumer() * self.getDenom())
				denomNew = other.getDenom() * self.getDenom()
				return fraction(numerNew, denomNew)
			
			# subtract fractions
			def __sub__(self, other):
				numerNew =   (other.getDenom() * self.getNumer()) \
								- (other.getNumber * self.getDenom)
				denomNew = other.getDenom() * self.getDenom()
				return fraction(numerNew, denomNew)
			
			# convert fractions into floats
			def convert(self):
				return self.getNumer() / self.getDenom()
				
		oneHalf = fraction(1,2)
		oneThird = fraction(1,3)
		
		foo = oneHalf + oneThird
		foo_float = foo.convert()
		
		print(foo_float)
	</code></pre>
	<pre class="language-bash"><code>
		0.8333333333333334
	</code></pre>
	<p>Great, it works.</p>
</section>

<section id="creating_sets_in_python">
	<p>
		<span class="topic">Application: Creating a Set of Integers.</span> A common
		mathematical entity is a <span class="italicsText">set</span>. Sets in
		mathematics inherenlty have no order &mdash; they are just a collection, or
		gathering, of elements. Let's create a new type that represents a set of
		integers, initially empty. Furthermore, for this particular set
		implementation, we depart from set theory's permissibility of non-uniqueness
		of elements, and require that a particular integer can appear only once in a
		set. In computer science, we call this property &mdash; an element appears
		only once in a collection &mdash;
		<span class="term">representational invariance</span>. The elements in such
		a collection are called
		<span class="italicsText">representational invariants</span>.
	</p>
	<p>
		Step 1: What will be the class's internal representation? Here we will use a
		<span class="monoText">list</span> to store the set's elements.
	</p>
	<p>
		Step 2: What will be the class's interface? Given that the class is supposed
		to represent a set, we want three particular methods: (1)
		<span class="monoText">insert(e)</span>, which inserts an integer
		<span class="monoText">e</span> if it isn't in the set already; (2)
		<span class="monoText">member(e)</span>, which returns
		<span class="monoText">True</span> if integer
		<span class="monoText">e</span> is in the set, otherwise
		<span class="monoText">False</span>; and (3)
		<span class="monoText">remove(e)</span>, which removes integer
		<span class="monoText">e</span> from the set and returns an error if no such
		integer exists (we should always inform a reader she is attempting to remove
		something that does not exist).
	</p>
	<pre class="language-python"><code>
		class intSet(object):
			def __init__(self):
				self.vals = []
			
			# methods
			def insert(self, e):
				if not e in self.vals:
					self.vals.append(e)
			def member(self, e):
				return e in self.vals
			def remove(self, e):
				try:
					self.vals.remove(e)
				except:
					raise ValueError(f"{e} not found")
			
			# print output
			def __str__(self):
				self.vals.sort()
				result = ''
				for e in self.vals:
					result = result + str(e) + ','
				return '{' + result[:-1] + '}'
	</code></pre>
	<p>
		Notice that in our code, we took advantage of the existing properties of
		lists. This is great example of why modularization is so important. We take
		existing methods and objects, and use them to create more methods and
		objects. Let's test our new data type:
	</p>
	<pre class="language-python"><code>
		class intSet(object):
			def __init__(self):
				self.vals = []
			
			# methods
			def insert(self, e):
				if not e in self.vals:
					self.vals.append(e)
			def member(self, e):
				return e in self.vals
			def remove(self, e):
				try:
					self.vals.remove(e)
				except:
					raise ValueError(f"{e} not found")
			
			# print output
			def __str__(self):
				self.vals.sort()
				result = ''
				for e in self.vals:
					result = result + str(e) + ','
				return '{' + result[:-1] + '}'

		naturals = intSet()
		print(naturals)
		
		naturals.insert(1)
		print(naturals)
		
		naturals.insert(2)
		print(naturals)
		
		naturals.insert(3)
		print(naturals)
		
		naturals.insert(1)
		print(naturals)
		
		is_one_in_naturals = naturals.member(1)
		print(is_one_in_naturals)
		
		naturals.remove(3)
		print(naturals)
		
		naturals.remove(4)
		print(naturals)	
	</code></pre>
	<pre class="language-bash"><code>
		{}
		{1}
		{1,2}
		{1,2,3}
		{1,2,3}
		True
		{1,2}
		ValueError: 4 not found
	</code></pre>
	<p>
		Success. Again, observe the way we used the existing methods for lists to
		create a method for a new data type. This the whole point of object-oriented
		programming: Grouping data and methods together into an object (a class),
		and using existing objects (classes) to create more complex objects grouping
		data and methods (classes).
	</p>
</section>

<section id="hierarchies">
	<h4>Inheritance</h4>
	<p>
		As aforementioned, classes are premised on classification. A key component
		of classification is the concept of
		<span class="italicsText">hierarchy</span>. Let's explore that concept in
		terms of Python programming.
	</p>
	<p>
		Classes can have hierarchies. Consider, for example, the following
		hierarchy:
	</p>
	<figure>
		<img src="{% static 'images/number_hierarchy.svg' %}" alt="num hierarchy" loading="lazy" />
	</figure>
	<p>
		As we can see, hierarchies can be complicated, and many problems can be
		simplified if we break them down along the hierarchy.
	</p>
	<p>
		At the very top of the hierarchy is the
		<span class="term">parent class</span>. Every class beneath the parent class
		is called a <span class="term">child class</span>. The parent class is said
		to be the <span class="term">superclass</span> of the child class, and the
		child class is said to be the <span class="term">subclass</span> of the
		parent class.
	</p>
	<p>
		Every subclass inherits all data attributes (state) and procedural
		attributes (behavior) of the parent class. However, we are free to add more
		data attributes, more procedural attributes, and override existing
		attributes with a subclass.
	</p>
	<p>
		Let's suppose we have a parent class called
		<span class="monoText">Animal</span>, and three child classes:
		<span class="monoText">Person</span>, <span class="monoText">Cat</span>, and
		<span class="monoText">Rabbit</span>. Then suppose the
		<span class="monoText">Person</span> class has the subclass
		<span class="monoText">Student</span>. We begin with the parent class,
		<span class="monoText">Animal</span>:
	</p>
	<pre class="language-python"><code>
		class Animal(object):
			def __init__(self, age):
				self.age = age
				self.name = None
			def get_age(self):
				return self.age
			def get_name(self):
				return self.name
			def set_age(self, newAge):
				self.age = newAge
			def set_name(self, newName):
				self.name = newName
			def __str__(self):
				return f"animal: {self.name} : {self.age}"
	</code></pre>
	<p>
		In the <span class="monoText">Animal</span> class above, we pass
		<span class="monoText">object</span> as a parameter, which tells Python that
		this class inherits all of Python's built-in objects and methods. This in
		turn means that every subclass of <span class="monoText">Animal</span> will
		inherit the same.
	</p>
	<p>
		Now we can define a subclass of <span class="monoText">Animal</span>,
		<span class="monoText">Cat</span>:
	</p>
	<pre class="language-python"><code>
		class Cat(Animal):
			def speak(self):
				print("meow")
			def __str__(self):
				return f"cat: {self.name} : {self.age}"
	</code></pre>
	<p>
		Notice that rather than passing <span class="monoText">object</span> as a
		parameter, we passed in <span class="monoText">Animal</span>. This is
		because <span class="monoText">Cat</span> is a subclass of
		<span class="monoText">Animal</span>, so it inherits all the properties of
		<span class="monoText">Animal</span>. Notice further that we did not
		explicitly write <span class="monoText">__init__</span>. Again, this is
		because <span class="monoText">Cat</span> inherits everything from
		<span class="monoText">Animal</span>. This is also why we can use
		<span class="monoText">self.name</span> and
		<span class="monoText">self.age</span>.
	</p>
	<p>All of the above defined, let us test:</p>
	<pre class="language-python"><code>
		wooster = Cat(1)
		wooster.set_name('Wooster')
		print(wooster.get_name())
	</code></pre>
	<pre class="language-bash"><code>
		Wooster
	</code></pre>
	<p>
		Our hierarchy works so far. Let's define another subclass,
		<span class="monoText">Rabbit</span>:
	</p>
	<pre class="language-python"><code>
		class Rabbit(Animal):
			def speak(self):
				print("meep")
			def __str__(self):
				return "rabbit: {self.name} : {self.age}"
	</code></pre>
	<p>Testing:</p>
	<pre class="language-python"><code>
		bugs = Rabbit(2)
		bugs.speak()
	</code></pre>
	<pre class="language-bash"><code>
		meep
	</code></pre>
	<p>
		Now, suppose we made an instance of
		<span class="monoText">Animal</span> called
		<span class="monoText">foobar</span>:
	</p>
	<pre class="language-python"><code>
		foobar = Animal(1)
		foobar.speak()
	</code></pre>
	<pre class="language-bash"><code>
		AttributeError: 'Animal' object has no attribute 'speak'
	</code></pre>
	<p>
		We get an <span class="monoText">AttributeError</span>. This is because the
		<span class="monoText">speak</span> method is found only in
		<span class="monoText">Cat</span> and <span class="monoText">Rabbit</span>.
		This is an instance of <span class="monoText">Animal</span>, which contains
		no such method. Remember: Only the subclasses inherit the superclass's
		properties. The superclass does not, in any way, inherit a subclass's
		properties (that would, after all, defeat the purpose of a hierarchy).
	</p>
	<p>Let's add one more class, <span class="monoText">Person</span>:</p>
	<pre class="language-python"><code>
		def __init__(self, name, age):
			Animal.__init__(self, age)
			Animal.set_name(self, name)
			self.friends = []
		def get_friends(self):
			return self.friends
		def add_friend(self, fname):
			if fname not in self.friends:
				self.friends.append(fname)
		def speak(self):
			print("hello")
		def age_diff(self, other):
			diff = self.get_age() - other.get_age()
			if self.age > other.age:
				print(f"{self.name} is {diff} years older than {other.name}.")
			else:
				print(f"{self.name} is {-diff} years younger than {other.name}.")
		def __str__(self):
			return f"Person: {self.name} : {self.age}"
	</code></pre>
	<p>
		Notice here that we used a different form of the
		<span class="monoText">__init__</span> method. Here, we called
		<span class="monoText">Animal</span> itself. In this form, we are telling
		Python to call the <span class="monoText">__init__</span> method for
		<span class="monoText">Animal</span>. We also called the
		<span class="monoText">set_name()</span> method associated with
		<span class="monoText">Animal</span>. The rest of the code, we create new
		data and procedural attributes for <span class="monoText">Person</span>.
	</p>
	<p>
		Finally, let's create the last class, a subclass of
		<span class="monoText">Person</span> called
		<span class="monoText">Student</span>:
	</p>
	<pre class="language-python"><code>
		class Student(Person):
			def __init__(self, name, age, major=None):
				Person.__init__(self, name, age)
				self.major = major
			def change_major(self, major):
				self = major
			def __str__(self):
				return f"student : {self.name} : self.age : self.major"
	</code></pre>
</section>

<section id="class_variables">
	<p>
		<span class="topic">Class Variables v. Instance Variables.</span> In every
		instance of a class, we have
		<span class="term">instance variables</span> &mdash; the data attributes
		stored in each instance. As such, these variables are specific to an
		instance, created for each instance, and belong to that instance. We ensure
		that these variables are created and used by referencing the generic name
		<span class="monoText">self</span> in the class definition.
	</p>
	<p>
		In contrast to instance variables are
		<span class="term">class variables</span> &mdash; these are the variables
		that <span class="italicsText">belong to the class</span> &mdash; they are
		defined inside the class, but outside any class methods, including
		<span class="monoText">__init__</span>. These variables are
		<span class="italicsText">shared among all instances of the class</span>.
	</p>
	<p>To illustrate, recall our <span class="monoText">Animal</span> class:</p>
	<pre class="language-python"><code>
		class Animal(object):
			def __init__(self, age):
				self.age = age
				self.name = None
			def get_age(self):
				return self.age
			def get_name(self):
				return self.name
			def set_age(self, newAge):
				self.age = newAge
			def set_name(self, newName):
				self.name = newName
			def __str__(self):
				return f"animal: {self.name} : {self.age}"
	</code></pre>
	<p>
		Each of the variables above, <span class="monoText">self.age</span>,
		<span class="monoText">self.name</span>, etc., are
		<span class="italicsText">instance variables</span>. Now, consider the
		follow class definition for <span class="monoText">Rabbit</span>, with a
		<span class="monoText">tag</span> variable:
	</p>
	<pre class="language-python"><code>
		class Rabbit(Animal):
			tag = 1
			def __init__(self, age, parent1=None, parent2=None)
				Animal.__init__(self, age)
				self.parent1 = parent1
				self.parent2 = parent2
				self.rabbit_id = Rabbit.tag
				Rabbit.tag += 1
	</code></pre>
	<p>
		The <span class="monoText">tag</span> variable above is a
		<span class="italicsText">class variable</span>, accessible to all instances
		of the class <span class="monoText">Rabbit</span>. In this case,
		<span class="monoText">tag</span>, is used as a unique identifier of each
		instance of <span class="monoText">class</span> &mdash; every new instance
		has a <span class="monoText">tag</span> equal to the previous instance's
		<span class="monoText">tag</span> plus 1.
	</p>
</section>
{% endblock %}
