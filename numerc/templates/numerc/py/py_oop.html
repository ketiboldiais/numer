{% extends '../layout.html' %} {% load static %} 

{% block description %}
<meta name="description" content="Python: Object-oriented programming">
{% endblock %}
{% block title %}
<title>Python OOP</title>
{% endblock %}

{% block content %}
<section id="object_oriented_programming">
	<h3>Object Oriented Programming</h3>
	<p>
		The ability to define functions allows us to write procedures and treat them
		as though they were built into the language, just like
		<span class="monoText">+, -, /, *, %</span> operators, or the build in
		methods like <span class="monoText">len()</span>.
	</p>
	<p>
		Now we want to do the same thing with data &mdash; creating
		<span class="italicsText">objects</span> and
		<span class="italicsText">classes of objects</span>. This ability
		drastically increases our ability to write complex and efficient programs.
	</p>
	<p>
		We have already encountered a number of objects:
		<span class="monoText">int</span>, <span class="monoText">string</span>,
		<span class="monoText">boolean</span>, etc. These are all data objects. We
		have also seen data structures, which themselves are data objects: tuples,
		lists, and dictionaries.
	</p>
	<p>
		All of these objects have (1) a <span class="italicsText">type</span>; (2)
		an <span class="italicsText">internal data representation</span> - whether
		the object is primitive or composite; and (3) a set of procedures for
		interacting with that particular object.
	</p>
	<p>
		The following are all <span class="term">instances</span> of a data object
		type: <span class="monoText">8</span> is an instance of
		<span class="monoText">int</span>; <span class="monoText">True</span> is an
		instance of <span class="monoText">boolean</span>;
		<span class="monoText">2.44</span> is an instance of
		<span class="monoText">float</span>;
		<span class="monoText">'hello'</span> is an instance of
		<span class="monoText">string</span>.
	</p>
	<p>
		All of this lends to an underlying principle grounding Python &mdash; nearly
		everything in Python is an object with a type. Objects, more generally, are
		<span class="italicsText">data abstractions</span>. That abstraction
		captures two things: (a) the
		<span class="italicsText">data attributes</span> and (b) it defines the
		data's <span class="italicsText">interface</span> through
		<span class="italicsText">methods</span> (procedures), which has the effect
		of defining the data object's
		<span class="italicsText">behavior</span> while hiding the object's
		implementation.
	</p>
	<p>
		With every data object, we can create new instances of that data object's
		type. Checking that ability, we can also destroy instances of that
		particular data object's type, either explicitly with methods like
		<span class="monoText">del</span>, or implicitly by allowing Python's
		garbage collection to eventually remove them from memory.
	</p>
	<p>
		To repeat, data objects are abstractions, just as functions are
		abstractions. For example, consider the data type
		<span class="monoText">list</span>. How are lists represented internally? It
		turns out lists in Python are
		<span class="italicsText">linked lists</span> &mdash; each list element
		consists of (a) the literal stored (itself a data object), and (b) a pointer
		to the next element in the list. We have many ways of manipulating the list:
		we can index, obtain length, find the max, etc. The data object
		<span class="monoText">list</span> allows us to create, manipulate, and
		destroy lists without worrying about the lower level implementation details
		&mdash; allocating memory, assigning pointers, freeing memory, etc. Data
		objects abstract away the technicalities.
	</p>
</section>

<section id="the_power_of_oop">
	<h4>The Value of Object-Oriented Programming</h4>
	<p>
		Object-oriented programming is a powerful approach to tackling programming
		problems because it bundles together things (objects) that share common
		attributes and procedures that operate on those attributes. Grouping similar
		things together because of their characteristics and what we can do based on
		those characters is something we do frequently not only in programming, but
		in real life as well. We can add two integers together, but it makes no
		sense to add a cat and a dog. We can determine what dry foods to feed a cat
		and what to feed a dog, but it makes no sense to ask what dry foods we
		should feed Booleans.
	</p>
	<p>
		Object-oriented programming abstracts away all of the lower level questions
		we ask: Is this a dog? Is this a cat? Is this a number? What happens when I
		add? What happens if the food is <span class="italicsText">Cereal K9</span>?
		We encapsulate all of these lower level details in a class, so we do not
		have ask them everytime we work with instances of that class. Because of
		<span class="italicsText">inheritance</span>, all of the attributes and
		methods in the class <span class="monoText">dog</span> will work for the
		sub-classes <span class="monoText">shiba inu</span>,
		<span class="monoText">German shephard</span>, and
		<span class="monoText">pitbull</span>. And the cherry on top: We can treat
		these classes as if Python built them in from the very beginning &mdash; we
		are, in a sense, extending the language.
	</p>
	<p>
		The whole concept of classes is based on the idea of classification.
		Persians, Siamese, and British Shorthairs are all cats. Cats, dogs, seals,
		dugongs, rabbits, and cows are all mammals. Mammals, reptiles, amphibians,
		and insects are all animals. Animals, plants, bacteria, and fungi are all
		living organisms. All living organisms contain carbon, so that data
		attribute is inherited by everything below. All living organisms propogate,
		so we might define a method for propogate inherited by everything below, and
		modify it accordingly for each of the subclasses &mdash; some need a mate;
		some have certain gestation periods; some have limits on how much they can
		propogate given a certain amount of time. These are all
		<span class="italicsText">layers of abstraction</span>.
	</p>
	<p>
		<span class="topic">Dangers in Python.</span> Python gives us an enormous
		amount of freedom when creating classes and using instances of those
		classes. That freedom, however, comes at a price &mdash; revealing and
		allowing too much access to information. As we've seen, we can access data
		from outside the class definition easily:
		<span class="monoText">instance.data_attribute</span>. We can also access
		and write to data from outside the class definition:
		<span class="monoText">instance.data_attribute = value</span>. We can also
		create data data attributes for an instance outside the class definition:
		<span class="monoText">instance.new_attribute = value</span>.
		<span class="boldText">Do not do these</span>. It is horrible style and can
		cause an inordinate amount of misery during testing and debugging.
	</p>
</section>
{% endblock %}
