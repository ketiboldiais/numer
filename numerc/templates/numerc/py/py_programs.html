{% extends "numerc/layout.html" %} {% block content %}

<section>
	<h4>Programs in Python</h4>
	<p>
		A Python <span class="boldItalics">program</span> is a sequence of
		<span class="italicsText">definitions</span> and
		<span class="italicsText">commands</span>. Definitions are
		<span class="italicsText">evaluated</span>, and commands are
		<span class="italicsText">executed</span> in a
		<span class="boldItalics">shell</span> &mdash; a window where we can type
		expressions to be passed to the Python interpreter. Commands are also called
		<span class="italicsText">statements</span> &mdash; they are expressions
		that tell the interpreter to do something.
	</p>
	<p>
		Both commands and expressions can be typed directly into a shell, or they
		can be stored in a Python file (files with the extension
		<span class="monoText">.py</span>), which is then
		<span class="italicsText">read</span> into a shell and evaluated.
	</p>
	<p>
		As we study Python, we'll likely notice how concise it is as a language.
		Without doubt, programs in Python are largely much shorter than programs in
		languages like C. Conciseness, readability, and user-friendliness, however,
		comes at a cost &mdash; speed. C is simply a much faster language when it
		comes to handling large data structures. This is largely because of how
		close the language is to the computer's hardware.
	</p>
	<p>
		Where C is a <span class="boldItalics">low-level language</span>, Python is
		a <span class="boldItalics">high-level language</span> &mdash; a language
		that abstracts away the low-level details we normally must handle. In C, we
		manage memory ourselves. If we find a more efficient approach, we can
		implement. If we see memory leaks, we can go straight to the source. In
		Python, we have no business handling memory. Instead, we are forced to use
		Python's general-purpose approach to memory management. This can be costly.
		Because memory management is not a one-size-fits-all issue, there will be
		instances were Python's approach is inefficient.
	</p>
	<p>
		Additionally, using a high-level language incurs overhead costs in memory
		consumption. In contrast to C code &mdash; which is handled directly by the
		<span class="italicsText">compiler</span> &mdash; Python code is handled by
		the Python <span class="italicsText">interpreter</span>. This distinction
		evidences two categories of programming languages: (1)
		<span class="boldItalics">compiled languages</span>, and (2)
		<span class="boldItalics">interpreted languages</span>.
	</p>
	<p>
		Interpreted languages are essentially programs themselves. The clearest
		evidence of this is when we execute Python code via our terminal:
	</p>
	<pre class="command-line language-bash" data-output=""><code>
	python foo.py
</code></pre>
	<p>
		That keyword, <span class="monoText">Python</span>, is a call to a program.
		More specifically, it is a call to the Python
		<span class="boldItalics">interpreter</span>, a program that translates our
		source code into 0s and 1s <span class="underlineText">on</span> execution,
		<span class="underlineText">without</span> compiling. This is different from
		C, where our source code must be translated into 0s and 1s &mdash; compiling
		&mdash; <span class="underlineText">before</span> execution. This difference
		is akin to analyzing a poem written in German when we only understand
		English. We can either (1) go to the first line, translate into English,
		analyze, then move to the second line and repeat, then the third line, the
		fourth, fifth, etc., or (2) translate the entire poem into English first,
		then analyze. The second approach is clearly faster. With the first
		approach, we have to translate each word one at a time, then put them all
		together, then analyze (likely changing our analysis because of previous
		lines), then move to the next line. In sum, whenever we execute Python code,
		we aren't just executing our code, we are also executing the interpreter's
		code. This incurs a certain amount of overhead in memory use and time.
	</p>
</section>

{% endblock %}
