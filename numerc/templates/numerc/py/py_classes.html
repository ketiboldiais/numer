{% extends '../layout.html' %} {% load static %} {% block content %}
<section id="python_classes">
	<h4>Classes</h4>
	<p>
		There is a distinction between <span class="italicsText">classes</span> and
		an <span class="italicsText">instance</span> of that class. The data object
		<span class="monoText">[1, 2, 3]</span> is an instance of the class
		<span class="monoText">list</span>.
	</p>
	<p>
		As a matter of Python programming, a <span class="term">class</span> is
		essentially a <span class="italicsText">type</span>. The use of
		&#8220;class&#8221; is largely a historic artifact. Originally, Python had
		both types and classes&mdash;separate, distinct, and never the twain shall
		meet. Types were built-in objects defined in C; classes were what the
		programmer built using a <span class="monoText">class</span> statement. The
		distinction existed because you could not legally use the two, type and
		class, together. That distinction has largely gone away.
	</p>
	<p>
		As a matter of type theory, however, there is a distinction between types
		and classes. A <span class="italicsText">type</span> is a collection of all
		the common features of
		<span class="italicsText">a set of objects</span> with the
		<span class="italicsText">same characteristics</span>. A
		<span class="italicsText">class</span>, on the other hand, is a specific
		<span class="italicsText">type</span> &mdash; it defines how a particular
		object is created. In other words, all classes are types, but not all types
		are classes.
	</p>
	<p>
		For example, tuples, lists, dictionaries, functions,
		<span class="monoText">int</span>, <span class="monoText">float</span>, and
		<span class="monoText">boolean</span> are all types. But
		<span class="monoText">int</span>, <span class="monoText">float</span>, and
		<span class="monoText">boolean</span> are not classes; they are are
		primitives. Arrays, tuples, dictionaries, and functions, however, are
		classes.
	</p>
	<p>
		<span class="topic">Object-Oriented Programming.</span> The ability to
		create classes is our forray into
		<span class="italicsText">object-oriented programming</span> &mdash; the
		programming paradigm where data is bundled with procedures into an object
		(in Python, a class), and modularize programs with such objects. There are
		several advantages to object-oriented programming.
	</p>
	<p>
		First, it embodies a
		<span class="italicsText">divide-and-conquer</span> development approach. By
		modularizing our programs into classes, we can implement and test each class
		separately. Not only does this ease testing and debugging, it reduces
		program complexity.
	</p>
	<p>
		Second, by encouraging us to use classes as much as we can, we have more
		pieces of reusable code. Many third-party Python modules (i.e., libraries)
		define new classes. Each of those classes have separate environments
		(avoiding collisions with our own function names), which in turn allows us
		to use pre-existing classes throughout our code. The same idea applies for
		our own modules. Furthermore, <span class="italicsText">inheritance</span>,
		a topic to be discussed in later sections, allows us to create
		<span class="italicsText">subclasses</span>, which in turn redefine or
		extend a selected <span class="italicsText">subset</span> of the
		<span class="italicsText">superclass</span>'s behavior.
	</p>
	<p>
		<span class="topic">Creating Classes.</span> Implementing, or creating, a
		class involves two steps: (1) defining the class name, and (2) defining the
		class attributes. When we use the class, we (a) create instances of objects
		of that class, and (b) perform operations on those instances. All that said,
		let us now turn to examples.
	</p>
	<p>
		To create a class, we use the symbol <span class="monoText">class</span>.
		The general form:
	</p>
	<figure class="math-display">
		<pre class="language-pseudo"><code>
			<span class="blueText">class</span> class_name(<span class="blueText">object</span>):
				⟨attributes⟩
		</code></pre>
	</figure>
	<p>
		Like <span class="monoText">def</span>, we indent code to tell Python which
		statements (the class's <span class="term">attributes</span>) are part of
		the <span class="term">class definition</span>. The symbol
		<span class="monoText">object</span> tells Python that
		<span class="monoText">class_name</span> is a Python object and
		<span class="italicsText">inherits</span> all its attributes. In other
		words, <span class="monoText">class_name</span> is a
		<span class="term">subclass</span> of <span class="monoText">object</span>,
		and <span class="monoText">object</span> is a
		<span class="term">superclass</span> of
		<span class="monoText">class_name</span>. A subclass always inherits from
		its superclass. Thus, the general form of a class definition is really:
	</p>
	<figure class="math-display">
		<pre class="language-pseudo"><code>
			class class_name(class_parent):
				⟨class attributes⟩
		</code></pre>
	</figure>
	<p>
		<span class="topic">Attributes.</span> The data and procedures beloning to a
		class are called the class's <span class="italicsText">attributes</span>.
		Thus, all attributes fall into two kinds: (a)
		<span class="term">data attributes</span> and (b)
		<span class="term">methods</span>. The
		<span class="italicsText">data attributes</span> are the other objects that
		make up the class. For example, suppose we had a class called
		<span class="monoText">coordinates</span>. That class might itself contain
		two objects: an object called <span class="monoText">x_coordinate</span>,
		and another object called <span class="monoText">y_coordinate</span>.
	</p>
	<p>
		The <span class="italicsText">methods</span> are the functions that work
		only within that class (this is where the distinction betwee
		<span class="italicsText">methods</span> and
		<span class="italicsText">functions</span> arises &mdash; all methods are
		functions, but not all functions are methods, but all methods and functions
		are procedures). For example, for the
		<span class="monoText">coordinate</span> class, we might have a method that
		calculates the distance between two
		<span class="monoText">coordinate</span> objects.
	</p>
	<p>
		<span class="topic">Creating Instances of an Class.</span> To use the class,
		we must define how to create an instance of the class. To do so, we use the
		the special method <span class="monoText">__init__()</span>. For example:
	</p>
	<pre class="language-python"><code>
		class Coordinate(object):
			def __init__(self, x, y):
				self.x = y
				self.y = y
	</code></pre>
	<p>
		The <span class="monoText">__init__()</span> method is a built-in method, or
		<span class="term">reserved method</span>, in Python for creating instances
		of a class. This particular kind of method is found in many other languages
		that support object-oriented programming like Java and C++, and is more
		broadly called a <span class="term">constructor</span>.
	</p>
	<p>
		The symbol <span class="monoText">self</span> is a special variable
		parameter, more specifically an object, that refers to an instance of the
		class. This symbol logically follows when we consider the following code:
	</p>
	<pre class="language-python"><code>
		class Coordinate(object):
			def __init__(self, x, y):
				self.x = x
				self.y = y

		origin = Coordinate(0,0) 
		point_A = Coordinate(5,5)
	</code></pre>
	<p>
		In the final line, we have an instance of the
		<span class="monoText">coordinate</span> class called
		<span class="monoText">origin</span>. That instance is passed into the
		<span class="monoText">class</span> definition as a parameter, by virtue of
		the special parameter <span class="monoText">self</span>.
	</p>
	<p>
		Inside the class definition, we have two statements:
		<span class="monoText">self.x = x</span> and
		<span class="monoText">self.y = y</span>. The values passed in the last
		line, <span class="monoText">coordinate(0,0)</span> are passed into the
		definition, and bound to <span class="monoText">self.x</span> and
		<span class="monoText">self.y</span>. The two statements &mdash;
		<span class="monoText">self.x</span> and
		<span class="monoText">self.y</span> &mdash; are examples of
		<span class="italicsText">data attributes</span>. More specifically,
		<span class="monoText">self.x</span> and
		<span class="monoText">self.y</span> are called
		<span class="term">instance variables</span>.
	</p>
	<p>
		Let's see what the value bound to <span class="monoText">origin</span> is:
	</p>
	<pre class="language-python"><code>
		class Coordinate(object):
			def __init__(self, x, y):
				self.x = x
				self.y = y

		origin = Coordinate(0,0) 
		point_A = Coordinate(5,5)

		print(origin)
		print(point_A)
	</code></pre>
	<pre class="language-bash"><code>
		&lt;__main__.Coordinate object at 0x7f5651ac9d00&gt;
		&lt;__main__.Coordinate object at 0x7f5651a947c0&gt;
	</code></pre>
	<p>
		Great. The definition worked just fine; we can see the two instances were
		created successfully. Notice that we did not explicitly pass an argument for
		the <span class="monoText">self</span> parameter. This is because the
		argument for the <span class="monoText">self</span> parameter is the
		instance itself. Python automatically creates a pointer to the instance for
		the definition to use.
	</p>
	<p>
		Now, once we have created an instance of the class, we have instance
		variables we can access:
	</p>
	<pre class="language-python"><code>
		class Coordinate(object):
			def __init__(self, x, y):
				self.x = x
				self.y = y

		origin = Coordinate(0,0) 
		point_A = Coordinate(5,5)

		print(origin.x)
		print(origin.y)
		print(point_A.x, point_A.y)
	</code></pre>
	<pre class="language-bash"><code>
		0
		0
		5 5
	</code></pre>
	<p>
		How does this all work? When we write
		<span class="monoText">origin.x</span>, the symbol
		<span class="monoText">origin</span> points to a
		<span class="italicsText">frame</span>, just like function calls. Within the
		scope of that frame, there are values bound to data attribute variables
		(<span class="monoText">self.x = x</span>). The expression
		<span class="monoText">origin.x</span> is interpreted as getting the value
		of <span class="monoText">origin</span> (a frame) and then looking up the
		value associated with <span class="monoText">x</span> within that frame (the
		specific value ofthat instance).
	</p>
	<p>
		Note what this all means. We can now organize data and use them just as if
		they were literals:
	</p>
	<pre class="language-python"><code>
		class Coordinate(object):
			def __init__(self, x, y):
				self.x = x
				self.y = y

		origin = Coordinate(0,0)
		point_A = Coordinate(5,5)
		point_B = Coordinate(6,6)

		x_coordinates = [origin.x, point_A.x, point_B.x]

		print(x_coordinates)
	</code></pre>
	<pre class="language-bash"><code>
		[0, 5, 6]
	</code></pre>
	<p>Very cool.</p>
	<p>
		<span class="topic">Methods.</span> With classes, we can also include
		functions that work only with a particular class. For example, the
		<span class="monoText">.len()</span> function only works with objects that
		have a length property. Functions that work only for a particular class are
		called <span class="term">methods</span>. In contrast to data attributes,
		methods are a class's <span class="term">procedural attributes</span>.
	</p>
	<p>
		When we define methods, Python will always pass the actual object as the
		first argument. Thus, as we did with data attributes, we include the
		<span class="monoText">self</span> argument as the first argument whenever
		we define a method.
	</p>
	<p>
		Additionally, we use <span class="italicsText">dot notation</span> to access
		procedural data attributes (methods), just as we would data attributes. To
		create methods, we use the same general form employed for data attributes.
		Consider the following:
	</p>
	<pre class="language-python"><code>
		class Coordinate(object):
			def __init__(self, x, y):
				self.x = x
				self.y = y
			def distance(self, other):
				x_diff_sq = (self.x-other.x) ** 2
				y_diff_sq = (self.y-other.y) ** 2
				return (x_diff_sq + y_diff_sq) ** 0.5
	</code></pre>
	<p>
		As we can see, we define methods just as we would functions, with the added
		syntax of <span class="monoText">self</span> and the dot operator. We use
		the dot operator for both arguments because we are accessing data attributes
		for instances of the particular class,
		<span class="monoText">Coordinate</span>. Testing:
	</p>
	<pre class="language-python"><code>
		class Coordinate(object):
			def __init__(self, x, y):
				self.x = x
				self.y = y
			def distance(self, other):
				x_diff_sq = (self.x-other.x) ** 2
				y_diff_sq = (self.y-other.y) ** 2
				return (x_diff_sq + y_diff_sq) ** 0.5
		
		origin = Coordinate(0,0)
		pt_A = Coordinate(3,4) 
		distance_origin_to_A = pt_A.distance(origin)
		print(distance_origin_to_A)
	</code></pre>
	<pre class="language-bash"><code>
		5.0
	</code></pre>
	<p>
		Great, it worked perfectly. Notice how we called it. We wrote
		<span class="monoText">pt_A.distance(origin)</span>. This tells Python, go
		to the instance <span class="monoText">pt_A</span>, access the method
		<span class="monoText">distance</span>, pass
		<span class="monoText">pt_A</span> and
		<span class="monoText">origin</span> as arguments into the method's
		definition, and execute. This is the conventional way of calling the method.
		However, we can also call the method with:
	</p>
	<pre class="language-python"><code>
		class Coordinate(object):
			def __init__(self, x, y):
				self.x = x
				self.y = y
			def distance(self, other):
				x_diff_sq = (self.x-other.x) ** 2
				y_diff_sq = (self.y-other.y) ** 2
				return (x_diff_sq + y_diff_sq) ** 0.5
		
		origin = Coordinate(0,0)
		pt_A = Coordinate(3,4) 
		distance_origin_to_A = Coordinate.distance(pt_A, origin)
		print(distance_origin_to_A)
	</code></pre>
	<pre class="language-bash"><code>
		5.0
	</code></pre>
	<p>
		Both approaches above are correct, but the former is conventional in Python.
	</p>
	<p>
		Earlier, we saw passing an instance of a class on its own to the
		<span class="monoText">print</span> method results in the following output:
	</p>
	<pre class="language-python"><code>
		class Coordinate(object):
			def __init__(self, x, y):
				self.x = x
				self.y = y

		origin = Coordinate(0,0) 
		point_A = Coordinate(5,5)

		print(origin)
		print(point_A)
	</code></pre>
	<pre class="language-bash"><code>
		&lt;__main__.Coordinate object at 0x7f5651ac9d00&gt;
		&lt;__main__.Coordinate object at 0x7f5651a947c0&gt;
	</code></pre>
	<p>
		This is an example of an <span class="term">uninformative</span> print
		representation, and it is the default representation for class instances. We
		can, however, change this with the
		<span class="monoText">__str__</span> method. This allows us to see what the
		object looks like when we use the
		<span class="monoText">print</span> statement. Even better, the
		<span class="monoText">__str__</span> method allows us to dictate what the
		result of a <span class="monoText">print</span> statement should look like
		when we pass the particular instance as an argument:
	</p>
	<pre class="language-python"><code>
		class Coordinate(object):
			def __init__(self, x, y):
				self.x = x
				self.y = y
			def __str__(self):
				return f"<{self.x},{self.y}>"
		
		pt_A = Coordinate(5,5)
		print(pt_A)
	</code></pre>
	<pre class="language-bash"><code>
		&lt;5,5&gt;
	</code></pre>
	<p>
		This is a very useful method to have, partuclarly for debugging. We can also
		check for <span class="monoText">type</span>:
	</p>
	<pre class="language-python"><code>
		class Coordinate(object):
			def __init__(self, x, y):
				self.x = x
				self.y = y
			def __str__(self):
				return f"<{self.x},{self.y}>"
		
		pt_A = Coordinate(5,5)
		print(type(pt_A))
	</code></pre>
	<pre class="language-bash"><code>
		&lt;'__main__.Coordinate'&gt;
	</code></pre>
	<p>
		Another very useful method to have is to check if an instance is an instance
		of a particular class (especially useful for branching programs). To do so,
		we use the <span class="monoText">isinstance()</span> method:
	</p>
	<pre class="language-python"><code>
		class Coordinate(object):
			def __init__(self, x, y):
				self.x = x
				self.y = y
			def __str__(self):
				return f"<{self.x},{self.y}>"
		
		pt_A = Coordinate(5,5)

		test = isinstance(pt_A, Coordinate)

		print(test)
	</code></pre>
	<pre class="language-bash"><code>
		True
	</code></pre>
	<p>
		<span class="topic">Special Operators.</span> We can define what certain
		operators mean for instances of a particular object:
	</p>
	<figure class="table">
		<table class="loop_table">
			<thead>
				<th>Operator</th>
				<th>Description</th>
			</thead>
			<tbody>
				<tr>
					<td><span class="monoText">__add__</span></td>
					<td>
						Define <span class="monoText">self + other</span>. This defines what
						it means when two instances of the class are added.
					</td>
				</tr>
				<tr>
					<td><span class="monoText">__sub__</span></td>
					<td>
						Define <span class="monoText">self - other</span>. This defines what
						it means when two instances of the class are subtracted.
					</td>
				</tr>
				<tr>
					<td><span class="monoText">__eq__</span></td>
					<td>
						Define <span class="monoText">self == other</span>. This defines
						what it means for two instances of the class to be equal.
					</td>
				</tr>
				<tr>
					<td><span class="monoText">__ne__</span></td>
					<td>
						Define <span class="monoText">self != other</span>. This defines
						what it means for two instances of the class to be not equal.
					</td>
				</tr>
				<tr>
					<td><span class="monoText">__lt__</span></td>
					<td>
						Define <span class="monoText">self < other</span>. This defines what
						it means for one instance of the class to be less than another.
					</td>
				</tr>
				<tr>
					<td><span class="monoText">__le__</span></td>
					<td>
						Define <span class="monoText">self <= other</span>. This defines
						what it means for one instance of the class to be less than or equal
						to another.
					</td>
				</tr>
				<tr>
					<td><span class="monoText">__gt__</span></td>
					<td>
						Define <span class="monoText">self > other</span>. This defines what
						it means for one instance of the class to be greater than another.
					</td>
				</tr>
				<tr>
					<td><span class="monoText">__ge__</span></td>
					<td>
						Define <span class="monoText">self >= other</span>. This defines
						what it means for one instance of the class to be greater than or
						equal to another.
					</td>
				</tr>
				<tr>
					<td><span class="monoText">__len__</span></td>
					<td>
						Define <span class="monoText">self < other</span>. This defines what
						the length of an instance of the class is.
					</td>
				</tr>
			</tbody>
		</table>
	</figure>
	<p>
		For example, we might want to define what it means to subtract two
		<span class="monoText">Coordinate</span> objects:
	</p>
	<pre class="language-python"><code>
		class Coordinate(object):
			def __init__(self, x, y):
				self.x = x
				self.y = y
			def __str__(self):
				return f"<{self.x},{self.y}>"
			def __sub__(self, other):
				return Coordinate(self.x - other.x, self.y - other.y)
		
		pt_A = Coordinate(5,5)
		pt_B = Coordinate(1,3)

		test = pt_A - pt_B

		print(test)
	</code></pre>
	<pre class="language-bash"><code>
		&lt;4,2&gt;
	</code></pre>
</section>

<section id="example_class_fractions" class="grid-item">
	<p>
		<span class="topic">Application: Creating a Class for Fractions</span>.
		Let's apply what we know so far and create a new data type to represent
		fractions.
	</p>
	<p>
		Step 1: Internal representation. What do we need to represent this data type
		internally? We need two things: (1) a numerator, and (2) a denominator.
	</p>
	<p>
		Step 2: Interface. What are the methods we need? In other words, how should
		instances of <span class="monoText">fraction</span> interact with one
		another? Let's just start with the most basic things we do with fractions:
		(a) add and subtract, (b) convert to a <span class="monoText">float</span>,
		and (c) a <span class="monoText">print</span> representation.
	</p>
	<pre class="language-python"><code>
		class fraction(object):
			def __init__(self, numer, denom):
				self.numer = numer
				self.denom = denom
			def __str__(self):
				return f"{self.numer}/{self.denom}"
	</code></pre>
	<p>Testing:</p>
	<pre class="language-python"><code>
		class fraction(object):
			def __init__(self, numer, denom):
				self.numer = numer
				self.denom = denom
			def __str__(self):
				return f"{self.numer}/{self.denom}"
			
		half = fraction(1, 2)
		print(half)
	</code></pre>
	<pre class="language-bash"><code>
		1/2
	</code></pre>
	<p>Great, it works.</p>
	<p>
		<span class="topic">Accessing Data Attributes.</span> With classes, we can
		define how to access data attributes with <span class="term">getters</span>.
		Getters are what allow us to quickly access data attributes:
	</p>
	<pre class="language-python"><code>
		class fraction(object):
			def __init__(self, numer, denom):
				self.numer = numer
				self.denom = denom
			def __str__(self):
				return f"{self.numer}/{self.denom}"

			def getNumer(self):
				return self.numer
			def getDenom(self):
				return self.denom
			
		half = fraction(1, 2)

		print( half.getNumer() )
		print( half.getDenom() )
	</code></pre>
	<pre class="language-bash"><code>
		1
		2
	</code></pre>
	<p>
		We can use getters to define more complex methods. For example, adding and
		subtracting fractions:
	</p>
	<pre class="language-python"><code>
		class fraction(object):
			def __init__(self, numer, denom):
				self.numer = numer
				self.denom = denom
			def __str__(self):
				return f'{self.numer}/{self.denom}'
			
			# getters
			def getNumer(self):
				return self.numer
			def getDenom(self):
				return self.denom
			
			# add fractions
			def __add__(self, other):
				numerNew =   (other.getDenom() * self.getNumer()) \ 
								+ ( other.getNumer() * self.getDenom())
				denomNew = other.getDenom() * self.getDenom()
				return fraction(numerNew, denomNew)
			
			# subtract fractions
			def __sub__(self, other):
				numerNew =   (other.getDenom() * self.getNumer()) \
								- (other.getNumber * self.getDenom)
				denomNew = other.getDenom() * self.getDenom()
				return fraction(numerNew, denomNew)
				
		oneHalf = fraction(1,2)
		oneThird = fraction(1,3)
		
		foo = oneHalf + oneThird
		
		print(foo)
	</code></pre>
	<pre class="language-bash"><code>
		5/6
	</code></pre>
	<p>
		Parfait. The getters stand in contrast to
		<span class="term">setters</span> &mdash;
		<span class="monoText">self.numer = numer</span> and
		<span class="monoText">self.denom = denom</span>. Why do we use getters
		instead of setters in the method definitions? Because we never want to
		modify an object's internal representation. Getters ensure that any
		computation or modification is performed on anything but the internal
		representation. That said, we now have the ability to create new instances
		of <span class="monoText">fraction</span> by performing arithmetic operators
		on existing instances. Let's add one more method: Converting the
		<span class="monoText">fraction</span> instances into floats:
	</p>
	<pre class="language-python"><code>
		class fraction(object):
			def __init__(self, numer, denom):
				self.numer = numer
				self.denom = denom
			def __str__(self):
				return f'{self.numer}/{self.denom}'
			
			# getters
			def getNumer(self):
				return self.numer
			def getDenom(self):
				return self.denom

			# add fractions
			def __add__(self, other):
				numerNew =   (other.getDenom() * self.getNumer()) \ 
								+ ( other.getNumer() * self.getDenom())
				denomNew = other.getDenom() * self.getDenom()
				return fraction(numerNew, denomNew)
			
			# subtract fractions
			def __sub__(self, other):
				numerNew =   (other.getDenom() * self.getNumer()) \
								- (other.getNumber * self.getDenom)
				denomNew = other.getDenom() * self.getDenom()
				return fraction(numerNew, denomNew)
			
			# convert fractions into floats
			def convert(self):
				return self.getNumer() / self.getDenom()
				
		oneHalf = fraction(1,2)
		oneThird = fraction(1,3)
		
		foo = oneHalf + oneThird
		foo_float = foo.convert()
		
		print(foo_float)
	</code></pre>
	<pre class="language-bash"><code>
		0.8333333333333334
	</code></pre>
	<p>Great, it works.</p>
</section>
{% endblock %}
