{% extends "numerc/layout.html" %} {% block description %}
<meta name="description" content="Introduction to Python" />
{% endblock %} {% block title %}
<title>Machine Learning with Python: Intro</title>
{% endblock %} {% block content %}

<h1>Machine Learning & Data Science: Python</h1>
<section id="intro">
	<p>
		In this volume, we explore machine learning and data science. To effectively
		study these fields, we will first establish a firm grounding in our language
		of choice, Python. By become familiar with Python, we can focus more on
		machine learning and data science without the hindrances of syntax. Much of
		this volume's first few sections will serve as reviews of fundamentals and
		should appear familiar.
	</p>
	<p>
		Recall: A programming language provides a set of
		<span class="boldItalics">primitive operations</span>. With those primitive
		operations, we can write <span class="boldItalics">expressions</span>, which
		are what we use to perform computations. In all programming languages,
		expressions and computations have a
		<span class="boldItalics">value</span> &mdash; their
		<span class="italicsText">meaning</span>.
	</p>
	<p>
		More explicitly, any programming language will have the following
		properties:
	</p>
	<figure class="math-display">
		<div class="rule">
			<ol>
				<li><span class="term">primitives</span>;</li>
				<li>
					a <span class="term">means of combination</span> &mdash; how
					primitives are arranged to form expressions; and
				</li>
				<li>
					a <span class="term">means of abstraction</span> &mdash; a way of
					taking an expression and treating it as a primitive.
				</li>
			</ol>
		</div>
	</figure>
	<p>
		In most programming languages, there are several primitives: booleans,
		numbers, strings (or sequences of characters), and simple arithmetic
		operations (addition, subtraction, comparison, etc.). These primitives can
		be arranged and combined to form newer things, just as bricks of legos can
		be connected to form larger structures.
	</p>
	<p>
		Unlike legos, however, there are rules about how we can connect and arrange
		primitives. These rules fall into two categories: (1)
		<span class="boldItalics">syntax</span> and (2)
		<span class="boldItalics">semantics</span>. Syntax is the set of rules that
		defines what is a valid arrangement of primitives (an expression) in a given
		programming language. In English, the word arrangement "a plane head fly" is
		not a valid sentence, but the arrangement "a plane flies overhead" is.
		Programming languages have similar rules. In Python, the arrangement
		<span class="monoText">2.9"12"</span> is not a valid expression. But the
		arrangement <span class="monoText">2.9 * 12</span> is. When an expression
		satisfies all of a programming language's syntax rules, we say that the
		expression is <span class="boldItalics">syntatically valid</span>.
	</p>
	<p>
		Just as sentences in English have meaning, so too do expressions in
		programming languages. In computer science, an expressions meaning is
		governed by <span class="boldItalics">semantics</span> &mdash; the set of
		all rules that define <span class="italicsText">when</span> an expression
		has meaning, and what that meaning is. Within semantics, there are two
		subsets: (a) <span class="boldItalics">static semantics</span> and (b)
		<span class="boldItalics">full semantics</span>.
	</p>
	<p>
		Static semantics is the set of all rules determining
		<span class="italicsText">when</span> a syntactically valid expression has
		meaning. In English, for example, "me call Ishmael" is a syntactically valid
		arrangement of words &mdash; it has a subject and a predicate. But
		semantically, it does not make sense. The arrangement "call me Ishmael,"
		however, is both syntactically and semantically valid. The same goes for
		programming languages. In Python, the expression
		<span class="monoText">2.9 * "12"</span> is syntactically valid, but
		semantically invalid. The expression <span class="monoText">2.9 * 12</span>,
		however, is both syntactically and semantically valid. The rules determining
		why the second expression is semantically valid are the programming
		language's <span class="italicsText">static semantics</span>.
	</p>
	<p>
		Even if an expression is both syntactically and static semantically valid,
		it is still subject to the programming language's
		<span class="boldItalics">full semantics</span> &mdash; the rules
		determining <span class="italicsText">what</span> an expression means. In
		English, there is room for ambiguity. For example, consider the famous
		headline: "The British left Waffles on Falklands." The sentence could mean,
		(a) the British left a beloved breakfast food made of batter on the
		Falklands, or (b) the political British left couldn't decide on what do with
		the Falklands. We call this phenomenon
		<span class="boldItalics">syntactic ambiguity</span>. In programming
		languages, there is no such thing. The foundational rule of full semantics
		is that expressions have
		<span class="underlineText">only one</span> meaning. This is always the
		case, whether or not we expect it (a crucial point to remember when we
		execute code and get back strange results).
	</p>
</section>

<section id="python_language">
	<h2>The &#8220;Python&#8221; Language</h2>
	<p>
		We've been referring to Python as if it were a single language. The truth
		is, Python is actually just a language concept. That concept has numerous
		implementations, the most popular of which is CPython. Other implementations
		include IronPython (Python running on .NET), Jython (Python running on the
		Java Virtual Machine), PyPy (Python implemented with a JIT compiler),
		Stackless Python (CPython but with microthreading), and MicroPython (Python
		for micro controllers).
	</p>
</section>

{% endblock %}
