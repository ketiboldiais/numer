{% extends "numerc/layout.html" %} {% block description %}
<meta name="description" content="Introduction to Python" />
{% endblock %} {% block title %}
<title>Machine Learning with Python: Intro</title>
{% endblock %} {% block content %}

<h1>Machine Learning & Data Science: Python</h1>
<section id="intro">
	<p>
		In this volume, we explore machine learning and data science. To effectively
		study these fields, we will first establish a firm grounding in our language
		of choice, Python. By become familiar with Python, we can focus more on
		machine learning and data science without the hindrances of syntax. Much of
		this volume's first few sections will serve as reviews of fundamentals and
		should appear familiar.
	</p>
	<p>
		Recall: A programming language provides a set of
		<span class="boldItalics">primitive operations</span>. With those primitive
		operations, we can write <span class="boldItalics">expressions</span>, which
		are what we use to perform computations. In all programming languages,
		expressions and computations have a
		<span class="boldItalics">value</span> &mdash; their
		<span class="italicsText">meaning</span>.
	</p>
	<p>
		More explicitly, any programming language will have the following
		properties:
	</p>
	<figure class="math-display">
		<div class="rule">
			<ol>
				<li><span class="term">primitives</span>;</li>
				<li>
					a <span class="term">means of combination</span> &mdash; how
					primitives are arranged to form expressions; and
				</li>
				<li>
					a <span class="term">means of abstraction</span> &mdash; a way of
					taking an expression and treating it as a primitive.
				</li>
			</ol>
		</div>
	</figure>
	<p>
		In most programming languages, there are several primitives: booleans,
		numbers, strings (or sequences of characters), and simple arithmetic
		operations (addition, subtraction, comparison, etc.). These primitives can
		be arranged and combined to form newer things, just as bricks of legos can
		be connected to form larger structures.
	</p>
	<p>
		Unlike legos, however, there are rules about how we can connect and arrange
		primitives. These rules fall into two categories: (1)
		<span class="boldItalics">syntax</span> and (2)
		<span class="boldItalics">semantics</span>. Syntax is the set of rules that
		defines what is a valid arrangement of primitives (an expression) in a given
		programming language. In English, the word arrangement "a plane head fly" is
		not a valid sentence, but the arrangement "a plane flies overhead" is.
		Programming languages have similar rules. In Python, the arrangement
		<span class="monoText">2.9"12"</span> is not a valid expression. But the
		arrangement <span class="monoText">2.9 * 12</span> is. When an expression
		satisfies all of a programming language's syntax rules, we say that the
		expression is <span class="boldItalics">syntatically valid</span>.
	</p>
	<p>
		Just as sentences in English have meaning, so too do expressions in
		programming languages. In computer science, an expressions meaning is
		governed by <span class="boldItalics">semantics</span> &mdash; the set of
		all rules that define <span class="italicsText">when</span> an expression
		has meaning, and what that meaning is. Within semantics, there are two
		subsets: (a) <span class="boldItalics">static semantics</span> and (b)
		<span class="boldItalics">full semantics</span>.
	</p>
	<p>
		Static semantics is the set of all rules determining
		<span class="italicsText">when</span> a syntactically valid expression has
		meaning. In English, for example, "me call Ishmael" is a syntactically valid
		arrangement of words &mdash; it has a subject and a predicate. But
		semantically, it does not make sense. The arrangement "call me Ishmael,"
		however, is both syntactically and semantically valid. The same goes for
		programming languages. In Python, the expression
		<span class="monoText">2.9 * "12"</span> is syntactically valid, but
		semantically invalid. The expression <span class="monoText">2.9 * 12</span>,
		however, is both syntactically and semantically valid. The rules determining
		why the second expression is semantically valid are the programming
		language's <span class="italicsText">static semantics</span>.
	</p>
	<p>
		Even if an expression is both syntactically and static semantically valid,
		it is still subject to the programming language's
		<span class="boldItalics">full semantics</span> &mdash; the rules
		determining <span class="italicsText">what</span> an expression means. In
		English, there is room for ambiguity. For example, consider the famous
		headline: "The British left Waffles on Falklands." The sentence could mean,
		(a) the British left a beloved breakfast food made of batter on the
		Falklands, or (b) the political British left couldn't decide on what do with
		the Falklands. We call this phenomenon
		<span class="boldItalics">syntactic ambiguity</span>. In programming
		languages, there is no such thing. The foundational rule of full semantics
		is that expressions have
		<span class="underlineText">only one</span> meaning. This is always the
		case, whether or not we expect it (a crucial point to remember when we
		execute code and get back strange results).
	</p>
</section>

<section>
	<h4>Computability</h4>
	<p>
		Mathematics can be viewed as a
		<span class="boldItalics">formal system</span> &mdash; a set of meaningless
		symbols that can be manipulated according to a set of fixed rules, so as to
		produce meaning. For example, the game of chess is a formal system. The
		symbols are the pieces &mdash; king, rook, bishop, etc. &mdash; and the
		fixed set of rules consists of those governing how the pieces move. These
		pieces and rules do not have any meaning outside of chess. Philsophers and
		mathematicians like David Hilbert argued that mathematics should be viewed
		in this way.
	</p>
	<p>
		Hilbert's arguments responded to a lingering philosophical question at the
		very heart of mathematics &mdash; Is mathematics invented or discovered? By
		viewing mathematics as a formal system, the question could be addressed
		without shaking the foundations of all of mathematics.
	</p>
	<p>
		To construct a formal system, however, Hilbert needed
		<span class="italicsText">foundational axioms</span> &mdash; the rules that
		provide what is allowed and prohibited in creating the formal system. To
		construct these foundational axioms, Hilbert focused on the three things
		most valued in mathematics:
	</p>
	<ol>
		<li>consistency;</li>
		<li>completeness; and</li>
		<li>decidability</li>
	</ol>
</section>

<section>
	<p>
		<span class="topic">Consistency.</span> The property of consistency provides
		that no contradictions can be proven within the system. For example, if you
		prove that ${1 + 1 = 2,}$ you cannot then prove that ${1 + 1 \neq 2.}$
		Without consistency, the entire formal system is useless; we would never be
		certain of our results. This property was largely unchallenged at the time,
		but recent work in logical pluralism has raised some questions.
	</p>
</section>

<section>
	<p>
		<span class="topic">Completeness</span>. The property of completeness
		provides that there is a proof demonstrating that all true statements in the
		formal system can be proven within the system. I.e., for any given true
		statement in the formal system, we do not need to go outside the system to
		prove that it is true. As an aside, Hilbert's work on this particular
		property was largely demolished by the German logician Kurt Gödel (see
		Gödel's <span class="italicsText">incompleteness theorems</span>).
	</p>
</section>

<section>
	<p>
		<span class="topic">Decidability.</span> Decidability provides that there
		exists an <span class="italicsText">effective procedure</span> for deciding
		whether any particulary statement in the formal system is true or false.
	</p>
	<p>
		It is this final property, decidability, that caught the attention of a
		young computer scientist named Alan Turing. Turing's question was
		straightforward in statement: Is there an
		<span class="italicsText">effective procedure</span> for deciding whether
		any mathematical statement is true or false? It was this notion of an
		&#8220;effective procedure&#8221; that Turing was particularly interested
		in.
	</p>
	<p>
		Today, we know these effective procedures as
		<span class="boldItalics">algorithms</span>. During Turing's time, however,
		there was no such parlance. Back then, "computers" were humans, most often
		women, given a set of instructions on what and how to compute a particular
		result. These were mindless, mechanical tasks. Turing saw the process as an
		"effective procedure," consisting of a series of steps:
	</p>
	<ol>
		<li>The human reads the instructions;</li>
		<li>
			the human reads and writes symbols on a piece of paper in response to
			reading the instructions;
		</li>
		<li>
			the human occassionally erases a symbol and replaces it with a new symbol;
			and
		</li>
		<li>the human stops working when the computation is complete.</li>
	</ol>
	<p>
		The breakthrough was Turing's realization that all of the steps above could
		be performed by a theoretical machine. Instead of a human, there's a
		scanner. The scanner sees, erases, and writes one symbol at a time. Instead
		of a piece of paper, the scanner works with an infinitely long piece of tape
		lined with squares, each square containing one symbol (<span
			class="monoText"
			>0</span
		>, <span class="monoText">1</span>, or blank).
	</p>
	<p>
		But what about the instructions? How does the scanner know what to do?
		Indeed, the scanner has no brain. To solve this problem, Turing looked to
		the instructions and what humans were doing. The instructions were largely
		routine, mechanical tasks. As such, if the instructions were reduced to
		conditional statements (i.e., statements that can be ascribed the values
		true or false), we can translate the instructions into a form where the
		machine (a) sees if it's a <span class="monoText">1</span>, a
		<span class="monoText">0</span>, or a blank, and write something in
		response. In doing so, we provide the machine with
		<span class="boldItalics">internal states</span> &mdash; what the machine
		should do when a particular condition (e.g., seeing a
		<span class="monoText">0</span>, <span class="monoText">1</span>, or a
		blank) is true. And if we can provide internal states, we can also provide
		internal states leading to other internal states &mdash; the machine can
		perform much more complex computations.
	</p>
	<p>
		In sum, Turing's machine &mdash; what we now refer to as a
		<span class="boldItalics">Turing Machine</span> &mdash; could accept as
		input <span class="monoText">0</span>s and <span class="monoText">1</span>s
		and output <span class="monoText">0</span>s and
		<span class="monoText">1</span>s to perform computations. Better yet, the
		machine could perform computations endlessly, as it was not subject to the
		same human limitations of physical and mental exhaustion. Turing had
		constructed one definition for an effective procedure &mdash; an effective
		procedure is any procedure that can be computed by a Turing Machine in a
		finite amount of time.
	</p>
	<p>
		Turing machines lead to the
		<span class="boldItalics">Church-Turing thesis</span>: If a function is
		computable, then a Turing Machine can be programmed to compute it.
		Unfortunately for David Hilbert, not all problems have computational
		solutions. Turing proved that it was impossible to write an internal state
		for a Turing Machine that takes any arbitrary program as input, and prints
		<span class="monoText">true</span> if, and only if, the program will run
		forever. This is known as the
		<span class="boldItalics">halting problem</span>.
	</p>
	<p>
		While we lend sympathy to Hilbert's failed project, the Church-Turing thesis
		yields a bedrock principle in computer science:
		<span class="boldItalics">Turing completeness</span>. A programming language
		is said to be Turing complete if it can be used to simulate a Turing
		Machine. And if a programming language is Turing complete, then
		<span class="italicsText">anything</span> that can be programmed in that
		language can be programmed in any other Turing complete programming
		language. Of course, some programs are easier to implement in one language
		over the other; Piet, Brainfuck, CSS3+HTML5, and Whitespace are all Turing
		complete, but it would be odd to choose them over Matlab when implementing
		Fourier transforms. Nevertheless, as a matter of pure theory, all Turing
		complete languages are equal with respect to computational ability.
	</p>
</section>

<section id="python_language">
	<h2>The &#8220;Python&#8221; Language</h2>
	<p>
		We've been referring to Python as if it were a single language. The truth
		is, Python is actually just a language concept. That concept has numerous
		implementations, the most popular of which is CPython. Other implementations
		include IronPython (Python running on .NET), Jython (Python running on the
		Java Virtual Machine), PyPy (Python implemented with a JIT compiler),
		Stackless Python (CPython but with microthreading), and MicroPython (Python
		for micro controllers).
	</p>
</section>



{% endblock %}
