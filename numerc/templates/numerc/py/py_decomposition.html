{% extends '../layout.html' %} {% load static %} {% block content %}
<section id="decomp_and_abstraction">
	<h3>Decomposition and Abstraction</h3>
	<p>
		So far, the programs we've written have been contained in a single file,
		called a <span class="boldItalics">script</span>. Each file contains a piece
		of code, and each code is a sequence of instructions. This is fine for small
		problems.
	</p>
	<p>
		The problem, however, is that designing and programs in this way can easily
		lead to messy, disorganized, and confusing work with large problems. By
		large problems, we mean problems that require thousands of lines of code.
		Once our programs start spanning thousands of lines, it becomes
		extraordinarly difficult to keep track of every detail. Where is this code's
		output going? Where is this code's input coming from? What does this piece
		of code do? These are all difficult questions when our programs just run in
		a linear fashion in a single file.
	</p>
	<p>
		Because of this hurdle, we need a better way to
		<span class="italicsText">structure</span> our code. Good programming is
		concise and efficient &mdash; more code is not necessarily a good thing.
		Great programming, however, is <span class="italicsText">functional</span>.
		Whether a program is great or horrid comes down to functionality. One way to
		ensure our code is functional is to use
		<span class="boldItalics">functions</span>.
	</p>
	<p>
		Functions provide us a way to "box up" pieces of computation. More
		generally, functions provide a means of achieving two critical concepts in
		computational thinking:
	</p>
	<ol>
		<li>decomposition (also called modularity); and</li>
		<li>abstraction.</li>
	</ol>
	<p>
		We can think of abstraction by way of analogy. Consider the modern printer.
		Most individuals do not know how it actually works. How does this box like
		entity take inputs from my phone or computer and output paper with pictures
		or various glyphs? But, the fact that we do not know how it works does not
		prevent us from using it. Most of us can quickly set up a new printer and
		print away. This is the essence of abstraction &mdash; we do not need to
		know how a particular piece of code works to use it.
	</p>
	<p>
		Abstraction is the approach of suppressing detail &mdash; we want to perform
		a particular computation without having to see or write long pieces of code.
		Much like how using a printer does not require us to understand how it
		works, we want to have the ability to use pieces of code freely, without
		worrying about the low level details.
	</p>
	<p>
		To abstract these low level details, we must
		<span class="italicsText">decompose</span> problems &mdash; we break the
		problem down into different, self-contained pieces, then address each of
		those pieces individually.
	</p>
	<p>
		<span class="topic">How do we decompose?</span> To decompose a problem, we
		must first isolate the problem into smaller problems. These smaller problems
		are targeted by code unique to those problems. We call such code
		<span class="boldItalics">modules</span>. These modules are effectively
		divisions of code, and they must meet the following criteria:
	</p>
	<ul>
		<li>the module is self-contained;</li>
		<li>used to break up code;</li>
		<li>hides tedious details;</li>
		<li>the module's details are in fact hidden;</li>
		<li>does not require us to see the details;</li>
		<li>intended to be <span class="underlineText">reusable</span>;</li>
		<li>keeps code organized;</li>
		<li>keeps code coherent</li>
	</ul>
	<p>
		For the next few sections, we will decompose with
		<span class="italicsText">functions</span>. In later sections, we will
		decompose with <span class="italicsText">classes</span>.
	</p>
</section>
{% endblock %}
