{% extends '../layout.html' %} {% load static %} {% block content %}
<section id="mutating_aliasing_cloning">
	<h4>Mutating, Aliasing, &amp; Cloning</h4>
	<p>
		Lists are mutable data objects in memory. When we initialize a list, the
		list's name is a <span class="italicsText">variable name</span> that points
		to the list object in memory. Lists, however, have a unique characteristic
		&mdash; we can have multiple variables pointing to the same list. These
		different variables are all <span class="term">aliases</span> of the list
		object &mdash; they all refer to the list object.
	</p>
	<figure>
		<img
			src="{% static 'images/multiple_list_aliases.svg' %}"
			alt="multiple aliases"
			loading="lazy"
			class="sixty-p"
		/>
		<figcaption>
			Multiple variable names pointing to the same list object
		</figcaption>
	</figure>
	<p>
		What this means is, if a list has multiple aliases, and we change one of its
		aliases, that change will affect all of the other aliases. This is called a
		<span class="term">side effect</span>, and it is something we must always
		keep in mind when handling lists. For example, the
		<span class="monoText">sort()</span> proceudre will mutate the list and
		return nothing. But, the <span class="monoText">sorted()</span> procedure
		does not mutate the list, and because it returns a new, sorted list, we must
		assign it to a variable:
	</p>
	<pre class="language-python"><code>
		list_a = [3, 4, 1, 2]
		list_b = [9, 8, 6, 7]

		print('list_a before sorting = ', list_a)
		print('list_b before sorting = ', list_b)

		sorted_list_a = list_a.sort()

		print('sorted_list_a = ', sorted_list_a)
		print('list_a = ', list_a)

		sorted_list_b = sorted(list_b)

		print('sorted_list_b = ', sorted_list_b)
		print('list_b = ', list_b)
	</code></pre>
	<pre class="language-bash"><code>
		list_a before sorting =  [3, 4, 1, 2]
		list_b before sorting =  [9, 8, 6, 7]
		sorted_list_a =  None
		list_a =  [1, 2, 3, 4]
		sorted_list_b =  [6, 7, 8, 9]
		list_b =  [9, 8, 6, 7]
	</code></pre>
	<p>
		The example above is evidence of how dangerous list mutability can be. The
		statement <span class="monoText">list_a.sort()</span> mutates the original
		list. This danger is exacerbated when we have multiple names for the same
		list.
	</p>
	<p>
		Another way to understand this concept of multiple aliases is by way of
		analogy. Consider a famous individual, say Calvin Cordozar Broadus Jr. We
		can associate attributes with Mr. Broadus: creative, rich, rapper. Mr.
		Broadus has many other names &mdash; Snoop Dogg; Snoop Doggy Dogg; Snoop
		Lion; Bigg Snoop Dogg; Dogg Father; Snoop Rock; Snoopzilla; DJ Snoopadelic.
		All these names point to the same person. As such, all of Mr. Broadus's
		attributes, old and new or associated with government or entertainment name,
		are attributable to Mr. Broadus: Snoop Doggy Dogg is a rapper; Snoop Dogg is
		rich; Snoop Lion is a reggae performer &mdash; they all point to the same
		person, Mr. Broadus. The same phenomenon occurs for list aliases:
	</p>
	<pre class="language-python"><code>
		warm = ['red', 'yellow', 'orange']
		hot = warm

		print(warm)
		print(hot)

		hot.append('pink')

		print(warm)
	</code></pre>
	<pre class="language-bash"><code>
		['red', 'yellow', 'orange']
		['red', 'yellow', 'orange']
		['red', 'yellow', 'orange', 'pink']
	</code></pre>
	<p>
		Notice that when we appended the data object
		<span class="monoText">pink</span> to the list
		<span class="monoText">hot</span>, we also appended the data object to the
		list <span class="monoText">warm</span>. This is because both
		<span class="monoText">warm</span> and
		<span class="monoText">hot</span> point to the same list object. This is a
		side effect of manipulating lists. The danger in mutability comes from the
		fact that we might not have intended to manipulate
		<span class="monoText">warm</span>.
	</p>
	<p>
		On the other hand, the fact that two different names print the same list
		does not imply that they are aliases for the same list. In other words, the
		fact that some list name <span class="monoText">list_a</span> and some list
		name <span class="monoText">list_b</span> print what appeas to be the same
		list does not imply that <span class="monoText">list_a == list_b.</span> We
		can see this is the case by mutating one of the lists and checking it
		against the other:
	</p>
	<pre class="language-python"><code>
		list_a = [1, 2, 3]
		list_b = [1, 2, 3]

		print('list_a: ', list_a)
		print('list_b: ', list_b)

		list_b.append(4)

		print('list_b mutated')

		print('list_b: ', list_b)
		print('list_a: ', list_a)
	</code></pre>
	<pre class="language-bash"><code>
		list_a:  [1, 2, 3]
		list_b:  [1, 2, 3]
		list_b mutated
		list_b:  [1, 2, 3, 4]
		list_a:  [1, 2, 3]
	</code></pre>
	<p>
		Mutating <span class="monoText">list_b</span> does not affect
		<span class="monoText">list_a</span> because
		<span class="monoText">list_a</span> and
		<span class="monoText">list_b</span> point to different list objects.
	</p>
	<p>
		<span class="topic">Cloning Lists.</span> We can also make copies of, or
		<span class="term">clone</span>, a list. When we clone a list, we create a
		new list, called a <span class="boldText">clone</span>, which is a copy of
		the original list, called the <span class="boldText">source</span>. To clone
		an entire list, we use the syntax
		<span class="monoText">list_name[:]</span>.
	</p>
	<pre class="language-python"><code>
		list_a = ['john', 'ali', 'sadako']
		list_b = list_a[:]

		print(list_b)
	</code></pre>
	<pre class="language-bash"><code>
		['john', 'ali', 'sadako']
	</code></pre>
	<p>
		A critical point with cloning is that we're creating a new list object.
		Modifying the clone does not modify the source:
	</p>
	<pre class="language-python"><code>
		list_a = ['john', 'ali', 'sadako']
		list_b = list_a[:]

		print('list_b:', list_b)

		list_b[0] = 'bing'

		print('list_b mutated')
		print('list_b:', list_b)
		print('list_a:', list_a)
	</code></pre>
	<pre class="language-bash"><code>
		list_b: ['john', 'ali', 'sadako']
		list_b mutated
		list_b: ['bing', 'ali', 'sadako']
		list_a: ['john', 'ali', 'sadako']
	</code></pre>
	<p>
		When we want to work some list ${a}$ but do not want to mutate ${a,}$ then
		cloning ${a}$ is the best approach.
	</p>
	<p>
		<span class="topic">Nested Lists.</span> Nothing stops us from having lists
		of lists, or lists of lists of lists. Nested lists, however, are ripe for
		unexpected mutation. Consider the following:
	</p>
	<pre class="language-python"><code>
		list_a = [1, 2]
		list_b = [3]
		list_c = [list_a]

		print(list_c)
	</code></pre>
	<pre class="language-bash"><code>
		[[1, 2]]
	</code></pre>
	<p>
		In the above code, we assigned as an element of
		<span class="monoText">list_c</span> the
		<span class="monoText">list_a</span>, resulting in a list containing a list.
		Visually, the lists point as such:
	</p>
	<figure>
		<img
			src="{% static 'images/nested_lists_pointers.svg' %}"
			alt="nested lists"
			loading="lazy"
			class="sixty-p"
		/>
	</figure>
	<p>
		Notice that <span class="monoText">list_c</span> points to the same object
		that <span class="monoText">list_a</span> points to. This means that if we
		modify the list inside <span class="monoText">list_c</span>, we modify
		<span class="monoText">list_a</span> as well, since they both point to the
		same object.
	</p>
	<pre class="language-python"><code>
		list_a = [1, 2]
		list_b = [3]
		list_c = [list_a]

		print('list_a =', list_a)
		print('list_c =', list_c)

		list_c[0].append(3)

		print('array inside list_c mutated')
		print('list_c =', list_c)
		print('list_a =', list_a)
	</code></pre>
	<pre class="language-bash"><code>
		list_a = [1, 2]
		list_c = [[1, 2]]
		array inside list_c mutated
		list_c = [[1, 2, 3]]
		list_a = [1, 2, 3]
	</code></pre>
	<p>
		But, as long as we do not modify the list inside
		<span class="monoText">list_c</span> (the list pointing to
		<span class="monoText">list_a</span>), we can modify
		<span class="monoText">list_c</span> without modifying
		<span class="monoText">list_a</span>:
	</p>
	<pre class="language-python"><code>
		list_a = [1, 2]
		list_b = [3]
		list_c = [list_a]

		print('list_a =', list_a)
		print('list_c =', list_c)

		list_c.append(list_b)

		print('list_c mutated')
		print('list_c =', list_c)
		print('list_a =', list_a)
	</code></pre>
	<pre class="language-bash"><code>
		list_a = [1, 2]
		list_c = [[1, 2]]
		list_c mutated
		list_c = [[1, 2], [3]]
		list_a = [1, 2]
	</code></pre>
	<p>
		<span class="topic">Mutation and Iteration.</span> One thing we should avoid
		doing as much as possible is mutating a list as we iterate over it. This is
		a common source for bug infestations:
	</p>
	<pre class="language-python"><code>
		def remove_duplicates(list_1, list_2):
			for element in list_1:
				if element in list_2:
					list_1.remove(element)
			return list_1

		myList = ['vodka', 'wine', 'coors', 'gin']
		herList = ['vodka', 'wine', 'tequila', 'whiskey']

		final_list = remove_duplicates(myList, herList)

		print(final_list)
	</code></pre>
	<pre class="language-bash"><code>
		['wine', 'coors', 'gin']
	</code></pre>
	<p>
		Weird. Why is the list
		<span class="monoText">['wine', 'coors', 'gin']</span> when it should be
		<span class="monoText">['coors', 'gin']</span>? This occurs because Python
		uses an internal counter to keep track of the index. At each iteration,
		however, we're removing an element from the list, which mutates the list's
		length. Python does not update the counter, so the loop never actually sees
		the element <span class="monoText">'wine'</span> as a duplicate.
	</p>
	<p>A better way to write the function is to first clone the list:</p>
	<pre class="language-python"><code>
		def remove_duplicates(list_1, list_2):
			list_1_clone = list_1[:]
			for element in list_1_clone:
				if element in list_2:
					list_1.remove(element)
			return list_1

		myList = ['vodka', 'wine', 'coors', 'gin']
		herList = ['vodka', 'wine', 'tequila', 'whiskey']

		final_list = remove_duplicates(myList, herList)

		print(final_list)
		print(myList)
	</code></pre>
	<pre class="language-bash"><code>
		['coors', 'gin']
		['coors', 'gin']
	</code></pre>
	<p>
		Note, however, that the code above mutates
		<span class="monoText">myList</span>. If we want to make sure
		<span class="monoText">myList</span> is not mutated, we need to create a
		separate list object.
	</p>
	<pre class="language-python"><code>
		def remove_duplicates(list_1, list_2):
			list_1_no_duplicates = []
			for element in list_1:
				if element not in list_2:
					list_1_no_duplicates.append(element)
			return list_1_no_duplicates

		myList = ['vodka', 'wine', 'coors', 'gin']
		herList = ['vodka', 'wine', 'tequila', 'whiskey']

		myList_no_duplicates = remove_duplicates(myList, herList)

		print(myList_no_duplicates)
		print(myList)
	</code></pre>
	<pre class="language-bash"><code>
		['coors', 'gin']
		['vodka', 'wine', 'coors', 'gin']
	</code></pre>
	<p>
		<span class="exh">Exercise.</span> For each of the following, specify the
		type and value of the last expression.
	</p>
	<ol>
		<li>
			<pre class="language-python"><code>
				list_a = [0, 1, 2, 3, 4, 5]
				list_b = list_a
				list_a[2] = 'hello'
				list_a == list_b
			</code></pre>
			<details class="answer">
				<summary>Solution</summary>
				<p>Value: <span class="monoText">True</span></p>
				<p>Type: <span class="monoText">boolean</span></p>
			</details>
		</li>
		<li>
			<pre class="language-python"><code>
				list_a = [0, 1, 2, 3, 4, 5]
				list_b = list_a
				list_a[2] = 'hello'
				list_a == list_b
				list_a is list_b
			</code></pre>
			<details class="answer">
				<summary>Solution</summary>
				<p>Value: <span class="monoText">True</span></p>
				<p>Type: <span class="monoText">Boolean</span></p>
			</details>
		</li>
		<li>
			<pre class="language-python"><code>
				list_a = [0, 1, 2, 3, 4, 5]
				list_b = list_a
				list_a[2] = 'hello'
				list_a == list_b
				list_a is list_b
				list_a
			</code></pre>
			<details class="answer">
				<summary>Solution</summary>
				<p>Value: <span class="monoText">[0, 1, 'hello', 3, 4, 5]</span></p>
				<p>Type: <span class="monoText">List</span></p>
			</details>
		</li>
		<li>
			<pre class="language-python"><code>
				list_a = [0, 1, 2, 3, 4, 5]
				list_b = list_a
				list_a[2] = 'hello'
				list_a == list_b
				list_a is list_b
				list_a
				list_b
			</code></pre>
			<details class="answer">
				<summary>Solution</summary>
				<p>Value: <span class="monoText">[0, 1, 'hello', 3, 4, 5]</span></p>
				<p>Type: <span class="monoText">List</span></p>
			</details>
		</li>
		<li>
			<pre class="language-python"><code>
				list_a = [0, 1, 2, 3, 4, 5]
				list_b = list_a
				list_a[2] = 'hello'
				list_a == list_b
				list_a is list_b
				list_a
				list_b
				list_c = [6, 5, 4, 3, 2]
				list_d = []
				for num in list_c:
					list_d.append(num)
				list_c == list_d
			</code></pre>
			<details class="answer">
				<summary>Solution</summary>
				<p>Value: <span class="monoText">True</span></p>
				<p>Type: <span class="monoText">boolean</span></p>
			</details>
		</li>
		<li>
			<pre class="language-python"><code>
				list_a = [0, 1, 2, 3, 4, 5]
				list_b = list_a
				list_a[2] = 'hello'
				list_a == list_b
				list_a is list_b
				list_a
				list_b
				list_c = [6, 5, 4, 3, 2]
				list_d = []
				for num in list_c:
					list_d.append(num)
				list_c == list_d
				list_c is list_d
			</code></pre>
			<details class="answer">
				<summary>Solution</summary>
				<p>Value: <span class="monoText">False</span></p>
				<p>Type: <span class="monoText">boolean</span></p>
				<p>
					Notice the difference between the
					<span class="monoText">is</span> operator and the
					<span class="monoText">==</span> operator. The
					<span class="monoText">is</span> operator will check if the list names
					point to the same address (i.e., point to the same list object). In
					contrast, the <span class="monoText">==</span> operator checks if both
					lists have exactly the same elements.
				</p>
			</details>
		</li>
		<li>
			<pre class="language-python"><code>
				list_a = [0, 1, 2, 3, 4, 5]
				list_b = list_a
				list_a[2] = 'hello'
				list_a == list_b
				list_a is list_b
				list_a
				list_b
				list_c = [6, 5, 4, 3, 2]
				list_d = []
				for num in list_c:
					list_d.append(num)
				list_c == list_d
				list_c is list_d
				list_c[2] = 20
				list_c
			</code></pre>
			<details class="answer">
				<summary>Solution</summary>
				<p>Value: <span class="monoText">[6, 5, 20, 3, 2]</span></p>
				<p>Type: <span class="monoText">List</span></p>
			</details>
		</li>
		<li>
			<pre class="language-python"><code>
				list_a = [0, 1, 2, 3, 4, 5]
				list_b = list_a
				list_a[2] = 'hello'
				list_a == list_b
				list_a is list_b
				list_a
				list_b
				list_c = [6, 5, 4, 3, 2]
				list_d = []
				for num in list_c:
					list_d.append(num)
				list_c == list_d
				list_c is list_d
				list_c[2] = 20
				list_c
				list_d
			</code></pre>
			<details class="answer">
				<summary>Solution</summary>
				<p>Value: <span class="monoText">[6, 5, 4, 3, 2]</span></p>
				<p>Type: <span class="monoText">List</span></p>
			</details>
		</li>
	</ol>
</section>
{% endblock %}
