{% extends '../layout.html' %} {% load static %} {% block content %}
<section id="functions_as_objects">
	<h4>Functions as Objects</h4>
	<p>
		Recall that nearly everything in Python is an object. Functions fall under
		this general rule, and we can treat them as objects.
	</p>
	<p>
		In programming languages, functions are
		<span class="term">first class objects</span>. First class objects are
		objects that: (1) have a type; (2) can be elements of data structures; and
		(3) can appear inside expressions (i.e., they can be assigned or be passed
		as arguments to functions). Because functions have all three of these
		properties, we can often use functions in the same way we would use literals
		like numbers or strings, and in the same way we would use data structures
		like tuples and lists.
	</p>
	<p>
		Given that functions can be treated as discrete data objects, we can store
		them inside lists, and perform operation on that list or pass the list
		itself as an argument. Doing so is an example of
		<span class="term">higher order programming. For example:</span>
	</p>
	<pre class="language-python"><code>
		def applyToEach(aList, func):
			'''
			inputs:
				aList, a list
				func, a function
			
			computation:
				replace each element of aList with func(element)
				
			output:
				mutated aList -- each element now func(element)
			'''

			for element in range(len(aList)): 
				aList[element] = func(aList[element])
	</code></pre>
	<p>
		The function above takes two arguments, (1) a list with elements, and (2) a
		function to apply. The function mutates the list argument by replacing each
		of its elements with the output of the function execution with the element
		passed as an argument. Let's apply this function:
	</p>
	<pre class="language-python"><code>
		def applyToEach(aList, func):
			for element in range(len(aList)): 
				aList[element] = func(aList[element])

		def fibonacci(n):
			if n == 0 or n == 1:
				return 1
			else:
				return fibonacci(n - 1) + fibonacci(n - 2)

		def factorial(n):
			if n == 1:
				return 1
			else:
				return n * factorial(n - 1)

		numList = [1, -2, 3.14] 

		applyToEach(numList, abs)
		print(numList)

		applyToEach(numList, int)
		print(numList)

		applyToEach(numList, factorial)
		print(numList)

		applyToEach(numList, fibonacci)
		print(numList)
	</code></pre>
	<pre class="language-bash"><code>
		[1, 2, 3.14]
		[1, 2, 3]
		[1, 2, 6]
		[1, 2, 13]
	</code></pre>
	<p>
		In the code above, we mutated the list several times by applying to each
		element in the list a function we passed as an argument. We can also perform
		the operation in the opposite direction:
	</p>
	<pre class="language-python"><code>
		def applyToEach(funcList, x):
			for func in funcList: 
				print(func(x))

		def fibonacci(n):
			if n == 0 or n == 1:
				return 1
			else:
				return fibonacci(n - 1) + fibonacci(n - 2)

		def factorial(n):
			if n == 1:
				return 1
			else:
				return n * factorial(n - 1)
		
		funcList = [abs, int, factorial, fibonacci]
		applyToEach(funcList, 5)
	</code></pre>
	<pre class="language-bash"><code>
		5
		5
		120
		8
	</code></pre>
	<p>
		Here, we applied a list of functions to a particular number. The
		<span class="monoText">applyToEach</span> function we wrote is an example of
		a <span class="term">higher order procedure</span> (&#8220;HOP&#8221;). HOPs
		are so common in programming that Python provides a general purpose HOP
		called <span class="monoText">map</span>.
	</p>
	<p>
		In its simplest form, a <span class="monoText">map</span> consists of a
		<span class="term">unary function</span> and a collection of suitable
		arguments. The simplest use follows the syntax:
	</p>
	<figure class="math-display">
		<pre class="language-pseudo"><code>
			map(unary_function, arguments)
		</code></pre>
	</figure>
	<p>
		For example, if we wanted to apply the
		<span class="monoText">abs</span> function to a list, we can use
		<span class="monoText">map</span>. <span class="monoText">map</span> returns
		a <span class="italicsText">map object</span>, an iterable data object:
	</p>
	<pre class="language-python"><code>
		aList = [1, -2, -5, -7]
		aList_all_positive = []
		for element in map(abs, aList):
			aList_all_positive.append(element)

		print(aList)
		print(aList_all_positive)
	</code></pre>
	<pre class="language-bash"><code>
		[1, -2, -5, -7]
		[1, 2, 5, 7]
	</code></pre>
	<p>
		To repeat, the return from <span class="monoText">map</span> is a map
		object:
	</p>
	<pre class="language-python"><code>
		aList = [1, -2, -5, -7]
		aList_map = map(abs, aList)

		print(aList_map)
	</code></pre>
	<pre class="language-bash"><code>
		&lt;map object at 0x7fb65a3c2ca0&gt;
	</code></pre>
	<p>
		To actually use the object's elements, we must iterate through the object.
		We can also use <span class="monoText">map</span> in a more general form:
	</p>
	<figure class="math-display">
		<pre class="language-pseudo"><code>
			map(n-ary_function, argument_1, argument_2, ... , argument_n)
		</code></pre>
	</figure>
	<p>
		In its general form, we can pass a
		<span class="term">${n-\text{ary}}$ function</span> &mdash; a function that
		takes multiple arguments, and provide the arguments thereafter. For example,
		suppose we have two lists, and we want to obtain a new list with the
		smallest element at a particular index:
	</p>
	<pre class="language-python"><code>
		list_a = [9, 117, 10, 15, 2]
		list_b = [12, 109, 98, 72, 23]
		min_element_per_index = []
		
		for element in map(min, list_a, list_b):
			min_element_per_index.append(element)
		
		print(min_element_per_index)
	</code></pre>
	<pre class="language-bash"><code>
		[9, 109, 10, 15, 2]
	</code></pre>
	<p>
		<span class="exh">Exercise.</span> Consider the following list and
		<span class="monoText">applyToEach</span> function:
	</p>
	<pre class="language-python"><code>
		L = [1, -4, 8, -9]

		def applyToEach(L, f):
			for i in range(len(L)):
				L[i] = f(L[i])
	</code></pre>
	<p>
		With the above list and function, write expressions that generate the
		output:
	</p>
	<ol>
		<li>
			<pre class="language-python"><code>
				print(L)
			</code></pre>
			<pre class="language-bash"><code>
				[1, 4, 8, 9]
			</code></pre>
			<details class="answer">
				<summary>Solution</summary>
				<pre class="language-python"><code>
					L = [1, -4, 8, -9]

					def applyToEach(L, f):
						for i in range(len(L)):
							L[i] = f(L[i])
					
					applyToEach(L, abs)
					print(L)
				</code></pre>
				<pre class="language-bash"><code>
					[1, 4, 8, 9]
				</code></pre>
			</details>
		</li>
		<li>
			<pre class="language-python"><code>
				print(L)
			</code></pre>
			<pre class="language-bash"><code>
				[2, -3, 9, -8]
			</code></pre>
			<details class="answer">
				<summary>Solution</summary>
				<pre class="language-python"><code>
					L = [1, -4, 8, -9]

					def applyToEach(L, f):
						for i in range(len(L)):
							L[i] = f(L[i])
					
					def increment(num):
						return num + 1
					
					applyToEach(L, increment)
					print(L)
				</code></pre>
				<pre class="language-bash"><code>
					[2, -3, 9, -8]
				</code></pre>
			</details>
		</li>
		<li>
			<pre class="language-python"><code>
				print(L)
			</code></pre>
			<pre class="language-bash"><code>
				[1, 16, 64, 81]
			</code></pre>
			<details class="answer">
				<summary>Solution</summary>
				<pre class="language-python"><code>
					L = [1, -4, 8, -9]

					def applyToEach(L, f):
						for i in range(len(L)):
							L[i] = f(L[i])
					
					def square(num):
						return num * num
					
					applyToEach(L, square)
					print(L)
				</code></pre>
				<pre class="language-bash"><code>
					[1, 16, 64, 81]
				</code></pre>
			</details>
		</li>
	</ol>
	<p><span class="exh">Exercise.</span> Consider the following functions:</p>
	<pre class="language-python"><code>
		def applyEachTo(L, x):
			result = []
			for i in range(len(L)):
				result.append(L[i](x))
			return result
		def square(a):
			return a*a
		def halve(a):
			return a/2
		def inc(a):
			return a+1
	</code></pre>
	<p>For each of the expressions below, what value and value's type?</p>
	<ol>
		<li>
			<pre class="language-python"><code>
				applyEachTo([inc, square, halve, abs], -3)
			</code></pre>
			<details class="answer">
				<summary>Solution</summary>
				<p>Output: <span class="monoText">[-2, 9, -1.5, 3]</span></p>
				<p>Type: <span class="monoText">list</span></p>
			</details>
		</li>
		<li>
			<pre class="language-python"><code>
				applyEachTo([inc, square, halve, abs], 3.0)
			</code></pre>
			<details class="answer">
				<summary>Solution</summary>
				<p>Output: <span class="monoText">[4.0, 9.0, 1.5, 3.0]</span></p>
				<p>Type: <span class="monoText">list</span></p>
			</details>
		</li>
		<li>
			<pre class="language-python"><code>
				applyEachTo([inc, max, int], -3)
			</code></pre>
			<details class="answer">
				<summary>Solution</summary>
				<p>Output: error</p>
				<p>Type: NoneType</p>
			</details>
		</li>
	</ol>
</section>
{% endblock %}
