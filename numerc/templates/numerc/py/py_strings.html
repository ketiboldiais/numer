{% extends '../layout.html' %} {% load static %} {% block content %}
<section id="strings_in_python">
	<h4>Strings in Python</h4>
	<p>
		In Python, letters, special characters, spaces, and digits
		<span class="italicsText"
			>enclosed in quotation marks or single quotes</span
		>
		are data objects of type <span class="monoText">str</span> (strings). The
		data type <span class="monoText">char</span>, a type present in languages
		like C and Java, does not exist in Python. All textual data fall under the
		type <span class="monoText">str</span>. For example:
	</p>
	<pre class="language-python"><code>
		hi = "hello world"
		greeting = 'hello'
	</code></pre>
	<p>
		We can combine strings in Python by
		<span class="boldItalics">concatenating</span> them:
	</p>
	<pre class="language-python"><code>
		hi = "hello"
		name = "torvald"
		greet = hi + name # returns "hitorvald" 
		greeting = hi + " " + name # returns "hi torvald"
	</code></pre>
	<p>
		Alternatively, we can <span class="boldItalics">format</span> strings in
		Python with curly braces:
	</p>
	<pre class="language-python"><code>
		name = "torvald"
		greeting = f"hi {name}"
		print(greeting)
	</code></pre>
	<pre class="command-line language-bash" data-output=""><code>
		hi torvald
	</code></pre>
	<p>
		In the code above, the string bound to
		<span class="monoText">greeting</span> is called an
		<span class="boldItalics">f-string</span> ("format string") &mdash; a string
		containing initialized variables. When we create strings in this way
		(embedding variables inside the string) we are
		<span class="boldItalics">interpolating</span> a string. Variables in
		formatted strings are enclosed in curly braces, and the string is preceded
		by the character <span class="monoText">f</span>. By prefacing with
		<span class="monoText">f</span>, we tell Python, "Hey, this is not just any
		string, it's a formatted string, so treat it as such."
	</p>
	<p>
		We can perform a number of operations on strings in addition to
		concatenating them. We can
		<span class="boldItalics">successively concatenate</span> strings:
	</p>
	<pre class="language-python"><code>
		3* 'sam' # returns 'samsamsam'
	</code></pre>
	<p>
		We can find obtain a string's <span class="boldItalics">length</span>. This
		returns a data object of type <span class="monoText">int</span>.
	</p>
	<pre class="language-python"><code>
		len('sam') # returns 3 (this includes spaces)
	</code></pre>
	<p>
		Strings are our first example of a
		<span class="boldItalics">non-scalar data object</span>. Strings have an
		internal structure that we can access. As we saw in C, strings are arrays of
		characters, so we can obtain a particular character in a string with its
		index:
	</p>
	<pre class="language-python"><code>
		'sam'[1] # returns 'a'
		'sam'[0] # returns 's'
	</code></pre>
	<p>
		Note, however, that strings are an
		<span class="boldItalics">immutable type</span>. Data objects of immutable
		type are objects that <span class="italicsText">cannot</span> be modified:
	</p>
	<pre class="language-python"><code>
		s = "hello"
		s[0] = 'y' # returns an error
		s = 'y' + s[1:len(s)] # this is ok; s is a new data object
	</code></pre>
	<p>
		Passing a negative number into the array brackets returns the character
		starting from last to first, with the number
		<span class="monoText">-1</span> indicating the last:
	</p>
	<pre class="language-python"><code>
		'hello'[-1] # returns 'o'
		'hello'[-2] # returns 'l'
		'hello'[-3] # returns 'l'
		'hello'[-4] # returns 'e'
		'hello'[-5] # returns 'h'
	</code></pre>
	<p>
		Note that since <span class="monoText">len()</span> returns a data object of
		type <span class="monoText">int</span>, we can also pass
		<span class="monoText">len()</span> into array brackets:
	</p>
	<pre class="language-python"><code>
		str = 'hello'
		str[len(str)-1] # returns o
	</code></pre>
	<p>We can <span class="boldItalics">slice</span> a string:</p>
	<pre class="language-python"><code>
		'eric'[1:3] # returns 'ri'
	</code></pre>
	<p>Thus, slicing a string takes the following form:</p>
	<pre class="language-pseudo"><code>
		string[i:j]

		returned string is: 
			string[i]+string[j-1] 
	</code></pre>
	<p>
		More explicitly, in the Python example above, the number
		<span class="monoText">1</span> indicates the starting point for the slice,
		and the number <span class="monoText">3</span> indicates the ending point
		for the slice. The slice includes the character at the starting point, but
		excludes the character at ending point. But, we do not have to include both
		numbers for the slice.
	</p>
	<pre class="language-python"><code>
		'eric'[:3] # returns 'eri'
		'eric'[1:] # returns 'ric'
	</code></pre>
	<p>
		If we omit the starting index, Python assumes our slice starts at index 0.
		If we omit the ending index, Python assumes we want our slice to end at the
		end of the string.
	</p>
	<p>We can also make a <span class="italicsText">copy</span> of the string:</p>
	<pre class="language-python"><code>
		'eric'[:] # returns 'eric'
	</code></pre>
	<p>We can also pass a third number:</p>
	<pre class="language-pseudo"><code>
		string[i:j:k]
	</code></pre>
	<p>
		The <span class="monoText">k</span> represents the
		<span class="boldItalics">step size</span> for the slice. For example:
	</p>
	<pre class="language-python"><code>
		s = 'Python is fun!'
		s[1:12:2] # returns 'yhni u'
	</code></pre>
	<p>
		If we pass a negative number into the step parameter, we count backwards:
	</p>
	<pre class="language-python"><code>
		str = 'helloworld'
		str[::-1] # returns 'dlrowolleh'
		palindrome = 'racecar'
		palindrome[::-1] # returns 'racecar'
	</code></pre>
	<p>
		Finally, we can also check whether a particular
		<span class="boldItalics">substring</span> is inside a string with the
		following syntax:
	</p>
	<pre class="language-pseudo"><code>
		element <span class="redText">in</span> colctn
		element <span class="monoText">not in</span> colctn
	</code></pre>
	<p>
		The word <span class="monoText">in</span> asks, "Is this element inside this
		collection?" The question returns either
		<span class="monoText">True</span> or <span class="monoText">False</span>.
		The same goes for the word <span class="monoText">not in</span>: "Is this
		element NOT inside this collection?" The words
		<span class="monoText">in</span> and
		<span class="monoText">not in</span> are what we use to test whether a
		particular data object is a member of a particular
		<span class="italicsText">collection</span> of data objects. Strings are an
		example of a collection of data objects.
	</p>
	<pre class="language-python"><code>
		str = 'world'
		'a' in str # returns False
	</code></pre>
	<p>
		Building off of this idea, suppose we ask for a user to vote yes or no, and
		output back confirmation. Suppose the user might input
		<span class="monoText">'y'</span>, <span class="monoText">'Y'</span>,
		<span class="monoText">'yes'</span>, <span class="monoText">'Yes'</span>, or
		<span class="monoText">'YES'</span>. Assume that abstaining counts as a no
		vote. One way to implement this would be to write:
	</p>
	<pre class="language-python"><code>
		ans = input('Do you support this proposition: ')
		if ans == 'y' or ans == 'Y' or ans == 'yes' or ans == 'Yes' or ans == 'YES':  
			print('You voted yes')
		else
			print('You voted no')
	</code></pre>
	<p>
		The above is unwiedly and long. We can use the previous idea of testing for
		whether a data objection is in a particular collection:
	</p>
	<pre class="language-python"><code>
		if ans in ['y', 'Y' 'yes', 'Yes', 'YES']:
			print('You voted yes')
		else
			print('You voted no')
	</code></pre>
</section>
{% endblock %}
