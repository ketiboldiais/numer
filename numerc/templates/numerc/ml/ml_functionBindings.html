{% extends '../layout.html' %} {% load static %} {% block content %}
<section id="function_bindings">
	<p>
		<span class="topic">Functions.</span> To define and use functions in
		<span class="monoText">ML</span>, we create
		<span class="term">function bindings</span>. For those coming from a Python
		or Java background, functions in <span class="monoText">ML</span> work much
		the same way, with a few stark differences: (1) There is no notion of a
		<span class="italicsText">class</span>; (2) there is no notion of a
		<span class="monoText">return</span> statement. As an example, consider a
		function that computes ${x^y}$ iff ${y \geq 0:}$
	</p>

	<pre class="language-sml"><code>
		fun pow (x:int, y:int) = (* correct only for y >= 0 *)
			if y = 0
				then 1
			else x * pow(x,y-1)
	</code></pre>

	<p>The general syntax for a function in <span class="monoText">ML</span>:</p>

	<figure class="math-display">
		<ul class="syntax">
			<li>fun ${f}$ (${a_1}$ : ${t_1}$, ${\ldots}$, ${a_n}$ : ${t_n}$) =</li>
			<ul>
				<li>${e_1}$</li>
				<li>${\vdots}$</li>
				<li>${e_n}$</li>
			</ul>
		</ul>
	</figure>

	<p>
		In the syntax above the definition is prefaced by the keyword
		<span class="monoText">fun</span>. ${f}$ is the function's name. It takes
		arguments ${a_1 \ldots a_n}$ of types ${t_1 \ldots t_n}$. The function's
		body is defined by the expressions ${e_1 \ldots e_n}$.
	</p>

	<p>
		<span class="topic">Function Type-checking.</span> To type check a function,
		the interpreter type-checks the function's body,
		<span class="monoText">⟨expressions⟩</span>, in a static environment,
		consisting of (1) all the earlier bindings and (2)
		<span class="monoText">arg-1</span> mapped to
		<span class="monoText">type-1</span> ...
		<span class="monoText">arg-n</span> mapped to
		<span class="monoText">type-n</span>. Because the static environment also
		includes <span class="monoText">⟨function-name⟩</span>, the function's body
		<span class="monoText">⟨expressions⟩</span> can include a call to
		<span class="monoText">⟨function-name⟩</span> (i.e., a
		<span class="italicsText">recursive function call</span>).
	</p>

	<p>
		<span class="topic">Evaluating Functions.</span> A function is a value; we
		are merely adding <span class="monoText">⟨function-name⟩</span> to be called
		later. Thus, <span class="monoText">⟨function-name⟩</span> is included in
		the dynamic environment in the function body and for subsequent bindings.
		However, <span class="monoText">⟨function-name⟩</span>
		<span class="underlineText">is not</span> included in the preceding
		bindings, so the order in which functions are defined is critical (i.e., the
		interpreter cannot &#8220;jump forward&#8221; to a function definition later
		down the program to evaluate the current expression).
	</p>

	<p>
		<span class="topic">Function Calls.</span> Function bindings are only useful
		if we can <span class="italicsText">call</span> them. To do so, we write a
		<span class="term">function call</span>. The syntax:
	</p>

	<figure class="math-display">$$ f \space (a_1, \ldots, a_n) $$</figure>

	<p>The parentheses are optional if there is exactly one argument:</p>

	<figure class="math-display">$$ f \space a $$</figure>

	<p>Here is an example of a function call:</p>

	<pre class="language-sml"><code>
		fun pow (x:int, y:int) = (* correct only for y >= 0 *)
			if y=0
				then 1
			else x * pow(x, y-1)

		fun cube (x:int) =
			pow(x, 3)

		val ans = cube(4)
	</code></pre>
</section>
{% endblock %}
