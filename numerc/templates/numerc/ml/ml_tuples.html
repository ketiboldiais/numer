{% extends '../layout.html' %} {% load static %} {% block content %}
<section id="tuples">
	<h4>Tuples &amp; Lists</h4>
	<p>
		A pair is really a 2-tuple. <span class="monoText">ML</span> allows us to
		have ${n-\text{tuples}.}$ For example, a 3-tuple (a triple):
	</p>

	<pre class="language-sml"><code>
		(*
			a 3-tuple
			type: int*int*int
		*)
		(2, 4, 6)
	</code></pre>

	<p>
		<span class="topic">Nesting Tuples.</span> Tuples are of fixed but
		<span class="term">arbtirary arity</span> &mdash; we can nest tuples however
		much we would like:
	</p>

	<pre class="language-sml"><code>
		(*
			Below is a 3-tuple containing a 2-tuple
			Type: int*(int*int)*int
		*)

		(2, (4, 6), 8) 

		(*
		Below is a 2-tuple containing a 2-tuple
		Type: int*(bool*int)
		*)

		(2, (true, 4))
	</code></pre>

	<p>
		<span class="topic">Lists.</span> We can nest pairs as much as we would
		like, but it can be difficult to determine how many parts are in a pair,
		since the type determines the amount of data contained in a pair. To get
		around this difficulty, <span class="monoText">ML</span> provides
		<span class="term">lists</span>. A list containing ${n}$ values is
		initialized with the following syntax:
	</p>

	<figure class="math-display">
		<ul class="syntax">
			<li>[${v_1, v_2, \ldots, v_n}$]</li>
		</ul>
	</figure>

	<p>
		Note that unlike tuples, lists are
		<span class="term">homogeneous</span> &mdash; a list's members must all be
		of the same type.
	</p>

	<p>
		The <span class="italicsText">empty list</span>,
		<span class="monoText">[]</span>, is the list with 0 elements. However,
		while it does not have any elements, it is a value nevertheless, and it
		evaluates to itself immediately. With the empty list
		<span class="monoText">[]</span>,
		<span class="monoText">null</span> evaluates to true. For non-empty lists,
		<span class="monoText">null</span> evaluates to
		<span class="monoText">false</span>. Here are some useful operators for
		lists:
	</p>

	<figure class="table">
		<table class="truth_table">
			<thead>
				<th>Operator</th>
				<th>Semantics</th>
			</thead>
			<tbody>
				<tr>
					<td>null</td>
					<td>
						evaluates to <span class="redText">true</span> if the list is the
						empty list []; otherwise <span class="redText">false</span> for
						non-empty lists
					</td>
				</tr>
				<tr>
					<td>hd</td>
					<td>
						return the first element of the list; i.e., the
						<span class="boldText">head</span> of the list; if the list is
						empty, an <span class="boldText">exception</span> is raised
					</td>
				</tr>
				<tr>
					<td>t1</td>
					<td>
						return the list without the first element; i.e., the
						<span class="boldText">tail</span> of the list; if the list is
						empty, an exception is raised
					</td>
				</tr>
			</tbody>
		</table>
	</figure>

	<p>Here are some functions operating on lists:</p>

	<pre class="language-sml"><code>
		fun sum_list (x_list : int list) =
			if null x_list
				then 0
			else hd(x_list) + sum_list(t1 x_list)

		fun countdown (x : int) =
			if x=0
				then []
			else x :: countdown(x-1)

		fun append (x_list : int list, y_list : int list) =
			if null x_list
				then y_list
			else (hd x_list) :: append(t1 x_list, y_list)
	</code></pre>

	<p>
		Functions using lists are almost always recursive because a list has an
		unknown length. When writing recursive functions for lists, there are two
		things to determine:
	</p>

	<ol>
		<li>The base case: What should the result be for an empty list?</li>
		<li>
			The recursive case: How can the answer be expressed in terms of the answer
			for the rest of the list?
		</li>
	</ol>

	<p>
		Thinking of terms of recursion rather than loops and assignment statements
		can both simplify a problem considerably, as well as yield a greater
		understanding of the problem parameters.
	</p>

	<p>
		<span class="topic"><span class="monoText">let</span> Expressions.</span> In
		<span class="monoText">ML</span>, the
		<span class="monoText">let</span> expression is what gives us
		<span class="italicsText">local bindings</span>, and as an expression, we
		can place it anywhere an expression may be placed. The
		<span class="monoText">let</span> expression takes the form:
	</p>

	<figure class="math-display">
		<ul class="syntax">
			<li>let ${b_1 \space b_2 \ldots b_n}$ in ${e}$ end</li>
		</ul>
	</figure>

	<p>
		Above: Each ${b}$ is a binding, ${e}$ is an expression, and the symbols
		<span class="monoText">let</span>, <span class="monoText">in</span>, and
		<span class="monoText">end</span> are keywords.
	</p>

	<p>
		To evaluate a <span class="monoText">let</span> expression, we evaluate each
		${b}$ using all earlier bindings in evaluating the
		<span class="monoText">let</span> expression and create a larger environment
		for the subsequent bindings.
	</p>

	<p>
		Recall that every binding in <span class="monoText">ML</span> has a scope.
		For the <span class="monoText">let</span> expression, the scope of a binding
		contained therein is the later bindings in that
		<span class="monoText">let</span> expression, and the
		<span class="italicsText">body</span> of the
		<span class="monoText">let</span> expression &mdash; the expression ${exp.}$
		The value of the entire <span class="monoText">let</span> expresion is the
		value of ${e.}$ Accordingly, the type of the entire
		<span class="monoText">let</span> expression is the type of the value of
		${e.}$ Here is a simple <span class="monoText">let</span> expression:
	</p>

	<pre class="language-sml"><code>
		let val x = 1
		in
			(let val x = 2 in x+1 end) + (let val y = x+2 in y+1 end)
		end
	</code></pre>

	<p>
		<span class="monoText">let</span> expressions in
		<span class="monoText">ML</span> are extremely handy with functions. For
		example, we can use a <span class="monoText">let</span> expression to bind a
		function, since a function is itself a binding. This leads to common design
		pattern:
	</p>

	<figure class="math-display">
		<div class="rule">
			<p>
				<span class="topic">Convention.</span> If a
				<span class="italicsText">helper function</span> is needed by only one
				other function and is unlikely to be useful elsewhere, we ought to bind
				it locally to the parent function:
			</p>
		</div>
	</figure>

	<p>
		For example, here is a function that produces the list
		<span class="monoText">[1, 2, ..., ${x}$]</span>:
	</p>

	<pre class="language-sml"><code>
		fun countUp_from_1 (x:int) =
			let fun count (from:int, to:int) =
				if from=to
					then to :: []
				else from :: count(from+1, to)
			in
				count(1,x)
			end
	</code></pre>

	<p>
		How does the code above work? First, we defined a function called
		<span class="monoText">countUp_from_1()</span>. This function consumes an
		<span class="monoText">int</span> type value, stored in the
		<span class="monoText">int</span> type variable
		<span class="monoText">x</span>. Inside the body of
		<span class="monoText">countUp_from_1</span>, we execute the function
		<span class="monoText">count()</span>. The function
		<span class="monoText">count</span> is
		<span class="italicsText">local</span> to the function
		<span class="monoText">countUp_from_1()</span>. How? Because we defined it
		through a <span class="monoText">let</span> expression inside the body of
		<span class="monoText">countUp_from_1</span>.
	</p>

	<p>
		Now, <span class="monoText">count()</span> takes two arguments: (1) an
		<span class="monoText">int</span> type value stored in the
		<span class="monoText">int</span> type variable
		<span class="monoText">from</span>, and (2) an
		<span class="monoText">int</span> type value stored in the
		<span class="monoText">int</span> type variable
		<span class="monoText">to</span>. However, given that the function
		<span class="monoText">countUp_from_1()</span> calls the function
		<span class="monoText">count()</span> with the arguments
		<span class="monoText">1</span> and <span class="monoText">x</span>, the
		variable <span class="monoText">from</span> is bound to the value
		<span class="monoText">1</span>, and the variable
		<span class="monoText">to</span> is bound to whatever
		<span class="monoText">int</span> type value we passed as an argument into
		<span class="monoText">countUp_from_1()</span>.
	</p>

	<p>
		Inside <span class="monoText">count()</span>, we ask several questions.
		First, <span class="monoText">from=to</span>, which is, Is
		<span class="monoText">from</span> equal to
		<span class="monoText">?</span> If it is, then return the singleton list
		<span class="monoText">[to]</span>. If it not, then ask the second question,
		<span class="monoText">else</span>. The answer to
		<span class="monoText">else</span> is always
		<span class="monoText">true</span>, so we return a list starting with
		<span class="monoText">from</span> and ending with
		<span class="monoText">count(from+1, to)</span>. So, for example,
		<span class="monoText">countUp_from_1(5)</span>, where
		<span class="monoText">countUp_from_1</span> is ${f}$ and
		<span class="monoText">count</span> is ${c}$
	</p>

	<figure class="math-display">
		<ul class="syntax">
			<li>${f(5)}$</li>
			<li>${c(1, 5)}$</li>
			<li>${[1, c(2, 5)]}$</li>
			<li>${[1, 2, c(3, 5)]}$</li>
			<li>${[1, 2, 3, c(4, 5)]}$</li>
			<li>${[1, 2, 3, 4, c(5, 5)]}$</li>
			<li>${[1, 2, 3, 4, 5]}$</li>
		</ul>
	</figure>

	<p>
		Although the algorithm works, there is room for optimization. First, notice
		that <span class="monoText">count()</span>'s first parameter,
		<span class="monoText">from:int</span>, always has the value
		<span class="monoText">1</span>. Second, notice that
		<span class="monoText">count()</span>'s second parameter,
		<span class="monoText">to:int</span>, is always the value stored in
		<span class="monoText">countUp_from_1()</span>'s second parameter,
		<span class="monoText">x</span>. Can we use <span class="monoText">x</span>?
		Of course! Never forget the core rule of dynamic environments in
		<span class="monoText">ML</span>: To evaluate a binding, we use all of the
		preceding bindings. Accordingly, <span class="monoText">count()</span> is
		absolutely free to use <span class="monoText">x</span>. Thus, we can write
		the function more concisely:
	</p>

	<pre class="language-sml"><code>
		fun countUp_from_1 (x:int) = 
			let fun count (from:int) =
				if from = x
					then x::[]
				else from :: count(from+1)
			in
				count 1
			end
	</code></pre>

	<p>
		The optimization above demonstrates a common technique in functional
		programming:
	</p>

	<figure class="math-display">
		<div class="rule">
			<p>
				<span class="topic">Convention.</span> In defining functions, reuse
				variables within the function's scope.
			</p>
		</div>
	</figure>

	<p>
		Be aware: The technique above is unique to functional programming languages.
		Unfortunately, many languages absolutely prohibit such practices. In
		functional programming &mdash; and programming in general &mdash; local
		variables should be preferred over
		<span class="italicsText">global variables</span>. For starts, locals make
		code easier to read rather than globals. For example, consider the following
		function that returns the maximum value in a list:
	</p>

	<pre class="language-sml"><code>
		fun max (x_list : int list) =
			if null x_list
				then 0
			else if null (t1 x_list) 
				then hd x_list
			else if hd x_list > max(t1 x_list)
				then hd x_list
			else max(t1 x_list)
	</code></pre>

	<p>The code above asks 4 different questions:</p>

	<figure class="math-display">
		<div class="rule">
			<ol>
				<li>Is <span class="monoText">x_list</span> the empty list?</li>
				<ul>
					<li>Yes ${\implies}$ evaluate to <span class="monoText">0</span>.</li>
					<li>No ${\implies}$ ask the next question.</li>
				</ul>
				<li>
					Is the tail of <span class="monoText">x_list</span> the empty list?
					(i.e., Is the list a singleton list?)
				</li>
				<ul>
					<li>
						Yes ${\implies}$ evaluate to the head of
						<span class="monoText">x_list</span>.
					</li>
					<li>No ${\implies}$ ask the next question.</li>
				</ul>
				<li>
					Is the head of <span class="monoText">x_list</span> greater than the
					maximum of the tail of the list?
				</li>
				<ul>
					<li>
						Yes ${\implies}$ evaluate to the head of
						<span class="monoText">x_list</span>
					</li>
					<li>No ${\implies}$ ask the next question.</li>
				</ul>
				<li><span class="monoText">else</span>.</li>
				<ul>
					<li>evaluate to the maximum of the tail of the list.</li>
				</ul>
			</ol>
		</div>
	</figure>

	<p>
		What is the problem with this algorithm? The problem is we are calling
		<span class="monoText">max()</span> twice recursively. This is an example of
		a common recursive error, the
		<span class="term">exponential blowup</span> &mdash;
		<span class="monoText">max()</span> asks for
		<span class="monoText">max()</span> twice, and in both those
		<span class="monoText">max()</span> calls,
		<span class="monoText">max()</span> is asked twice (now 4
		<span class="monoText">max()</span> calls), and in each of those 4
		<span class="monoText">max()</span> calls,
		<span class="monoText">max()</span> is asked twice (now 16
		<span class="monoText">max()</span> calls), etc. If we passed into
		<span class="monoText">max()</span> the value of
		<span class="monoText">countUp_from_1(100)</span>, we would execute
		${2^{100}}$ calls.
	</p>

	<p>
		<span class="monoText">let</span> expressions solve this problem: Compute
		the <span class="monoText">max</span> of the tail once, store that result in
		<span class="monoText">tail_max</span>, and use
		<span class="monoText">tail_max</span> as the comparison:
	</p>

	<pre class="language-sml"><code>
		fun max (x_list : int list) =
			if null x_list
				then 0
			else if null (t1 x_list)
				then hd x_list
			else
				let val tail_max = max(t1 x_list)
				in
					if hd x_list > tail_max
						then hd x_list
					else tail_max 
				end
	</code></pre>

	<p>
		With the code above, we go through the same first two questions, and if they
		are both <span class="monoText">false</span>, then we go through the
		<span class="monoText">else</span> question: First, bind the value of the
		max of the list's tail to the variable
		<span class="monoText">tail_max</span>. If the head of
		<span class="monoText">x_list</span> is greater than
		<span class="monoText">tail_max</span>, evaluate to the head of
		<span class="monoText">x_list</span>. Otherwise, evaluate to
		<span class="monoText">tail_max</span>. So, for example, suppose we wrote
		<span class="monoText">max([1, 2, 3, 4, 5])</span>. Where
		<span class="monoText">max()</span> is ${M,}$
		<span class="monoText">hd</span> is ${h}$,
		<span class="monoText">t1</span> is ${t,}$ ${\ell}$ is
		<span class="monoText">[1, 2, 3, 4, 5]</span>, and ${v}$ is
		<span class="monoText">tail_max</span>:
	</p>

	<figure class="math-display">
		<ul class="syntax">
			<li>${M(\ell)}$</li>
			<li>${M([1, 2, 3, 4, 5])}$</li>
			<li>${h(\ell) > v}$</li>
			<li>${h(\ell) > M(t(\ell))}$</li>
			<li>${1 > M([2, 3, 4, 5])}$</li>
			<li>${1 > (h(\ell) > v)}$</li>
			<li>${1 > (h(\ell) > M(t(\ell)))}$</li>
			<li>${1 > (2 > M([3, 4, 5]))}$</li>
			<li>${1 > (2 > (3 > v))}$</li>
			<li>${1 > (2 > (3 > M(t(\ell))))}$</li>
			<li>${1 > (2 > (3 > M[4, 5]))}$</li>
			<li>${1 > (2 > (3 > (4 > v)))}$</li>
			<li>${1 > (2 > (3 > (4 > M(t(\ell)))))}$</li>
			<li>${1 > (2 > (3 > (4 > M([5]))))}$</li>
			<li>${1 > (2 > (3 > (4 > (5 > v))))}$</li>
			<li>${1 > (2 > (3 > (4 > (5 > M(t(\ell))))))}$</li>
			<li>${1 > (2 > (3 > (4 > (5 > M([])))))}$</li>
			<li>${1 > (2 > (3 > (4 > (5 > 0))))}$</li>
			<li>${1 > (2 > (3 > (4 > (5))))}$</li>
			<li>${1 > (2 > (3 > (5)))}$</li>
			<li>${1 > (2 > (5))}$</li>
			<li>${1 > (5)}$</li>
			<li>${5}$</li>
		</ul>
	</figure>

	<p>
		<span class="topic">Options.</span> There is a small problem with the
		algorithm above. The answer to the first question,
		<span class="monoText">null x_list</span> is
		<span class="monoText">0</span>. But this isn't logically correct. The
		maximum value of an empty list isn't zero, because there are no values in an
		empty list to compare with in the first place. We should avoid making such
		illogical statements. So what can we do? We could raise an exception.
		However, a better way would be to use an
		<span class="monoText">option</span>. In <span class="monoText">ML</span>,
		an <span class="monoText">option</span> is a data type with only one of two
		values: <span class="monoText">NONE</span> or
		<span class="monoText">SOME</span>. The
		<span class="monoText">option</span> value
		<span class="monoText">NONE</span> represents
		<span class="italicsText">nothingness</span>, or &#8220;carries
		nothing.&#8221; The <span class="monoText">option</span> value
		<span class="monoText">SOME ${e}$</span>, where ${e}$ is an expression,
		represents <span class="italicsText">existence</span>, or &#8220;carries
		something.&#8221; More specifically, the value
		<span class="monoText">SOME ${e}$</span> will evaluate ${e}$ to a value
		${v,}$ at which point <span class="monoText">SOME ${e}$</span> becomes the
		option carrying the one and only value ${v.}$
	</p>

	<p>
		Like <span class="monoText">null</span>, we can ask whether a value is
		<span class="monoText">SOME ${e}$</span> or
		<span class="monoText">NONE</span>. The operator
		<span class="monoText">isSome</span> evaluates to
		<span class="monoText">false</span> if its argument is
		<span class="monoText">NONE</span>. And if we want to access the value
		carried by a <span class="monoText">SOME</span>, we use the operator
		<span class="monoText">valOf</span>. Using options, we can rewrite the code
		above as such:
	</p>

	<pre class="language-sml"><code>
		fun max (x_list : int list) =
			if null x_list
				then NONE
			else
				let val tail_max = max(t1 x_list)
				in
					if isSome tail_max andalso valOf tail_max > hd x_list
						then tail_max
					else
						SOME (hd x_list)
				end
	</code></pre>
</section>
{% endblock %}
