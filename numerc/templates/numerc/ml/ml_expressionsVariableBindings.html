{% extends '../layout.html' %} {% load static %} {% block content %}
<section id="expressions_and_variable_bindings">
	<p>
		<span class="topic">Expressions &amp; Variable Bindings.</span> Before we
		study <span class="monoText">ML</span>, we must first understand its
		foundational terminology and concepts. In <span class="monoText">ML</span>,
		a program is a sequence of <span class="term">bindings</span>. Each
		<span class="term">binding</span> has a <span class="term">type</span>,
		which is checked. If it the binding passes its type-check, then it is
		<span class="term">evaluated</span>.
	</p>

	<p>
		A binding's type depends on its
		<span class="term">static environment</span> &mdash; roughly, the
		<span class="italicsText">types</span> of the preceding bindings. How a
		binding is evaluated depends on its
		<span class="term">dynamic environment</span> &mdash; roughly, the
		<span class="italicsText">values</span> of the preceding bindings. The term
		<span class="term">environment</span> usually refers to the dynamic
		environment, and the term <span class="term">context</span> usually refers
		to the static environment. The following are some common expressions in
		<span class="monoText">ML</span>:
	</p>

	<figure class="table">
		<table class="truth_table heading_center">
			<thead>
				<th>Expression</th>
				<th>Type</th>
				<th>Result Type</th>
				<th>Comments</th>
			</thead>
			<tbody>
				<tr>
					<td>
						<span class="monoText">if ${c}$ then ${e_1}$ else ${e_2}$</span>
					</td>
					<td>
						${b}$ must be an expression of type
						<span class="boldText">bool</span>. ${e_1}$ and ${e_2}$ must have
						the same types.
					</td>
					<td>same as ${e_1}$ and ${e_2}$</td>
					<td></td>
				</tr>
				<tr>
					<td>${e_1}$ andalso ${e_2}$</td>
					<td>
						${e_1}$ and ${e_2}$ must both be of type
						<span class="boldText">bool</span>
					</td>
					<td><span class="boldText">bool</span></td>
					<td>logical AND</td>
				</tr>
				<tr>
					<td>${e_1}$ orelse ${e_2}$</td>
					<td>
						${e_1}$ and ${e_2}$ must both be of type
						<span class="boldText">bool</span>
					</td>
					<td><span class="boldText">bool</span></td>
					<td>logical OR</td>
				</tr>
				<tr>
					<td>NOT ${e}$</td>
					<td>${e}$ must be of type <span class="boldText">bool</span></td>
					<td><span class="boldText">bool</span></td>
					<td>logical NOT</td>
				</tr>
				<tr>
					<td>${e_1}$ + ${e_2}$</td>
					<td>
						Either: (1) Both ${e_1}$ and ${e_2}$ are both of type
						<span class="boldText">int</span>; or (2) both ${e_1}$ and ${e_2}$
						are both of type <span class="boldText">real</span>
					</td>
					<td>Same as ${e_1}$ and ${e_2}$</td>
					<td>${e_1 + e_2}$; overload operator</td>
				</tr>
				<tr>
					<td>${e_1}$ - ${e_2}$</td>
					<td>
						Either: (1) Both ${e_1}$ and ${e_2}$ are both of type
						<span class="boldText">int</span>; or (2) both ${e_1}$ and ${e_2}$
						are both of type <span class="boldText">real</span>
					</td>
					<td>Same as ${e_1}$ and ${e_2}$</td>
					<td>${e_1 - e_2}$; overload operator</td>
				</tr>
				<tr>
					<td>${e_1}$/${e_2}$</td>
					<td>
						Both ${e_1}$ and ${e_2}$ must both be
						<span class="boldText">real</span>
					</td>
					<td><span class="boldText">real</span></td>
					<td>real division</td>
				</tr>
				<tr>
					<td>${e_1}$ div ${e_2}$</td>
					<td>
						Both ${e_1}$ and ${e_2}$ must both be
						<span class="boldText">int</span>
					</td>
					<td><span class="boldText">int</span></td>
					<td>integer division</td>
				</tr>
				<tr>
					<td>${e_1}$ * ${e_2}$</td>
					<td>
						Either: (1) Both ${e_1}$ and ${e_2}$ are both of type
						<span class="boldText">int</span>; or (2) both ${e_1}$ and ${e_2}$
						are both of type <span class="boldText">real</span>
					</td>
					<td>Same as ${e_1}$ and ${e_2}$</td>
					<td>${e_1 \cdot e_2}$; overload operator</td>
				</tr>
				<tr>
					<td>${e_1}$ < ${e_2}$</td>
					<td>
						Either: (1) Both ${e_1}$ and ${e_2}$ are both of type
						<span class="boldText">int</span>; or (2) both ${e_1}$ and ${e_2}$
						are both of type <span class="boldText">real</span>
					</td>
					<td><span class="boldText">bool</span></td>
					<td>${e_1 < e_2?}$; overload operator</td>
				</tr>
				<tr>
					<td>${e_1}$ > ${e_2}$</td>
					<td>
						Either: (1) Both ${e_1}$ and ${e_2}$ are both of type
						<span class="boldText">int</span>; or (2) both ${e_1}$ and ${e_2}$
						are both of type <span class="boldText">real</span>
					</td>
					<td><span class="boldText">bool</span></td>
					<td>${e_1 > e_2?}$; overload operator</td>
				</tr>
				<tr>
					<td>${e_1}$ <= ${e_2}$</td>
					<td>
						Either: (1) Both ${e_1}$ and ${e_2}$ are both of type
						<span class="boldText">int</span>; or (2) both ${e_1}$ and ${e_2}$
						are both of type <span class="boldText">real</span>
					</td>
					<td><span class="boldText">bool</span></td>
					<td>${e_1 \leq e_2?}$; overload operator</td>
				</tr>
				<tr>
					<td>${e_1}$ >= ${e_2}$</td>
					<td>
						Either: (1) Both ${e_1}$ and ${e_2}$ are both of type
						<span class="boldText">int</span>; or (2) both ${e_1}$ and ${e_2}$
						are both of type <span class="boldText">real</span>
					</td>
					<td><span class="boldText">bool</span></td>
					<td>${e_1 \geq e_2?}$; overload operator</td>
				</tr>
				<tr>
					<td>${e_1}$ = ${e_2}$</td>
					<td>
						${e_1}$ and ${e_2}$ must both be either
						<span class="boldText">unit</span>,
						<span class="boldText">int</span>,
						<span class="boldText">char</span>, or
						<span class="boldText">string</span>.
						<span class="underlineText">Cannot</span> be
						<span class="boldText">real</span>.
					</td>
					<td><span class="boldText">bool</span></td>
					<td>${e_1 = e_2?}$</td>
				</tr>
				<tr>
					<td>${e_1}$^${e_2}$</td>
					<td>
						${e_1}$ and ${e_2}$ must both be
						<span class="boldText">string</span>
					</td>
					<td><span class="boldText">string</span></td>
					<td>concatenation</td>
				</tr>
			</tbody>
		</table>
	</figure>

	<p>
		There are many kinds of bindings in <span class="monoText">ML</span>, but
		the simplest binding is the <span class="term">variable binding</span>. It
		takes the general form:
	</p>

	<figure class="math-display">
		<ul class="syntax">
			<li>val ${v}$ = ${e}$</li>
		</ul>
	</figure>

	<p>
		In the syntax above, <span class="monoText">val</span> is a
		<span class="italicsText">keyword</span>, ${v}$ is the
		<span class="italicsText">variable</span>, and ${e}$ is any
		<span class="italicsText">expression</span>. The semicolon is optional, but
		it is necessary in a <span class="term">REPL</span> (<span
			class="italicsText"
			>read-eval-print</span
		>
		loop) to inform the <span class="italicsText">interpreter</span> that the
		binding is complete.
	</p>

	<p>
		Every binding in <span class="monoText">ML</span> has a
		<span class="term">scope</span>, which we can think of as &#8220;where it
		can be used.&#8221;
	</p>

	<p>
		The example above tells us the <span class="italicsText">syntax</span> for a
		variable binding (how to write it), but it does not tell us the
		<span class="italicsText">semantics</span> (how the binding is type-checked
		and evaluated; its <span class="italicsText">meaning</span>). The semantics
		of a variable binding are largely determined by the
		<span class="monoText">⟨expression⟩</span>.
	</p>

	<p>
		To type check the variable binding, the interpreter uses the
		<span class="italicsText">current static environment</span> (the types of
		preceding bindings) to type check the
		<span class="monoText">⟨expression⟩</span>. Once the
		<span class="monoText">⟨expression⟩</span> is type-checked, the interpreter
		produces a <span class="italicsText">new static environment</span> where the
		<span class="monoText">⟨variable⟩</span> has the type of the the
		<span class="monoText">⟨expression⟩</span>.
	</p>

	<p>
		To evaluate the variable binding, the interpreter uses the
		<span class="italicsText">current dynamic environment</span> (the
		<span class="italicsText">values</span> of the preceding bindings) to
		evaluate the <span class="monoText">⟨expression⟩</span>. Once the
		<span class="monoText">⟨expression⟩</span> is evaluated, the interpreter
		produces a <span class="italicsText">new dynamic environment</span> where
		the current dynamic environment now includes
		<span class="monoText">⟨variable⟩</span> with the value of the
		<span class="monoText">⟨expression⟩</span>'s evaluation.
	</p>

	<p>
		What is a <span class="term">value</span>? A
		<span class="italicsText">value</span> is an expression that cannot be
		further simplified &mdash; i.e., there is no more work to be done. For
		example, <span class="monoText">10</span> is a value, but
		<span class="monoText">5 + 5</span> is not. Both
		<span class="monoText">10</span> and <span class="monoText">5 + 5</span>,
		however, are <span class="italicsText">expressions</span>. In
		<span class="monoText">ML</span>, all values are expressions, but not all
		expressions are values. From the facts above, we have different
		<span class="italicsText">kinds of expressions</span>. These kinds are
		defined as such.
	</p>

	<figure class="table">
		<table class="truth_table heading_center">
			<thead>
				<th>Kind of Expression</th>
				<th>Syntax</th>
				<th>Type-checking</th>
				<th>Evaluation</th>
			</thead>
			<tbody>
				<tr>
					<td>integer constant</td>
					<td>a sequence of digits</td>
					<td>
						type <span class="redText">int</span> in any static environment
					</td>
					<td>to itself in any dynamic environment (it is a value)</td>
				</tr>
				<tr>
					<td>addition</td>
					<td>
						<span class="redText">${a}$ + ${b}$</span> where ${a}$ and ${b}$ are
						expressions
					</td>
					<td>
						type <span class="redText">int</span> if and only if ${a}$ and ${b}$
						have type <span class="redText">int</span> in the same static
						environment; else does not type-check
					</td>
					<td>
						evaluate ${a}$ to ${v}$ and ${b}$ to ${w}$ in the same static
						environment, where ${v}$ and ${w}$ are values; then produce the sum
						of ${v}$ and ${w}$
					</td>
				</tr>
				<tr>
					<td>variables</td>
					<td>a sequence of letters, underscores, etc.</td>
					<td>
						look up the variable in the current static environment and use that
						type
					</td>
					<td>
						look up the variable in the current dynamic environment and use that
						type
					</td>
				</tr>
				<tr>
					<td>conditionals</td>
					<td>
						<span class="redText">if ${a}$ then ${b}$ else ${c}$</span> where
						${a,}$ ${b,}$ and ${c}$ are expressions.
					</td>
					<td>
						type-checks only if (1) ${a}$ has type
						<span class="monoText">bool</span>, and (2) ${b}$ and ${c}$ have the
						same type. The type of the whole expression is the type of ${b}$ and
						${c.}$
					</td>
					<td>
						using the current dynamic environment, evaluate ${a.}$ If the result
						is <span class="redText">true</span>, the result of ${b}$ is the
						overall result. If the result is <span class="redText">false</span>,
						then the result of ${c}$ is the overall result.
					</td>
				</tr>
				<tr>
					<td>boolean constants</td>
					<td>
						either <span class="redText">true</span> or
						<span class="redText">false</span>
					</td>
					<td>
						type <span class="redText">bool</span> in any static environment.
					</td>
					<td>to itself in any dynamic environment (it is a value)</td>
				</tr>
				<tr>
					<td>comparison</td>
					<td>
						<span class="redText">${a}$ < ${b}$</span> where ${a}$ and ${b}$ are
						expressions
					</td>
					<td>
						type <span class="redText">bool</span> if and only if ${a}$ and
						${b}$ have type <span class="redText">int</span> in the same static
						environment; else does not type-check
					</td>
					<td>
						in the same dynamic environment, evaluate ${a}$ to ${v}$ and ${b}$
						to ${w}$ where ${v}$ and ${w}$ are values; produce
						<span class="redText">true</span> if ${v}$ is less than ${w,}$
						otherwise <span class="redText">false</span>.
					</td>
				</tr>
			</tbody>
		</table>
		<p>
			Whenever we learn a new construct in a programming language, there are
			three things we must seek out and ingrain in memory:
		</p>
		<ol>
			<li>What is the construct's syntax?</li>
			<li>What is the rule for type-checking the construct?</li>
			<li>What is the rule for evaluating the construct?</li>
		</ol>
	</figure>
</section>
{% endblock %}
