{% extends '../layout.html' %} {% load static %} {% block description %}
<meta
	name="description"
	content="Overview of composite data types: product types, sum types, recursive types, datatype bindings, polymorphic types"
/>
{% endblock %} {% block title %}
<title>ML: Composite Data Types</title>
{% endblock %} {% block content %}

<h1>Composite Data Types</h1>
<section id="custom_data_types">
	<div class="toc">
		<h3>Outline</h3>
		<ol>
			<li><a href="#product_types">Product Types</a></li>
			<ol>
				<li><a href="">Record Types</a></li>
			</ol>
			<li><a href="#sum_types">Sum Types</a></li>
			<ol>
				<li><a href="#datatype_bindings">Datatype Bindings</a></li>
				<li><a href="#caseExpressions">Pattern Matching</a></li>
			</ol>
			<li><a href="#recursive_types">Recursive Types</a></li>
			<li><a href="#type_synonyms">Type Synonyms</a></li>
			<li><a href="#polymorphic_dataTypes">Polymorphic Datatypes</a></li>
			<li>
				<a href="#functions_patternMatching">Pattern Matching & Functions</a>
			</li>
			<li>
				<a href="#type_inference_and_patternMatching"
					>Type Inference & Pattern Matching</a
				>
			</li>
			<ol>
				<li>
					<a href="#polymorphicEqualityTypes">Polymorphic & Equality Types</a>
				</li>
			</ol>
			<li><a href="#nested_patterns">Nested Patterns</a></li>
		</ol>
	</div>

	<p>
		Data types in programming languages fall into two categories: (1)
		<span class="term">base types</span>, and (2)
		<span class="term">compound types</span> (also called
		<span class="italicsText">composite types</span>). We avoid using the term
		<span class="italicsText">primitive types</span> for base types because the
		word <span class="italicsText">primitive type</span> connotes a type that
		cannot be modified, which is not necessarily true of all languages (Swift,
		for example, allows its base types provided by the standard library to be
		extended). A language's base types are the types the language provides by
		default. These are the types that describe the basic values the language
		understands. In ML, these types include <span class="monoText">int</span>,
		<span class="monoText">bool</span>, <span class="monoText">real</span>,
		<span class="monoText">unit</span>, etc.
	</p>

	<p>
		In contrast, composite types are data types that contain other types in
		their definition. The data types <span class="monoText">tuple</span>,
		<span class="monoText">list</span>, and
		<span class="monoText">option</span> are all examples of a compound data
		type. More specifically, these are a kind of compound data type called an
		<span class="term">algebraic data type</span>.
	</p>

	<p>
		In ML and most other languages, there are three building blocks to
		constructing a composite type: (1) an <span class="term">each-of</span> type
		(more formally, <span class="term">product types</span>); (2) a
		<span class="term">one-of</span> type (formally a
		<span class="term">sum type</span>); and (3) a
		<span class="term">self-reference</span> type (a
		<span class="term">recursive type</span>). We go over each of these in turn.
	</p>

	<p>
		In an <span class="italicsText">each-of type</span> ${p,}$ the value of type
		${p}$ contains multiple values, where each value has the type ${t_1,}$
		${t_2,}$ ${\ldots,}$ ${t_n.}$ (Type ${t_i}$) being some base type or other
		compound type). Thus, if we have a value of type ${p,}$ then that value will
		have values of ${t_1,}$ ${t_2,}$
		<span class="underlineText">and</span> ${t_n.}$
	</p>

	<p>
		In a <span class="italicsText">one-of type</span> ${s,}$ the value of type
		${s}$ contains multiple values, where each value is one of ${t_1,}$ ${t_2,}$
		${\ldots,}$ ${t_n.}$ In other words, if we have value of type ${s,}$ then
		the value has values of type type ${t_1,}$ ${t_2,}$
		<span class="underlineText">or</span> ${t_n.}$
	</p>

	<p>
		Finally, a value with a
		<span class="italicsText">self-reference type</span> ${r}$ is a value that
		contains other values of type ${r.}$ I.e., there is some notion of
		self-reference. Types like lists or trees are self-reference types. Why?
		Because values of a list type contain other lists, and values of a tree type
		contain other trees.
	</p>

	<p>
		Notice that these types correspond to the logical
		<span class="monoText">AND</span>, <span class="monoText">OR</span>, and the
		axiom of induction. It turns out that with just these three constructs, we
		can describe an enormous amount of data. How? For starters, compound data
		types can nest, so we can have many different combinations of the data types
		above. We might have a recursive-sum type, or a sum-product type, or a
		recursive-sum-product type, etc.
	</p>
</section>

<section id="product_types">
	<h2>Product Types</h2>
	<p>
		The each-of type is more formally the product type. A product type describes
		the values containing <span class="italicsText">each of</span> the values of
		type ${t_1, t_2, \ldots, \textit{ and } \space t_n.}$ Tuples are the most
		obvious example of product type data. A tuple such as
		<span class="monoText">(1, true)</span> is a value of type
		<span class="monoText">int*bool</span>. The tuple describes the values
		containing an <span class="monoText">int</span>
		<span class="underlineText">and</span> a <span class="monoText">bool</span>.
	</p>

	<p>
		<span class="topic">Record Types.</span> One way to create a product type is
		through a <span class="term">record type</span>. In a record type, each
		component has a <span class="term">named field</span>. And to each named
		field, there is a value. Creating and instantiating a record type has two
		results: (1) a <span class="term">record value</span>, which holds values,
		and (2) a <span class="term">record type</span>, which holds types. For
		example:
	</p>

	<pre class="language-sml"><code>
		val student = {name="Jo Ann", age=19, enrolled=true}
	</code></pre>
	<pre class="language-bash"><code>
		val student = {age=19,enrolled=true,name="Jo Ann"} :
			{age:int, enrolled:bool, name:string}
	</code></pre>

	<p>
		<span class="marginnote"
			>In other languages, the canonical example of a record type is the
			<span class="monoText">struct</span>.</span
		>
		Above, we created a <span class="italicsText">record</span> called
		<span class="monoText">student</span>, which contains the fields
		<span class="monoText">name</span>, <span class="monoText">age</span>, and
		<span class="monoText">enrolled</span>. We can also see the record's type:
		<span class="monoText">{age:int, enrolled:bool, name:string}</span>.
		Depending on the language implementation, we may or may not see a different
		ordering of the fields. This is because records do not have inherent order.
		It is up to the language implementation on how to order the fields. Here,
		this particular implementation of ML went with alphabetical order.
	</p>

	<p>
		Instantiating the record <span class="monoText">student</span>, we create a
		record value containing <span class="monoText">19</span>,
		<span class="monoText">true</span>, and
		<span class="monoText">"Jo Ann"</span>. We also have a record type
		<span class="monoText">{age:int, enrolled:bool, name:string}</span>. If we
		want to access the values in the fields, we use the same hash-syntax we saw
		with tuples:
	</p>

	<pre class="language-sml"><code>
		val student = {name="Jo Ann", age=19, enrolled=true}
		val JoAnnName = #name student
	</code></pre>
	<pre class="language-bash"><code>
		val student = {age=19,enrolled=true,name="Jo Ann"} :
			{age:int, enrolled:bool, name:string}
		val JoAnnName = "Jo Ann" : string
	</code></pre>

	<p>
		Above, we have the <span class="term">record expression</span>
		<span class="monoText">#name student</span>, and it evaluates to a record
		value. In sum, the general syntax for a record expression:
	</p>

	<figure class="math-display">
		<ul class="syntax">
			<li>{ ${f_1}$ = ${e_1}$, ${\ldots}$, ${f_n}$ = ${e_n}$ }</li>
		</ul>
		<ul class="def">
			<li class="where">
				${f_1 \ldots f_n}$ are <span class="italicsText">unique</span> field
				names, and
			</li>
			<li>${e_1 \ldots e_n}$ are expressions</li>
		</ul>
	</figure>

	<p>
		Astute observation reveals how closely a record resembles a tuple. In fact,
		tuples <span class="italicsText">are</span> records. Specifically, they are
		records with numeric field names to indicate
		<span class="italicsText">position</span>:
	</p>
	<pre class="language-sml"><code>
		val foo = (1, 2, 3)
		val bar = {1=1, 2=2, 3=3}
	</code></pre>
	<p>
		Above, there are few differences between
		<span class="monoText">foo</span> and <span class="monoText">bar</span> (if
		we print bar, we get back a tuple, <span class="monoText">(1, 2, 3)</span>).
		The most obvious of which is the way we would access the component values,
		and that tuples are shorter. To access a record with a field name
		<span class="monoText">age</span>, we would reference the field name
		<span class="monoText">age</span> to access the value stored in that field
		name. In contrast, we access a particular value in a tuple by referencing
		that value's position &mdash; e.g.,
		<span class="monoText">(#1 myTuple)</span> to access the value in position
		1. Why not just use records? Because tuples are such a common data structure
		that we provide it a syntax of its own; a form of
		<span class="term">syntactic sugar</span>.
	</p>
	<p>
		Which should we use? It depends on what we are trying to accomplish. Records
		are easier to access in terms of remembering which values are associated
		with which field (at least in comparison to indices). Usually, where a
		particular piece of information is best represented by numerous fields,
		records are the preferred choice, since they allow us to write descriptive
		field names. At the end of the day, it comes down to whether we want to
		refer to values in a collection by position, or by name.
	</p>
</section>

<section id="sum_types">
	<h2>Sum Types</h2>
	<p>
		A sum type describes the values containing a value of
		<span class="italicsText">one of</span> the types ${t_1, t_2, \ldots,
		\textit{ or } \space t_n.}$ An example of sum type data is
		<span class="monoText">int option</span>. Here, the data type either
		contains an <span class="monoText">int</span>
		<span class="underlineText">or</span> it does not. Functional languages like
		ML tend to handle sum types succinctly, at least as compared to
		object-oriented languages like Java, where sub-classing is almost always
		required.
	</p>

	<p>
		<span class="topic" id="datatype_bindings">Datatype Bindings.</span> Sum
		type data provide a good segway to
		<span class="term">datatype bindings</span>. So far, we've seen variable
		bindings, indicated by the use of <span class="monoText">val</span>, and
		function bindings, indicated by the use of
		<span class="monoText">fun</span>. With datetype bindings, we use the symbol
		<span class="monoText">datatype</span>. To create custom sum types, we
		create <span class="italicsText">datatype bindings</span>. The datatype
		binding takes the following form:
	</p>
	<figure class="math-display">
		<ul class="syntax">
			<li>
				datatype ${n}$ = ${a}$ of ${t_0}$ | ${b}$ of ${t_1}$ | ${c}$ of ${t_n}$
			</li>
		</ul>
		<ul class="def">
			<li class="where">${n}$ is the name of the datatype;</li>
			<li>${a, b, c}$ are constructors; and</li>
			<li>${t_n}$ are existing types</li>
		</ul>
	</figure>
	<p>
		Each of ${a, b, c}$ are called constructors. A constructor does what its
		name suggests &mdash; it constructs instances of the datatype ${n.}$ Those
		instances can be one of three things: ${t_0}$ of type ${n,}$ ${t_1}$ or type
		${n,}$ or ${t_n}$ of type ${n.}$ When we create a datatype bindings, we add
		all of these possibilities &mdash; ${t_0}$ of type ${n,}$ etc. &mdash; to
		both the static and dynamic environment. For example:
	</p>
	<p>
		A <span class="term">constructor</span> is just another function. In the
		case of datatype ${n,}$ it is a function that returns instances of datatype
		${n.}$.
	</p>
	<pre class="language-sml"><code>
		datatype fooType = TwoInts of int * int
										 | Str of string
									   | xyz
		val a = Str "Hi"
		val b = Str
		val c = xyz
		val d = TwoInts(1 + 1, 2 + 2)
		val e = a
	</code></pre>
	<pre class="language-bash"><code>
		datatype fooType = Str of string | TwoInts of int * int | xyz
		val a = Str "Hi" : fooType
		val b = fn : string -> fooType
		val c = xyz : fooType
		val d = TwoInts (2,4) : fooType
		val e = Str "Hi" : fooType
	</code></pre>
	<span class="marginnote"
		>We can think of the constructs like <span class="monoText">Str</span> and
		<span class="monoText">xyz</span> as &#8220;tags&#8221; indicating what
		kind, or <span class="term">variant</span>, of
		<span class="monoText">fooType</span> we have.</span
	>
	<p>
		This data type defines a new type for a value that can be one of three
		types: (1)
		<span class="monoText">int*int</span> (constructed by
		<span class="monoText">TwoInts</span>), (2)
		<span class="monoText">string</span> (constructed by
		<span class="monoText">Str</span>), or (3) nothing (constructed by
		<span class="monoText">xyz</span>). These three types determine what
		<span class="term">variant</span> of the data type the value is (e.g., is it
		an <span class="monoText">int*int</span>, a
		<span class="monoText">string</span>, or nothing). Again, these three
		entities are called constructors.
		<span class="marginnote"
			>More generally, the three entities are called
			<span class="term">tagged unions</span>.</span
		>
	</p>
	<p>
		When we include the constructor above, we insert four new entities to the
		environment: (1) a new type called <span class="monoText">fooType</span> to
		be used like any other type; (2) a constructor
		<span class="monoText">TwoInts</span>; (3) a constructor
		<span class="monoText">Str</span>; and (4) a constructor
		<span class="monoText">xyz</span>.
	</p>
	<p>
		Having created the datatype <span class="monoText">fooType</span>, we can
		instantiate the datatype:
	</p>
	<pre class="language-sml"><code>
		val a = Str "Hello" (* evaluates to Str("Hello") *)
		val b = TwoInts(1, 3-2)
		val c = Str (* evaluates to fn : string -> fooType *)
	</code></pre>
	<p>
		Anytime we create a datatype ${n}$, subsequent values of type ${n}$ are made
		with one of ${n}$'s constructors. Hence the name &#8220;one-of type.&#8221;
		The constructor's return consists of two parts &mdash; (1) a tag indicating
		which constructor was used to create the value, and (2) the actual data
		stored.
	</p>

	<p>
		Once we've created a datatype, we need a way to access its variants. We do
		so with what we might call
		<span class="term">variant-accessing functions</span>. These functions
		generally take two forms: (1) checking
		<span class="italicsText">what</span> the variant is, or (2) extracting, if
		any, the data associated with that variant. We've seen some of these
		functions already. The functions <span class="monoText">null</span> and
		<span class="monoText">isSome</span> check what variant a
		<span class="monoText">list</span> is (is it a
		<span class="monoText">list</span> or is it
		<span class="monoText">null</span>) and whether an
		<span class="monoText">option</span> has a some-value respectively. In
		contrast, the <span class="monoText">hd</span>,
		<span class="monoText">tl</span>, and
		<span class="monoText">valOf</span> functions all
		<span class="italicsText">extract</span> data from a given datatype.
	</p>

	<p>
		<span class="topic">Enumerations.</span> An enumeration, or
		<span class="term">an enumerated type</span>, are one kind of sum type. In
		object-oriented languages, they are often called
		<span class="monoText">enum</span>s (&#8220;eh-nooms&#8221;), and in R, it
		is called a <span class="monoText">factor</span>. In formal mathematics and
		statistics, they are broadly referred to as
		<span class="italicsText">categorical variables</span>. Some examples: U.S.
		currency has many different enumerations: penny, nickel, quarter,
		half-dollar, one-dollar, five-dollar, ten-dollar, twenty-dollar,
		fifty-dollar, a hundred-dollar. Traffic lights in North America have three
		enumerations: red, yellow, green. Here is another example in ML code:
	</p>

	<pre class="language-sml"><code>
		datatype suit = Club | Diamond | Heart | Spade
	</code></pre>

	<p>
		Regardless of what variant of <span class="monoText">suit</span> the value
		is, that variant can itself contain data:
	</p>

	<pre class="language-sml"><code>
		datatype rank = Jack | Queen | King | Ace | Num of int
	</code></pre>

	<p>
		We can combine these two sum types into a product type:
		<span class="monoText">suit * rank</span>. Sum types are particularly useful
		when we want to have different data in response to the state of the world.
		For example, maybe we are operating a library where we want to identify a
		book by an ID number, but if the book does not have an ID, use instead the
		book's title:
	</p>

	<pre class="language-sml"><code>
		datatype id = BookNum of int
								| Title of string*(string option)*string 
	</code></pre>

	<p>
		Enumerations, or sum types more generally, are often neglected by beginning
		programmers. Often, students will instead use a product type when a sum type
		is a much better fit. For example, say we wanted to represent a student in a
		course. Representing the cards with a product type, we might write:
	</p>
	<pre class="language-sml"><code>
		{
			studentID : int, (* if studentID is less than 0, use other fields, otherwise use studentID. *)
			firstName : string,
			middleName : string option, (* not all students have middle names *)
			lastName : string
		}
	</code></pre>
	<p>
		The problem with the approach above is twofold: (1) It's not very concise
		nor is it immediately clear; (2) the comments are playing too important of a
		role. The second point is more problematic than the first. Comments are
		important in code, but the moment they start controlling how a program runs,
		we've entered dangerous territory. Our program can have hundreds, if not
		thousands, of comments, and we can't expect either ourselves or others to
		remember all of them. A much better approach is to use a sum type:
	</p>
	<pre class="language-sml"><code>
		datatype student = studentID of int
										 | firstName of string
										 | middleName of string option
										 | lastName of string
	</code></pre>
	<p>
		The code above tells us that every value of type
		<span class="monoText">student</span> has at least one of the constructors
		above. Now, all this said, there are situations where we might want to use a
		product type. For example, maybe the
		<span class="monoText">student</span> type is one where every single
		<span class="monoText">student</span> must have all the properties above. In
		those situations, a product type would be more appropriate. But if we don't
		need all these properties &mdash; i.e., we just need to identify a student
		&mdash; a sum type is appropriate. As an aside, if we decide to use a
		product type, we should use an <span class="monoText">option</span> instead
		of a comment for the <span class="monoText">studentID</span>:
	</p>
	<pre class="language-sml"><code>
		{
			studentID : int option
			firstName : string,
			middleName : string option
			lastName : string
		}
	</code></pre>
</section>

<section id="caseExpressions">
	<h2>Case Expressions</h2>
	<p>
		Now that we know about variant-accessing functions, we might notice that
		some data types do not have the variant-accessing functions we saw for
		things like lists and optionals. For example, the
		<span class="monoText">string</span> type doesn't have variant-accessing
		functions like <span class="monoText">isString</span> or
		<span class="monoText">getString</span>. What happened there?
	</p>

	<p>
		Recall what we want with datatype bindings: (1) We need a way to determine
		what <span class="italicsText">variant</span> the value is, and (2) a way to
		extract the data, if any, associated with that variant. Languages like ML
		combine these two needs as a single construct through
		<span class="term">case expressions</span> and
		<span class="term">pattern matching</span>.
	</p>

	<pre class="language-sml"><code>
		datatype fooType = TwoInts of int * int
								 | Str of string
								 | xyz
		fun f (x : fooType) =
			case x of
				xyz => 3
				| Str s => 8
				| TwoInts(i1, i2) => i1 + i2
	</code></pre>

	<p>
		In the code above, we have the same datatype we saw before &mdash;
		<span class="monoText">fooType</span>.
		<span class="marginnote"
			>In ML, pattern matching is done in the order written.</span
		>
		The more interesting part is that we now have a function that takes a value
		of type <span class="monoText">fooType</span> (note that the parameter list
		is optional, but we include it for clarity). This function takes a
		<span class="monoText">myType</span> and returns an
		<span class="monoText">int</span>. The keywords
		<span class="monoText">case ... of</span> denote a
		<span class="italicsText">case expression</span>, and they are what we use
		to access the values of the given datatype. Each of the lines following
		<span class="monoText">case ... of</span> are
		<span class="italicsText">cases</span>, separated by a pipe (<span
			class="monoText"
			>|</span
		>). The case expression works as such: (1) If
		<span class="monoText">x</span> is an <span class="monoText">xyz</span>,
		evaluate to <span class="monoText">3.</span> (2) If
		<span class="monoText">x</span> is a <span class="monoText">Str</span>,
		evaluate to <span class="monoText">8</span>. (3) If
		<span class="monoText">x</span> is a <span class="monoText">TwoInts</span>,
		evaluate to <span class="monoText">i1 + i2</span>.
	</p>

	<figure class="math-display">
		<ul class="syntax">
			<li>${p}$ => ${\textit{exp}}$</li>
		</ul>
	</figure>

	<p>
		Where ${p}$ is a pattern, and ${\textit{exp}}$ is an expression. A more
		general syntax:
	</p>
	<figure class="math-display">
		<ul class="syntax">
			<li>fun ${f}$ ${x}$ =</li>
			<ul>
				<li>case ${x}$ of</li>
				<ul>
					<li>${p_0}$ => ${exp_0}$</li>
					<li>| ${p_1}$ => ${exp_1}$</li>
					<li>| ${p_2}$ => ${exp_2}$</li>
					<li>| ${\vdots}$</li>
					<li>| ${p_n}$ => ${exp_n}$</li>
				</ul>
			</ul>
		</ul>
	</figure>
	<p>
		Patterns are the construct used to
		<span class="underlineText">match</span> against the result of evaluating
		the case's first expression (in the syntax above,
		<span class="monoText">${p_0}$ => ${exp_0}$</span>.) This form of evaluation
		has a specific name &mdash; <span class="term">pattern matching</span>.
	</p>
	<p>
		Importantly, case expressions are <span class="term">first-match</span>,
		meaning that the moment there is a
		<span class="italicsText">pattern match</span>, the entire expression
		evaluates to that pattern match's expression. ML will not continue to check
		the remaining branches.
	</p>
	<p>
		Having introduced case expressions, we will stray from using
		<span class="monoText">hd</span>, <span class="monoText">tl</span>, and
		<span class="monoText">null</span>. These are all constructors, but it is
		far better to use the constructors <span class="monoText">[]</span> and
		<span class="monoText">::</span>. The constructor
		<span class="monoText">[]</span> represents the empty list, and
		<span class="monoText">::</span> represents the non-empty list. We will use
		these constructors alongside case expressions.
	</p>
	<p>
		<span class="topic">Pattern Matching in Other Languages.</span>
		pattern matching is almost synonymous with functional languages. This is
		because in many functional language implementations, designers follow the
		premise that the <span class="monoText">=</span> sign denotes
		<span class="italicsText">equivalence</span> rather than
		<span class="italicsText">assignment</span>.
		<span class="marginnote"
			>Introductory programming courses often emphasize that
			<span class="monoText">=</span> means assignment, not equality. This is
			usually the case for object-oriented languages like Java, but not
			necessarily accurate for the functional languages. Of course, such courses
			emphasize this point heavily without mention of the functional language
			side to avoid overcomplicating an introductory course.</span
		>
		The distinction between equivalence and assignment is a good point to
		distinguish the ways programs are written across various languages.
	</p>
	<p>
		In functional languages like ML (and more broadly, declarative languages),
		programs are written as a sequence of
		<span class="italicsText">expressions</span>. In other words, every
		expression in the language evaluates to some value, but the programmer
		leaves it to the computer to decide what to do, or how to handle, those
		values. In procedural languages (and more broadly, imperative languages)
		like C, programs are written as a sequence of
		<span class="italicsText">statements</span> &mdash; the programmer must
		instruct the computer how to perform a particular computation. The premise
		that <span class="monoText">=</span> means assignment stems from the
		imperative language tradition.
	</p>
	<p>
		Pattern matching in object-oriented languages like Java is not as clean or
		straightforward as it is in functional languages like ML. In ML, we have the
		<span class="monoText">case...of</span> construct. However, in other
		languages, we may have to use either a
		<span class="monoText">switch</span> statement or a series of
		<span class="monoText">if-elseIf-else</span> statements. Consider for
		example, Java:
	</p>
	<pre class="language-java"><code>
		enum TrafficLight {
			GREEN,
			YELLOW,
			RED
		}

		public class MainProgram{
			public static void main(String []args){
				TrafficLight streetA = TrafficLight.GREEN;
				String result = motion(streetA);
				System.out.println(result);
			}
			
			public static String motion(TrafficLight light) {
				if (light == TrafficLight.GREEN) {
						return "Go";
				}
				else if (light == TrafficLight.YELLOW) {
						return "Slow Down";
				}
				else {
						return "Stop";
				}
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		Go
	</code></pre>
	<p>
		The code above works, but it's not as clean as how we would write it in ML:
	</p>
	<pre class="language-sml"><code>
		datatype TrafficLight = Green
								 | Yellow
								 | Red
		fun motion x =
			case x of
				Green => "Go"
				| Yellow => "Slow down"
				| Red => "Stop"
		val x = Green
		val y = motion(x)
	</code></pre>
	<pre class="language-bash"><code>
		datatype TrafficLight = Green | Red | Yellow
		val motion = fn : TrafficLight -> string
		val x = Green : TrafficLight
		val y = "Go" : string
	</code></pre>
	<p>
		Moreover, the Java implementation won't check to see if we missed a case. ML
		will return a compiler error if we miss a case in a case expression.
		Moreover, the Java implementation won't catch if we have duplicate cases in
		the pattern matching. ML again will return a compiler error. Both these
		safeguards ensure that our program never uses runtime unless a pattern is
		found.
	</p>
	<p>
		Why isn't pattern matching more common in object-oriented languages? It's
		largely due to history and the market for programming languages. pattern
		matching &mdash; and algebraic data types more generally &mdash; can be
		traced to the Hope language in 1980.<span
			data-text="Although, possibly earlier, depending
		on how we define pattern matching"
			class="tooltip"
			><sup></sup
		></span>
		From Hope, algebraic data types and their associated features like pattern
		matching made their way into ML, and later on to Miranda, Haskell, and
		today, languages like Scala and Erlang. Had functional languages taken off,
		we probably would see more pattern matching constructs today.
	</p>
	<p>
		Unfortunately for the functional languages, the object-oriented languages
		reigned supreme. In their traditions, algebraic data types are arguably
		antithetical to the object-oriented philosophy, where data is expressed
		through objects and subtyping. We will see why there may be an antithesis in
		later sections.
	</p>
</section>

<section id="recursive_types">
	<h2>Recursive Types</h2>
	<p>
		A recursive compound data type is a type that can refer to itself in its
		definition to describe a recusive structure. We've seen one such recursive
		type, lists. An <span class="monoText">int</span> list describes values that
		contain either nothing, <span class="underlineText">or</span> contains an
		<span class="monoText">int</span>
		<span class="underlineText">and</span> another
		<span class="monoText">int</span> list. We can see this to be the case when
		we build a list recursively:
	</p>

	<figure class="math-display">
		<ul class="syntax">
			<li>1 :: [ 2 :: [3 :: [4 :: [5 :: [6 :: []]]]]]</li>
			<li>${\darr}$</li>
			<li>[1, 2, 3, 4, 5, 6]</li>
		</ul>
	</figure>

	<p>In fact, we can implement our own definition of a list:</p>

	<pre class="language-sml"><code>
		datatype list = Empty
								  | Cons of int * list
		val x = Cons(1, Cons(2, Cons (3, Empty)))
	</code></pre>
	<pre class="language-bash"><code>
		datatype list = Cons of int * list | Empty
		val x = Cons (1,Cons (2,Cons (3,Empty))) : list
	</code></pre>

	<p>
		Those familiar with a languages of the Lisp family may recognize the example
		above. With our implementation, we can write various functions:
	</p>

	<pre class="language-sml"><code>
		datatype list = Empty
							| Cons of int * list
		val x = Cons(1, Cons(2, Cons (3, Empty)))

		fun append (xs, ys) =
			case xs of
				Empty => ys
				| Cons(x, xs') => Cons(x, append(xs', ys))
	</code></pre>

	<h5>Expression Trees</h5>
	<p>
		Recursive types can be created through a combination of product or sum
		types. One particularly powerful recursive type are
		<span class="term">expression trees</span>. Expression trees are recursive
		product types. Consider, for example, the following:
	</p>
	<pre class="language-sml"><code>
		datatype exp = Constant of int
								 | Negate of exp
								 | Add of exp * exp
								 | Multiply of exp * exp
		fun eval e =
			case e of
				Constant i => i
				| Negate e2 => ~ (eval e2)
				| Add(e1, e2) => (eval e1) + (eval e2)
				| Multiply(e1, e2) => (eval e1) * (eval e2)

		val x = Add(Constant (10 + 9), Negate (Constant 4))
		val y = eval(x)
	</code></pre>
	<pre class="language-bash"><code>
		datatype exp
			= Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
		val eval = fn : exp -> int
		val x = Add (Constant 19,Negate (Constant 4)) : exp
		val y = 15 : int
	</code></pre>
	<p>
		Let's walk through this slowly. First, let's look at the datatype binding:
	</p>
	<pre class="language-sml"><code>
		datatype exp = Constant of int
								 | Negate of exp
								 | Add of exp * exp
								 | Multiply of exp * ex	
	</code></pre>
	<p>
		This datatype is called <span class="monoText">exp</span>. In it, there are
		four constructors: <span class="monoText">Constant</span>,
		<span class="monoText">Negate</span>, <span class="monoText">Add</span>, and
		<span class="monoText">Multiply</span>. The
		<span class="monoText">Constant</span> constructor is of type
		<span class="monoText">int</span>. I.e., it's a function that takes an
		<span class="monoText">int</span>. The other constructors,
		<span class="monoText">Negate</span>, <span class="monoText">Add</span>, and
		<span class="monoText">Multiply</span>, are recursive. They take an
		<span class="monoText">exp</span>. Now, let's focus on the value bound to
		<span class="monoText">x</span>:
	</p>
	<pre class="language-sml"><code>
		val x = Add(Constant (10 + 9), Negate (Constant 4))
	</code></pre>
	<p>
		This expression represents an
		<span class="italicsText">expression tree</span>:
	</p>
	<figure>
		<img
			src="{% static 'images/expressTree.svg' %}"
			alt="An expression tree"
			loading="lazy"
			class="forty-p"
		/>
	</figure>
	<p>
		The value we've assigned to <span class="monoText">x</span> is a value of
		type <span class="monoText">exp</span>. The value itself is composed of
		values of type <span class="monoText">exp</span>:
		<span class="monoText">Constant (10 + 9)</span> and
		<span class="monoText">Negate (Constant 4)</span>. The value
		<span class="monoText">Constant(10 + 9)</span> is composed of just one
		value, <span class="monoText">10 + 9</span>, which evaluates to an
		<span class="monoText">int</span>, <span class="monoText">19</span>. The
		value <span class="monoText">Negate(Constant 4)</span> consists of one
		value, <span class="monoText">Constant(4)</span>. In turn,
		<span class="monoText">Constant(4)</span> consists of one value,
		<span class="monoText">4</span>, which is an
		<span class="monoText">int</span>.
	</p>
	<p>
		We've effectively encapsulated the entire tree above into a single
		expression, made possible by a datatype binding. This means that every value
		of type <span class="monoText">exp</span> will look like some sort of tree.
		We can then pass that tree into a function:
	</p>
	<pre class="language-sml"><code>
		fun eval e =
			case e of
				Constant i => i
				| Negate e2 => ~ (eval e2)
				| Add(e1, e2) => (eval e1) + (eval e2)
				| Multiply(e1, e2) => (eval e1) * (eval e2)
	</code></pre>
	<p>
		The function above will perform a pattern match. If the value is a
		<span class="monoText">Constant</span>, return the integer. If the value is
		a <span class="monoText">Negate</span>, return the negation. If it's
		<span class="monoText">Add</span>, return the sum. And if it's a
		<span class="monoText">Multiply</span>, return the product. When we pass
		<span class="monoText">x</span> into the function, ML begins the pattern
		matching:
	</p>
	<figure class="math-display">
		<div>
			<pre class="language-pseudo"><code>
				Add(Constant (10 + 9), Negate (Constant 4))
				(Constant (10 + 9)) + (Negate(Constant 4))
				19 + (Negate(Constant 4))
				19 + (-(Constant 4))
				19 + (-4)
				15
			</code></pre>
		</div>
	</figure>
</section>

<section id="type_synonyms">
	<h2>Type Synonyms</h2>
	<p>
		Another extremely useful binding is the
		<span class="term">type synonym</span>. Many languages, for example Swift,
		provide this feature in other terms like
		<span class="italicsText">type alias</span>. A type synonym creates another
		name for existing type. We can then use that name interchangeable with the
		existing type.
	</p>

	<p>For example, if we write:</p>

	<pre class="language-sml"><code>
		type age = int
	</code></pre>

	<p>
		We now have a type called <span class="monoText">age</span>, which we can
		use wherever we must write <span class="monoText">int</span>. Needless to
		say, type synonyms are extremely lead to much more readable and meaningful
		programs.
	</p>

	<p>
		Note that type synonyms are a kind of
		<span class="term">name binding</span>, rather than a
		<span class="term">datatype binding</span>. In a datatype binding, we are
		introducing a new type &mdash; it is not the same as any existing type. The
		datatype binding will create constructors that produce a value of the new
		type. A type synonym, however, is a name binding &mdash; it is simply a name
		that points to an existing data type.
	</p>
	<p>
		Type synonyms are particularly useful when used with composite data types
		(i.e., the types we've created ourselves). For example:
	</p>
	<pre class="language-sml"><code>
		datatype suit = Club | Diamond | Heart | Spade
		datatype rank = Jack | Queen | King | Ace | Number of int
		type card = suit * rank
	</code></pre>
	<p>
		In the code above, we've created two sum types,
		<span class="monoText">suit</span> and <span class="monoText">rank</span>.
		Then, we represent a card as a tuple,
		<span class="monoText">(suit, rank)</span>. Instead of repeatedly writing
		<span class="monoText">suit * rank</span>, we simply call it
		<span class="monoText">card</span>.
	</p>
	<p>
		The same idea extends to product types. Instead of repeatedly writing a
		record, we can encapsulate it in a type synonym:
	</p>
	<pre class="language-sml"><code>
		type studentIdentification = { studentID : int option, 
																	 firstName : string,
																	 middleName : string option,
																	 lastName : string }
	</code></pre>
</section>

<section id="polymorphic_dataTypes">
	<h2>Polymorphic Datatypes</h2>
	<p>
		Recall that we noted how the <span class="monoText">list</span> and
		<span class="monoText">option</span> types are really datatype bindings. We
		want to refine this notion just a bit further. Lists and options are a
		special type of datatype binding &mdash; they are datatype bindings that
		take <span class="term">option parameters</span>. Thus,
		<span class="monoText">list</span> itself is not a type. The data types are
		actually <span class="monoText">int list</span> or
		<span class="monoText">string list</span>. The same goes for optionals.
		<span class="monoText">option</span> is not a type; it's
		<span class="monoText">int option</span>, or
		<span class="monoText">string option</span>.
	</p>
	<p>
		So what do the identifiers <span class="monoText">list</span> and
		<span class="monoText">option</span> represent? They are
		<span class="term">type constructors</span> &mdash; functions that take
		<span class="italicsText">type parameters</span> to produce types. More
		specifically, <span class="monoText">list</span> and
		<span class="monoText">option</span> are
		<span class="italicsText">polymorphic type constructors</span>.
	</p>
	<p>
		The type constructors <span class="monoText">list</span> and
		<span class="monoText">option</span> are examples of a big decision language
		designers have to make. Do we want a single
		<span class="term">polymorphic data type</span> (a data type that changes
		depending on what's passed into it) list, or do we want a single constructor
		called <span class="monoText">list</span> that produces different types
		depending on its parameters? ML's designers went with the second option, and
		included the ability for users to define their own polymorphic datatypes.
	</p>
	<p>
		For example, we can create a
		<span class="italicsText">polymorphic binary tree</span> type:
	</p>
	<pre class="language-sml"><code>
		datatype ('a, 'b) tree = Node of 'a * ('a, 'b) tree * ('a, 'b) tree
													 | Leaf of 'b
	</code></pre>
	<p>
		In the data type above, the type is not <span class="monoText">tree</span>.
		Instead, the types are <span class="monoText">int * string tree</span> or
		<span class="monoText">int * int tree</span>. It all depends on what's
		passed as arguments for alpha <span class="monoText">a</span> and alpha
		<span class="monoText">b</span> (the parameters
		<span class="monoText">'a</span> and <span class="monoText">'b</span>).
	</p>
</section>

<section id="functions_patternMatching">
	<h2>Pattern Matching & Functions</h2>
	<p>
		It turns out that in ML, we've been using pattern matching all along. To see
		how, we explore pattern matching further.
	</p>
	<p>
		In the previous sections, we used pattern matching with respect to sum
		types. We did so because that's really the only way we access the values
		stored in a sum type. But what about product types? We can actually use
		pattern matching for records and tuples. Let's consider the tuple. Suppose
		we had a function that takes a triple, and returns the sum of its individual
		parts:
	</p>
	<pre class="language-sml"><code>
		fun sum_triple triple =
			case triple of
				(x, y, z) => x + y + z
		
		val x = (1, 2, 3)
		val y = sum_triple(x)
	</code></pre>
	<pre class="language-bash"><code>
		val sum_triple = fn : int * int * int -> int
		val x = (1,2,3) : int * int * int
		val y = 6 : int
	</code></pre>
	<p>
		Above, we used a case expression. In this case, the function takes the
		tuple, and performs a computation, addition, where each of
		<span class="monoText">x</span>, <span class="monoText">y</span>, and
		<span class="monoText">z</span> match.
	</p>
	<p>
		The example above, however, is poor style. We've written what's called a
		<span class="italicsText">one-armed case expression</span> &mdash; a case
		expression that only has one case. A much better way:
	</p>
	<pre class="language-sml"><code>
		fun sum_triple triple = 
			let val (x, y, z) = triple
			in
				x + y + z
			end
		val x = (1, 2, 3)
		val y = sum_triple(x)
	</code></pre>
	<pre class="language-bash"><code>
		val sum_triple = fn : int * int * int -> int
		val x = (1,2,3) : int * int * int
		val y = 6 : int
	</code></pre>
	<p>
		Notice how we bound <span class="monoText">(x, y, z)</span> to
		<span class="monoText">triple</span>, the argument passed. This is just a
		pattern match. Another example:
	</p>
	<pre class="language-sml"><code>
		fun full_name person =
			let val { firstName = x, lastName = z } = person 
			in
				x ^ " " ^ z
			end
		val jane = { firstName = "Jane", lastName = "Eyre" } 
		val janeEyre = full_name(jane)
	</code></pre>
	<pre class="language-bash"><code>
		val full_name = fn : {firstName:string, lastName:string} -> string
		val jane = {firstName="Jane",lastName="Eyre"} :
			{firstName:string, lastName:string}
		val janeEyre = "Jane Eyre" : string
	</code></pre>
	<p>We can write the code above even more concisely:</p>
	<pre class="language-sml"><code>
		fun sum_triple (x, y, z) =
			x + y + z
		fun full_name { firstName = x, lastName = z } =
			x ^ " " ^ z

		val x = (1, 2, 3)
		val y = sum_triple(x)
		val jane = { firstName = "Jane", lastName = "Eyre" } 
		val janeEyre = full_name(jane)
	</code></pre>
	<pre class="language-bash"><code>
		val sum_triple = fn : int * int * int -> int
		val full_name = fn : {firstName:string, lastName:string} -> string
		val x = (1,2,3) : int * int * int
		val y = 6 : int
		val jane = {firstName="Jane",lastName="Eyre"} :
			{firstName:string, lastName:string}
		val janeEyre = "Jane Eyre" : string
	</code></pre>
	<p>
		Take a close look at how we wrote the functions. The variable we pass into
		the function &mdash; the argument &mdash; is actually a pattern match! This
		in turn means that we do not have to use the
		<span class="monoText">#</span> symbol to extract data from a tuple. We can
		simply pattern match. This also means that we do not always have to specify
		types for arguments.
	</p>
	<p>
		Having seen enough ML, we might notice something jump out at us. That
		function <span class="monoText">sum_triple</span> looks an awful lot like a
		function that takes three arguments. We've seen functions that take just one
		argument:
	</p>
	<pre class="language-sml"><code>
		fun double(x) =
			x * 2
		val x = 3
		val y = double(3)
	</code></pre>
	<pre class="language-bash"><code>
		val double = fn : int -> int
		val x = 3 : int
		val y = 6 : int
	</code></pre>
	<p>
		How does ML know when we're doing a pattern match and when we're passing
		arguments to a function? With a simple rule: Every function in ML only takes
		one argument, and uses pattern matching to take the parts out. In the case
		of our regular function definitions, the argument passed is a tuple. The
		tuple is the one argument.
		<span class="marginnote"
			>This feature in ML leads to the peculiar observation that ML is a
			language where there is no such thing as a multi-argument function. In
			other words, functions in ML can only take one parameter. Of course, this
			borders on pedantry and isn't a great marketing opener.</span
		>
		Whether the tuple has one, two, three, or a hundred parts, ML uses pattern
		matching to extract them. But what about functions that take no arguments?
	</p>
	<pre class="language-sml"><code>
		fun greet() = print "Hello!\n"
	</code></pre>
	<p>
		The rule still applies. Every function takes only one argument. Here, there
		are no arguments, so a pattern match is done. In this case, the pattern to
		match is <span class="monoText">()</span>, and it matches to a value of type
		<span class="monoText">unit</span>.
	</p>
	<p>
		Using pattern matching for functions allows us to write functions that would
		otherwise be extremely unwieldy to write in languages like Java.
	</p>
	<pre class="language-sml"><code>
		fun turn_left (x, y, z) = (y, z, x)
		fun turn_right coordinate = 
			turn_left(turn_left coordinate)
		fun complete_rotation coordinate = 
			turn_right(turn_right(turn_right coordinate))

		val original = (1, 2, 3)
		val turnLeft = turn_left(original) 
		val turnRight = turn_right(original)
		val turnRight_turnRight_turnRight = complete_rotation(original)
	</code></pre>
	<pre class="language-bash"><code>
		val turn_left = fn : 'a * 'b * 'c -> 'b * 'c * 'a
		val turn_right = fn : 'a * 'b * 'c -> 'c * 'a * 'b
		val complete_rotation = fn : 'a * 'b * 'c -> 'a * 'b * 'c
		val original = (1,2,3) : int * int * int
		val turnLeft = (2,3,1) : int * int * int
		val turnRight = (3,1,2) : int * int * int
		val turnRight_turnRight_turnRight = (1,2,3) : int * int * int
	</code></pre>
	<p>
		Using pattern matching allows us to write functions whose arguments
		immediately pass into another function without the need to explicitly write
		out parameters. This is something not very many languages can do. In ML, the
		three functions above are written succinctly because of pattern matching. In
		other languages like Java, it's fairly awkward to implement. Not only does
		pattern matching allow ML to handle functions like those above easily, it
		reduces the <span class="italicsText">size</span> of a language's
		implementation. Here, ML's size is reduced by the fact that there is no
		separate implementation for multi-argument functions.
	</p>

	<h3>Excursion: Pattern Matching in Swift</h3>
	<p>
		Some languages, like Swift, have been directly inspired by pattern matching
		in functional languages. And rightly so; it is a truly killer feature. For
		example, in Swift, we can iterate through a list of tuples in several ways.
		Suppose we have an array of 2-tuples, and we want to print just the second
		part of the tuple:
	</p>
	<pre class="language-swift"><code>
		import Foundation

		let arrTuple = [(0, 1), (2, 3), (4, 5)]
		for i in 0..&lt;arrTuple.count {
				print(arrTuple[i].1)
		}
	</code></pre>
	<pre class="language-bash"><code>
		1
		3
		5
	</code></pre>
	<p>
		The code above works fine, but it can be made more concise with pattern
		matching:
	</p>
	<pre class="language-swift"><code>
		import Foundation

		let arr = [(0, 1), (2, 3), (4, 5)]
		for (_, i) in arr {
				print(i)
		}
	</code></pre>
	<pre class="language-bash"><code>
		1
		3
		5
	</code></pre>
	<p>
		In this case, we've used <span class="monoText">_</span> (the underscore) to
		indicate a pattern match, since we don't care for the first part of the
		tuple.
	</p>
</section>

<section id="type_inference_and_patternMatching">
	<h2>Type Inference & Pattern Matching</h2>
	<p>
		Having discussed pattern matching, we should address its relationship to
		type inference. The topic of type inference will be discussed in later
		sections. Recall that we can use <span class="monoText">#</span> to access
		the values in a record or tuple. With pattern matching, we no longer need to
		use <span class="monoText">#</span>, nor do we need to explicitly state the
		types for our function arguments. Why are we allowed to do this? Because ML
		uses pattern-matching to infer types. However, for type inference to work,
		we have to give ML enough information to work with.
	</p>
	<p>Notice ML's type inference for these functions:</p>
	<pre class="language-sml"><code>
		fun sum_triple (x, y, z) =
			x + y + z
		fun full_name {firstName = x, lastName = y} =
			x ^ " " ^ y
	</code></pre>
	<pre class="language-bash"><code>
		val sum_triple = fn : int * int * int -> int
		val full_name = fn : {firstName:string, lastName:string} -> string
	</code></pre>
	<p>
		ML can infer the types for these functions because of the computations we
		intend to perform in the functions' bodies. For
		<span class="monoText">sum_triple</span>, we are asking for addition, so ML
		infers <span class="monoText">int</span>. In
		<span class="monoText">full_name</span>, we are asking for concatenation, so
		ML infers <span class="monoText">string</span>. The patterns told ML most of
		what is needed for type inference; the rest of the necessary information is
		provided by the operations. If we used the
		<span class="monoText">#</span> syntax, type inference will still work:
	</p>
	<pre class="language-sml"><code>
		fun sum_triple (triple : int*int*int) =
			#1 triple + #2 triple + #3 triple
		fun full_name (n: {firstName:string, lastName:string}) =
			#firstName n ^ " " ^ #lastName n
	</code></pre>
	<pre class="language-bash"><code>
		val sum_triple = fn : int * int * int -> int
		val full_name = fn : {firstName:string, lastName:string} -> string
	</code></pre>
	<p>
		Now, notice what happens when remove our explicit type indicator for the
		first function:
	</p>
	<pre class="language-sml"><code>
		fun sum_triple (triple) =
			#1 triple + #2 triple + #3 triple
		fun full_name (n: {firstName:string, lastName:string}) =
			#firstName n ^ " " ^ #lastName n
	</code></pre>
	<pre class="language-bash"><code>
		records.sml:1.3-2.36 Error: unresolved flex record (need to know the names of ALL the fields
		in this context)
			type: {1:'Y[OL(+,+)], 2:'Y[OL(+,+)], 3:'Y[OL(+,+)]; 'Z}
	</code></pre>
	<p>
		ML cannot infer the type and returns a compilation error. This is because ML
		knows that there must be a tuple, but it has no idea whether the tuple has
		four, five, or even a hundred parts. Thus, we have to provide the indicator
		explicitly.
	</p>
	<p>
		<span class="topic">Polymorphic Functions.</span> What happens when a
		function doesn't use all of its arguments? How does type inference work
		there? Well, let's see an example:
	</p>
	<pre class="language-sml"><code>
		fun partial_sum (x, y, z) =
			x + z

		fun full_name {firstName = x, middleName = y, lastName = z} =  
			x ^ " " ^ z
	</code></pre>
	<pre class="language-bash"><code>
		val partial_sum = fn : int * 'a * int -> int
		val full_name = fn :
			{firstName:string, lastName:string, middleName:'a} -> string
	</code></pre>
	<p>
		Notice the <span class="monoText">'a</span>. The
		<span class="monoText">'a</span> indicates that the particular part not used
		can be of any type. The function will still work; the function is just more
		general &mdash; i.e., a <span class="term">polymorphic function</span>.
	</p>
</section>

<section id="polymorphicEqualityTypes">
	<h3>Polymorphic & Equality Types</h3>
	<p>
		We can gain some insight into how ML infers types for polymorphic functions
		by looking at a simple example:
	</p>
	<pre class="language-sml"><code>
		fun append(xs, ys) =
			case xs of
				[] => ys
				| x::<span data-text="Note that this is just a variable binding. We could have used anything here." class="tooltip">xs'</span> => x :: append(xs', ys)
		val list1 = append(["a", "b"], ["c", "d"])
		val list2 = append([1, 2], [3, 4])
	</code></pre>
	<pre class="language-bash"><code>
		val append = fn : 'a list * 'a list -> 'a list
		val list1 = ["a","b","c","d"] : string list
		val list2 = [1,2,3,4] : int list
	</code></pre>
	<p>
		Notice that ML can infer the list's type even if we didn't explicitly state
		it. Our function <span class="monoText">append()</span> is polymorphic. It
		has a type of <span class="monoText">'a list * 'a list -> 'a list</span>,
		which is more general than some like
		<span class="monoText">string list * string list -> string list</span>. The
		<span class="monoText">xs</span> and <span class="monoText">ys</span> can be
		of any type. What we cannot do is use
		<span class="monoText">append()</span> with lists of different types:
	</p>
	<pre class="language-sml"><code>
		fun append(xs, ys) =
			case xs of
				[] => ys
				| x::xs' => x :: append(xs', ys)
		val list3 = append([1, 2], ["a", "b"])
	</code></pre>
	<pre class="language-bash"><code>
		records.sml:7.5-7.39 Error: operator and operand do not agree [overload - bad instantiation]
		operator domain: 'Z[INT] list * 'Z[INT] list
		operand:         'Z[INT] list * string list
		in expression:
			append (1 :: 2 :: nil,"a" :: "b" :: nil)
	</code></pre>
	<p>
		We cannot do so because all the <span class="monoText">'a</span> must be
		replaced with a single type. However, we can append two lists of different
		types, as long as we use a second type parameter,
		<span class="monoText">'b</span>.
	</p>
	<p>
		In some situations, we might notice a
		<span class="monoText">''a</span> &mdash; two quotations instead of one. For
		example, a function type that looks like:
	</p>
	<figure class="math-display">
		<div>
			<pre class="language-pseudo"><code>
				''a list * ''a -> int
			</code></pre>
		</div>
	</figure>
	<p>
		The two prime ticks indicate an <span class="term">equality type</span>. An
		equality type is a type whose value can be used with the
		<span class="monoText">=</span> operator. This means that a function with
		the type above is polymorphic, but we the set of possible types that
		<span class="monoText">''a</span> can take is limited &mdash; only those
		that can be used with the <span class="monoText">=</span> operator. The set
		includes types like <span class="monoText">string</span>,
		<span class="monoText">int</span>, as well as tuples and lists (as long as
		they are composed of equality type values), but does not include types like
		<span class="monoText">real</span> (floating point values) and function
		types.
	</p>
</section>

<section id="nested_patterns">
	<h2>Nested Patterns</h2>
	<p>
		Return to pattern matching, we can nest case expressions as much as we'd
		like. However, a better approach is nesting the patterns rather than the
		case expressions themselves; nested patterns are usually much easier to read
		than nested case expressions.
	</p>
	<p>
		Pattern matching is recursive. The process: ML takes a pattern (which itself
		can contain patterns) and a value (which can contain other values) and asks,
		does this value have the same &#8220;shape&#8221; described by the pattern?
		If the answer is yes, then ML binds the relevant variables to the
		corresponding parts. This is very abstract, so several examples are needed.
	</p>
	<p>Suppose we have the following tuple of lists:</p>
	<figure class="math-display">
		<div>
			<pre class="language-pseudo"><code>
				([1, 2, 3], [4, 5, 6], [7, 8, 9])
			</code></pre>
		</div>
	</figure>
	<p>We want to write a function that returns the following:</p>
	<figure class="math-display">
		<div>
			<pre class="language-pseudo"><code>
				[(1, 4, 7), (2, 5, 6), (3, 6, 9)]
			</code></pre>
		</div>
	</figure>
	<p>
		Notice the pattern? The function takes a tuple of three lists, then returns
		a list of three tuples, where each the first tuple consists of all the first
		elements of the three lists, the second tuple consists of all the second
		elements of the three lists, and the third tuple consists of all the third
		elements of the three lists.
	</p>
	<p>Without pattern matching, the function would look like:</p>
	<pre class="language-sml"><code>
		exception ListLengthMisMatch

		fun zip1(l1, l2, l3) = 
			if null l1 andalso null l2 andalso null l3
			then []
			else if null l1 orelse null l2 orelse null l3
			then raise ListLengthMismatch
			else (h2 l1, hd l2, hd l3) :: zip(tl l1, tl l2, tl l3)
	</code></pre>
	<p>
		The function above is pretty messy to look at. Worse, we are taking the risk
		of missing a case, and we aren't relying on any help from the type checker.
		What if we used pattern matching?
	</p>
	<pre class="language-sml"><code>
		fun zip2 (l1, l2, l3) =
			case l1 of
				[] =>
				(case l2 of
					[] => (case l3 of
							[] => []
							| _ => raise ListLengthMismatch)
						| _ => raise ListLengthMismatch)
					| hd1 :: tl1 =>
						(case l2 of
							[] => raise ListLengthMismatch
							| hd2::tl2 => (case l3 of
									[] => raise ListLengthMismatch
									| hd3::tl3 =>
										(hd1, hd2, hd3)::zip3(tl1, tl2, tl3)))
	</code></pre>
	<p>
		This looks even worse than the previous implementation. Rather than using
		<span class="monoText">andalso</span> and
		<span class="monoText">orelse</span>, we're manually checking for all the
		possible patterns. Luckily there's a better way. Instead of checking for
		every pattern, we want to use the fact that patterns can exist inside
		patterns.
	</p>
	<p>Here is another implementation:</p>
	<pre class="language-sml"><code>
		fun zip list_triple =
			case list_triple of
				([], [], []) => []
				| (hd1::tl1, hd2::tl2, hd3::tl3) => (hd1, hd2, hd3)::zip3(tl1, tl2, tl3)
				| _ => raise ListLengthMismatch
	</code></pre>
	<p>In the example above, we're only considering three patterns. First:</p>
	<figure class="math-display">
		<div>
			<pre class="language-pseudo"><code>
				
				([], [], [])
			</code></pre>
		</div>
	</figure>
	<p>
		The pattern above is a tuple with three lists. When ML sees this pattern, it
		will match any value it finds that has the pattern of three empty lists
		within a tuple. If ML finds a match, it returns the empty list
		<span class="monoText">[]</span>.
	</p>
	<p>Then there's a second pattern:</p>
	<figure class="math-display">
		<div>
			<pre class="language-pseudo"><code>
				(hd1::tl1, hd2::tl2, hd3::tl3)
			</code></pre>
		</div>
	</figure>
	<p>
		This pattern consists of a few parts: First, it is a tuple. Second, it is a
		3-tuple with three non-empty lists. I.e., it has a head and a tail. This
		means that <span class="monoText">list_triple</span> will only match if it
		is a tuple with three non-empty lists. If matches, then we bind each head of
		the three lists in the tuple to <span class="monoText">hd1</span>,
		<span class="monoText">hd2</span>, and <span class="monoText">hd3</span>.
		The same goes for <span class="monoText">tl1</span>,
		<span class="monoText">tl2</span>, and <span class="monoText">tl3</span>.
		Then, <span class="monoText">cons</span> the result of
		<span class="monoText">(hd1, hd2, hd3)</span> to
		<span class="monoText">zip3(tl1, tl2, tl3)</span>. Notice how this is
		recursive.
	</p>
</section>

<section id="exceptions">
	<h2>Exceptions</h2>
	<p>
		Having discussed patterns, we can now more thoroughly investigate
		<span class="term">exceptions</span>: idioms for indicating a particular
		condition as a runtime error. Exceptions are not unique to ML; they are
		found in numerous languages, both old and new. They are even found in
		reality &mdash; they are quite literally exceptions to a general rule or
		condition. For example, a professor might have a general rule of not
		accepting late assignments. However, there may be exceptions to that general
		rule: A personal emergency, being ill, or obtaining special permission for a
		late submission. Examining this from a programming perspective, we might
		model the professor's grading scheme as including a function called
		<span class="monoText">is_generally_compliant()</span>, which checks whether
		a given submission is late. If the submission is late, it returns false.
		But, if some condition is true (i.e., excused earlier), we
		<span class="italicsText">throw</span>, or
		<span class="italicsText">raise</span> an exception. When that exception is
		raised, we need some way to <span class="italicsText">handle</span>, or
		<span class="italicsText">catch</span>, that exception: Return some message,
		execute that function, or store this data, etc.
	</p>
	<p>The syntax for defining exceptions in ML:</p>
	<figure class="math-display">
		<div>
			<ul class="syntax">
				<li>exception ${e_n}$</li>
			</ul>
		</div>
		<figcaption>where ${e_n}$ is some identifier</figcaption>
	</figure>
	<p>
		Th expression ${e_n}$ is actually a constructor, with the identifier
		${e_n.}$ Because constructors are functions, exceptions in ML are first
		class, so they are themselves values. And because they are values, they have
		type, namely <span class="monoText">exn</span>. Thus, if we wrote:
	</p>
	<pre class="language-sml"><code>
		exception Error
	</code></pre>
	<p>
		we introduce into the environment the value
		<span class="monoText">Error : exn</span>.<label
			for="sml_exception"
			class="margin-toggle"
			><sup></sup
		></label>
		<input
			type="checkbox"
			id="sml_exception"
			class="margin-toggle sidenote-number"
		/>
		<span class="marginnote"
			>The keyword <span class="monoText">exn</span> is a clipping of
			&#8220;exception name.&#8221;</span
		>
		To repeat, in the example above, the value
		<span class="monoText">Error</span> is not itself the exception; it's the
		constructor for an exception. Thus, to derive any use of exceptions, they
		must be <span class="term">raised</span>.<label
			for="throwing"
			class="margin-toggle"
			><sup></sup
		></label>
		<input
			type="checkbox"
			id="throwing"
			class="margin-toggle sidenote-number"
		/>
		<span class="marginnote"
			>In other languages, raising an exception is called
			<span class="term">throwing</span> an exception.</span
		>
		Here is an example:
	</p>
	<pre class="language-sml"><code>
			(* This function computes the factorial of a number. *)
			fun factorial n =
				let exception Negative
				in
					if n = 0
						then 1
					else
						if n < 0 then raise Negative
						else n * factorial(n - 1)
				end

			val x = factorial 4
			val y = factorial ~2
		</code></pre>
	<pre class="language-bash"><code>
			uncaught exception Negative
				raised at: exceptions.sml:8.24-8.32
		</code></pre>
	<p>
		In the example above, we created a new value,
		<span class="monoText">Negative : exn</span>, and we raise it whenever a
		negative number is passed as a value to the function
		<span class="monoText">factorial()</span>. Fixing the error:
	</p>
	<pre class="language-sml"><code>
		(* This function computes the factorial of a number. *)
		fun factorial n =
			let exception Negative
			in
				if n = 0
					then 1
				else
					if n < 0 then raise Negative
					else n * factorial(n - 1)
			end

		val x = factorial 4
		val y = factorial 2
	</code></pre>
	<pre class="language-bash"><code>
		val factorial = fn : int -> int
		val x = 24 : int
		val y = 2 : int
	</code></pre>
	<p>
		In many situations, we want to <span class="term">handle</span> the
		exception.<label for="handle" class="margin-toggle"><sup></sup></label>
		<input type="checkbox" id="handle" class="margin-toggle sidenote-number" />
		<span class="marginnote"
			>In other languages, this is also called
			<span class="term">catching</span> the exception.</span
		>
		For example, perhaps we might want, for whatever reason, to immediately
		return <span class="monoText">0</span> whenever we pass a negative number to
		the <span class="monoText">factorial()</span> function. To do so, we can use
		a <span class="term">handle expression</span>:
	</p>
	<pre class="language-sml"><code>
		(* This function computes the factorial of a number. *)
		fun factorial n =
			let 
				exception Negative
			in
				if n = 0
					then 1
				else
					if n < 0 then raise Negative
					else n * factorial(n - 1)
			end

		val a = 5
		val b = ~5
		val x = factorial a
		val y = factorial b handle Negative => 0
	</code></pre>
	<pre class="language-bash"><code>
		val factorial = fn : int -> int
		val a = 5 : int
		val b = ~5 : int
		val x = 120 : int
		val y = 0 : int
	</code></pre>
	<p>
		In the last line of the source code above, when the
		<span class="monoText">factorial()</span> function raises the exception
		<span class="monoText">Negative</span>, the value of
		<span class="monoText">y</span> is immediately bound to
		<span class="monoText">0</span>.
	</p>
</section>

<section id="tail_recursion">
	<h2>Tail Recursion</h2>
	<p>
		Most of the functions we've seen are recursive. This raises a fair question:
		How efficient is recursion? To answer this question, we investigate the idea
		of <span class="term">tail recursion</span>. To understand tail recursion,
		let's talk about the <span class="term">call stack</span>.
	</p>
	<p>
		The call stack is an abstract idea; think of it as this stack of papers,
		each with a single task. Those tasks are functions, and each piece of paper
		is called a <span class="term">stack frame</span>. The piece of paper, or
		call stack, contains the value of local variables, and all the operations
		the function must perform. Whenever we call a function ${f,}$ we push a
		stack frame of ${f,}$ a new piece of paper, onto the stack. Once that call
		to ${f}$ finishes (i.e., the task is complete), ${f}$ is removed from the
		stack (in programming parlance, the stack frame is
		<span class="italicsText">popped off</span> the stack).
	</p>
	<p>
		Now, with recursion, we are calling functions that call themselves. Thus,
		there is a situation where we have multiple stack-frames resulting from
		calls to the same function. For example, with the
		<span class="monoText">factorial()</span> function we wrote previously,
		calling <span class="monoText">factorial(3)</span> results in four separate
		stack frames: <span class="monoText">factorial(3)</span>,
		<span class="monoText">factorial(2)</span>,
		<span class="monoText">factorial(1)</span>, and
		<span class="monoText">factorial(0)</span>.
	</p>
	<p>
		Here is a more efficient version of
		<span class="monoText">factorial()</span> (for simplicity, we've removed the
		exception from the earlier section):
	</p>
	<pre class="language-cpp"><code>
		(* This function computes the factorial of a number. *)
		fun factorial n =
			let fun factorial_helper(n, accumulator) =
				if n = 0
					then accumulator
					else factorial_helper(n - 1, accumulator * n)
			in
				factorial_helper(n, 1)
			end

		val a = factorial(3)
	</code></pre>
	<pre class="language-bash"><code>
		val factorial = fn : int -> int
		val a = 6 : int
	</code></pre>
	<p>
		This looks more complicated, so let's walk through it. Inside
		<span class="monoText">factorial()</span>, we have a locally-defined helper
		function, <span class="monoText">factorial_helper()</span>. That function
		takes two arguments: <span class="monoText">n</span>, the argument passed to
		<span class="monoText">factorial()</span>, and
		<span class="monoText">accumulator</span>.
		<span class="monoText">factorial_helper()</span> works as such: If
		<span class="monoText">n=0</span>, then return the
		<span class="monoText">accumulator</span>; otherwise, return
		<span class="monoText">factorial_helper(n-1, accumulator * n)</span>.
	</p>
	<p>
		Thus, when we call <span class="monoText">factorial(3)</span>, we end up
		creating the following stacks:
		<span class="monoText">factorial_helper(3, 1)</span>,
		<span class="monoText">factorial_helper(2, 3)</span>,
		<span class="monoText">factorial_helper(1, 6)</span>, and
		<span class="monoText">factorial(0, 6)</span>. This may not seem like an
		improvement; we have a bigger stack than the previous implementation!
	</p>
	<p>
		This is where tail recursion comes into play. In languages that implement
		tail recursion &mdash; such as ML &mdash; calls like
		<span class="monoText">factorial_helper()</span> are identified by the
		language as tail calls. And when a call is identified as a tail call, the
		language follows a specific rule: Do not keep a function's stack frame if
		all the function performs is getting back a callee's result and return it
		without any further evaluation. Following this rule, languages like ML
		perform the following whenever it encounters a tail call like
		<span class="monoText">factorial_helper()</span>:
	</p>
	<figure class="math-display">
		<div class="rule">
			<ol>
				<li>
					Remove the caller <span class="underlineText">before</span> the call.
				</li>
				<li>Let the callee use the resulting empty stack.</li>
			</ol>
		</div>
	</figure>
	<p>
		Thus, when we call <span class="monoText">factorial(3)</span>, a tail call,
		we create a stack frame for <span class="monoText">factorial(3)</span>.
		However, because it's a tail call, the stack frame is &#8220;cleared&#8221;
		of <span class="monoText">factorial(3)</span>'s machine code, and replaced
		with <span class="monoText">factorial_helper(3, 1)</span>. This in turn
		calls <span class="monoText">factorial_helper(n-1, accumulator * n)</span>,
		and as such, <span class="monoText">factorial_helper(3, 1)</span> is itself
		a tail call. Thus, <span class="monoText">factorial_helper(3, 1)</span> has
		its stack frame cleared, and replaced with
		<span class="monoText">factorial_helper(2, 3)</span>. This goes on until we
		reach <span class="monoText">factorial_helper(0, 6)</span>. The end result:
		We only used 1 stack frame.
	</p>
	<p>
		To refactor recursive functions as tail-recursive, we can use the following
		approach:
	</p>
	<figure class="math-display">
		<div class="rule">
			<ol>
				<li>Create a helper function with an accumulator parameter.</li>
				<ul>
					<li>
						Think of the accumulator as a variable that &#8220;holds&#8221; the
						answer so far.
					</li>
				</ul>
				<li>Think of the old base case as the initial accumulator.</li>
				<li>Think of the new base case as the final accumulator.</li>
			</ol>
		</div>
	</figure>
	<p>For example, consider a function that sums all the elements in a list:</p>
	<pre class="language-sml"><code>
		(* linear recursion *)
		fun summate1 xs =
			case xs of
				[] => 0
				| x::xs' => x + summate1 xs'

		(* tail recursion *)
		fun summate xs =
			let 
				fun helper(xs, accumulator) =
					case xs of
						[] => accumulator
						| x::xs' => helper(xs', x + accumulator)
			in
				helper(xs, 0)
			end
	</code></pre>
</section>
{% endblock %}
