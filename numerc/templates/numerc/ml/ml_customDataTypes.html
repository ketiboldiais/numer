{% extends '../layout.html' %} {% load static %} {% block content %}
<section id="custom_data_types">
	<h3>Composite Data Types</h3>

	<p>
		Data types in programming languages fall into two categories: (1)
		<span class="term">base types</span>, and (2)
		<span class="term">compound types</span> (also called
		<span class="italicsText">composite types</span>). We avoid using the term
		<span class="italicsText">primitive types</span> for base types because the
		word <span class="italicsText">primitive type</span> connotes a type that
		cannot be modified, which is not necessarily true of all languages (Swift,
		for example, allows its base types provided by the standard library to be
		extended). A language's base types are the types the language provides by
		default. These are the types that describe the basic values the language
		understands. In ML, these types include <span class="monoText">int</span>,
		<span class="monoText">bool</span>, <span class="monoText">real</span>,
		<span class="monoText">unit</span>, etc.
	</p>

	<p>
		In contrast, composite types are data types that contain other types in
		their definition. The data types <span class="monoText">tuple</span>,
		<span class="monoText">list</span>, and
		<span class="monoText">option</span> are all examples of a compound data
		type. More specifically, these are a kind of compound data type called an
		<span class="term">algebraic data type</span>.
	</p>

	<p>
		In ML and most other languages, there are three building blocks to
		constructing a composite type: (1) an <span class="term">each-of</span> type
		(more formally, <span class="term">product types</span>); (2) a
		<span class="term">one-of</span> type (formally a
		<span class="term">sum type</span>); and (3) a
		<span class="term">self-reference</span> type (a
		<span class="term">recursive type</span>). We go over each of these in turn.
	</p>

	<p>
		In an <span class="italicsText">each-of type</span> ${p,}$ the value of type
		${p}$ contains multiple values, where each value has the type ${t_1,}$
		${t_2,}$ ${\ldots,}$ ${t_n.}$ (Type ${t_i}$) being some base type or other
		compound type). Thus, if we have a value of type ${p,}$ then that value will
		have values of ${t_1,}$ ${t_2,}$
		<span class="underlineText">and</span> ${t_n.}$
	</p>

	<p>
		In a <span class="italicsText">one-of type</span> ${s,}$ the value of type
		${s}$ contains multiple values, where each value is one of ${t_1,}$ ${t_2,}$
		${\ldots,}$ ${t_n.}$ In other words, if we have value of type ${s,}$ then
		the value has values of type type ${t_1,}$ ${t_2,}$
		<span class="underlineText">or</span> ${t_n.}$
	</p>

	<p>
		Finall, a value with a
		<span class="italicsText">self-reference type</span> ${r}$ is a value that
		contains other values of type ${r.}$ I.e., there is some notion of
		self-reference. Types like lists or trees are self-reference types. Why?
		Because values of a list type contain other lists, and values of a tree type
		contain other trees.
	</p>

	<p>
		Notice that these types correspond to the logical
		<span class="monoText">AND</span>, <span class="monoText">OR</span>, and the
		axiom of induction. It turns out that with just these three constructs, we
		can describe an enormous amount of data. How? For starters, compound data
		types can nest, so we can have many different combinations of the data types
		above. We might have a recursive-sum type, or a sum-product type, or a
		recursive-sum-product type, etc.
	</p>
</section>
{% endblock %}
