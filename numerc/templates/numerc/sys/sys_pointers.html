{% extends '../layout.html' %} {% load static %} {% block description %}
<meta
	name="description"
	content="What are pointers? Overview of pointers, pointer operators, allocating memory in the heap, pointer arithmetic."
/>
{% endblock %} {% block title %}
<title>Pointers</title>
{% endblock %} {% block content %}
<h1>Pointers</h1>

<section id="pointer_basics">
	<p>
		<span class="drop">L</span>et's talk pointers. We saw pointers in the volume
		on C++, but now we're going to explore them much more rigorously. Pointers
		are often a point of confusion among new programmers, but their underlying
		concepts are fairly simple. Applying those concepts, however, can be
		challenging, as we'll see. The trick to getting over these challenges:
		Establishing a very strong understanding of the underlying concepts, and
		practicing using pointers as much as possible.
	</p>

	<p>
		Programming in C, it's pretty much inevitable that we use pointers in some
		way. The language is too substantially limited without using pointers.
		Because much of exploration into computer systems relies heavily on C, it is
		imperative that we are as comfortable with pointers as possible.
	</p>

	<p>Pointers in C are necessary for the following tasks:</p>

	<figure>
		<ol class="numd">
			<li>Passing by pointer.</li>
			<li>Returning more than one output from a function.</li>
			<li>Passing arrays and strings to functions.</li>
			<li>Allocating unknown memory at runtime.</li>
		</ol>
	</figure>

	<p>
		That said, let's get some terminology out of the way. At the end of the day,
		a <b>pointer</b> is just a variable. But, it's a variable with a special
		ability: It stores a <b>reference</b> to another variable. The variable the
		pointer refers to is called the pointer's <b>pointee</b>. When two pointers
		refer to the same pointee, we say that the pointers are <b>sharing</b>.
		Because a pointer is a variable with this special feature, there are two
		things we should always keep in mind:
	</p>

	<figure>
		<ol class="numd">
			<li>The pointer itself has an address of its own.</li>
			<li>The pointer stores an address to some other variable.</li>
		</ol>
	</figure>

	<p>
		When we <b>dereference</b> a pointer, we are commanding:
		<q>Give me the value at the address stored in this pointer</q>. But, when we
		<b>reference</b> a pointer, we command,
		<q>Give me the address of this pointer</q>. A large amount of confusion with
		pointers stems from failing to separate these two traits of pointers. We
		state them explicitly to ensure clarity. Now, for dereferencing, we have the
		following rule:
	</p>

	<figure>
		<div class="rule">
			<p>
				<span class="topic">Rule.</span> A pointer can be dereferenced
				<em>if and only if</em> it has a pointee.
			</p>
		</div>
	</figure>

	<p>
		If a pointer has no pointee, it cannot be dereferenced. Almost all
		pointer-bred bugs originate in some violation of the rule above. To place
		all of this in context, let's briefly review how main memory works. First,
		visualize main memory as the following:
	</p>

	<figure>
		<div>
			<pre class="language-pseudo"><code>
				⋮
				109 [□□□□□□□□]
				108 [□□□□□□□□]
				107 [□□□□□□□□]
				106 [□□□□□□□□]
				105 [□□□□□□□□]
				104 [□□□□□□□□]
				103 [□□□□□□□□]
				102 [□□□□□□□□]
				101 [□□□□□□□□]
				⋮
				000 [□□□□□□□□]
			</code></pre>
		</div>
		<figcaption>
			The numbers to the left are
			<i>memory addresses</i>. These are not valid addresses. They are used just
			to keep things simple. In reality, they would be in hexadecimal.
		</figcaption>
	</figure>

	<p>
		We use the □ to indicate the place of a bit, and the vertical ellipses ⋮ to
		indicate further stacks. Notice that each stack contains eight □. This
		represents the fact that each frame is a
		<b>byte</b> &mdash; a sequence of 8 bits. We'll keep this in mind as we
		continue.
	</p>

	<p>
		In C, we must explicitly state the data type for our variables. This serves
		as an instruction to the compiler to allocate a certain amount of memory. On
		modern computers, <var>int</var> is allocated 4 bytes, <var>char</var> is
		allocated 1 byte, and <var>float</var> is allocated 4 bytes. When write
		<var>int a;</var> the memory appears as such:
	</p>

	<figure>
		<div>
			<pre class="language-pseudo"><code>
				⋮
				109 [□□□□□□□□]
				108 [□□□□□□□□]
				107 [□□□□□□□□]
				106 [□□□□□□□□]
				--------------
				105 [▨▨▨▨▨▨▨▨]
				104 [▨▨▨▨▨▨▨▨]
				103 [▨▨▨▨▨▨▨▨]
				102 [▨▨▨▨▨▨▨▨] a
				--------------
				101 [□□□□□□□□]
				⋮
				000 [□□□□□□□□]
			</code></pre>
		</div>
	</figure>
	<p>
		In the diagram above, we use the ▨ to indicate that the space is allocated,
		but the value therein could be anything. I.e.,
		<i>garbage value</i>. Writing <var>char c;</var> thereafter:
	</p>
	<figure>
		<div>
			<pre class="language-pseudo"><code>
				⋮
				109 [□□□□□□□□]
				108 [□□□□□□□□]
				107 [□□□□□□□□]
				--------------
				106 [▨▨▨▨▨▨▨▨] c
				--------------
				105 [▨▨▨▨▨▨▨▨]
				104 [▨▨▨▨▨▨▨▨]
				103 [▨▨▨▨▨▨▨▨]
				102 [▨▨▨▨▨▨▨▨] a
				--------------
				101 [□□□□□□□□]
				⋮
				000 [□□□□□□□□]
			</code></pre>
		</div>
	</figure>
	<p>
		A <var>char</var> variable takes 1 byte of memory, so it takes up a single
		address. If we then write <var>a = 5;</var> the memory then appears as:
	</p>
	<figure>
		<div>
			<pre class="language-pseudo"><code>
				⋮
				109 [□□□□□□□□]
				108 [□□□□□□□□]
				107 [□□□□□□□□]
				--------------
				106 [▨▨▨▨▨▨▨▨] c
				--------------
				105 [00000101]
				104 [00000000]
				103 [00000000]
				102 [00000000] a
				--------------
				101 [□□□□□□□□]
				⋮
				000 [□□□□□□□□]
			</code></pre>
		</div>
	</figure>
	<p>
		We now fill the addresses from <var>102</var> to <var>105</var> (4 bytes),
		with the bits representing <var>5</var>. Writing <var>char c = 'a';</var> we
		get:
	</p>
	<figure>
		<div>
			<pre class="language-pseudo"><code>
				⋮
				109 [□□□□□□□□]
				108 [□□□□□□□□]
				107 [□□□□□□□□]
				--------------
				106 [01100001] c
				--------------
				105 [00000101]
				104 [00000000]
				103 [00000000]
				102 [00000000] a
				--------------
				101 [□□□□□□□□]
				⋮
				000 [□□□□□□□□]
			</code></pre>
		</div>
	</figure>
	<p>
		And when we write <var>a++;</var> we are simply changing the bits in the
		address allocated for <var>a</var>:
	</p>
	<figure>
		<div>
			<pre class="language-pseudo"><code>
				⋮
				109 [□□□□□□□□]
				108 [□□□□□□□□]
				107 [□□□□□□□□]
				--------------
				106 [01100001] c
				--------------
				105 [00000111]
				104 [00000000]
				103 [00000000]
				102 [00000000] a
				--------------
				101 [□□□□□□□□]
				⋮
				000 [□□□□□□□□]
			</code></pre>
		</div>
	</figure>
	<p>
		In all of the examples above, the address of
		<var>a</var> is <var>102</var>. We can store that address in a variable.
		That variable is called a <b>pointer</b>. For example, if we next wrote
		<var>int *p</var>, the memory would appear as such:
	</p>
	<figure>
		<div>
			<pre class="language-pseudo"><code>
				⋮
				116 [□□□□□□□□]
				115 [□□□□□□□□]
				--------------
				114 [▨▨▨▨▨▨▨▨]
				113 [▨▨▨▨▨▨▨▨]
				112 [▨▨▨▨▨▨▨▨]
				111 [▨▨▨▨▨▨▨▨]
				110 [▨▨▨▨▨▨▨▨]
				109 [▨▨▨▨▨▨▨▨]
				108 [▨▨▨▨▨▨▨▨]
				107 [▨▨▨▨▨▨▨▨] p
				--------------
				106 [01100001] c
				--------------
				105 [00000111]
				104 [00000000]
				103 [00000000]
				102 [00000000] a
				--------------
				101 [□□□□□□□□]
				⋮
				000 [□□□□□□□□]
			</code></pre>
		</div>
	</figure>
	<p>
		Notice that the pointer takes up 8 bytes. For now, we will say that this is
		the case for a 64-bit machine. On a 32-bit machine, the pointer would take
		up 4 bytes. Now, let's say we then wrote
		<var>p = &amp;a;</var>. This assigns the <i>address</i> of <var>a</var> to
		the pointer <var>p</var>, resulting in:
	</p>
	<figure>
		<div>
			<pre class="language-pseudo"><code>
				⋮
				116 [□□□□□□□□]
				115 [□□□□□□□□]
				--------------
				114 [01100110]
				113 [00000000]
				112 [00000000]
				111 [00000000]
				110 [00000000]
				109 [00000000]
				108 [00000000]
				107 [00000000] p
				--------------
				106 [01100001] c
				--------------
				105 [00000111]
				104 [00000000]
				103 [00000000]
				102 [00000000] a
				--------------
				101 [□□□□□□□□]
				⋮
				000 [□□□□□□□□]
			</code></pre>
		</div>
	</figure>
	<p>
		Again, in our diagram, the address stored in
		<var>p</var> is not a valid address. We use the simple integer addresses to
		the left to keep the illustration simple, but the principle is the same
		&mdash; the pointer <var>p</var> stores a number, and that number is an
		address. In actuality, a valid address stored in <var>p</var> would be in
		hexadecimal and appear something like: <var>66 00 00 00</var>. The address
		of <var>p</var> itself would look something like
		<var>1C 91 96 EC FE 7F 00 00</var>.
	</p>
	<p>
		From these demonstrations, we observe the following: Whenever we deal with
		pointers, there are really only three perspectives: (i) the address
		<em>in</em>, (iii) the address <em>of</em>, and (iii) the value
		<em>at</em> the address <em>in</em>.
	</p>
	<figure>
		<table class="alg">
			<thead>
				<th>Expression</th>
				<th>Command</th>
				<th>Value</th>
			</thead>
			<tbody>
				<tr>
					<td>
						<p><var>${t}$ *p;</var></p>
					</td>
					<td><p>Let there be a pointer of type ${t.}$</p></td>
					<td><var>p == null</var></td>
				</tr>
				<tr>
					<td>
						<p><var>${t}$ a;</var></p>
						<p><var>${t}$ *p = &amp;a;</var></p>
					</td>
					<td>
						<p>
							Assign to the pointer <var>p</var> the address-of
							<var>a</var>
						</p>
					</td>
					<td><var>p ==</var> ${\textit{address-of}}$ <var>a</var></td>
				</tr>
				<tr>
					<td colspan="3">
						<p>Suppose:</p>
						<p>Address-of <var>a == 102</var></p>
						<p>Address-of <var>p == 107</var></p>
						<p><var>a == 5</var></p>
						<p><var>*p = &a</var></p>
					</td>
				</tr>
				<tr>
					<td>
						<p><var>p</var></p>
					</td>
					<td>
						<p>Return the address-in <var>p</var></p>
					</td>
					<td><var>102</var></td>
				</tr>
				<tr>
					<td>
						<p><var>&a</var></p>
					</td>
					<td>
						<p>Return the address-of <var>a</var></p>
					</td>
					<td><var>102</var></td>
				</tr>
				<tr>
					<td>
						<p><var>&p</var></p>
					</td>
					<td>
						<p>Return the address-of <var>p</var></p>
					</td>
					<td><var>107</var></td>
				</tr>
				<tr>
					<td>
						<p><var>*p</var></p>
					</td>
					<td>
						<p>
							Return the value at the address-in
							<var>p</var>.
						</p>
					</td>
					<td><var>5</var></td>
				</tr>
				<tr>
					<td>
						<p><var>*p = ${\large v}$</var></p>
					</td>
					<td>
						<p>
							Change the value at the address-in
							<var>p</var> to ${\large v}$
						</p>
					</td>
					<td><var>a == ${\large v}$</var></td>
				</tr>
			</tbody>
		</table>
	</figure>
	<p>Let's see some more examples. Consider the following code:</p>
	<pre class="language-c"><code>
		int main() {
			int i = 17;
			int j = 32;
			int *p = &amp;i;
			int *q = &amp;j;
			return 0;
		}
	</code></pre>
	<p>In RAM, the code above appears as such:</p>
	<figure>
		<img
			src="{% static 'images/pointer_address_C.svg' %}"
			alt="Pointer in memory"
			loading="lazy"
			class="sixty-p"
		/>
		<figcaption>
			A section of RAM. The ellipses represent some other section of RAM
			preceding the section we're concerned with.
		</figcaption>
	</figure>
	<p>
		The variables <var>i</var> and <var>j</var> are variables storing
		<var>17</var> and <var>32</var> respectively. The variables
		<var>*p</var> and <var>*q</var>, however, are pointers. They store the
		addresses of <var>i</var> and <var>j</var> respectively. The start symbol,
		<var>*</var>, is what we use to tell the compiler that a variable is a
		pointer. Thus, whenever the compiler comes across a variable prepended with
		<var>*</var>, it goes,
		<q>Oh, this is a pointer. There's going to be an address in here.</q> The
		ampersand symbol, <var>&</var>, is what we use to obtain the address of a
		variable. Thus, when the compiler sees a variable prepended with
		<var>&</var>, it goes,
		<q
			>Ah, they're asking for what address is named with this variable name. Let
			me go and get it.</q
		>
		<sup></sup>
	</p>
	<div class="note">
		<p>
			Remember, variables are just names for addresses. We could imagine a world
			where we didn't have variables, where we'd manually write memory addresses
			and assign them values; a frightening thought to say the least.
		</p>
	</div>
	<p>
		Notice the memory addresses in the diagram above. They go by increment by 4,
		but after the first pointer, <var>p</var>, it increments by 8. This is
		intentional. Notice further that the pointers occupy a space slightly larger
		than the others. This too is intentional.
	</p>
	<p>
		Each of the addresses above is the address of a particular
		<b>byte</b> in memory. An <var>int</var>, however, cannot fit in one byte of
		memory. For this particular architecture, a 64-bit system, the
		<var>int</var> requires 4 bytes of memory. Thus, the value <var>17</var>,
		assigned to <var>i</var>, occupies the addresses <var>0x1000</var>,
		<var>0x1001</var>, <var>0x1002</var>, and <var>0x1003</var>. Then, for
		<var>32</var>, assigned to <var>j</var>, occupies the addresses
		<var>0x1004</var>, <var>0x1005</var>, <var>0x1006</var>, and
		<var>0x1007</var>.
	</p>
	<p>
		Pointers, again for this machine, occupy 8 bytes of memory. Thus, the
		pointer <var>p</var> occupies the addresses from <var>0x1008</var> through
		<var>0x1015</var>. And the pointer <var>q</var> occupies the addresses
		<var>0x1016</var> through <var>0x1023</var>.
	</p>
	<p>Let's add a bit more code:</p>
	<pre class="language-c"><code>
		#include &lt;stdio.h&gt;

		int main() {
			int i = 17;
			int j = 32;
			int *p = &amp;i;
			int *q = &amp;j;
			printf("Content of *p : %i\n", *p);
			printf("Content of p : %p\n", p);
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		Content of *p : 17
		Content of p : 0x7ffeed37e158
	</code></pre>
	<p>
		Examine the output closely. When we ask for the value
		<var>*p</var>, we are <b>dereferencing</b> the pointer <var>p</var>. This is
		often a point of confusion among newcomers. The <var>*</var> symbol is used
		for both creating pointers <em>and</em> dereferencing.<sup></sup> Thus, if
		we want to access the value stored in the address a pointer points to, we
		must use the dereference operator <var>*</var>. Without using that operator,
		i.e., just writing <var>p</var>, we are asking for the address the pointer
		points to. These are two very different things. One way to remember the two
		different uses of <var>*</var> is to think of it as a star for navigating
		the wildnerness. The first time we use <var>*</var>, we are marking a
		particular location. When when we use it again, we journey back to that
		location, wherein lies a value.
	</p>
	<div class="note">
		<p>
			The first star creates a marker, the second star goes to the marker, and
			the amp obtains an address.
		</p>
	</div>
	<section id="exercises">
		<ol class="ex grid">
			<li class="grid-item">
				<p>What output:</p>
				<pre class="language-pseudo"><code>
					int main() {
						int n = 5, m = 7;
						int *p1, *p2; 
						printf("n = %d, m = %d \n", n, m);
					}
				</code></pre>
				<details class="answer">
					<summary>Solution</summary>
					<pre class="language-bash"><code>
						n = 5
						m = 7
					</code></pre>
				</details>
			</li>

			<li class="grid-item">
				<p>What output:</p>
				<pre class="language-pseudo"><code>
					int main() {
						int n = 5, m = 7;
						int *p1, *p2;
						p1 = &amp;n;
						p2 = &amp;m;
						printf("n = &d, m = %d\n", n, m);
					}	
				</code></pre>
				<details class="answer">
					<summary>Solution</summary>
					<pre class="language-bash"><code>
						n = 5
						m = 7
					</code></pre>
					<p>
						<var>p1</var> now stores <var>&n</var> (the address of
						<var>n</var>), and <var>p2</var> now stores <var>&m</var> (the
						address of <var>m</var>).
					</p>
				</details>
			</li>

			<li class="grid-item">
				<p>What output:</p>
				<pre class="language-pseudo"><code>
					#include &lt;stdio.h&gt;

					int main() {
						int n = 5, m = 7;
						int *p1, *p2;
						p1 = &amp;n;
						p2 = &amp;m;
						*p1 = *p1 + 1;
						*p2 = *p2 + 3;
						printf("n = &d, m = %d\n", n, m);
						return 0;
					}	
				</code></pre>
				<details class="answer">
					<summary>Solution</summary>
					<pre class="language-bash"><code>
							n = 6
							m = 10
					</code></pre>
					<p>
						Writing <var>*p = *p + 1</var> is equivalent to saying, "Go to the
						address stored in <var>p</var>, and assign it <var>*p + 1</var>.
						Writing <var>*p + 1</var> is equivalent to writing, "Go to address
						stored in <var>*p</var>, and add <var>1</var> to whatever's in
						there. The same goes for <var>*p2 = *p2 + 3</var>.
					</p>
				</details>
			</li>

			<li class="grid-item">
				<p>What output:</p>
				<pre class="language-pseudo"><code>
					#include &lt;stdio.h&gt;

					int main() {
						int n = 5, m = 7;
						int *p1, *p2;
						p1 = &amp;n;
						p2 = &amp;m;
						*p1 = *p1 + 1;
						*p2 = *p2 + 3;
						p1 = p2;
						p2 = p1;
						printf("n = %d, m = %d\n", n, m);
						printf("*p1 = %d, *p2 = %d\n", *p1, *p2);
						return 0;
					}
				</code></pre>
				<details class="answer">
					<summary>Solution</summary>
					<pre class="language-bash"><code>
						n = 6, m = 10
						*p1 = 10, *p2 = 10
					</code></pre>
					<p>
						&nbsp;Writing <var>p1 = p2</var> instructs, "Assign the address in
						<var>p2</var> to <var>p1</var>. Writing
						<var>p2 = p1</var> instructs, "Assign the address in
						<var>p1</var> to <var>p2</var>. Because <var>p2</var> points to
						<var>m</var>, writing <var>p1 = p2</var> means that
						<var>p1</var> now points to <var>m</var>. And since
						<var>p1</var> points to <var>m</var>, writing
						<var>p2 = p1</var> means that <var>p2</var> also points to
						<var>m</var>.
					</p>
				</details>
			</li>

			<li class="grid-item">
				<p>What output:</p>
				<pre class="language-pseudo"><code>
					#include &lt;stdio.h&gt;

					int main() {
						int n = 5, m = 7;
						int *p1, *p2;
						p1 = &amp;n;
						p2 = &amp;m;
						*p1 = *p1 + 1;
						*p2 = *p2 + 3;
						p1 = p2;
						p2 = p1;
						n = *p2;
						m = n - 3;
						printf("n = %d, m = %d\n", n, m);
						printf("*p1 = %d, *p2 = %d\n", *p1, *p2);
						return 0;
					}	
				</code></pre>
				<details class="answer">
					<summary>Solution</summary>
					<pre class="language-bash"><code>
						n = 10, m = 7;
					</code></pre>
				</details>
			</li>

			<li class="grid-item">
				<p>Explain the code in English:</p>
				<pre class="language-pseudo"><code>
					int main() {
						int a;
						int *p;
						p = &amp;a;
						*p = 5; 
					}
				</code></pre>
				<details class="answer">
					<summary>Solution</summary>
					<ul>
						<li>Initialize a variable <var>a</var> of type <var>int</var>.</li>
						<li>Initialize pointer <var>p</var> of type <var>int*</var>.</li>
						<li>
							Assign to the pointer <var>p</var> the address of the variable
							<var>a</var>.
						</li>
						<li>
							Go the address stored in <var>p</var> (the address of
							<var>a</var>), and store inside of it the literal <var>5</var>.
						</li>
					</ul>
				</details>
			</li>

			<li class="grid-item">
				<p>What result:</p>
				<pre class="language-pseudo"><code>
					int main() {
						int* p;
						return 0;
					}
				</code></pre>
				<details class="answer">
					<summary>Solution</summary>
					<p>Creates a pointer of <var>p</var> of type <var>int*</var>.</p>
				</details>
			</li>

			<li class="grid-item">
				<p>Consider the code below. What is the output of the last line?</p>
				<pre class="language-pseudo"><code>
					int main() {
						int a;
						int *p;
						printf("%p\n", p);
						return 0;
					}
				</code></pre>
				<details class="answer">
					<summary>Solution</summary>
					<pre class="language-bash"><code>
						0x7ffee8e00138
					</code></pre>
					<p>
						This returns the address stored in <var>p</var>. Note that because
						<var>p</var> is uninitialized, it is called a
						<b>wild pointer</b> &mdash; a pointer that points to an arbitrary
						(random) memory location.
					</p>
				</details>
			</li>

			<li class="grid-item">
				<p>Consider the code below. What is the output of the last line?</p>
				<pre class="language-pseudo"><code>
					int main() {
						int a;
						int *p;
						printf("%p\n", *p);
						return 0;
					}
				</code></pre>
				<details class="answer">
					<summary>Solution</summary>
					<pre class="language-bash"><code>
						exercises.c:6:17: warning: format specifies type 'void *' but the argument has type 'int' [-Wformat]
							printf("%p\n", *p);
											~~     ^~
											%d
					</code></pre>
					<p>
						This returns a warning. <var>*p</var> is the
						<i>dereference operator</i>. It will return the value stored in the
						address in <var>p</var>. The format specifier, however,
						<var>%p</var>, pertains to those of type <var>void *</var>.
					</p>
				</details>
			</li>

			<li class="grid-item">
				<p>Consider the code below. What is the output of the last line?</p>
				<pre class="language-pseudo"><code>
					int main() {
						int a;
						int *p;
						printf("%d\n", *p);
						return 0;
					}
				</code></pre>
				<details class="answer">
					<summary>Solution</summary>
					<pre class="language-c"><code>
						0
					</code></pre>
					<p>
						This is <b>undefined behavior</b>. It is not, however, necessarily
						always zero. When we dereference a wild pointer, we are essentially
						dereferencing random memory locations. Because of this fact, it is
						best practice to perform <i>inline initialization</i> when creating
						pointers. Instead of simply writing <var>int *p</var>, we write
						<var>int *p = NULL</var>.
					</p>
				</details>
			</li>

			<li class="grid-item">
				<p>
					Consider the code below. What is the result of
					<var>p = q</var>?
				</p>
				<pre class="language-pseudo"><code>
					int main() {
						int i = 0;
						int j = 1;
						int *p = &amp;i;
						int *q = &amp;j;
						p = q;
						return 0;
					}
				</code></pre>
				<details class="answer">
					<summary>Solution</summary>
					<p>
						The line <var>p = q</var> assigns to the pointer <var>p</var> the
						address stored in <var>q</var>. Thus, <var>p</var> now stores the
						address <var>&j</var>, as opposed to <var>&i</var>. The result:
						<var>p</var> and <var>q</var> are now aliases for the address
						<var>&j</var>. We can confirm this is the case with some
						print-statements:
					</p>
					<pre class="language-c"><code>
						#include &lt;stdio.h&gt;
						int main() {
							int i = 0;
							printf("i = 0;\n");
							printf("\t &i: %p\n", &i);
							int j = 1;
							printf("j = 1;\n");
							printf("\t &j: %p\n", &j);
							int *p = &amp;i;
							printf("*p = &amp;i;\n");
							printf("\t p: %p\n", p);
							int *q = &amp;j;
							printf("*q = &amp;j;\n");
							printf("\t q: %p\n", q);
							p = q;
							printf("p = q;\n");
							printf("\t p: %p\n", p);
							return 0;
						}
					</code></pre>
					<pre class="language-bash"><code>
						i = 0;
											&i: 0x7ffee7f6a118
						j = 1;
											&j: 0x7ffee7f6a114
						*p = &amp;i;
											p: 0x7ffee7f6a118
						*q = &amp;j;
											q: 0x7ffee7f6a114
						p = q;
											p: 0x7ffee7f6a114
					</code></pre>
				</details>
			</li>

			<li class="grid-item">
				<p>
					Consider the code below. What is the result of
					<var>p = q</var>?
				</p>
				<pre class="language-pseudo"><code>
					int main() {
						int i = 0;
						int j = 1;
						int *p = &amp;i;
						int *q = &amp;j;
						p = q;
						return 0;
					}
				</code></pre>
				<details class="answer">
					<summary>Solution</summary>
					<p>
						We always evaluate the right-hand part of the expression first.
						Here, we dereference <var>q</var>, so we get the value <var>1</var>.
						Then, we dereference <var>p</var> &mdash; accessing what's inside
						the address stored by <var>p</var> &mdash; and we place inside it
						the value <var>1</var>. Thus, <var>i</var> is now <var>1</var>.
					</p>
					<pre class="language-c"><code>
							#include &lt;stdio.h&gt;
							int main() {
								int i = 0;
								printf("i = 0;\n");
								printf("\t i: %d\n", i);
								int j = 1;
								printf("j = 1;\n");
								printf("\t j: %d\n", j);
								int *p = &amp;i;
								printf("*p = &amp;i;\n");
								printf("\t *p: %d\n", *p);
								int *q = &amp;j;
								printf("*q = &amp;j;\n");
								printf("\t *q: %d\n", *q);
								*p = *q;
								printf("*p = *q;\n");
								printf("\t *p: %d\n", *p);
								printf("\t i: %d\n", i);
								return 0;
							}
						</code></pre>
					<pre class="language-bash"><code>
							i = 0;
											i: 0
							j = 1;
											j: 1
							*p = &amp;i;
											*p: 0
							*q = &amp;j;
											*q: 1
							*p = *q;
											*p: 1
											i: 1
						</code></pre>
				</details>
			</li>

			<li class="grid-item">
				<p>
					Consider the code below. What is the result of
					<var>p = q</var>?
				</p>
				<pre class="language-pseudo"><code>
					int main() {
						int i = 0;
						int j = 1;
						int *p = &amp;i;
						int *q = &amp;j;
						*p = q;
						return 0;
					}
				</code></pre>
				<details class="answer">
					<summary>Solution</summary>
					<pre class="language-bash"><code>
						exercises.c:16:5: warning: incompatible pointer to integer conversion assigning to 'int' from 'int *'; dereference with * [-Wint-conversion]
										*p = q;
											^ ~
												*
						1 warning generated.
					</code></pre>
					<p>
						Again, evaluate the right-hand part of the expression. Here, it's a
						lone <var>q</var>, meaning we're going to get an address. Then, we
						dereference <var>p</var> &mdash; accessing what's inside the address
						stored by <var>p</var> &mdash; and we place inside it the address
						stored by <var>q</var>. This will likely return a warning, given
						that addresses are fairly large numbers. The <var>int</var> variable
						is likely not large enough to fit the address; if the compiler
						allows us to do this, it's like that parts of the data are lost,
						since the compiler can't fit everything into the allocated space.
					</p>
				</details>
			</li>

			<li class="grid-item">
				<p>
					Consider the code below. What is the result of
					<var>p = q</var>?
				</p>
				<pre class="language-pseudo"><code>
					int main() {
						int i = 0;
						int j = 1;
						int *p = &amp;i;
						int *q = &amp;j;
						p = *q;
						return 0;
					}
				</code></pre>
				<details class="answer">
					<summary>Solution</summary>
					<pre class="language-bash"><code>
						exercises.c:8:4: warning: incompatible integer to pointer conversion assigning to 'int *' from 'int'; remove * [-Wint-conversion]
										p = *q;
											^ ~~
						1 warning generated.
					</code></pre>
					<p>
						Here, we are dereferencing <var>q</var>. The value stored in the
						address pointed at by <var>q</var> is then stored as the address
						stored by <var>p</var>. This essentially means that the address
						stored by <var>p</var> is the <var>1</var>. This is not a valid
						address. This will not itself cause a crash. However, if we try to
						dereference <var>p</var>, we will get a <b>segmentation fault</b>.
					</p>
				</details>
			</li>
		</ol>
	</section>

	<section id="printing_variable_address">
		<p>
			<span class="topic">Printing the Address of a Variable.</span> Whenever we
			are unsure of what a particular variable or reference is, it's helpful to
			print the value and/or the address:
		</p>
		<pre class="language-c"><code>
			#include &lt;stdio.h&gt;
	
			int main() {
				int x = 5;
				printf("x VALUE: %d\n", x);
				printf("x ADDRESS: %p\n", &x);
			}
		</code></pre>
		<pre class="language-bash"><code>
			x VALUE: 5
			x ADDRESS: 0x7ffedffe61bc
		</code></pre>
	</section>

	<section id="uninitialized_pointer">
		<h3>Failing to Initialize</h3>
		<p>
			As we know, failing to initialize variables before using them is asking
			for trouble. For example, consider the output of the following code:
		</p>

		<pre class="language-c"><code>
			#include &lt;stdio.h&gt;
			int main() {
				int i;
				printf("i = %i\n", i);
				return 0;
			}
		</code></pre>
		<pre class="language-bash"><code>
			i = 358010917
		</code></pre>

		<p>
			The value of <var>i</var> is called a <b>garbage value</b>. It's the value
			in the memory address identified as <var>i</var> at time of compilation
			and essentially random. Worse, this will not cause a crash. It's a
			potentially lethal and massive bug, eager to crawl out of the woodwork.
		</p>
		<div class="mainIdea">
			<p>
				C provides a great deal of freedom when it comes to pointers. That
				freedom, however, also means that C is unforgiving of our mistakes.
				Contrast this with a language like Java, where pointers are
				automatically set to
				<var>NULL</var> when they're declared. No such safeguard exists in C
				&mdash; the programmer is assumed to know what they want and how best to
				obtain it.
			</p>
		</div>
		<p>
			The same danger applies pointers, as they too are variable. When a pointer
			is first declared, it has no pointee. Without assigning an address to a
			declared pointer, we say that the pointer is an
			<b>uninitialized pointer</b>. Because C will not prevent us from
			dereferencing the uninitialized pointer, such dereferences lead to runtime
			errors. This is even worse than using an uninitialized non-pointer
			variable. Uninitialized pointers effectively point to anywhere in memory,
			and that memory could be in use by another program. This will more than
			likely lead to segmentation fault, causing our program to crash. That's
			the best case scenario. The worst case scenario is if C, for whatever
			reason, allows us to touch the value in that random address, thereby
			modifying &mdash; and potentially crashing &mdash; an entirely unrelated
			program.
		</p>
		<p>
			For this reason, whenever we work with pointers, it is best practice to
			strictly follow these rules:
		</p>
		<figure>
			<ol class="numd">
				<li>Initialize pointers in a single line, always.</li>
				<li>
					If a pointer cannot be initialized in a single line, follow the
					pointer's declaration by assignining the pointer
					<var>NULL</var> immediately.
				</li>
			</ol>
		</figure>
		<p>For example, here is an application of rule 1:</p>
		<pre class="language-c"><code>
			int a = 1;
			int *p = &amp;a;
		</code></pre>
		<p>And here is an application of rule 2:</p>
		<pre class="language-c"><code>
			int a = 1;
			int *p;
			p = NULL;
		</code></pre>
	</section>

	<section id="the_null_pointer">
		<h3>The Null Pointer</h3>
		<p>
			By assigining the value
			<var>NULL</var> to a pointer, we are essentially assigning the integer
			<var>0</var> as the pointer's address. We call such a pointer a
			<b>null pointer</b>. At the very least, this ensures the pointee isn't
			some <i>random</i> address.
		</p>
		<p>
			The catch, however, is that <var>0</var> is not a valid address.
			Attempting to dereference the null pointer will return a
			<b>segmentation fault (<q>seg fault</q>)</b>. This danger, however, is
			precisely what makes the null pointer so useful. Many data structures rely
			on the null pointer, particularly where we have to ensure the pointer
			we're working with is or is not the null pointer.
		</p>
		<pre class="language-c"><code>
			if (p == NULL) {
				// do something
			}
		</code></pre>
	</section>
</section>

<section id="pointer_types">
	<h2>Pointer Types</h2>
	<p>
		Because C is a static- and explicitly-typed language, all pointers must have
		an explicit type on declaration. These types are denoted in the language
		with symbols like <var>int*</var> or <var>char*</var>. For example, if we
		have a pointer to an <var>int</var> variable, the pointer's type is
		<var>int*</var>. If we have a pointer to a <var>char</var> variable, the
		pointer's type is <var>char*</var>.
	</p>
	<table class="alg">
		<thead>
			<th>Syntax</th>
			<th>Meaning</th>
		</thead>
		<tbody>
			<tr>
				<td><var>int*</var></td>
				<td>Pointer to an <var>int</var></td>
			</tr>
			<tr>
				<td><var>float*</var></td>
				<td>Pointer to an <var>float</var></td>
			</tr>
			<tr>
				<td><var>char*</var></td>
				<td>Pointer to an <var>char</var></td>
			</tr>
			<tr>
				<td><var>struct fraction*</var></td>
				<td>Pointer to a struct called <var>fraction</var></td>
			</tr>
			<tr>
				<td><var>struct fraction**</var></td>
				<td>Pointer to a pointer to a struct called <var>fraction</var></td>
			</tr>
		</tbody>
	</table>
	<p>
		More formally: Suppose ${p}$ is a pointer, ${t}$ is a type, and ${x}$ is a
		standard variable. When we write ${t \space {*p} = x;}$ we are stating that
		that value stored in ${x}$ is of type ${t.}$ More explicitly, we are stating
		to C: &#8220;Treat the value inside ${\texttt{\&}x}$ as a value of type
		${t.}$&#8221;<sup></sup>
	</p>
	<div class="note">
		<p>
			Note that assigning the address of a particular value to an incompatible
			pointer type doesn't cause an error &mdash; it will generate a
			<i>compiler warning</i>. Why not an error? Because it's not necessarily
			<q>wrong.</q> If we try to fit a <var>double</var> into an address space
			for an <var>int</var>, all we're really doing is trying to fit a larger
			value into a small space. We'll lose data in the process, but that's on
			us.
		</p>
	</div>
	<p>
		Why can't we just use <var>int</var>? Or some other numeric type? After all,
		aren't memory addresses just numbers? C requires strong types because the
		pointer isn't solely used for storing addresses. They also have the added
		feature of <i>dereferencing</i>. Not only can they store addresses, they can
		be used to access and modify the values inside the addresses they store. And
		because values can be of different types (and by implication of different
		sizes), pointers must have types. Otherwise, C would allow us to do things
		like assigning an <var>int</var> value in a <var>char</var> variable. The
		costs of allowing this (most significantly, data loss) significantly
		outweigh the convenience of not requiring explicit typing.
	</p>
</section>

<section id="pointer_arguments">
	<h2>Pointer Parameters</h2>
	<p>
		With pointers, we can write functions that modify their arguments. For
		example, suppose that instead of writing <var>a++</var>, we want to write a
		separate function called <var>increment()</var>:
	</p>

	<pre class="language-c"><code>
		#include &lt;stdio.h&gt;

		void increment(int a) {
			a = a + 1;
		}
		
		int main() {
			int a = 1;
			increment(a);
			printf("a = %d\n", a);
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		1
	</code></pre>

	<p>
		It does not work. In C, the default rule is
		<b>pass-by-value</b>: When a datum is passed as an argument to a function, a
		<em>copy</em> of the datum is passed; <em>not</em> the original. Whether its
		simple or composite data, only a copy is passed. Once
		<var>increment()</var> has finished executing all of the data passed into it
		is destroyed.
	</p>

	<p>
		What we instead want to do is pass the address of
		<var>a</var> into the function <var>increment()</var> as an argument. This
		is called <b>pass-by-address</b>, or <b>pass-by-reference</b>.
	</p>

	<pre class="language-c"><code>
		#include &lt;stdio.h&gt;

		void increment(int *a) {
			*a = *a + 1;
		}
		
		int main() {
			int a = 1;
			increment(&a);
			printf("a = %d\n", a);
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		2
	</code></pre>

	<p>Now it works. Notice the syntax. We wrote:</p>

	<pre class="language-c"><code>
		*a = *a + 1;
	</code></pre>

	<section id="variable_swap">
		<h3>Swapping with Pointers</h3>
		<p>
			The previous example was a relatively simple demonstration. A clearer
			illustration of why pointers are so useful is to consider the idiom of
			swapping variables:
		</p>
		<pre class="language-c"><code>
			#include &lt;stdio.h&gt;

			int main() {
				int a = 0;
				int b = 1;
				int temp = a;
				a = b;
				b = temp;
				return 0;
			}
		</code></pre>
		<p>
			Given how useful the operation of swapping is, we want to write modularize
			this operation as a function. Doing so allows us to use it whenever and
			wherever we'd like. Unfortunately, a simple function will not work:
		</p>
		<pre class="language-c"><code>
			#include &lt;stdio.h&gt;

			void swap(int var1, int var2) {
				int temp = var1;
				var1 = var2;
				var2 = temp;
			}
			
			int main() {
				int a = 0;
				int b = 1;
				printf("a = %d\n", a);
				printf("b = %d\n", b);
				swap(a, b);
				printf("a = %d\n", a);
				printf("b = %d\n", b);
				return 0;
			}
		</code></pre>
		<pre class="language-bash"><code>
			a = 0
			b = 1
			a = 0
			b = 1
		</code></pre>
		<p>
			Again, because the default rule in C for functions is pass-by-value, the
			<var>swap()</var> function has no idea what <var>a</var> and
			<var>b</var> are. It only has the values <var>0</var> and <var>1</var>.
			Accordingly, when <var>swap()</var> executes, it only performs the
			swapping inside itself. Nothing actually happens inside <var>main()</var>.
		</p>
		<p>
			The fix is to pass addresses as arguments, instead of the values inside
			those addresses. We call this <b>pass-by-reference</b>:
		</p>
		<pre class="language-c"><code>
			#include &lt;stdio.h&gt;

			void swap(int *var1, int *var2) {
				// int *var1 = &a
				// int *var2 = &b

				int temp = *var1; // dereference *var1 (store the value 0)
				*var1 = *var2; // address in *var1 stores contents of address in *var2
				*var2 = temp; // address in *var2 stores temp
			}
			
			int main() {
				int a = 0;
				int b = 1;

				printf("a = %d\n", a);
				printf("b = %d\n", b);

				swap(&a, &b);

				printf("a = %d\n", a);
				printf("b = %d\n", b);

				return 0;
			}
		</code></pre>
		<pre class="language-bash"><code>
			a = 0
			b = 1
			a = 1
			b = 0
		</code></pre>
	</section>

	<section id="functions_multiple_returns">
		<h3>Multifunctions</h3>
		<p>
			By default, functions in C can only output one value. More formally,
			functions in C are equivalent to
			<i>injective functions</i> &mdash; functions whose output matches exactly
			one input. With pointers, however, we can write
			<b>multifunctions</b> &mdash; non-functional relations where several
			output values map to a single input. For example, let's say we want to
			write a function that returns both a minimum and a maximum given two
			numbers. They words &#8220;returns both&#8221; should alert us immediately
			that this is a big no no under the default rules of C. However, pointers
			provide the bypass:
		</p>
		<pre class="language-c"><code>
			#include &lt;stdio.h&gt;

			void setMinMax(int num1, int num2, int *pMax, int *pMin) {
				// int num1 = a;
				// int num2 = b;
				// int *pMax = &amp;min;
				// int *pMin = &amp;max;

				if (num1 > num2) {
					*pMin = num2;
					*pMax = num1;
				} else {
					*pMin = num1;
					*pMax = num2;
				}
			}
			
			int main() {
				int a = 149332;
				int b = 149328;
				int min, max;
				setMinMax(a, b, &min, &max);
				return 0;
			}
		</code></pre>
		<p>
			The example above is another demonstration of pass-by-reference. By
			passing by reference, we effectively modify the arguments passed into
			<var>setMinMax</var>. And because we modify the arguments, changes are
			affected in <var>main()</var>.
		</p>
	</section>

	<p>
		Pointers are what allow us to return more than one thing from a function.
		For example, a function that returns both the minimum and the maximum.
		Furthermore, they allow us to pass arrays, strings, and entire data
		structures into functions. Finally, pointers allow us to allocate unknown
		memory at run time. This is a powerful ability, given that we don't always
		know the future, or potential, sizes of our program's inputs. Having this
		ability allows us to handle arbitrarily large sizes of data.
	</p>
</section>

<section id="pointer_arithmetic">
	<h2>Pointer Arithmetic</h2>
	<p>
		Because pointers store a memory address, and because memory addresses are
		just numbers, it follows that we can perform arithmetic with pointers. This
		is called <b>pointer arithmetic</b>. For example, suppose a pointer
		<var>p</var> of type <var>int</var> stores the address <var>1001</var>. What
		is the value of <var>p++</var>? Well, let's try it:
	</p>
	<pre class="language-c"><code>
		#include &lt;stdio.h&gt;

		int main() {
			int i = 0;
			int *p = &amp;i;
			printf("p: %p\n", p);
			p++;
			printf("p: %p\n", p);
		}
	</code></pre>
	<pre class="language-bash"><code>
		p: 0x7ffeeb9e311c
		p: 0x7ffeeb9e3120
	</code></pre>
	<p>These are hexadecimal numbers. Let's print these as integers instead:</p>
	<pre class="language-c"><code>
		#include &lt;stdio.h&gt;

		int main() {
			int i = 0;
			int *p = &amp;i;
			printf("p: %lu\n", (unsigned long) p);
			p++;
			printf("p: %lu\n", (unsigned long) p);
		}
	</code></pre>
	<pre class="language-bash"><code>
		p: 140732660441372
		p: 140732660441376
	</code></pre>
	<p>
		Notice that the difference between these addresses is 4. This is because an
		<var>int</var> is allocated 4 bytes of memory. Thus, when we increment the
		pointer <var>p</var>, we are asking for the next <var>int</var> address.
		Essentially, 4 bytes more than the address in <var>p</var>.
	</p>
	<p>
		Pointer arithmetic provides us greater control in navigating memory. This is
		a great deal of power, and we can run into trouble if we aren't careful. For
		example, the value at the address in <var>p++</var> is garbage value:
	</p>
	<pre class="language-c"><code>
		#include &lt;stdio.h&gt;

		int main() {
			int i = 0;
			int *p = &amp;i;
			printf("p: %lu\n", (unsigned long) p);
			printf("*p = %d\n", *p);
			p++;
			printf("p: %lu\n", (unsigned long) p);
			printf("*(p++) = %d\n", *p);
		}
	</code></pre>
	<pre class="language-bash"><code>
		p: 140732773290268
		*p = 0
		p: 140732773290272
		*(p++) = -420097736
	</code></pre>
	<p>
		Look at how random the value of <var>p++</var> is. If we used the value of
		the dereferenced <var>p</var> later down our program, we'd be in for
		surprises. A few helpful general rules with pointer arithmetic:
	</p>

	<p>
		The core rule behind pointer arithmetic is that arithmetic operations are
		done in chunks of the pointee's data type. Generally, these chunks are as
		follows:
	</p>

	<table class="api">
		<thead>
			<th>Type</th>
			<th>Chunk</th>
		</thead>
		<tbody>
			<tr>
				<td>
					<var><mark>char</mark></var>
				</td>
				<td>1 byte</td>
			</tr>
			<tr>
				<td>
					<var><mark>signed char</mark></var>
				</td>
				<td>1 byte</td>
			</tr>
			<tr>
				<td>
					<var><mark>unsigned char</mark></var>
				</td>
				<td>1 byte</td>
			</tr>
			<tr>
				<td>
					<var><mark>short</mark></var
					>, <var><mark>short int</mark></var
					>, <var><mark>signed short</mark></var
					>, <var><mark>signed short int</mark></var>
				</td>
				<td>2 bytes</td>
			</tr>
			<tr>
				<td>
					<var><mark>unsigned short</mark></var
					>, <var><mark>unsigned short int</mark></var>
				</td>
				<td>2 bytes</td>
			</tr>
			<tr>
				<td>
					<var><mark>int</mark></var
					>, <var><mark>signed</mark></var
					>, <var><mark>signed int</mark></var>
				</td>
				<td>4 bytes (2 bytes for a 32-bit compiler)</td>
			</tr>
			<tr>
				<td>
					<var><mark>unsigned</mark></var
					>, <var><mark>unsigned int</mark></var>
				</td>
				<td>4 bytes (2 bytes for a 32-bit compiler)</td>
			</tr>
			<tr>
				<td>
					<var><mark>long</mark></var
					>, <var><mark>long int</mark></var
					>, <var><mark>signed long</mark></var
					>, <var><mark>signed long int</mark></var>
				</td>
				<td>8 bytes (4 bytes for a 32-bit compiler)</td>
			</tr>
			<tr>
				<td>
					<var><mark>unsigned long</mark></var
					>, <var><mark>unsigned long int</mark></var>
				</td>
				<td>8 bytes (4 bytes for a 32-bit compiler)</td>
			</tr>
			<tr>
				<td>
					<var><mark>long long</mark></var
					>, <var><mark>long long int</mark></var
					>, <var><mark>signed long long</mark></var
					>, <var><mark>signed long long int</mark></var>
				</td>
				<td>8 bytes</td>
			</tr>
			<tr>
				<td>
					<var><mark>unsigned long long</mark></var
					>, <var><mark>unsigned long long int</mark></var>
				</td>
				<td>8 bytes</td>
			</tr>
			<tr>
				<td>
					<var><mark>float</mark></var>
				</td>
				<td>typically 4 bytes</td>
			</tr>
			<tr>
				<td>
					<var><mark>double</mark></var>
				</td>
				<td>typically 8 bytes</td>
			</tr>
			<tr>
				<td>
					<var><mark>long double</mark></var>
				</td>
				<td>typically 10 bytes</td>
			</tr>
		</tbody>
	</table>

	<p>
		As an aside, notice that the memory addresses have changed. This evidences
		the fact that our program's data doesn't just stay in a single location
		forever. Because there are multiple processes running on our computer, the
		operating system will move data around in memory to accomodate for newer
		processes and changes.
	</p>
</section>

<section id="the_size_of_a_pointer">
	<h2>The Size of a Pointer</h2>
	<p>
		Suppose we have two computers, <var>Machine1</var> and <var>Machine2</var>.
		On <var>Machine1</var>, we write the following:
	</p>
	<pre class="language-c"><code>
		int main() {
			int n = 10;
			int *p = &amp;n;
			printf("sizeof(p) = %d bytes", sizeof(p));
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		sizeof(p) = 8 bytes
	</code></pre>
	<p>
		Notice, however, what happens when we execute the same code on
		<var>Machine2</var>:
	</p>
	<pre class="language-bash"><code>
		main.c:6:27: warning: format specifies type 'int' but the argument has type 'unsigned long' [-Wformat]
        printf("sizeof(p) = %d", sizeof(p));
                            ~~   ^~~~~~~~~
                            %lu
	</code></pre>
	<p>
		Why are there two different outputs? We're seeing two different results
		because <var>Machine1</var> is running on a 32-bit system, while
		<var>Machine2</var> is running on a 64-bit system. To understand the
		differences between these systems, let's brush up on some computer memory
		concepts.
	</p>
	<p>
		As we know, we can think of computer memory as a single, giant array of
		bytes, each with a unique <i>address</i>. When we initialize and access
		variables, we are effectively reading and writing these bytes. Our programs
		refer to these bytes by their addresses, and variable names &mdash;
		identifiers &mdash; are just a convenience for not having to write the
		actual numeric address of a byte. The set of all possible addresses a
		computer can have is called the <b>address space</b>.
	</p>
	<p>
		Now, not all values can fit in just one byte. For example, the
		<var>int</var> value <var>3921</var> cannot fit in a single byte. There are
		8 bits in a byte, and the number <var>3921</var> in binary is
		<var>111101010001</var>. That's ${12}$ bits, so we need at least 3 bytes.
		Recall that memory addresses themselves are just numbers. Thus, addresses
		themselves have sizes. And given that addresses have sizes, a computer's
		ability to read and write an address is limited by how large an address can
		be &mdash; i.e., the address's size. The size of a memory address in machine
		is called the machine's <b>word size</b>.
	</p>
	<p>
		When we say that a computer runs on a <q>64-bit system</q>, we're really
		saying that the machine uses ${64}$ bits for addressing. With 64 bits, the
		computer can read and write ${2^{64} \approx 1.8 \times 10^{19}}$ addresses.
		For a <q>32-bit system</q>, addresses exist as ${32}$ bits, allowing the
		computer to read and write ${2^{32}}$ addresses. Comparing the two:
	</p>
	<figure>
		<img
			src="{% static 'images/32_vs_64_bit.svg' %}"
			alt="32- verus 64-bit words"
			loading="lazy"
			class="eighty-p"
		/>
	</figure>
	<p>
		Since each byte consists of 8 bits, <i>words</i> are 8 bytes long on a 64
		bit system, and 4 bytes long on a 32-bit system. Importantly, addresses
		still specify the locations of bytes in memory. A word is simply the largest
		chunk of bits a processor can perform computations at a single point in
		time. This is why the terms <i>word size</i> and <i>register size</i> are
		often used interchangeably. When we perform operations like addition and
		multiplication, we aren't actually working with the bytes themselves &mdash;
		the machine is working with words. To work with those words, however, the
		computer must use the addresses of the bytes.
	</p>
	<p>
		Going back to our example, <var>Machine1</var> allows us to print the
		address stored in <var>p</var> because it's a 32-bit system. The address can
		<q>fit</q> in an <var>int</var> because it consists of ${32}$ bits &mdash;
		${4}$ bytes. Thus, we can use the format specifier <var>%d</var>. On
		<var>Machine2</var>, however, the address cannot fit in an
		<var>int</var> because <var>Machine2</var>'s addresses consist of ${64}$
		bits &mdash; ${8}$ bytes. This is why <var>Machine2</var>'s compiler is
		instructing us to use the format specifier <var>%lu</var> (a
		<var>long unsigned</var> type), since a <var>long unsigned</var> takes up
		${64}$ bits on a ${64-bit}$ system.
	</p>
	<p>
		The simplest way to determine whether a given machine uses a 32-bit or
		64-bit system is to determine size of <var>char</var> pointer. Running the
		code below on <var>Machine2</var>, we see:
	</p>
	<pre class="language-c"><code>
		#include &lt;stdio.h&gt;

		int main() {
			printf("sizeof(char*) = %lu\n", sizeof(char*));
			return 0;
		}	
	</code></pre>
	<pre class="language-bash"><code>
		sizeof(char*) = 8
	</code></pre>
	<p>
		Given that the size of <var>char*</var> is eight, we can conclude that the
		machine runs on a 64-bit system. If we ran the same code above on
		<var>Machine1</var> &mdash; a 32-bit system &mdash; we would see:
	</p>
	<pre class="language-bash"><code>
		sizeof(char*) = 4
	</code></pre>
	<p>
		Note, however, that the test above only informs us of the machine performing
		the compilation. If we ran a 32-bit executable on a 64-bit system, we would
		see
		<var>sizeof(char*) = 4</var>, unless a cross-compiler is used.
	</p>
</section>

<section id="pointers_to_pointers">
	<h2>Pointers to Pointers</h2>
	<p>
		Because pointers are variables, we can have pointers pointing to pointers.
		This ability essentially allows us to bypass the boundaries of
		<i>variable scope</i> by establishing bridges between memory locations. For
		example, suppose we wrote the following:
	</p>
	<pre class="language-c"><code>
		#include &lt;stdio.h&gt;

		int main() {
			int x = 5;
			int *p = &amp;x;
			return 0;
		}
	</code></pre>
	<p>
		As we know, the code above allocates 4 bytes for
		<var>int x = 5</var>, and 8 bytes for <var>int *p = &amp;x;</var>. Suppose
		the address of <var>x</var> is <var>125</var>. Then the value of
		<var>p</var> is <var>125</var>. Now suppose that the address of
		<var>p</var> is <var>432</var>. Can we have a pointer <var>q</var> pointing
		to <var>p</var>? Sure. But wait. What should type of <var>q</var> be? Well,
		because <var>p</var> points to an <var>int</var>, it follows that
		<var>p</var> is of type <var>int*</var>. And because <var>p</var> is of type
		<var>int*</var>, it follows that <var>q</var> must be of type
		<var>int**</var>. Hence:
	</p>
	<pre class="language-c"><code>
		#include &lt;stdio.h&gt;

		int main() {
			int x = 5;
			int *p = &amp;x;
			int **q = &amp;p;
			return 0;
		}
	</code></pre>
	<p>
		Just to verify that we've done this correctly, let's see print some values:
	</p>
	<pre class="language-c"><code>
		#include &lt;stdio.h&gt;

		void print_bytes(void *ptr, int size) {
			unsigned char *p = ptr;
			int i;
			for (i=0; i&lt;size; i++) {
				printf("%02hhX ", p[i]);
			}
			printf("\n");
		}
		
		int main() {
			int x = 5;
			int *p = &amp;x;
			print_bytes(&p, sizeof(p));
			int **q = &amp;p;
			print_bytes(q, sizeof(q));
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		18 D1 AE E9 FE 7F 00 00 
		18 D1 AE E9 FE 7F 00 00 
	</code></pre>
	<p>
		Exact same addresses. We can then create another pointer,
		<var>r</var>, that points to <var>q</var>:
	</p>
	<pre class="language-c"><code>
		#include &lt;stdio.h&gt;

		int main() {
			int x = 5;
			int *p = &amp;x;
			int **q = &amp;p;
			int ***r = &amp;q;
			return 0;
		}
	</code></pre>
	<p>Verifying once more:</p>
	<pre class="language-c"><code>
		#include &lt;stdio.h&gt;

		void print_bytes(void *ptr, int size) {
			unsigned char *p = ptr;
			int i;
			for (i=0; i&lt;size; i++) {
				printf("%02hhX ", p[i]);
			}
			printf("\n");
		}
		
		int main() {
			int x = 5;
			int *p = &amp;x;
			print_bytes(&p, sizeof(p));
			int **q = &amp;p;
			print_bytes(q, sizeof(q));
			int ***r = &amp;q;
			print_bytes(r, sizeof(r));
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		18 61 D5 E7 FE 7F 00 00 
		18 61 D5 E7 FE 7F 00 00 
		10 61 D5 E7 FE 7F 00 00 
	</code></pre>
	<p>
		Notice that the address in <var>r</var> looks different. It's off by 8
		bytes. This is because <var>r</var> doesn't point to <var>p</var>; it points
		to <var>q</var>. If we printed the address of <var>q</var>, we would see
		that it is in fact the address in <var>r</var>:
	</p>
	<pre class="language-c"><code>
		#include &lt;stdio.h&gt;

		void print_bytes(void *ptr, int size) {
			unsigned char *p = ptr;
			int i;
			for (i=0; i&lt;size; i++) {
				printf("%02hhX ", p[i]);
			}
			printf("\n");
		}
		
		int main() {
			int x = 5;
			int *p = &amp;x;
			print_bytes(&p, sizeof(p));
			int **q = &amp;p;
			print_bytes(q, sizeof(q));
			int ***r = &amp;q;
			print_bytes(&q, sizeof(&q));
			print_bytes(r, sizeof(r));
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		18 41 4E E9 FE 7F 00 00 
		18 41 4E E9 FE 7F 00 00 
		10 41 4E E9 FE 7F 00 00 
		10 41 4E E9 FE 7F 00 00
	</code></pre>
</section>

<section id="void_pointer">
	<h2>Void Pointers</h2>
	<p>
		So far, we've seen pointers with specific types. For example, an
		<var>int*</var> is a pointer to an <var>int</var>, a <var>char*</var> is a
		pointer to a <var>char</var>, a <var>float**</var> is a pointer to a pointer
		to a <var>float</var>. There is, however, a special pointer type &mdash;
		<var><mark>void*</mark></var
		>. This type denotes a <b>void pointer</b>. Observe that the code below
		compiles just fine:
	</p>
	<pre class="language-c"><code>
		#include &lt;stdio.h&gt;

		int main() {
			int n = 5;
			void* p = &amp;n;
		}	
	</code></pre>
	<p>
		This may seem odd. Under normal circumstances, this shouldn't compile.
		<var>void</var> and <var>int</var> are not the same type. And indeed, they
		aren't. The void pointer, however, is a <i>universal pointer</i>. It can
		point to <em>any</em> address storing any data type.
	</p>
	<p>
		Void pointers are most often used for two situations. (1) Implementing
		unctions that should return a pointer type value, but we don't know what
		that type will be ahead of time. (2) Implementing general purpose functions
		&mdash; i.e., some mathematical function that takes any numeric data,
		whether it's a <var>float</var>, <var>int</var>, or <var>double</var>.
	</p>
	<p>
		Before we delve deeper into void pointers, we should be clear on why
		pointers have types in the first place. C implements explicit- and
		static-typing as a matter of efficiency. Given that every type takes a fixed
		amount of memory, when we write <var>int* p</var> on a 64-bit machine, we
		are providing additional information to the compiler:
		<q>This pointer points to a value that spans 4 memory addresses.</q> In
		other words, the pointer type serves as a way of giving the compiler just
		enough information for counting. By providing this information, the compiler
		does not have to perform all the additional steps of determining which
		addresses contain the value's bits.
	</p>
	<p>
		When we write something like <var>void* p = &n</var>, we are saying that the
		pointer <var>p</var> points to the address identified as <var>n</var>, which
		is <i>some type</i>. Now, notice what happens when we try to dereference
		<var>p</var>:
	</p>
	<pre class="language-c"><code>
		#include &lt;stdio.h&gt;

		int main() {
			int n = 5;
			void* p = &amp;n;
			printf("*p = %d", *p);
		}	
	</code></pre>
	<pre class="language-bash"><code>
		main.c:6:20: error: argument type 'void' is incomplete
        printf("*p = %d", *p);
                          ^
		1 error generated.
	</code></pre>
	<p>
		We're seeing a compiler error &mdash; the type <var>'void'</var> is
		incomplete. This is because the compiler has no idea how many bytes in
		memory it should read. The void pointer allows us to point to any given
		type, but that's all it permits. Want to read and write? We have to give the
		compiler more information:
	</p>
	<pre class="language-c"><code>
		#include &lt;stdio.h&gt;

		int main() {
			int n = 5;
			void* p = &amp;n;
			printf("*p = %d\n", *((int*) p));
		}	
	</code></pre>
	<pre class="language-bash"><code>
		*p = 5
	</code></pre>
	<p>Closely examine what we wrote:</p>
	<figure>
		<table class="alg">
			<thead>
				<th>Statement</th>
				<th>Meaning</th>
			</thead>

			<tbody>
				<tr>
					<td>
						<var><mark>*((int*) p)</mark></var>
					</td>
					<td>
						Dereference <var><mark>(int*) p</mark></var>
					</td>
				</tr>
				<tr>
					<td>
						<var><mark>(int*) p</mark></var>
					</td>
					<td>
						Cast <var>p</var> to <var><mark>int* p</mark></var>
					</td>
				</tr>
			</tbody>
		</table>
	</figure>
</section>

<section id="malloc_memcpy">
	<h2>Malloc and Memcpy</h2>
	<p>
		With void pointers, we can write more generalized functions. For example,
		consider the humble <var>swap()</var> function:
	</p>
	<pre class="language-c"><code>
		#include &lt;stdio.h&gt;

		void swap(int* a, int* b) {
			int temp = *a;
			*a = *b;
			*b = temp;
		}
		
		int main() {
			int n = 1;
			int m = 2;
			swap(&n, &m);
			return 0;
		}	
	</code></pre>
	<p>
		The most obvious limitation with our function is that it can only work with
		arguments of type <var>int*</var>. Thus, it cannot swap <var>float</var>,
		<var>char</var>, or <var>double</var> values. With what we know thus far, if
		we wanted to swap non-<var>int</var> values, we must implement separate
		<var>swap()</var> functions. This is where the void pointer comes in:
	</p>
	<pre class="language-c"><code>
		#include &lt;stdio.h&gt;
		#include &lt;stdlib.h&gt;
		#include &lt;string.h&gt;
		
		void swap(void* a, void* b, int size) {
			void* tempMemory = malloc(size);
			memcpy(tempMemory, a, size);
			memcpy(a, b, size);
			memcpy(b, tempMemory, size);
		}
		
		int main() {
			int n = 1;
			int m = 2;
			printf("Pre swap(): \n n = %d \n m = %d \n", n, m);
		
			swap(&n, &m, 4);
		
			printf("Post swap(): \n n = %d \n m = %d \n", n, m);
			return 0;
		}	
	</code></pre>
	<pre class="language-bash"><code>
		Pre swap(): 
		 n = 1 
		 m = 2 
		Post swap(): 
		 n = 2 
		 m = 1
	</code></pre>
	<p>Let's focus on the function we wrote:</p>
	<pre class="language-c"><code>
		#include &lt;stdio.h&gt;
		#include &lt;stdlib.h&gt;
		#include &lt;string.h&gt;
		
		void swap(void* a, void* b, int size) {
			void* tempMemory = malloc(size);
			memcpy(tempMemory, a, size);
			memcpy(a, b, size);
			memcpy(b, tempMemory, size);
		}
	</code></pre>
	<p>
		First, this function has a <var>void</var> return type. Nothing new here,
		since we're just swapping values. Inside parameter list, we see three
		things:
	</p>
	<figure>
		<ol class="numd">
			<li>
				<var><mark>void* a</mark></var>
			</li>
			<li>
				<var><mark>void* b</mark></var>
			</li>
			<li>
				<var><mark>int size</mark></var>
			</li>
		</ol>
	</figure>
	<p>
		As we know, <var>void* a</var> and <var>void* b</var> are void pointers.
		They will point to the addresses of the two variables we pass as arguments
		&mdash; <var>swap(&n, &m)</var>. The parameter
		<var>int size</var> corresponds to the size of the data types for
		<var>n</var> and <var>m</var>. For an <var>int</var> on a 64-bit system,
		that's ${4.}$ Hence the call <var>swap(&n, &m, 4)</var>.
	</p>
	<p>Insie the function's body, the first line is:</p>
	<figure>
		<div>
			<p><var>void* tempMemory = malloc(size);</var></p>
		</div>
	</figure>
	<p>
		This line instructs,
		<q
			>Create a pointer <var>tempMemory</var> of type void, and have it point to
			<var>malloc(size)</var>.</q
		>
		The function <var><mark>malloc()</mark></var> (short for
		<q>memory allocate</q>) is a function provided by C's standard library,
		<var><mark>&lt;stdlib.h&gt;</mark></var
		>. The general template:
	</p>
	<figure>
		<ul class="syntax">
			<li>malloc(${s}$)</li>
		</ul>
	</figure>
	<p>
		In the template above, ${s}$ is an <var>int</var> value, corresponding to
		the size of a memory block, in bytes. Importantly, this memory is allocated
		in the <b>heap</b>, but we'll get back to this later.
		<var>malloc()</var> has a <var>void</var> return type, and the value
		returned is a <i>void pointer</i> to the allocated space, or
		<var>NULL</var> if there is insufficient memory available. By writing
		<var>malloc(size)</var>, we're really writing <var>malloc(4)</var> &mdash;
		allocate ${4}$ bytes of memory in the heap.
	</p>
	<p>The next line we wrote is the following:</p>
	<figure>
		<div>
			<p><var>memcpy(tempMemory, a, size);</var></p>
		</div>
	</figure>
	<p>
		Here, we're invoking another C library function,
		<var><mark>memcpy()</mark></var> (short for <q>memory copy</q>). This
		function is found in the library <var><mark>&lt;string.h&gt;</mark></var
		>. The general template:
	</p>
	<figure>
		<ul class="syntax">
			<li>memcpy(${d}$, ${s}$, ${n}$)</li>
		</ul>
	</figure>
	<p>The <var>memcpy()</var> function takes three arguments:</p>
	<figure>
		<ol>
			<li>
				${d,}$ the destination. This is a void pointer to where in memory we
				would like the data copied.
			</li>
			<li>
				${s,}$ the source. This is a void pointer to the location in memory
				where the data we want copied exists.
			</li>
			<li>
				${n,}$ the size. This is an <var>int</var> value, corresponding to the
				number of bytes we want copied.
			</li>
		</ol>
	</figure>
	<p>Thus, when we write:</p>
	<figure>
		<div>
			<p><var>memcpy(tempMemory, a, size)</var></p>
		</div>
	</figure>
	<p>we execute the following procedure:</p>

	<ol class="numd">
		<li>
			Go to the address identified <var><mark>a</mark></var
			>.
		</li>
		<li>
			Starting at that address, read the data contained in
			<var><mark>a</mark></var> and the 3 bytes following (i.e., copy 4 bytes).
		</li>
		<li>Save that data.</li>
		<li>
			Go to the address identified as <var><mark>tempMemory</mark></var
			>.
		</li>
		<li>Starting at that address, write the saved data.</li>
	</ol>

	<p>
		The same process extends to the remaining lines. We're just copying and
		transferring the copies from one address to the next. Using void pointers,
		we've written more generic functions. We can call <var>swap()</var> on
		<var>int</var>s, <var>double</var>s, <var>char</var>s, and so on.
	</p>
	<p>
		<span class="topic">Freeing Memory.</span> The function we've written,
		however, is incomplete. We have one piece missing:
	</p>
	<pre class="language-c"><code>
		#include &lt;stdio.h&gt;
		#include &lt;stdlib.h&gt;
		#include &lt;string.h&gt;
		
		void swap(void* a, void* b, int size) {
			void* tempMemory = malloc(size);
			memcpy(tempMemory, a, size);
			memcpy(a, b, size);
			memcpy(b, tempMemory, size);
			free(tempMemory);
		}
	</code></pre>
	<p>
		The final line calls another library function, <var><mark>free()</mark></var
		>. This function essentially clears out, or makes available for others, the
		memory occupied by <var>tempMemory</var>. Whenever we allocate memory with
		<var>malloc()</var>, we <em>always</em> free the allocated memory once it's
		no longer needed.
	</p>
</section>

<section id="dynamic_memory_allocation">
	<h2>Dynamic Memory Allocation</h2>

	<figure>
		<div>
			<pre class="language-pseudo" style="width: fit-content"><code>
				the heap
				+------------------------------+
				|▧□▧▧□▧▧▧▧□□▧▧▧▧□□▧▧□▧▧▤▦▧▧□▧▧▩|
				|▧▧□▧▧□▧□▧▩▧▧□▧□▧▧▦▧▧□▧▧▧□▧▧▧□▧|
				|▧□▧▧□▧▧□▧□□▧▧▧▧□□▧▧□▧▧▤□▧▧□▧▧▩|
				|□▧▧□□▧□▧▧▩□▧▧▦▧▧□▧▧▤▧□▧□▧▧□□□▧|
				+------------------------------+
	
				the stack
				[□□□□□□□□] [□□□□□□□□] [□□□□□□□□]
				[□□□□□□□□] [□□□□□□□□] [□□□□□□□□]
				[□□□□□□□□] [□□□□□□□□] [□□□□□□□□]
				[□□□□□□□□] [□□□□□□□□] [□□□□□□□□]
			</code></pre>
		</div>
	</figure>

	<p>
		The void pointer is what brings us to <b>dynamic memory allocation</b>. In
		previous examples above, we allocated memory strictly in the <b>stack</b>.
		When we allocate memory in the stack, the memory is automatically cleaned
		when the function returns. In most of our programs, the primary function was
		<var>main()</var>. Once <var>main()</var> returns &mdash; i.e., the line
		<var>return 0</var> is executed &mdash; all of the memory we asked to be
		allocated for our program is cleaned.
	</p>
	<p>
		In some situations, however, we want more control over how to use memory. In
		C, we achieve greater control by using memory in the
		<b>heap</b>. In C, there are two functions for dynamic memory allocation
		&mdash; <var><mark>malloc()</mark></var> and <var><mark>calloc()</mark></var
		>. Both of these functions communicate directly with the operating system
		&mdash; they request a specific allocation of memory, and they address of
		that allocated memory. Let's consider <var>malloc()</var> first.<sup></sup>
	</p>
	<div class="note">
		<p>
			To use memory allocation functions like <var>malloc()</var> and
			<var>calloc()</var>, we must include <var>malloc.h</var> or
			<var>stdlib.h</var>.
		</p>
	</div>
	<section id="malloc">
		<h3>The Malloc Function</h3>
		<p>
			When we write <var>malloc(8)</var>, we get back a sequence of eight bytes
			of memory in the heap allocated and the address of the first byte of that
			eight-byte sequence. When we write <var>malloc(12)</var>, we get back a
			sequence of twelve bytes. With <var>malloc(16)</var>, a sequence of
			sixteen bytes.
		</p>
		<p>
			There are a few helpful idioms to employ when using <var>malloc()</var>.
			For example, consider the follwing:
		</p>
		<pre class="language-c"><code>
			int main() {
				int *arr;
				int arrSize;
				scanf("%d", &arrSize);
				arr = (int*)malloc(sizeof(int) * arrSize);
			}
		</code></pre>
		<p>
			The code above returns an array of size <var>arrSize</var> times the size
			of an <var>int</var>. Notice that we're casting the result of
			<var>malloc()</var> to an <var>int*</var>. This is because
			<var>malloc()</var>'s return type is <var>void*</var>. Moreover, the code
			snippet above is how we allocate memory dynamically. Going line by line:
		</p>
		<table class="alg">
			<thead>
				<th>Statement</th>
				<th>Operation</th>
			</thead>
			<tbody>
				<tr>
					<td><var>int *arr</var></td>
					<td>Declare a pointer to an <var>int</var> called <var>arr</var>.</td>
				</tr>
				<tr>
					<td><var>int arrSize</var></td>
					<td>
						Declare a pointer to an <var>int</var> called <var>arrSize</var>.
					</td>
				</tr>
				<tr>
					<td><var>scanf("%d", &arrSize)</var></td>
					<td>
						Prompt the user for keyboard input. Take the user's input stream,
						and format it as a decimal (i.e., <var>int</var>). Store that
						formatted data in the address <var>&arrSize</var>.
					</td>
				</tr>
				<tr>
					<td colspan="2" class="grey center">
						<var>arr = (int*)malloc(sizeof(int) * arrSize)</var>
					</td>
				</tr>
				<tr>
					<td><var>(sizeof(int)) * arrSize</var></td>
					<td>
						Take the size of an <var>int</var> and multiply it by
						<var>arrSize</var>
					</td>
				</tr>
				<tr>
					<td><var>malloc(sizeof(int) * arrSize)</var></td>
					<td>
						Allocate a sequence of bytes in the heap with a length equal to the
						product from the previous result. Return the address of the first
						byte in the allocated bytes.
					</td>
				</tr>
				<tr>
					<td><var>(int*)malloc(sizeof(int) * arrSize)</var></td>
					<td>Cast the address returned to be of type <var>int*</var>.</td>
				</tr>
				<tr>
					<td><var>arr = (int*)malloc(sizeof(int) * arrSize)</var></td>
					<td>
						Assign the result to the previously declared pointer <var>arr</var>.
					</td>
				</tr>
			</tbody>
		</table>
		<p>
			Although the code above works, it isn't best practice. There are
			situations where we must work with memory-limited machines, or programs
			that consume large amounts of memory. Accordingly, we must
			<em>always</em> include <i>memory sentinels</i> whenever we work dynamic
			memory allocation:
		</p>
		<pre class="language-c"><code>
			int main() {
				double *arr;
				int arrSize;
				scanf("%d", &arrSize);
				arr = (double*)malloc(sizeof(double) * arrSize);
				if (arr != NULL) {
					printf("Allocation succeeded");
	
					// Code to execute if allocation succeeded
	
				} else {
					printf("Allocation failed.");
				}
			}
		</code></pre>
		<p>
			Above, the memory sentinel is <var>arr != NULL</var>. By including this
			test condition, we are saying, if <var>arr == NULL</var> (i.e.,
			<var>arr</var> does not contain a valid address), then do not proceed
			&mdash; inform us that the allocation failed.
		</p>
	</section>

	<section id="calloc">
		<h3>The Calloc Function</h3>
		<p>
			Like <var>malloc()</var>, <var><mark>calloc()</mark></var> allocates a
			sequence of bytes and returns the address of the sequence (the address of
			the first byte). The difference with <var>calloc()</var>, however, is that
			every allocated byte in the sequence is <em>initially set to zero</em>.
			Thus, when we write <var>calloc(4)</var>, we get the four-byte sequence:
		</p>
		<ol class="array">
			<li>
				<ul>
					<li>0</li>
					<li>1</li>
				</ul>
			</li>
			<li>
				<ul>
					<li>0</li>
					<li>2</li>
				</ul>
			</li>
			<li>
				<ul>
					<li>0</li>
					<li>3</li>
				</ul>
			</li>
			<li>
				<ul>
					<li>0</li>
					<li>4</li>
				</ul>
			</li>
		</ol>
		<p>The <var>calloc()</var> function also has slightly different syntax:</p>
		<ul class="syntax">
			<li>calloc(${n}$, ${s}$)</li>
		</ul>
		<p>
			Above, ${n}$ is an unsigned integer, corresponding to the number of
			elements &mdash; how many <var>int</var>, <var>double</var>, or
			<var>float</var> should be allocated? The parameter ${s}$ is also an
			unsigned integer, corresponding to the size of each element (i.e., the
			size of the data type). Like <var>malloc()</var>, however, the return type
			is a void pointer, so we must cast. To illustrate, writing:
		</p>
		<pre class="language-c"><code>
			(int*)calloc(5, sizeof(int))
		</code></pre>
		<p>
			allocates a sequence of bytes with a length equal to
			<var>5 * sizeof(int)</var>. Again, this is similar to writing:
		</p>
		<pre class="language-c"><code>
			(int*)malloc(sizeof(int) * 5)
		</code></pre>
		<p>
			The key difference being each byte in the allocated sequence is
			initialized to <var>0</var>. We can use <var>calloc()</var> just as we
			would <var>malloc()</var>:
		</p>
		<pre class="language-c"><code>
			int main() {
				int *arr;
				int arrSize;
				scanf("%d", &arrSize);
				arr = (int*)calloc(arrSize, sizeof(int));
			}
		</code></pre>
		<p>Why use <var>calloc()</var>?</p>
	</section>

	<section id="free_function">
		<h3>The Free Function</h3>
		<p>
			Once we've allocated memory in the heap, that memory remains allocated
			unless we call the <var><mark>free()</mark></var
			>. This means that unless we call <var>free()</var>, memory allocated in
			the heap through some function ${f}$ will remain allocated even after
			${f}$ has been popped off the stock. Thus, it is imperative that we always
			call <var>free()</var> after we've finished using the allocated memory.
		</p>
	</section>
</section>

<section id="pointers_to_arrays">
	<h2>Pointers & Arrays</h2>
	<p>Examine the code below:</p>
	<pre class="language-c"><code>
		#include &lt;stdio.h&gt;

		int main() {
			int array[3];  
			return 0;
		}
	</code></pre>
	<p>
		This is an array declaration. In memory, this results in what roughly looks
		like the following:
	</p>
	<figure>
		<div>
			<pre class="language-pseudo"><code>
				⋮
				113 [▨▨▨▨▨▨▨▨]
				112 [▨▨▨▨▨▨▨▨]
				================+  
				111 [□□□□□□□□]  |
				110 [□□□□□□□□]  |
				109 [□□□□□□□□]  |
				108 [□□□□□□□□]  |
				================|
				107 [□□□□□□□□]  |
				106 [□□□□□□□□]  |
				105 [□□□□□□□□]  | array
				104 [□□□□□□□□]  |
				================|
				103 [□□□□□□□□]  |
				102 [□□□□□□□□]  |
				101 [□□□□□□□□]  |
				100 [□□□□□□□□]  |
				================+
				099 [▨▨▨▨▨▨▨▨]
				098 [▨▨▨▨▨▨▨▨]
				⋮
			</code></pre>
		</div>
	</figure>
	<p>
		The diagram above illustrates the fact that when we declare an array in the
		manner we did above, we are allocating memory in the
		<i>stack</i> for future use. Observe further that each of the allocated
		blocks consists of 4 bytes. Thus, with an array of size 3, we consume 12
		bytes of memory. Once we initialize the array:
	</p>
	<pre class="language-c"><code>
		#include &lt;stdio.h&gt;

		int main() {
			int array[3] = {13924, 39287, 998768};  
			return 0;
		}
	</code></pre>
	<p>the memory appears as such:</p>
	<figure>
		<div>
			<pre class="language-pseudo"><code>
				⋮
				113 [▨▨▨▨▨▨▨▨]
				112 [▨▨▨▨▨▨▨▨]
				==============
				111 [<span class="blueText">01110000</span>]
				110 [<span class="blueText">00111101</span>]
				109 [<span class="blueText">00001111</span>]
				108 [<span class="blueText">00000000</span>] <span class="redText">array[2] = 998768</span>
				==============
				107 [<span class="blueText">01110111</span>]
				106 [<span class="blueText">10011001</span>]
				105 [<span class="blueText">00000000</span>]
				104 [<span class="blueText">00000000</span>] <span class="redText">array[1] = 39287</span>
				==============
				103 [<span class="blueText">01100100</span>]
				102 [<span class="blueText">00110110</span>]
				101 [<span class="blueText">00000000</span>]
				100 [<span class="blueText">00000000</span>] <span class="redText">array[0] = 13924</span>
				==============
				099 [▨▨▨▨▨▨▨▨]
				098 [▨▨▨▨▨▨▨▨]
				⋮
			</code></pre>
		</div>
	</figure>
	<p>
		Once the array is initialized, the bits composing each element of the array
		fill these allocated blocks. This evidences a critical fact about arrays:
		Arrays provide a way for us to initialize multiple variables at once, where
		the values bound to each variable are stored sequentially in memory. Given
		this fact, it follows that we can have pointers to arrays:
	</p>

	<pre class="language-c"><code>
		#include &lt;stdio.h&gt;

		int main() {
			int array[3] = {13924, 39287, 998768};  
			int *p = array;
			return 0;
		}
	</code></pre>
	<p>In memory:</p>
	<pre class="language-pseudo"><code style="font-size: 0.53rem;">
		⋮
		<span class="redText">100</span> [<span class="blueText">00000000</span>]|104 [<span class="blueText">00000000</span>]|108 [<span class="blueText">00000000</span>]|116 [<span class="greenText">00000000</span>] 119 [<span class="greenText">00000000</span>]|
		101 [<span class="blueText">00000000</span>]|105 [<span class="blueText">00000000</span>]|109 [<span class="blueText">00001111</span>]|117 [<span class="greenText">00000000</span>] 120 [<span class="greenText">00000000</span>]|
		102 [<span class="blueText">00110110</span>]|106 [<span class="blueText">10011001</span>]|110 [<span class="blueText">00111101</span>]|118 [<span class="greenText">00000000</span>] 121 [<span class="greenText">00000000</span>]|
		103 [<span class="blueText">01100100</span>]|107 [<span class="blueText">01110111</span>]|111 [<span class="blueText">01110000</span>]|119 [<span class="greenText">00000000</span>] 122 [<span class="greenText">01100100</span>]|
		 a[0] = 13924   a[1] = 39287  a[2] = 998768            <span class="redText">p = 100</span>
	</code></pre>
	<p>
		Notice the syntax <var>int *p = array</var>. This is equivalent to
		<var>int *p = array[0]</var>. Thus, when we assign a variable storing an
		array to a pointer ${p,}$ we are assigning the memory address of the
		<em>first</em> element of the array to the pointer. Examining the different
		values:
	</p>
	<pre class="language-c"><code>
		#include &lt;stdio.h&gt;

		void print_bytes(void *ptr, int size) {
			unsigned char *p = ptr;
			int i;
			for (i=0; i&lt;size; i++) {
				if ((i % 4) == 0) {
					printf(" | ");
				}
				printf("%02hhX ", p[i]);
			}
			printf(" |\n");
		}
		
		int main() {
			int array[3] = {13924, 39287, 998768};
			int *p = array;

			// the address in p
			printf("%p\n", p);

			// the address of array using square brackets
			printf("%p\n", &array[0]);

			// print 'array': the address of the first element
			printf("%p\n", array);

			// dereference 'array': the value at the address of array
			printf("%d\n", *array); 

			// index 0: the value of the first element
			printf("%d\n", array[0]); 

			// dereference p: the value at the address of array
			printf("%d\n", *p);
			
			// the memory addresses occupied by the first element
			print_bytes(&array[0], sizeof(array[0])); 

			// all the memory addresses occupied by array
			print_bytes(array, sizeof(array)); 
		}
	</code></pre>
	<pre class="language-bash"><code>
		0x7ffee41441bc
		0x7ffee41441bc
		0x7ffee41441bc
		13924
		13924
		13924
		 | 64 36 00 00  |
		 | 64 36 00 00  | 77 99 00 00  | 70 3D 0F 00  |
	</code></pre>
	<p>
		Notice the various syntax. The variable <var>array</var>, on its own, will
		return the address of the array's first element. This is called the array's
		<b>base address</b>. If we want to access that element, we write
		<var>*array</var>. If we wanted to access the second element, we write
		<var>*(array + 1)</var>. And the second, <var>*(array + 2),</var> the third
		<var>*(array + 3)</var>, and so on. This is a big insight:
	</p>
	<figure>
		<div class="rule">
			<p>
				<span class="topic">Observation.</span>
				Given an array ${A}$ and ${n \in \Z,}$ the following syntactical forms
				are equivalent:
			</p>
			<figure>
				<div>
					<p><var>&${A}$[${i}$] ${\equiv}$ &${A}$</var></p>
					<p><var>${A}$[${i}$] ${\equiv}$ *${A}$</var></p>
					<p>
						<span class="monoText"
							>&${A}$[${i}$ + ${n}$] ${\equiv}$ &(${A}$ + ${n}$)</span
						>
					</p>
					<p>
						<span class="monoText"
							>${A}$[${i}$ + ${n}$] ${\equiv}$ *(${A}$ + ${n}$)</span
						>
					</p>
				</div>
			</figure>
		</div>
	</figure>
	<p>
		Note that while the arithmetic operators work on array identifiers, we
		cannot use the unary operators like <var>++</var>, <var>--</var>, etc. These
		will return a compiler error.
	</p>
	<p>
		Separately, we can always print the size of an array with the
		<var>sizeof</var> operator:
	</p>
	<pre class="language-c"><code>
		#include &lt;stdio.h&gt;

		int main() {
			int arr[5] = {1, 2, 3, 4, 5};
			printf("sizeof(arr) = %lu bytes\n", sizeof(arr));
			return 0;
		}	
	</code></pre>
	<pre class="language-bash"><code>
		sizeof(arr) = 20 bytes
	</code></pre>

	<section id="arrays_as_function_arguments">
		<h3>Arrays as Function Arguments</h3>
		<p>
			Suppose we wrote the following program that computes the average from an
			array of prices:
		</p>
		<pre class="language-c"><code>
			#include &lt;stdio.h&gt;

			double average(double array[]) {
				int arrayLength = sizeof(array)/sizeof(double);
				double sum = 0.0;
				for (int i = 0; i < arrayLength; i++) {
					sum += array[i];
				}
				return sum / arrayLength;
			}
			
			int main() {
				double prices[] = {53.55, 54.87, 55.08, 58.23};
				double averagePrice = average(prices);
				printf("Average price = %f", averagePrice);
				return 0;
			}
		</code></pre>
		<p>Compiling, we see a problem:</p>
		<pre class="language-bash"><code>
			arrayArgs.c:4:26: warning: sizeof on array function parameter will return size of 'double *' instead of 'double []' [-Wsizeof-array-argument]
							int arrayLength = sizeof(array)/sizeof(double);
																			^
			arrayArgs.c:3:23: note: declared here
							double average(double array[]) {
														^
			arrayArgs.c:4:33: warning: 'sizeof (array)' will return the size of the pointer, not the array itself [-Wsizeof-pointer-div]
							int arrayLength = sizeof(array)/sizeof(double);
																~~~~~~~~~~~~~^
			arrayArgs.c:3:23: note: pointer 'array' declared here
							double average(double array[]) {
																	^
			2 warnings generated.
		</code></pre>
		<p>
			There are two warnings and a note. To understand why we're seeing this
			output, we must understand what actually happens when we indicate an array
			parameter for a function.
		</p>
		<p>
			When we tell the compiler that a function takes an array as an argument,
			the compiler <em>will not</em> make a copy of the array for the function
			to use in its stack frame. Notice that this is in contrast to
			non-composite data like <var>int</var> or <var>char</var> values. Those
			values will be passed by value (i.e., the function gets its own copy of
			the value; not the original). Composite data like arrays, on the other
			hand, are passed by pointer. Why? Efficiency. Arrays are a staple in
			programming, but more often than not, the functions we write do not need
			an entire copy of the array for themselves. The array we have above is a
			small one. Imagine an array with a million values being used by several
			thousand functions. That's a fair amount of memory usage.
		</p>
		<p>
			So what does pass by pointer imply? It implies that the parameter
			<var>array[]</var> in the function above is actually a pointer to base
			type. In this case, <var>double</var>. This in turn means that all the
			compiler knows with respect to <var>array[]</var> is that it's a
			<var>double</var> pointer &mdash; <var>double*</var>. Nothing else. It
			doesn't know what that pointer points to, or whether it points to anything
			at all. Accordingly, for this program to work, we must initialize the
			<var>size</var> parameter <em>outside</em> the function:
		</p>
		<pre class="language-c"><code>
			#include &lt;stdio.h&gt;

			double average(double array[], int size) {
				double sum = 0.0;
				for (int i = 0; i < size; i++) {
					sum += array[i];
				}
				return sum / size;
			}
			
			int main() {
				double prices[] = {53.55, 54.87, 55.08, 58.23};
				int numPrices = sizeof(prices)/sizeof(double);
				double averagePrice = average(prices, numPrices);
				printf("Average price = %f\n", averagePrice);
				return 0;
			}
		</code></pre>
		<pre class="language-bash"><code>
			Average price = 55.432500
		</code></pre>
	</section>

	<section id="exercises">
		<ol class="ex">
			<li class="grid-item">
				<p>
					Implement a function that takes an <var>int</var> array and returns
					<em>both</em> the minimum and maximum <var>int</var> elements.
				</p>
				<details class="answer">
					<summary>Solution</summary>
					<p>Here's an implementation:</p>
				</details>
			</li>
		</ol>
	</section>
</section>

<section id="pointers_to_character_arrays">
	<h2>Pointers &amp; Character Arrays</h2>
	<p>
		As we know, character arrays in C are strings. Character arrays are what we
		use to perform operations on strings. Whenever we work$ith strings in C, we
		must check off the following:
	</p>

	<ol class="checklist">
		<li>
			The <var>char</var> array must be large enough to commodate the string.
			<br /><br />
			A <var>char</var> array is sufficiently large if:
			<figure>$$s \geq \ell + 1$$</figure>
			Where ${s}$ is the size of the <var>char</var> array and ${\ell}$ is the
			number of characters in the string. This is because every string has a
			string delimiter, a <var>char</var> value, <var>'\0'</var>.
		</li>
		<li>
			Ensure that the <var>char</var> array has a string delimiter,
			<var>'\0'</var>.
		</li>
	</ol>

	<p>
		Arrays and pointers are different types, but are used in similar ways.
		Recall that an array's identifier is actually the identifier for the memory
		address of the first element in the array. For example, in the character
		array:
	</p>
	<pre class="language-c"><code>
		char S[] = "Hello";
	</code></pre>
	<p>
		the identifier <var>S</var> is the identifier for the first character in the
		array, <var>H</var>. Suppose we initialized a pointer <var>SP</var>, and
		assigned it <var>S</var>:
	</p>
	<pre class="language-c"><code>
		char S[] = "Hello";
		char* SP = S;
	</code></pre>
	<p>
		This statements above are perfectly valid. Why? Because <var>S</var> is the
		identifier for the address of the first element in the character array.
		Because of this fact, we can use <var>SP</var> to access the array
		<var>S</var>:
	</p>
	<pre class="language-c"><code>
		char S[] = "Hello";
		char* SP = S;
		SP[0] = 'h'; // S is now "hello"
		SP[1] = 'a'; // S is now "hallo"
	</code></pre>
	<p>More generally:</p>
	<figure>
		<div class="rule">
			<p>
				<span class="topic">Syntax.</span>
				Where <var>p</var> is a pointer to some <var>char</var> array
				<var>S</var>:
			</p>
			<figure>
				<div>
					<p>${\texttt{p[i]} \equiv \texttt{*(p+i)}}$</p>
				</div>
			</figure>
			<p>
				I.e., the syntax <var>p[i]</var> is equivalent to dereferencing
				<var>(p+i)</var>.
			</p>
		</div>
	</figure>
</section>
{% endblock %}
