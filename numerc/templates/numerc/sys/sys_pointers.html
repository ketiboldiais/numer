{% extends '../layout.html' %} {% load static %} {% block description %}
<meta
	name="description"
	content="What are pointers? Overview of pointers, pointer operators, allocating memory in the heap, pointer arithmetic."
/>
{% endblock %} {% block title %}
<title>Pointers</title>
{% endblock %} {% block content %}
<h1>Pointers</h1>

<section id="pointer_basics">
	<p>
		<span class="drop">L</span>et's talk pointers. We saw pointers in the volume
		on C++, but now we're going to explore them much more rigorously. Pointers
		are often a point of confusion among new programmers, but their underlying
		concepts are fairly simple. Applying those concepts, however, can be
		challenging, as we'll see. The trick to getting over these challenges:
		Establishing a very strong understanding of the underlying concepts, and
		practicing using pointers as much as possible.
	</p>
	<p>
		Programming in C, it's pretty much inevitable that we use pointers in some
		way. The language is too substantially limited without using pointers.
		Because much of exploration into computer systems relies heavily on C, it is
		imperative that we are as comfortable with pointers as possible.
	</p>

	<p>
		To begin, we review how main memory works. First, visualize main memory as
		the following:
	</p>
	<figure class="math-display">
		<div>
			<pre class="language-pseudo"><code>
				⋮
				109 [□□□□□□□□]
				108 [□□□□□□□□]
				107 [□□□□□□□□]
				106 [□□□□□□□□]
				105 [□□□□□□□□]
				104 [□□□□□□□□]
				103 [□□□□□□□□]
				102 [□□□□□□□□]
				101 [□□□□□□□□]
				⋮
				000 [□□□□□□□□]
			</code></pre>
		</div>
		<figcaption>
			The numbers to the left are
			<span class="italicsText">memory addresses</span>. These are not valid
			addresses. They are used just to keep things simple. In reality, they
			would be in hexadecimal.
		</figcaption>
	</figure>
	<p>
		We use the □ to indicate the place of a bit, and the vertical ellipses ⋮ to
		indicate further stacks. Notice that each stack contains eight □. This
		represents the fact that each frame is a
		<span class="term">byte</span> &mdash; a sequence of 8 bits. We'll keep this
		in mind as we continue.
	</p>
	<p>
		In C, we must explicitly state the data type for our variables. This serves
		as an instruction to the compiler to allocate a certain amount of memory. On
		modern computers, <span class="monoText">int</span> is allocated 4 bytes,
		<span class="monoText">char</span> is allocated 1 byte, and
		<span class="monoText">float</span> is allocated 4 bytes. When write
		<span class="monoText">int a;</span> the memory appears as such:
	</p>
	<figure class="math-display">
		<div>
			<pre class="language-pseudo"><code>
				⋮
				109 [□□□□□□□□]
				108 [□□□□□□□□]
				107 [□□□□□□□□]
				106 [□□□□□□□□]
				--------------
				105 [▨▨▨▨▨▨▨▨]
				104 [▨▨▨▨▨▨▨▨]
				103 [▨▨▨▨▨▨▨▨]
				102 [▨▨▨▨▨▨▨▨] a
				--------------
				101 [□□□□□□□□]
				⋮
				000 [□□□□□□□□]
			</code></pre>
		</div>
	</figure>
	<p>
		In the diagram above, we use the ▨ to indicate that the space is allocated,
		but the value therein could be anything. I.e.,
		<span class="italicsText">garbage value</span>. Writing
		<span class="monoText">char c;</span> thereafter:
	</p>
	<figure class="math-display">
		<div>
			<pre class="language-pseudo"><code>
				⋮
				109 [□□□□□□□□]
				108 [□□□□□□□□]
				107 [□□□□□□□□]
				--------------
				106 [▨▨▨▨▨▨▨▨] c
				--------------
				105 [▨▨▨▨▨▨▨▨]
				104 [▨▨▨▨▨▨▨▨]
				103 [▨▨▨▨▨▨▨▨]
				102 [▨▨▨▨▨▨▨▨] a
				--------------
				101 [□□□□□□□□]
				⋮
				000 [□□□□□□□□]
			</code></pre>
		</div>
	</figure>
	<p>
		A <span class="monoText">char</span> variable takes 1 byte of memory, so it
		takes up a single address. If we then write
		<span class="monoText">a = 5;</span> the memory then appears as:
	</p>
	<figure class="math-display">
		<div>
			<pre class="language-pseudo"><code>
				⋮
				109 [□□□□□□□□]
				108 [□□□□□□□□]
				107 [□□□□□□□□]
				--------------
				106 [▨▨▨▨▨▨▨▨] c
				--------------
				105 [00000101]
				104 [00000000]
				103 [00000000]
				102 [00000000] a
				--------------
				101 [□□□□□□□□]
				⋮
				000 [□□□□□□□□]
			</code></pre>
		</div>
	</figure>
	<p>
		We now fill the addresses from <span class="monoText">102</span> to
		<span class="monoText">105</span> (4 bytes), with the bits representing
		<span class="monoText">5</span>. Writing
		<span class="monoText">char c = 'a';</span> we get:
	</p>
	<figure class="math-display">
		<div>
			<pre class="language-pseudo"><code>
				⋮
				109 [□□□□□□□□]
				108 [□□□□□□□□]
				107 [□□□□□□□□]
				--------------
				106 [01100001] c
				--------------
				105 [00000101]
				104 [00000000]
				103 [00000000]
				102 [00000000] a
				--------------
				101 [□□□□□□□□]
				⋮
				000 [□□□□□□□□]
			</code></pre>
		</div>
	</figure>
	<p>
		And when we write <span class="monoText">a++;</span> we are simply changing
		the bits in the address allocated for <span class="monoText">a</span>:
	</p>
	<figure class="math-display">
		<div>
			<pre class="language-pseudo"><code>
				⋮
				109 [□□□□□□□□]
				108 [□□□□□□□□]
				107 [□□□□□□□□]
				--------------
				106 [01100001] c
				--------------
				105 [00000111]
				104 [00000000]
				103 [00000000]
				102 [00000000] a
				--------------
				101 [□□□□□□□□]
				⋮
				000 [□□□□□□□□]
			</code></pre>
		</div>
	</figure>
	<p>
		In all of the examples above, the address of
		<span class="monoText">a</span> is <span class="monoText">102</span>. We can
		store that address in a variable. That variable is called a
		<span class="term">pointer</span>. For example, if we next wrote
		<span class="monoText">int *p</span>, the memory would appear as such:
	</p>
	<figure class="math-display">
		<div>
			<pre class="language-pseudo"><code>
				⋮
				116 [□□□□□□□□]
				115 [□□□□□□□□]
				--------------
				114 [▨▨▨▨▨▨▨▨]
				113 [▨▨▨▨▨▨▨▨]
				112 [▨▨▨▨▨▨▨▨]
				111 [▨▨▨▨▨▨▨▨]
				110 [▨▨▨▨▨▨▨▨]
				109 [▨▨▨▨▨▨▨▨]
				108 [▨▨▨▨▨▨▨▨]
				107 [▨▨▨▨▨▨▨▨] p
				--------------
				106 [01100001] c
				--------------
				105 [00000111]
				104 [00000000]
				103 [00000000]
				102 [00000000] a
				--------------
				101 [□□□□□□□□]
				⋮
				000 [□□□□□□□□]
			</code></pre>
		</div>
	</figure>
	<p>
		Notice that the pointer takes up 8 bytes. For now, we will say that this is
		the case for a 64-bit machine. On a 32-bit machine, the pointer would take
		up 4 bytes. Now, let's say we then wrote
		<span class="monoText">p = &amp;a;</span>. This assigns the
		<span class="italicsText">address</span> of
		<span class="monoText">a</span> to the pointer
		<span class="monoText">p</span>, resulting in:
	</p>
	<figure class="math-display">
		<div>
			<pre class="language-pseudo"><code>
				⋮
				116 [□□□□□□□□]
				115 [□□□□□□□□]
				--------------
				114 [01100110]
				113 [00000000]
				112 [00000000]
				111 [00000000]
				110 [00000000]
				109 [00000000]
				108 [00000000]
				107 [00000000] p
				--------------
				106 [01100001] c
				--------------
				105 [00000111]
				104 [00000000]
				103 [00000000]
				102 [00000000] a
				--------------
				101 [□□□□□□□□]
				⋮
				000 [□□□□□□□□]
			</code></pre>
		</div>
	</figure>
	<p>
		Again, in our diagram, the address stored in
		<span class="monoText">p</span> is not a valid address. We use the simple
		integer addresses to the left to keep the illustration simple, but the
		principle is the same &mdash; the pointer
		<span class="monoText">p</span> stores a number, and that number is an
		address. In actuality, a valid address stored in
		<span class="monoText">p</span> would be in hexadecimal and appear something
		like: <span class="monoText">66 00 00 00</span>. The address of
		<span class="monoText">p</span> itself would look something like
		<span class="monoText">1C 91 96 EC FE 7F 00 00</span>.
	</p>
	<p>
		From these demonstrations, we observe the following: Whenever we deal with
		pointers, there are really only three perspectives: (i)
		<span class="italicsText"
			>the address <span class="underlineText">in</span></span
		>,
		<span class="italicsText"
			>(iii) the address <span class="underlineText">of</span></span
		>, and (iii)
		<span class="italicsText"
			>the value <span class="underlineText">at</span> the address
			<span class="underlineText">in</span>.</span
		><label for="pionterrhyme" class="margin-toggle"><sup></sup></label>
		<input
			type="checkbox"
			id="pionterrhyme"
			class="margin-toggle sidenote-number"
		/>
		<span class="marginnote"
			>&#8220;The address in, the address of, the value at the address
			in.&#8221;</span
		>
	</p>
	<figure class="table">
		<table class="api">
			<thead>
				<th>Expression</th>
				<th>Command</th>
				<th>Value</th>
			</thead>
			<tbody>
				<tr>
					<td><span class="monoText">${t}$ *p;</span></td>
					<td>Create a pointer of type ${t}$</td>
					<td><span class="monoText">p == null</span></td>
				</tr>
				<tr>
					<td>
						<p><span class="monoText">${t}$ a = ${n}$;</span></p>
						<p><span class="monoText">${t}$ *p = &amp;a;</span></p>
					</td>
					<td>
						Assign to the pointer <span class="monoText">p</span> the
						${\textit{address-of}}$ <span class="monoText">a</span>
					</td>
					<td>
						<span class="monoText">p ==</span> ${\textit{address-of}}$
						<span class="monoText">x</span>
					</td>
				</tr>
				<tr>
					<td colspan="3">
						Suppose:
						<ul class="smallBullets">
							<li><span class="monoText">a == 5</span></li>
							<li><span class="monoText">*p = &a</span></li>
							<li>
								${\textit{address-of}}$ <span class="monoText">a == 102</span>
							</li>
							<li>
								${\textit{address-of}}$ <span class="monoText">p == 107</span>
							</li>
						</ul>
						then:
					</td>
				</tr>
				<tr>
					<td><span class="monoText">p</span></td>
					<td>
						Give me the ${\textit{address-in}}$ <span class="monoText">p</span>
					</td>
					<td><span class="monoText">102</span></td>
				</tr>
				<tr>
					<td><span class="monoText">&a</span></td>
					<td>
						Give me the ${\textit{address-of}}$ <span class="monoText">a</span>
					</td>
					<td><span class="monoText">102</span></td>
				</tr>
				<tr>
					<td><span class="monoText">&p</span></td>
					<td>
						Give me the ${\textit{address-of}}$ <span class="monoText">p</span>
					</td>
					<td><span class="monoText">107</span></td>
				</tr>
				<tr>
					<td><span class="monoText">*p</span></td>
					<td>
						Give me the ${\textit{value-at-the-address-in}}$
						<span class="monoText">p</span>.
					</td>
					<td><span class="monoText">5</span></td>
				</tr>
				<tr>
					<td><span class="monoText">*p = ${v}$</span></td>
					<td>
						Change the ${\textit{value-at-the-address-in}}$
						<span class="monoText">p</span> to ${v}$
					</td>
					<td><span class="monoText">a == ${v}$</span></td>
				</tr>
			</tbody>
		</table>
	</figure>
	<p>Let's see some more examples. Consider the following code:</p>
	<pre class="language-c"><code>
		int main() {
			int i = 17;
			int j = 32;
			int *p = &amp;i;
			int *q = &amp;j;
			return 0;
		}
	</code></pre>
	<p>In RAM, the code above appears as such:</p>
	<figure>
		<img
			src="{% static 'images/pointer_address_C.svg' %}"
			alt="Pointer in memory"
			loading="lazy"
			class="eighty-p"
		/>
		<figcaption>
			A section of RAM. The ellipses represent some other section of RAM
			preceding the section we're concerned with.
		</figcaption>
	</figure>
	<p>
		The variables <span class="monoText">i</span> and
		<span class="monoText">j</span> are variables storing
		<span class="monoText">17</span> and
		<span class="monoText">32</span> respectively. The variables
		<span class="monoText">*p</span> and <span class="monoText">*q</span>,
		however, are pointers. They store the addresses of
		<span class="monoText">i</span> and
		<span class="monoText">j</span> respectively. The start symbol,
		<span class="monoText">*</span>, is what we use to tell the compiler that a
		variable is a pointer. Thus, whenever the compiler comes across a variable
		prepended with <span class="monoText">*</span>, it goes, &#8220;Oh, this is
		a pointer. There's going to be an address in here.&#8221; The ampersand
		symbol, <span class="monoText">&</span>, is what we use to obtain the
		address of a variable. Thus, when the compiler sees a variable prepended
		with <span class="monoText">&</span>, it goes, &#8220;Ah, they're asking for
		what address is named with this variable name. Let me go and get
		it.&#8221;<label for="variableName" class="margin-toggle"
			><sup></sup
		></label>
		<input
			type="checkbox"
			id="variableName"
			class="margin-toggle sidenote-number"
		/>
		<span class="marginnote"
			>Remember, variables are just names for addresses. We could imagine a
			world where we didn't have variables, where we'd manually write memory
			addresses and assign them values; a frightening thought to say the
			least.</span
		>
	</p>
	<p>
		Notice the memory addresses in the diagram above. They go by increment by 4,
		but after the first pointer, <span class="monoText">p</span>, it increments
		by 8. This is intentional. Notice further that the pointers occupy a space
		slightly larger than the others. This too is intentional.
	</p>
	<p>
		Each of the addresses above is the address of a particular
		<span class="term">byte</span> in memory. An
		<span class="monoText">int</span>, however, cannot fit in one byte of
		memory. For this particular architecture, a 64-bit system, the
		<span class="monoText">int</span> requires 4 bytes of memory. Thus, the
		value <span class="monoText">17</span>, assigned to
		<span class="monoText">i</span>, occupies the addresses
		<span class="monoText">0x1000</span>, <span class="monoText">0x1001</span>,
		<span class="monoText">0x1002</span>, and
		<span class="monoText">0x1003</span>. Then, for
		<span class="monoText">32</span>, assigned to
		<span class="monoText">j</span>, occupies the addresses
		<span class="monoText">0x1004</span>, <span class="monoText">0x1005</span>,
		<span class="monoText">0x1006</span>, and
		<span class="monoText">0x1007</span>.
	</p>
	<p>
		Pointers, again for this machine, occupy 8 bytes of memory. Thus, the
		pointer <span class="monoText">p</span> occupies the addresses from
		<span class="monoText">0x1008</span> through
		<span class="monoText">0x1015</span>. And the pointer
		<span class="monoText">q</span> occupies the addresses
		<span class="monoText">0x1016</span> through
		<span class="monoText">0x1023</span>.
	</p>
	<p>Let's add a bit more code:</p>
	<pre class="language-c"><code>
		#include &lt;stdio.h&gt;

		int main() {
			int i = 17;
			int j = 32;
			int *p = &amp;i;
			int *q = &amp;j;
			printf("Content of *p : %i\n", *p);
			printf("Content of p : %p\n", p);
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		Content of *p : 17
		Content of p : 0x7ffeed37e158
	</code></pre>
	<p>
		Examine the output closely. When we ask for the value
		<span class="monoText">*p</span>, we are
		<span class="term">dereferencing</span> the pointer
		<span class="monoText">p</span>. This is often a point of confusion among
		newcomers. The <span class="monoText">*</span> symbol is used for both
		creating pointers
		<span class="underlineText">and</span> dereferencing.<label
			for="star"
			class="margin-toggle"
			><sup></sup
		></label>
		<input type="checkbox" id="star" class="margin-toggle sidenote-number" />
		<span class="marginnote"
			>&#8220;The first star points, the second retrieves.&#8221;</span
		>
		Thus, if we want to access the value stored in the address a pointer points
		to, we must use the dereference operator <span class="monoText">*</span>.
		Without using that operator, i.e., just writing
		<span class="monoText">p</span>, we are asking for the address the pointer
		points to. These are two very different things. One way to remember the two
		different uses of <span class="monoText">*</span> is to think of it as a
		star for navigating the wildnerness. The first time we use
		<span class="monoText">*</span>, we are marking a particular location. When
		when we use it again, we journey back to that location, wherein lies a
		value.
	</p>
	<ol class="ex grid" data-colcade="columns: .grid-col, items: .grid-item">
		<div class="grid-col grid-col--1"></div>
		<div class="grid-col grid-col--2"></div>
		<div class="grid-col grid-col--3"></div>
		<div class="grid-col grid-col--4"></div>

		<li class="grid-item">
			Consider the code below. What is the output of the last line?
			<pre class="language-pseudo"><code>
				int main() {
					int a;
					int *p;
					printf("%p\n", p);
					return 0;
				}
			</code></pre>
			<details class="answer">
				<summary>Solution</summary>
				<pre class="language-bash"><code>
					0x7ffee8e00138
				</code></pre>
				<p>
					This returns the address stored in <span class="monoText">p</span>.
					Note that because <span class="monoText">p</span> is uninitialized, it
					is called a <span class="term">wild pointer</span> &mdash; a pointer
					that points to an arbitrary (random) memory location.
				</p>
			</details>
		</li>
		<li class="grid-item">
			Consider the code below. What is the output of the last line?
			<pre class="language-pseudo"><code>
				int main() {
					int a;
					int *p;
					printf("%p\n", *p);
					return 0;
				}
			</code></pre>
			<details class="answer">
				<summary>Solution</summary>
				<pre class="language-bash"><code>
					exercises.c:6:17: warning: format specifies type 'void *' but the argument has type 'int' [-Wformat]
						printf("%p\n", *p);
										~~     ^~
										%d
				</code></pre>
				<p>
					This returns a warning. <span class="monoText">*p</span> is the
					<span class="italicsText">dereference operator</span>. It will return
					the value stored in the address in <span class="monoText">p</span>.
					The format specifier, however, <span class="monoText">%p</span>,
					pertains to those of type <span class="monoText">void *</span>.
				</p>
			</details>
		</li>
		<li class="grid-item">
			Consider the code below. What is the output of the last line?
			<pre class="language-pseudo"><code>
				int main() {
					int a;
					int *p;
					printf("%d\n", *p);
					return 0;
				}
			</code></pre>
			<details class="answer">
				<summary>Solution</summary>
				<pre class="language-bash"><code>
					0
				</code></pre>
				<p>
					This is <span class="term">undefined behavior</span>. It is not,
					however, necessarily always zero. When we dereference a wild pointer,
					we are essentially dereferencing random memory locations. Because of
					this fact, it is best practice to perform
					<span class="italicsText">inline initialization</span> when creating
					pointers. Instead of simply writing
					<span class="monoText">int *p</span>, we write
					<span class="monoText">int *p = NULL</span>.
				</p>
			</details>
		</li>
		<li class="grid-item">
			Consider the code below. What is the result of
			<span class="monoText">p = q</span>?
			<pre class="language-pseudo"><code>
				int main() {
					int i = 0;
					int j = 1;
					int *p = &amp;i;
					int *q = &amp;j;
					p = q;
					return 0;
				}
			</code></pre>
			<details class="answer">
				<summary>Solution</summary>
				<p>
					The line <span class="monoText">p = q</span> assigns to the pointer
					<span class="monoText">p</span> the address stored in
					<span class="monoText">q</span>. Thus,
					<span class="monoText">p</span> now stores the address
					<span class="monoText">&j</span>, as opposed to
					<span class="monoText">&i</span>. The result:
					<span class="monoText">p</span> and
					<span class="monoText">q</span> are now aliases for the address
					<span class="monoText">&j</span>. We can confirm this is the case with
					some print-statements:
				</p>
				<pre class="language-c"><code>
					#include &lt;stdio.h&gt;
					int main() {
						int i = 0;
						printf("i = 0;\n");
						printf("\t &i: %p\n", &i);
						int j = 1;
						printf("j = 1;\n");
						printf("\t &j: %p\n", &j);
						int *p = &amp;i;
						printf("*p = &amp;i;\n");
						printf("\t p: %p\n", p);
						int *q = &amp;j;
						printf("*q = &amp;j;\n");
						printf("\t q: %p\n", q);
						p = q;
						printf("p = q;\n");
						printf("\t p: %p\n", p);
						return 0;
					}
				</code></pre>
				<pre class="language-bash"><code>
					i = 0;
										&i: 0x7ffee7f6a118
					j = 1;
										&j: 0x7ffee7f6a114
					*p = &amp;i;
										p: 0x7ffee7f6a118
					*q = &amp;j;
										q: 0x7ffee7f6a114
					p = q;
										p: 0x7ffee7f6a114
				</code></pre>
			</details>
		</li>

		<li class="grid-item">
			Consider the code below. What is the result of
			<span class="monoText">p = q</span>?
			<pre class="language-pseudo"><code>
				int main() {
					int i = 0;
					int j = 1;
					int *p = &amp;i;
					int *q = &amp;j;
					p = q;
					return 0;
				}
			</code></pre>
			<details class="answer">
				<summary>Solution</summary>
				<p>
					We always evaluate the right-hand part of the expression first. Here,
					we dereference <span class="monoText">q</span>, so we get the value
					<span class="monoText">1</span>. Then, we dereference
					<span class="monoText">p</span> &mdash; accessing what's inside the
					address stored by <span class="monoText">p</span> &mdash; and we place
					inside it the value <span class="monoText">1</span>. Thus,
					<span class="monoText">i</span> is now
					<span class="monoText">1</span>.
				</p>
				<pre class="language-c"><code>
						#include &lt;stdio.h&gt;
						int main() {
							int i = 0;
							printf("i = 0;\n");
							printf("\t i: %d\n", i);
							int j = 1;
							printf("j = 1;\n");
							printf("\t j: %d\n", j);
							int *p = &amp;i;
							printf("*p = &amp;i;\n");
							printf("\t *p: %d\n", *p);
							int *q = &amp;j;
							printf("*q = &amp;j;\n");
							printf("\t *q: %d\n", *q);
							*p = *q;
							printf("*p = *q;\n");
							printf("\t *p: %d\n", *p);
							printf("\t i: %d\n", i);
							return 0;
						}
					</code></pre>
				<pre class="language-bash"><code>
						i = 0;
										i: 0
						j = 1;
										j: 1
						*p = &amp;i;
										*p: 0
						*q = &amp;j;
										*q: 1
						*p = *q;
										*p: 1
										i: 1
					</code></pre>
			</details>
		</li>

		<li class="grid-item">
			Consider the code below. What is the result of
			<span class="monoText">p = q</span>?
			<pre class="language-pseudo"><code>
				int main() {
					int i = 0;
					int j = 1;
					int *p = &amp;i;
					int *q = &amp;j;
					*p = q;
					return 0;
				}
			</code></pre>
			<details class="answer">
				<summary>Solution</summary>
				<pre class="language-bash"><code>
					exercises.c:16:5: warning: incompatible pointer to integer conversion assigning to 'int' from 'int *'; dereference with * [-Wint-conversion]
									*p = q;
										^ ~
											*
					1 warning generated.
				</code></pre>
				<p>
					Again, evaluate the right-hand part of the expression. Here, it's a
					lone <span class="monoText">q</span>, meaning we're going to get an
					address. Then, we dereference <span class="monoText">p</span> &mdash;
					accessing what's inside the address stored by
					<span class="monoText">p</span> &mdash; and we place inside it the
					address stored by <span class="monoText">q</span>. This will likely
					return a warning, given that addresses are fairly large numbers. The
					<span class="monoText">int</span> variable is likely not large enough
					to fit the address; if the compiler allows us to do this, it's like
					that parts of the data are lost, since the compiler can't fit
					everything into the allocated space.
				</p>
			</details>
		</li>

		<li class="grid-item">
			Consider the code below. What is the result of
			<span class="monoText">p = q</span>?
			<pre class="language-pseudo"><code>
				int main() {
					int i = 0;
					int j = 1;
					int *p = &amp;i;
					int *q = &amp;j;
					p = *q;
					return 0;
				}
			</code></pre>
			<details class="answer">
				<summary>Solution</summary>
				<pre class="language-bash"><code>
					exercises.c:8:4: warning: incompatible integer to pointer conversion assigning to 'int *' from 'int'; remove * [-Wint-conversion]
									p = *q;
										^ ~~
					1 warning generated.
				</code></pre>
				<p>
					Here, we are dereferencing <span class="monoText">q</span>. The value
					stored in the address pointed at by <span class="monoText">q</span> is
					then stored as the address stored by <span class="monoText">p</span>.
					This essentially means that the address stored by
					<span class="monoText">p</span> is the
					<span class="monoText">1</span>. This is not a valid address. This
					will not itself cause a crash. However, if we try to dereference
					<span class="monoText">p</span>, we will get a
					<span class="term">segmentation fault</span>.
				</p>
			</details>
		</li>
	</ol>

	<p>
		<span class="topic">Failing to Initialize.</span> Failing to initialize
		variables before using them is asking for trouble. For example, consider the
		output of the following code:
	</p>
	<pre class="language-c"><code>
		#include &lt;stdio.h&gt;
		int main() {
			int i;
			printf("i = %i\n", i);
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		i = 358010917
	</code></pre>
	<p>
		The value above is called a <span class="term">garbage value</span>. It's
		the value in the memory address at time of compilation, and it's pretty much
		random. This won't cause a crash, but it will lead to strange results.
	</p>
	<p>
		The same danger applies to uninitialized pointers, only worse. Uninitialized
		pointers effectively point to anywhere in memory, and that memory could be
		in use by another program. This will more than likely lead to segmentation
		fault, causing our program to crash.
	</p>
	<p>
		<span class="topic">The Null Pointer.</span> We can assign the value
		<span class="monoText">NULL</span> to a pointer. When we do so, we are
		essentially assigning the integer <span class="monoText">0</span> as the
		pointer's address, and <span class="monoText">0</span> is not a valid
		address. Attempting to dereference the null pointer will return a
		segmentation fault.
	</p>
	<p>
		This danger, however, is precisely what makes the null pointer so useful.
		Many data structures rely on the null pointer, particularly where we have to
		ensure the pointer we're working with is or is not the null pointer.
	</p>
	<pre class="language-c"><code>
		if (p == NULL) {
			// do something
		}
	</code></pre>
</section>

<section id="pointer_arguments">
	<h2>Pointer as Arguments to Functions</h2>
	<p>
		With pointers, we can write functions that modify their arguments. For
		example, suppose that instead of writing <span class="monoText">a++</span>,
		we want to write a separate function called
		<span class="monoText">increment()</span>:
	</p>

	<pre class="language-c"><code>
		#include &lt;stdio.h&gt;

		void increment(int a) {
			a = a + 1;
		}
		
		int main() {
			int a = 1;
			increment(a);
			printf("a = %d\n", a);
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		1
	</code></pre>
	<p>
		It does not work. In C, the default rule is
		<span class="term">pass-by-value</span>: When a datum is passed as an
		argument to a function, a <span class="underlineText">copy</span> of the
		datum is passed; <span class="underlineText">not</span> the original.
		Whether its simple or composite data, only a copy is passed. Once
		<span class="monoText">increment()</span> has finished executing all of the
		data passed into it is destroyed.
	</p>
	<p>
		What we instead want to do is pass the address of
		<span class="monoText">a</span> into the function
		<span class="monoText">increment()</span> as an argument. This is called
		<span class="term">pass-by-address</span>, or
		<span class="term">pass-by-reference</span>.
	</p>

	<pre class="language-c"><code>
		#include &lt;stdio.h&gt;

		void increment(int *a) {
			*a = *a + 1;
		}
		
		int main() {
			int a = 1;
			increment(&a);
			printf("a = %d\n", a);
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		2
	</code></pre>
	<p>
		Now it works. Notice the syntax. We wrote
		<span class="monoText">*a = *a + 1</span>.
	</p>

	<section id="variable_swap">
		<p>
			<span class="topic">Swapping with Pointers.</span> The previous example
			was a relatively simple demonstration. A clearer illustration of why
			pointers are so useful is to consider the idiom of swapping variables:
		</p>
		<pre class="language-c"><code>
			#include &lt;stdio.h&gt;

			int main() {
				int a = 0;
				int b = 1;
				int temp = a;
				a = b;
				b = temp;
				return 0;
			}
		</code></pre>
		<p>
			Given how useful the operation of swapping is, we want to write modularize
			this operation as a function. Doing so allows us to use it whenever and
			wherever we'd like. Unfortunately, a simple function will not work:
		</p>
		<pre class="language-c"><code>
			#include &lt;stdio.h&gt;

			void swap(int var1, int var2) {
				int temp = var1;
				var1 = var2;
				var2 = temp;
			}
			
			int main() {
				int a = 0;
				int b = 1;
				printf("a = %d\n", a);
				printf("b = %d\n", b);
				swap(a, b);
				printf("a = %d\n", a);
				printf("b = %d\n", b);
				return 0;
			}
		</code></pre>
		<pre class="language-bash"><code>
			a = 0
			b = 1
			a = 0
			b = 1
		</code></pre>
		<p>
			Again, because the default rule in C for functions is pass-by-value, the
			<span class="monoText">swap()</span> function has no idea what
			<span class="monoText">a</span> and <span class="monoText">b</span> are.
			It only has the values <span class="monoText">0</span> and
			<span class="monoText">1</span>. Accordingly, when
			<span class="monoText">swap()</span> executes, it only performs the
			swapping inside itself. Nothing actually happens inside
			<span class="monoText">main()</span>.
		</p>
		<p>
			The fix is to pass addresses as arguments, instead of the values inside
			those addresses. We call this <span class="term">pass-by-reference</span>:
		</p>
		<pre class="language-c"><code>
			#include &lt;stdio.h&gt;

			void swap(int *var1, int *var2) {
				// int *var1 = &a
				// int *var2 = &b

				int temp = *var1; // dereference *var1 (store the value 0)
				*var1 = *var2; // address in *var1 stores contents of address in *var2
				*var2 = temp; // address in *var2 stores temp
			}
			
			int main() {
				int a = 0;
				int b = 1;

				printf("a = %d\n", a);
				printf("b = %d\n", b);

				swap(&a, &b);

				printf("a = %d\n", a);
				printf("b = %d\n", b);

				return 0;
			}
		</code></pre>
		<pre class="language-bash"><code>
			a = 0
			b = 1
			a = 1
			b = 0
		</code></pre>
	</section>

	<section id="functions_multiple_returns">
		<p>
			<span class="topic">Multifunctions.</span> By default, functions in C can
			only output one value. More formally, functions in C are equivalent to
			<span class="italicsText">injective functions</span> &mdash; functions
			whose output matches exactly one input. With pointers, however, we can
			write <span class="term">multifunctions</span> &mdash; non-functional
			relations where several output values map to a single input. For example,
			let's say we want to write a function that returns both a minimum and a
			maximum given two numbers. They words &#8220;returns both&#8221; should
			alert us immediately that this is a big no no under the default rules of
			C. However, pointers provide the bypass:
		</p>
		<pre class="language-c"><code>
			#include &lt;stdio.h&gt;

			void setMinMax(int num1, int num2, int *pMax, int *pMin) {
				// int num1 = a;
				// int num2 = b;
				// int *pMax = &amp;min;
				// int *pMin = &amp;max;

				if (num1 > num2) {
					*pMin = num2;
					*pMax = num1;
				} else {
					*pMin = num1;
					*pMax = num2;
				}
			}
			
			int main() {
				int a = 149332;
				int b = 149328;
				int min, max;
				setMinMax(a, b, &min, &max);
				return 0;
			}
		</code></pre>
		<p>
			The example above is another demonstration of pass-by-reference. By
			passing by reference, we effectively modify the arguments passed into
			<span class="monoText">setMinMax</span>. And because we modify the
			arguments, changes are affected in <span class="monoText">main()</span>.
		</p>
	</section>

	<p>
		Pointers also allow us to return more than one thing from a function. For
		example, a function that returns both the minimum and the maximum.
		Furthermore, they allow us to pass arrays, strings, and entire data
		structures into functions. Finally, pointers allow us to allocate unknown
		memory at run time. This is a powerful ability, given that we don't always
		know the future, or potential, sizes of our program's inputs. Having this
		ability allows us to handle arbitrarily large sizes of data.
	</p>
</section>

<section id="pointer_arithmetic">
	<h2>Pointer Arithmetic</h2>
	<p>
		Because pointers store a memory address, and because memory addresses are
		just numbers, it follows that we can perform arithmetic with pointers. This
		is called <span class="term">pointer arithmetic</span>. For example, suppose
		a pointer <span class="monoText">p</span> of type
		<span class="monoText">int</span> stores the address
		<span class="monoText">1001</span>. What is the value of
		<span class="monoText">p++</span>? Well, let's try it:
	</p>
	<pre class="language-c"><code>
		#include &lt;stdio.h&gt;

		int main() {
			int i = 0;
			int *p = &amp;i;
			printf("p: %p\n", p);
			p++;
			printf("p: %p\n", p);
		}
	</code></pre>
	<pre class="language-bash"><code>
		p: 0x7ffeeb9e311c
		p: 0x7ffeeb9e3120
	</code></pre>
	<p>These are hexadecimal numbers. Let's print these as integers instead:</p>
	<pre class="language-c"><code>
		#include &lt;stdio.h&gt;

		int main() {
			int i = 0;
			int *p = &amp;i;
			printf("p: %lu\n", (unsigned long) p);
			p++;
			printf("p: %lu\n", (unsigned long) p);
		}
	</code></pre>
	<pre class="language-bash"><code>
		p: 140732660441372
		p: 140732660441376
	</code></pre>
	<p>
		Notice that the difference between these addresses is 4. This is because an
		<span class="monoText">int</span> is allocated 4 bytes of memory. Thus, when
		we increment the pointer <span class="monoText">p</span>, are asking for the
		next <span class="monoText">int</span> address. Essentially, 4 bytes more
		than the address in <span class="monoText">p</span>.
	</p>
	<p>
		Pointer arithmetic provides us greater control in navigating memory. This is
		a great deal of power, and we can run into trouble if we aren't careful. For
		example, the value at the address in <span class="monoText">p++</span> is
		garbage value:
	</p>
	<pre class="language-c"><code>
		#include &lt;stdio.h&gt;

		int main() {
			int i = 0;
			int *p = &amp;i;
			printf("p: %lu\n", (unsigned long) p);
			printf("*p = %d\n", *p);
			p++;
			printf("p: %lu\n", (unsigned long) p);
			printf("*(p++) = %d\n", *p);
		}
	</code></pre>
	<pre class="language-bash"><code>
		p: 140732773290268
		*p = 0
		p: 140732773290272
		*(p++) = -420097736
	</code></pre>
	<p>
		Look at how random the value of <span class="monoText">p++</span> is. If we
		used the value of the dereferenced <span class="monoText">p</span> later
		down our program, we'd be in for surprises.
	</p>
	<p>
		As an aside, notice that the memory addresses have changed. This evidences
		the fact that our program's data doesn't just stay in a single location
		forever. Because there are multiple processes running on our computer, the
		operating system will move data around in memory to accomodate for newer
		processes and changes.
	</p>
</section>

<section id="pointer_types">
	<h2>Pointer Types</h2>
	<p>
		Because C is a static- and explicitly-typed language, all pointers must have
		an explicit type on declaration. These types are denoted in the language
		with symbols like <span class="monoText">int*</span> or
		<span class="monoText">char*</span>. For example, if we have a pointer to an
		<span class="monoText">int</span> variable, the pointer's type is
		<span class="monoText">int*</span>. If we have a pointer to a
		<span class="monoText">char</span> variable, the pointer's type is
		<span class="monoText">char*</span>.
	</p>
	<p>
		More formally: Suppose ${p}$ is a pointer, ${t}$ is a type, and ${x}$ is a
		standard variable. When we write ${t \space {*p} = x;}$ we are stating that
		that value stored in ${x}$ is of type ${t.}$ More explicitly, we are stating
		to C: &#8220;Treat the value inside ${\texttt{\&}x}$ as a value of type
		${t.}$&#8221;
	</p>
	<p>
		Why can't we just use <span class="monoText">int</span>? Or some other
		numeric type? After all, aren't memory addresses just numbers? C requires
		strong types because the pointer isn't solely used for storing addresses.
		They also have the added feature of
		<span class="italicsText">dereferencing</span>. Not only can they store
		addresses, they can be used to access and modify the values inside the
		addresses they store. And because values can be of different types (and by
		implication of different sizes), pointers must have types. Otherwise, C
		would allow us to do things like assigning an
		<span class="monoText">int</span> value in a
		<span class="monoText">char</span> variable. The costs of allowing this
		(most significantly, data loss) significantly outweigh the convenience of
		not requiring explicit typing.
	</p>
</section>

<section id="pointers_to_pointers">
	<h2>Pointers to Pointers</h2>
	<p>
		Because pointers are variables, we can have pointers pointing to pointers.
		This ability essentially allows us to bypass the boundaries of
		<span class="italicsText">variable scope</span> by establishing bridges
		between memory locations. For example, suppose we wrote the following:
	</p>
	<pre class="language-c"><code>
		#include &lt;stdio.h&gt;

		int main() {
			int x = 5;
			int *p = &amp;x;
			return 0;
		}
	</code></pre>
	<p>
		As we know, the code above allocates 4 bytes for
		<span class="monoText">int x = 5</span>, and 8 bytes for
		<span class="monoText">int *p = &amp;x;</span>. Suppose the address of
		<span class="monoText">x</span> is <span class="monoText">125</span>. Then
		the value of <span class="monoText">p</span> is
		<span class="monoText">125</span>. Now suppose that the address of
		<span class="monoText">p</span> is <span class="monoText">432</span>. Can we
		have a pointer <span class="monoText">q</span> pointing to
		<span class="monoText">p</span>? Sure. But wait. What should type of
		<span class="monoText">q</span> be? Well, because
		<span class="monoText">p</span> points to an
		<span class="monoText">int</span>, it follows that
		<span class="monoText">p</span> is of type
		<span class="monoText">int*</span>. And because
		<span class="monoText">p</span> is of type
		<span class="monoText">int*</span>, it follows that
		<span class="monoText">q</span> must be of type
		<span class="monoText">int**</span>. Hence:
	</p>
	<pre class="language-c"><code>
		#include &lt;stdio.h&gt;

		int main() {
			int x = 5;
			int *p = &amp;x;
			int **q = &amp;p;
			return 0;
		}
	</code></pre>
	<p>
		Just to verify that we've done this correctly, let's see print some values:
	</p>
	<pre class="language-c"><code>
		#include &lt;stdio.h&gt;

		void print_bytes(void *ptr, int size) {
			unsigned char *p = ptr;
			int i;
			for (i=0; i&lt;size; i++) {
				printf("%02hhX ", p[i]);
			}
			printf("\n");
		}
		
		int main() {
			int x = 5;
			int *p = &amp;x;
			print_bytes(&p, sizeof(p));
			int **q = &amp;p;
			print_bytes(q, sizeof(q));
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		18 D1 AE E9 FE 7F 00 00 
		18 D1 AE E9 FE 7F 00 00 
	</code></pre>
	<p>
		Exact same addresses. We can then create another pointer,
		<span class="monoText">r</span>, that points to
		<span class="monoText">q</span>:
	</p>
	<pre class="language-c"><code>
		#include &lt;stdio.h&gt;

		int main() {
			int x = 5;
			int *p = &amp;x;
			int **q = &amp;p;
			int ***r = &amp;q;
			return 0;
		}
	</code></pre>
	<p>Verifying once more:</p>
	<pre class="language-c"><code>
		#include &lt;stdio.h&gt;

		void print_bytes(void *ptr, int size) {
			unsigned char *p = ptr;
			int i;
			for (i=0; i&lt;size; i++) {
				printf("%02hhX ", p[i]);
			}
			printf("\n");
		}
		
		int main() {
			int x = 5;
			int *p = &amp;x;
			print_bytes(&p, sizeof(p));
			int **q = &amp;p;
			print_bytes(q, sizeof(q));
			int ***r = &amp;q;
			print_bytes(r, sizeof(r));
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		18 61 D5 E7 FE 7F 00 00 
		18 61 D5 E7 FE 7F 00 00 
		10 61 D5 E7 FE 7F 00 00 
	</code></pre>
	<p>
		Notice that the address in <span class="monoText">r</span> looks different.
		It's off by 8 bytes. This is because <span class="monoText">r</span> doesn't
		point to <span class="monoText">p</span>; it points to
		<span class="monoText">q</span>. If we printed the address of
		<span class="monoText">q</span>, we would see that it is in fact the address
		in <span class="monoText">r</span>:
	</p>
	<pre class="language-c"><code>
		#include &lt;stdio.h&gt;

		void print_bytes(void *ptr, int size) {
			unsigned char *p = ptr;
			int i;
			for (i=0; i&lt;size; i++) {
				printf("%02hhX ", p[i]);
			}
			printf("\n");
		}
		
		int main() {
			int x = 5;
			int *p = &amp;x;
			print_bytes(&p, sizeof(p));
			int **q = &amp;p;
			print_bytes(q, sizeof(q));
			int ***r = &amp;q;
			print_bytes(&q, sizeof(&q));
			print_bytes(r, sizeof(r));
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		18 41 4E E9 FE 7F 00 00 
		18 41 4E E9 FE 7F 00 00 
		10 41 4E E9 FE 7F 00 00 
		10 41 4E E9 FE 7F 00 00
	</code></pre>
</section>

<section id="memory_allocation">
	<h2>Memory Allocation</h2>
	<p>
		In the examples above, we allocated memory strictly in the
		<span class="term">stack</span>. When we allocate memory in the stack, the
		memory is automatically cleaned when the function returns. In the preceding
		examples, the function was <span class="monoText">main()</span>. Once
		<span class="monoText">main()</span> returns &mdash; i.e., the line
		<span class="monoText">return 0</span> &mdash; all of the memory we asked to
		be allocated for our program is cleaned.
	</p>
	<figure class="math-display">
		<div>
			<pre class="language-pseudo"><code>
				the heap
				+------------------------------+
				|▧□▧▧□▧▧▧▧□□▧▧▧▧□□▧▧□▧▧▤▦▧▧□▧▧▩|
				|▧▧□▧▧□▧□▧▩▧▧□▧□▧▧▦▧▧□▧▧▧□▧▧▧□▧|
				|▧□▧▧□▧▧□▧□□▧▧▧▧□□▧▧□▧▧▤□▧▧□▧▧▩|
				|□▧▧□□▧□▧▧▩□▧▧▦▧▧□▧▧▤▧□▧□▧▧□□□▧|
				+------------------------------+

				the stack
				[□□□□□□□□] [□□□□□□□□] [□□□□□□□□]
				[□□□□□□□□] [□□□□□□□□] [□□□□□□□□]
				[□□□□□□□□] [□□□□□□□□] [□□□□□□□□]
				[□□□□□□□□] [□□□□□□□□] [□□□□□□□□]
			</code></pre>
		</div>
	</figure>
	<p>
		In some situations, however, we want more control over how to use memory. In
		C, we achieve greater control by using memory in the
		<span class="term">heap</span>. To use heap memory, we use the
		<span class="monoText">malloc(${s}$)</span> function, where ${s}$ is the
		<span class="italicsText">size</span> of memory we want.
	</p>
</section>

<section id="pointers_to_arrays">
	<h2>Pointers & Arrays</h2>
	<p>Examine the code below:</p>
	<pre class="language-c"><code>
		#include &lt;stdio.h&gt;

		int main() {
			int array[3];  
			return 0;
		}
	</code></pre>
	<p>
		This is an array declaration. In memory, this results in what roughly looks
		like the following:
	</p>
	<figure class="math-display">
		<div>
			<pre class="language-pseudo"><code>
				⋮
				113 [▨▨▨▨▨▨▨▨]
				112 [▨▨▨▨▨▨▨▨]
				================+  
				111 [□□□□□□□□]  |
				110 [□□□□□□□□]  |
				109 [□□□□□□□□]  |
				108 [□□□□□□□□]  |
				================|
				107 [□□□□□□□□]  |
				106 [□□□□□□□□]  |
				105 [□□□□□□□□]  | array
				104 [□□□□□□□□]  |
				================|
				103 [□□□□□□□□]  |
				102 [□□□□□□□□]  |
				101 [□□□□□□□□]  |
				100 [□□□□□□□□]  |
				================+
				099 [▨▨▨▨▨▨▨▨]
				098 [▨▨▨▨▨▨▨▨]
				⋮
			</code></pre>
		</div>
	</figure>
	<p>
		The diagram above illustrates the fact that when we declare an array in the
		manner we did above, we are allocating memory in the
		<span class="italicsText">stack</span> for future use. Observe further that
		each of the allocated blocks consists of 4 bytes. Thus, with an array of
		size 3, we consume 12 bytes of memory. Once we initialize the array:
	</p>
	<pre class="language-c"><code>
		#include &lt;stdio.h&gt;

		int main() {
			int array[3] = {13924, 39287, 998768};  
			return 0;
		}
	</code></pre>
	<p>the memory appears as such:</p>
	<figure class="math-display">
		<div>
			<pre class="language-pseudo"><code>
				⋮
				113 [▨▨▨▨▨▨▨▨]
				112 [▨▨▨▨▨▨▨▨]
				==============
				111 [<span class="blueText">01110000</span>]
				110 [<span class="blueText">00111101</span>]
				109 [<span class="blueText">00001111</span>]
				108 [<span class="blueText">00000000</span>] <span class="redText">array[2] = 998768</span>
				==============
				107 [<span class="blueText">01110111</span>]
				106 [<span class="blueText">10011001</span>]
				105 [<span class="blueText">00000000</span>]
				104 [<span class="blueText">00000000</span>] <span class="redText">array[1] = 39287</span>
				==============
				103 [<span class="blueText">01100100</span>]
				102 [<span class="blueText">00110110</span>]
				101 [<span class="blueText">00000000</span>]
				100 [<span class="blueText">00000000</span>] <span class="redText">array[0] = 13924</span>
				==============
				099 [▨▨▨▨▨▨▨▨]
				098 [▨▨▨▨▨▨▨▨]
				⋮
			</code></pre>
		</div>
	</figure>
	<p>
		Once the array is initialized, the bits composing each element of the array
		fill these allocated blocks. This evidences a critical fact about arrays:
		Arrays provide a way for us to initialize multiple variables at once, where
		the values bound to each variable are stored sequentially in memory. Given
		this fact, it follows that we can have pointers to arrays:
	</p>

	<pre class="language-c"><code>
		#include &lt;stdio.h&gt;

		int main() {
			int array[3] = {13924, 39287, 998768};  
			int *p = array;
			return 0;
		}
	</code></pre>
	<p>In memory:</p>
	<pre class="language-pseudo"><code style="font-size: 0.53rem;">
		⋮
		<span class="redText">100</span> [<span class="blueText">00000000</span>]|104 [<span class="blueText">00000000</span>]|108 [<span class="blueText">00000000</span>]|116 [<span class="greenText">00000000</span>] 119 [<span class="greenText">00000000</span>]|
		101 [<span class="blueText">00000000</span>]|105 [<span class="blueText">00000000</span>]|109 [<span class="blueText">00001111</span>]|117 [<span class="greenText">00000000</span>] 120 [<span class="greenText">00000000</span>]|
		102 [<span class="blueText">00110110</span>]|106 [<span class="blueText">10011001</span>]|110 [<span class="blueText">00111101</span>]|118 [<span class="greenText">00000000</span>] 121 [<span class="greenText">00000000</span>]|
		103 [<span class="blueText">01100100</span>]|107 [<span class="blueText">01110111</span>]|111 [<span class="blueText">01110000</span>]|119 [<span class="greenText">00000000</span>] 122 [<span class="greenText">01100100</span>]|
		 a[0] = 13924   a[1] = 39287  a[2] = 998768            <span class="redText">p = 100</span>
	</code></pre>
	<p>
		Notice the syntax <span class="monoText">int *p = array</span>. This is
		equivalent to <span class="monoText">int *p = array[0]</span>. Thus, when we
		assign a variable storing an array to a pointer ${p,}$ we are assigning the
		memory address of the <span class="underlineText">first</span> element of
		the array to the pointer. Examining the different values:
	</p>
	<pre class="language-c"><code>
		#include &lt;stdio.h&gt;

		void print_bytes(void *ptr, int size) {
			unsigned char *p = ptr;
			int i;
			for (i=0; i&lt;size; i++) {
				if ((i % 4) == 0) {
					printf(" | ");
				}
				printf("%02hhX ", p[i]);
			}
			printf(" |\n");
		}
		
		int main() {
			int array[3] = {13924, 39287, 998768};
			int *p = array;

			// the address in p
			printf("%p\n", p);

			// the address of array using square brackets
			printf("%p\n", &array[0]);

			// print 'array': the address of the first element
			printf("%p\n", array);

			// dereference 'array': the value at the address of array
			printf("%d\n", *array); 

			// index 0: the value of the first element
			printf("%d\n", array[0]); 

			// dereference p: the value at the address of array
			printf("%d\n", *p);
			
			// the memory addresses occupied by the first element
			print_bytes(&array[0], sizeof(array[0])); 

			// all the memory addresses occupied by array
			print_bytes(array, sizeof(array)); 
		}
	</code></pre>
	<pre class="language-bash"><code>
		0x7ffee41441bc
		0x7ffee41441bc
		0x7ffee41441bc
		13924
		13924
		13924
		 | 64 36 00 00  |
		 | 64 36 00 00  | 77 99 00 00  | 70 3D 0F 00  |
	</code></pre>
	<p>
		Notice the various syntax. The variable <span class="monoText">array</span>,
		on its own, will return the address of the array's first element. This is
		called the array's <span class="term">base address</span>. If we want to
		access that element, we write <span class="monoText">*array</span>. If we
		wanted to access the second element, we write
		<span class="monoText">*(array + 1)</span>. And the second,
		<span class="monoText">*(array + 2),</span> the third
		<span class="monoText">*(array + 3)</span>, and so on. This is a big
		insight:
	</p>
	<figure class="math-display">
		<div class="rule">
			<p>
				<span class="topic">Observation.</span>
				Given an array ${A}$ and ${n \in \Z,}$ the following syntactical forms
				are equivalent:
			</p>
			<figure class="math-display">
				<div>
					<p><span class="monoText">&${A}$[${i}$] ${\equiv}$ &${A}$</span></p>
					<p><span class="monoText">${A}$[${i}$] ${\equiv}$ *${A}$</span></p>
					<p>
						<span class="monoText"
							>&${A}$[${i}$ + ${n}$] ${\equiv}$ &(${A}$ + ${n}$)</span
						>
					</p>
					<p>
						<span class="monoText"
							>${A}$[${i}$ + ${n}$] ${\equiv}$ *(${A}$ + ${n}$)</span
						>
					</p>
				</div>
			</figure>
		</div>
	</figure>
	<p>
		Note that while the arithmetic operators work on array identifiers, we
		cannot use the unary operators like <span class="monoText">++</span>,
		<span class="monoText">--</span>, etc. These will return a compiler error.
	</p>

	<section id="arrays_as_function_arguments">
		<p><span class="topic">Arrays as Function Arguments.</span></p>
	</section>
</section>
{% endblock %}
