{% extends '../layout.html' %} {% load static %} {% block description %}
<meta name="description" content="Notes on Rust" />
{% endblock %} {% block title %}
<title>Intro to Rust</title>
{% endblock %} {% block content %}
<h1>Introduction to Rust</h1>
<section id="intro">
	<p>
		<span class="drop">I</span>n this essay, we explore the Rust programming
		language. While most of the materials in this volume will use the C
		language, we will also use Rust to explore more high level concepts. We can
		think of Rust as the modern approach to low-level programming. We have
		low-level constructs like pointers, as well as high-level constructs like
		pattern matching. In a sense, where the C programmer is an Olympic gymnast,
		her Rust counterpart is a Cirque du Soleil performer with protective gear.
	</p>
	<p>
		Because Rust provides many protections for low-level programming &mdash;
		without taking away too much control on our part &mdash; we can focus more
		on concepts rather than implementation details. For example, automatic
		freeing of heap-allocated memory. Moreover, Rust's type system is partly
		inspired by the Hindley-Milner type system, similar to the type systems
		behind ML and OCaml. For example, Rust provides generics. And while they are
		not as expressive as Haskell (e.g., there is no higher-kinded polymorphism),
		they allow us to concisely write constructs like generalized functions with
		pointer parameters. All that said, let's proceed.
	</p>
</section>

<section id="first_program">
	<h2>First Program</h2>
	<p>As always, here is our first Rust program:</p>
	<pre class="language-rust"><code>
		// This is a comment.
		fn main() {
			println!("Hello world!");
		}
	</code></pre>
	<pre class="language-bash"><code>
		$ rustc hello.rs
		$ ./hello
		Hello world!
	</code></pre>
	<p>
		No surprises here, but there's wealth of useful information. First, Rust
		source code files use the extension
		<var><mark>.rs</mark></var
		>. To compile a <var>.rs</var> file, we run
		<var><mark>rustc</mark></var> with the file name passed. Then, to execute
		the resulting binary, we simply run <var>./hello</var>. This is no different
		from C and C++.
	</p>
	<p>
		Inside the source code file, we see the keyword
		<var><mark>fn</mark></var
		>. This indicates a function. Specifically, a function called
		<var><mark>main()</mark></var
		>. Similar to C and C++, the <var>main()</var> function will contain our
		driver code.
	</p>
</section>

<section id="variables">
	<h2>Variables</h2>
	<p>Let's rewrite our previous program as follows:</p>
	<pre class="language-rust"><code>
		fn main() {
			let message = "Hello world!";
			println!("{}", message);
		}
	</code></pre>
	<pre class="language-bash"><code>
		$ rustc hellor.s
		$ ./hello
		Hello world!
	</code></pre>
	<p>
		Notice that the keyword <var><mark>let</mark></var
		>. This is how we declare variables in Rust. Moreover, observe the use of
		<var>"{}"</var> inside the <var>println!()</var> call. This is similar to
		how <var>printf()</var> calls are made in C.
	</p>

	<section id="mutability">
		<h3>Mut Variables</h3>
		<p>
			In Rust, variables are, by default, <i>immutable</i>. Consider the
			following:
		</p>
		<pre class="language-rust"><code>
			fn main() {
				let message = "Hello world!";
				println!("{}", message);
				message = "Bye world!";
				println!("{}", message);
			}
		</code></pre>
		<pre class="language-bash"><code>
			error[E0384]: cannot assign twice to immutable variable `message`
			--> main.rs:4:2
				|
			2 |     let message = "Hello world!";
				|         -------
				|         |
				|         first assignment to `message`
				|         help: consider making this binding mutable: `mut message`
			3 |     println!("{}", message);
			4 |     message = "Bye world!";
				|     ^^^^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable

			error: aborting due to previous error

			For more information about this error, try `rustc --explain E0384`.
		</code></pre>
		<p>
			We're getting the compiler warning because we're attempting to mutate the
			value bound to the variable <var>message</var>, when in fact, we cannot.
			To actually change <var>message</var>, we must use the keyword
			<var>mut</var>:
		</p>
		<pre class="language-rust"><code>
			fn main() {
				let mut message = "Hello world!";
				println!("{}", message);
				message = "Bye world!";
				println!("{}", message);
			}
		</code></pre>
		<pre class="language-bash"><code>
			Hello world!
			Bye world!
		</code></pre>
	</section>
</section>

<section id="cargo">
	<h2>Cargo</h2>
	<p>
		Cargo is the Rust package manager, similar to how JavaScript has NPM. To
		determine if Cargo is installed, we run the command:
	</p>
	<pre class="language-bash"><code>
		cargo --version
	</code></pre>
	<p>
		If a version identifier is returned, then Cargo is installed. With Cargo
		installed, we can create a new Cargo package for our project by writing the
		following:
	</p>
	<pre class="language-bash"><code>
		cargo init
	</code></pre>
	<p>
		Running the command above, we should see a new file called
		<var><mark>Cargo.toml</mark></var
		>. The extension <var>.toml</var> is just a file format for configuration
		files.<sup></sup> If we look inside <var>toml</var> file, we see:
	</p>
	<div class="note">
		<p>
			<var>.toml</var> is short for
			<q>Tom's Obvious, Minimal Language,</q> after its creator, Tom
			Preston-Werner, the founder and former CEO of GitHub.
		</p>
	</div>
	<pre class="language-bash"><code>
		[package]
		name = "lab"
		version = "0.1.0"
		edition = "2021"

		# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

		[dependencies]

		[[bin]]
		name = "lab"
		path = "main.rs"
	</code></pre>
	<p>
		The file is straightforward. We the package's name is called
		<var>lab</var> (the name of the folder <var>cargo init</var> was run in), a
		version number, and an edition year. We also see a header for
		<var>dependencies</var>, and another header for binaries.
	</p>
	<p>
		Once we have a Cargo package, we no longer need to run files manually (i.e.,
		running
		<var>rustc main.rs</var> then running <var>./main</var>). Instead, all we
		have to do is execute:
	</p>
	<pre class="language-bash"><code>
		$ cargo run
				Compiling lab v0.1.0 (/Users/ketiboldiais/My Drive/prj/rust/snake)
				Finished dev [unoptimized + debuginfo] target(s) in 4.17s
				Running `target/debug/lab`
		Hello world!
		Bye world!
	</code></pre>
	<p>
		In Rust, the individual packages comprising the Cargo package are called
		<b>crates</b>. Rust maintains a large registry of crates made by Rustaceans
		on <a href="https://crates.io/" target="_blank">crates.io</a>.
	</p>
</section>

<section id="functions">
	<h2>Functions</h2>
	<p>Here's a simple function in Rust:</p>
	<pre class="language-rust"><code>
		fn main() {
			let message = "Hello world!";
			greet_user(message);
		}
		
		fn greet_user(text: &str) {
			println!("{}", text);
		}
	</code></pre>
	<pre class="language-bash"><code>
		Hello world!
	</code></pre>
	<p>
		This is similar to writing functions in C and C++, with a few key
		differences. First, we can define the function anywhere. In this case, we've
		defined it after
		<var>main()</var>. We could have also defined it before <var>main()</var>.
		Second, notice the syntax:
	</p>
	<ul class="syntax">
		<li>fn ${n}$(${p}$: ${t}$) { ${body}$ };</li>
	</ul>
	<p>
		Above, ${n}$ is the function's name. Note that in Rust, the convention is to
		use pothole casing (separating multiple words with underscores). Next, the
		variable ${p}$ is a function parameter. That parameter is followed by a
		colon, then the parameter's type. We'll discuss types later. Finally, the
		function's ${body}$ is enclosed in curly braces.
	</p>
	<p>
		The syntax above is how we write functions with no returns. For functions
		with returns, we use the following syntax:
	</p>
	<ul class="syntax">
		<li>fn ${n}$(${p}$: ${t}$) -> ${r_t}$ { ${body}$ };</li>
	</ul>
	<p>
		The only difference here is the use of <var>-> ${r_t}$</var>, where ${r_t}$
		is the return type. For example, the <var>square()</var> function below
		squares its argument:
	</p>
	<pre class="language-rust"><code>
		fn main() {
			let x = 2;
			let y = square(x);
			println!("{}", y);
		}

		fn square(num: i32) -> i32 {
			let b = num * num;
			return b;
		}
	</code></pre>
	<pre class="language-bash"><code>
		4
	</code></pre>
	<p>
		A more common way to write the <var>square()</var> function is to omit the
		<var>return</var> keyword:
	</p>
	<pre class="language-rust"><code>
		fn square(num: i32) -> i32 {
			let b = num * num;
			b
		}
	</code></pre>
	<p>
		Importantly, if this approach is taken, we must also omit the semicolon.
		Otherwise, Rust will not interpret it as an implicit return. That said, the
		Rust programmer is more likely to just write:
	</p>
	<pre class="language-rust"><code>
		fn square(num: i32) -> i32 {
			num * num
		}
	</code></pre>
</section>

<section id="primitive_types">
	<h2>Primitive Types</h2>
	<p>
		Rust has several primitive types. The <b>primitives</b> are divided into two
		categories: <b>scalar types</b> and <b>compound types</b>.
	</p>

	<section id="signed_int">
		<h3>Signed Integers</h3>
		<p>
			Most languages have something along the lines of a generic
			<var>int</var> type. Not Rust &mdash; we're specific about memory. In this
			case, there are five <i>signed integer types</i> to choose from:
			<var>i8</var>, <var>i16</var>, <var>i32</var>, <var>i64</var>,
			<var>i128</var>, and <var>isize</var>:
		</p>
		<figure>
			<table class="api">
				<thead>
					<th>Type</th>
					<th>Description</th>
					<th>Remark</th>
				</thead>
				<tbody>
					<tr>
						<td>
							<var><mark>i8</mark></var>
						</td>
						<td>8-bit integer type</td>
						<td>Minimum value of ${-128,}$ maximum value of ${127.}$</td>
					</tr>
					<tr>
						<td>
							<var><mark>i16</mark></var>
						</td>
						<td>16-bit integer type</td>
						<td>Minimum value of ${-32~768,}$ maximum value of ${32~767.}$</td>
					</tr>
					<tr>
						<td>
							<var><mark>i32</mark></var>
						</td>
						<td>32-bit integer type</td>
						<td>
							Minimum value of ${-2~147~483~648,}$ maximum value of
							${2~147~483~647.}$
						</td>
					</tr>
					<tr>
						<td>
							<var><mark>i64</mark></var>
						</td>
						<td>64-bit integer type</td>
						<td>
							Minimum value of ${-9~223~372~036~854~775~808,}$ maximum value of
							${9~223~372~036~854~775~807.}$
						</td>
					</tr>
					<tr>
						<td>
							<var><mark>i128</mark></var>
						</td>
						<td>128-bit integer type</td>
						<td>
							Minimum value of
							${-170~141~183~460~469~231~731~687~303~715~884~105~728,}$ maximum
							value of ${170~141~183~460~469~231~731~687~303~715~884~105~727.}$
						</td>
					</tr>
				</tbody>
			</table>
		</figure>
		<p>
			The table above isn't all that surprising. The ranges are computed with
			the equation ${[-(2^{n-1}), 2^{n-1}-1].}$ If we're working with algorithms
			requiring the use of a type's minimum or maximum value, we can do so with
			the functions
			<var><mark>min_value()</mark></var> and <var><mark>max_value()</mark></var
			>. For example, <var>i8::max_value()</var> returns <var>127</var>.
		</p>
		<pre class="language-rust"><code>
			let n = 5; // defaults to i32
			let m: i32 = 15; 
		</code></pre>
	</section>

	<section id="unsigned_int">
		<h3>Unsigned Integers</h3>
		<p>
			Alongside the signed integers, we have the
			<b>unsigned integer types</b>. Because unsigned integers are just integers
			with the sign bit free to use, the ranges are determined as ${[0,
			2^{n}-1].}$
		</p>
		<figure>
			<table class="api">
				<thead>
					<th>Type</th>
					<th>Description</th>
					<th>Remark</th>
				</thead>
				<tbody>
					<tr>
						<td>
							<var><mark>u8</mark></var>
						</td>
						<td>8-bit unsigned integer</td>
						<td>Minimum value of ${0,}$ maximum value of ${255.}$</td>
					</tr>
					<tr>
						<td>
							<var><mark>u16</mark></var>
						</td>
						<td>16-bit unsigned integer</td>
						<td>Minimum value of ${0,}$ maximum value of ${65~535.}$</td>
					</tr>
					<tr>
						<td>
							<var><mark>u32</mark></var>
						</td>
						<td>32-bit unsigned integer</td>
						<td>Minimum value of ${0,}$ maximum value of ${4~294~967~295.}$</td>
					</tr>
					<tr>
						<td>
							<var><mark>u64</mark></var>
						</td>
						<td>64-bit unsigned integer</td>
						<td>
							Minimum value of ${0,}$ maximum value of
							${18~446~744~073~709~551~615.}$
						</td>
					</tr>
					<tr>
						<td>
							<var><mark>u128</mark></var>
						</td>
						<td>128-bit unsigned integer</td>
						<td>
							Minimum value of ${0,}$ maximum value of
							${340~282~366~920~938~463~463~374~607~431~768~211~455.}$
						</td>
					</tr>
				</tbody>
			</table>
		</figure>
		<p>
			A common question asked by newcomers: Which integer type should we use?
			The truth is, there's no single right answer. It depends on what we're
			trying to do. This presents an opportunity for planning our work. What
			integer values might we expect? How important is memory? If this kind of
			planning can't be done, defaulting to
			<var>i32</var>, as Rust does automatically, or, if we know we're only
			working with positive values, <var>u32</var>. Either or, always keep the
			minimum and maximum values for the types when making a selection.
		</p>
		<pre class="language-rust"><code>
			let a = 100       // defaults to i32
			let b: u32 = 100  // explicit u32
		</code></pre>
	</section>

	<section id="isize_usize">
		<h3>isize & usize</h3>
		<p>
			The datatypes
			<var><mark>isize</mark></var> and <var><mark>usize</mark></var> are used
			for pointers. These are integer types, but they're more specifically
			<b>pointer size types</b>. Actual bit sizes depends on the compiler's
			targeted computer architecture. For example, if we're compiling for a
			32-bit platform, <var>isize</var> is the same as <var>i32</var>. For a
			64-bit platform, it's the same as <var>i64</var>. And for a 128-bit
			platform, it's the same as <var>i128</var>.
		</p>
		<p>
			The same idea extends to <var>usize</var>. The difference between
			<var>usize</var> and <var>isize</var>: <var>isize</var> can be negative,
			while <var>usize</var> is always zero or positive. Negative pointer size
			values (represented with <var>isize</var>) are useful for operations like
			offsets to addresses, positions, indices, or lengths. In comparison,
			because <var>usize</var> cannot be negative, it is generally used for
			memory addresses, positions, indices, lengths, or sizes.
		</p>
	</section>

	<section id="number_formats">
		<p>
			<span class="topic">Number Formats.</span> There are a number of ways to
			format numbers in Rust. Consider this code's output:
		</p>
		<pre class="language-rust"><code>
			fn main() {
				let separated_num = 2_124_393;
				let hex_num = 0xfa;
				let bin_num = 0b0010_1011;
				let byte_num = b'E';
				
				println!("{}", separated_num);
				println!("{}", hex_num);
				println!("{}", bin_num);
				println!("{}", byte_num);
			}
		</code></pre>
		<pre class="language-bash"><code>
			2124393
			250
			43
			69
		</code></pre>
		<p>
			With the first number, <var>2_124_393</var>, the underscore merely acts as
			a separator. Using underscores as separators traces its roots all the way
			back to Ada in 1979, and is present in Perl, C#, D, Haskell, Java, Kotlin,
			OCaml, Perl, Python, PHP, Ruby, Go, Rust, Julia, and Swift. Those coming
			from C++ can think of the underscore as akin to apostrophes
			(<var>2'124'393</var>).<sup></sup>
		</p>
		<div class="note">
			<p>
				Languages like Fortran are the true winners in this game; white spaces
				are entirely ignored in all contexts, so we can write things like
				<var>2 124 393</var>.
			</p>
		</div>
		<p>
			Next, the value <var>0xfa</var> is a hexadecimal number. To denote
			hexadecimals, we prepend to each number the symbol
			<var><mark>0x</mark></var
			>. The same goes for binary numbers &mdash; prepend a
			<var><mark>0b</mark></var
			>. Notice that with binary numbers, we can use underscores to as
			separators. Following some conventions in computer science academia, we
			separate every four binary digits.
		</p>
		<p>
			Last but not least, we can denote byte numbers by prepending a
			<var><mark>b</mark></var
			>, followed by an ASCII character in single quotes. Because a byte number
			consists of eight bits, byte numbers allow us to represent the numbers
			${0}$ to ${256}$ with ASCII characters (a base-256 number system).
		</p>
	</section>

	<section id="floats">
		<h3>Floating Point Types</h3>
		<p>
			Rust has two floating point types,
			<var><mark>f32</mark></var> and <var><mark>f64</mark></var
			>. Following the pattern we've seen, <var>f32</var> corresponds to 32-bit
			floating point numbers, and <var>f64</var> corresponds to 64-bit floating
			point numbers (similar to a <var>double</var> in other languages).
		</p>
		<p>
			Unlike the integer types, we generally do not want to use
			<var>f32</var>, unless we're doing very low-level optimization or
			targetting architectures that do not support 64-bit floats. Following this
			convention, Rust defaults to <var>f64</var> if a type is not explicitly
			stated.
		</p>
		<pre class="language-rust"><code>
			let x = 3.14;       // default to f64
			let y: f64 = 2.17;  // explicitly stated
		</code></pre>
	</section>

	<section id="bool">
		<h3>Booleans</h3>
		<p>
			Boolean values in Rust are represented with the type
			<var><mark>bool</mark></var
			>:
		</p>
		<pre class="language-rust"><code>
			let p = true;
			let q: bool = false;
		</code></pre>
		<p>
			If we're coming from a language like C or C++, one habit we'll need to
			break away from is using <var>1</var> or <var>0</var> for Booleans. Rust
			is strict about what it considers a Boolean type &mdash; it's either
			<var><mark>true</mark></var> or <var><mark>false</mark></var
			>. It's not <var>1</var>, <var>0</var>, <var>TRUE</var>, <var>FALSE</var>,
			<var>True</var>, or <var>False</var>.
		</p>
	</section>

	<section id="char">
		<h3>Characters</h3>
		<p>
			Single characters in Rust are represented by the
			<var><mark>char</mark></var> datatype. As a modern language, Rust uses a
			single Unicode scalar value to represent characters. Following other
			languages like Java and C, Rust differentiates <var>char</var> values from
			strings with single quotes:
		</p>
		<pre class="language-rust"><code>
			let n = 'n';
			let allClear: char = 'ðŸ˜Ž';
		</code></pre>
	</section>
</section>

<section id="tuples">
	<h2>Tuples</h2>
	<p>
		The previous types we saw are called <b>scalar types</b>. Like many other
		languages, half of the primitives in Rust are scalars, while the other half
		consists of <b>compound types</b>. There are two primitive compound types in
		Rust: <b>tuples</b> and <b>arrays</b>. We consider the tuple first.
	</p>
	<p>
		The tuple data type, denoted with the keyword
		<var><mark>tup</mark></var
		>, is a general way of grouping various instances of a particular type into
		a single collection. Tuples are defined by the following properties:
	</p>
	<ol>
		<li>
			Tuples are of fixed size. Once declared, they cannot grow or shrink.
		</li>
		<li>
			Tuples are initialized by writing a comma-separated list of values within
			parentheses.
		</li>
		<li>Each element in the tuple can be of any type.</li>
		<li>
			Each position in the tuple has a type and an index, starting at zero.
		</li>
	</ol>
	<p>For example, here is a tuple:</p>
	<pre class="language-rust"><code>
		let tup = (100, 5.2, 'a');
	</code></pre>
	<p>
		The tuple above consists of an <var>i32</var>, a <var>f64</var>, and a
		<var>char</var>. We can also explicitly state the types:
	</p>
	<pre class="language-rust"><code>
		let tup: (i32, f64, char) = (100, 5.2, 'a');
	</code></pre>
	<p>
		Because tuples have indices, we can access each element by index. This is
		done with the syntax, <var><mark>${t}$.${i}$</mark></var
		>, where ${t}$ is the tuple's name and ${i}$ is a valid index:
	</p>
	<pre class="language-rust"><code>
		fn main() {
			let tup = (100, 5.2, 'a');
			
			println!("{}", tup.0);
			println!("{}", tup.1);
			println!("{}", tup.2);
		}
	</code></pre>
	<pre class="language-bash"><code>
		100
		5.2
		a
	</code></pre>
	<p>
		Alternatively, we can give each of the tuple's elements an identifier, or
		name, through <b>destructuring</b>:
	</p>
	<pre class="language-rust"><code>
		fn main() {
			let tup = (100, 5.2, 'a');
			let (x, y, z) = tup;
		
			println!("{}", x);
			println!("{}", y);
			println!("{}", z);
		}
	</code></pre>
	<pre class="language-bash"><code>
		100
		5.2
		a
	</code></pre>
	<p>
		In the example above, we <i>destructure</i> the tuple <var>tup</var> into
		three separate variables: <var>x</var> is bound to <var>100</var>,
		<var>y</var> is bound to <var>5.2</var>, and <var>z</var> is bound to
		<var>'a'</var>. This is an example of <b>pattern-matching</b>, and is found
		in many functional languages like ML and Haskell.
	</p>
	<p>
		Those coming from a functional programming background like ML will find that
		Rust also has the <b>unit type</b>, with the single value
		<var><mark>()</mark></var
		>, called the <b>unit value</b>. Expressions in Rust implicitly return the
		unit value if no value is returned.
	</p>
</section>

<section id="array">
	<h2>Arrays</h2>
	<p>
		The other primitive compound type is the <b>array</b>. Like the tuple, the
		array provides a means of grouping different values into a single
		collection. However, unlike the tuple, each value in the array must be of
		the same type. Alongside this property, there are a few others:
	</p>
	<ol>
		<li>Arrays are of fixed length. They cannot grow or shrink.</li>
		<li>
			Arrays are initialized by writing a comma-separated list of values within
			parentheses.
		</li>
		<li>Each element in the array must be of the same type.</li>
		<li>Each position in the array has an index, starting at zero.</li>
	</ol>
	<p>Illustrating, here is an array in Rust:</p>
	<pre class="language-rust"><code>
		let arr = [1,2,3,4,5];
	</code></pre>
	<p>We can als explicitly provide a type annotation:</p>
	<pre class="language-rust"><code>
		let arr: [i32; 5] = [1,2,3,4,5];
	</code></pre>
	<p>
		The type annotation tells us that the array <var>arr</var> has the type
		<var>[i32; 5]</var>, meaning &mdash; an array (denoted by the square
		brackets), with five elements (denoted by the <var>5</var>), each element of
		type <var>i32</var> (denoted by the <var>i32</var>).
	</p>
	<p>
		Some algorithms require initializing an array where each element in the
		array is set to <var>0</var>. For example, an array of size ten, each
		element zero, can be written concisely in Rust as follows:
	</p>
	<pre class="language-rust"><code>
		let arr = [0; 10];
	</code></pre>
	<p>The initialization above expands to:</p>
	<pre class="language-rust"><code>
		let arr = [0,0,0,0,0,0,0,0,0,0];
	</code></pre>
	<p>
		To access each element in the array <var>arr</var>, we use square bracket
		syntax, much like other languages:
	</p>
	<pre class="language-rust"><code>
		fn main() {
			let arr = [1,2,3,4,5];
		
			println!("{}", arr[0]);
			println!("{}", arr[1]);
			println!("{}", arr[2]);
			println!("{}", arr[3]);
			println!("{}", arr[4]);
		}
	</code></pre>
	<pre class="language-bash"><code>
		1
		2
		3
		4
		5
	</code></pre>
	<p>
		<span class="topic">Invalid Indices.</span> What happens when we enter an
		invalid index? Well, let's try it:
	</p>
	<pre class="language-rust"><code>
		fn main() {
			let arr = [1,2,3];
		
			println!("{}", arr[0]);
			println!("{}", arr[1]);
			println!("{}", arr[2]);
			println!("{}", arr[3]);
		}
	</code></pre>
	<pre class="language-bash"><code>
		error: this operation will panic at runtime
		--> main.rs:7:17
			|
		7 |     println!("{}", arr[3]);
			|                    ^^^^^^ index out of bounds: the length is 3 but the index is 3
			|
			= note: `#[deny(unconditional_panic)]` on by default
	</code></pre>
	<p>
		Above, we got a <b>out-of-bounds error</b>. This is a compiler error. If the
		array was initialized through user input at runtime, we would get a
		<i>runtime error</i>. Unlike other languages, however, Rust goes the extra
		step not to execute any further lines the moment it encounters a runtime
		error. This is one of the hallmarks of Rust's memory safety principles. Many
		other languages like C and C++ do not provide this kind of check at runtime.
	</p>
</section>

<section id="control_flow">
	<h2>Control Flow</h2>
	<p>
		A language's <b>control flow constructs</b> are the constructs that allow
		the programmer to run specified code if a particular condition is true. In
		Rust, we can achieve control flow through two means:
		<b>Conditional control</b>, and <b>iterative control</b>. Conditional
		control is done through <i>if-expressions</i>, <i>else-if-expressions</i>,
		<i>else-expressions</i>, and <i>loops</i>. Let's consider conditional
		control first.
	</p>

	<section id="conditional_control">
		<h3>Conditional Control</h3>
		<p>
			The <b>if-expression</b> executes a block of code if its condition is met.
			Usually, an if-expression is followed by an <b>else-expression</b>. If the
			if-expression's condition is not met, we proceed to the else-expression's
			block. The else-expression, however, is entirely optional. If an
			if-expression's condition is false, the if-expression's block of code
			&mdash; the <b>if-block</b> &mdash; is skipped entirely. For example:
		</p>
		<pre class="language-rust"><code>
			fn main() {
				let n = 2;
				if n % 2 == 0 {
					println!("Even!");
				} else {
					println!("Odd!");
				}
			}
		</code></pre>
		<pre class="language-bash"><code>
			Even!
		</code></pre>
		<p>
			Notice the lack of parentheses. In Rust, we can simply write the
			if-condition after the keyword <var>if</var>. Further, notice the
			indentation for the control structure. Rust follows the <b>1TBS</b> (<q
				>One True Brace Style</q
			>) convention, a variant of the K&R brace style in C. Separately, we used
			the <var>==</var> operator to check for equality. Rust provides the
			standard relational operators we're familiar with:
		</p>
		<pre class="language-rust"><code>
			n > 20     // n is greater than 20
			n < 20     // n is less than 20
			n >= 20    // n is greater than or equal to 20
			n >= 20    // n is less than or equal to 20
			n == 20    // n is equal to 20
			n != 20    // n is not equal to 20
		</code></pre>
		<p>
			Unsurprisingly, the conditions for Boolean expressions must be expressions
			that evaluate to type <var>bool</var>. Otherwise, we get a
			<b>mismatched type error</b>. Unlike languages like Ruby and JavaScript
			(which have <i>truthy</i> and <i>falsey</i> values), Rust does not
			implicitly cast non-Boolean types to Booleans.
		</p>
		<p>
			If our program branches into more than two paths, we can specify when a
			particular path is taken with an
			<b>else-if-expression</b>:
		</p>
		<pre class="language-bash"><code>
			fn main() {
				let n = 30;
				if n % 5 == 0 {
					println!("Divisible by 5.");
				} else if n < 100 {
					println!("Less than 100.");
				} else {
					println!("It's an integer.");
				}
			}
		</code></pre>
		<pre class="language-bash"><code>
			Divisible by 5
		</code></pre>
		<p>
			Notice that because the first condition is met, we see the corresponding
			output. The second condition is also true, but we don't execute that
			condition. Why? Because the if-expression's condition is true. Like most
			other programming languages, once Rust encounters a Boolean expression
			that evaluates to true in a conditional control block, it executes that
			line and continues, paying no heed to the remaining conditions.
		</p>
		<p>
			If we want to also evaluate the second condition, we can use the logical
			AND operator &mdash; <var><mark>&&</mark></var
			>:
		</p>
		<pre class="language-rust"><code>
			fn main() {
				let n = 30;
				if (n % 5 == 0) && (n < 100) {
					println!("Divisible by 5 and less than 100.");
				} else if n % 5 == 0 {
					println!("Divisible by 5.");
				} else {
					println!("It's an integer.");
				}
			}
		</code></pre>
		<pre class="language-bash"><code>
			Divisible by 5 and less than 100.
		</code></pre>
		<p>Rust has the usual logical operators found in other languages:</p>
		<pre class="language-rust"><code>
			x && y    // true iff both x and y are true; otherwise false
			x || y    // false iff both x and y are false; otherwise true
			!x        // if x is true, returns false; if x is false, returns true
		</code></pre>
	</section>

	<section id="iterative_control">
		<h3>Iterative Control</h3>
		<p>
			Iterative control is what allows us to execute blocks of code repeatedly.
			Rust has three forms of loops: an
			<b>infinite loop</b> (using the keyword <var><mark>loop</mark></var
			>), a <b>for-loop</b> (using the keyword <var><mark>for</mark></var
			>) and a <b>while-loop</b> (using the keyword <var><mark>while</mark></var
			>). Let's consider each loop.
		</p>
		<p>The infinite loop takes the following form:</p>
		<pre class="language-rust"><code>
			fn main() {
				loop {
					println!("Infinite loop!");
				}
			}
		</code></pre>
		<p>
			Running the code above, we see <var>Infinite loop!</var> print over and
			over again, stopping only if we enter an interrupt (on most computers,
			typing ctrl-c). Alternatively, we can exit the loop by using the
			<var><mark>break</mark></var> keyword.
		</p>
		<pre class="language-rust"><code>
			fn main() {
				let mut countdown = 5;
				println!("Countdown started.");
				loop {
					println!("{}", countdown);
					countdown -= 1;
					if countdown == 0 {
						break;
					}
				}
				println!("Countdown ended.");
			}
		</code></pre>
		<pre class="language-bash"><code>
			Countdown started.
			5
			4
			3
			2
			1
			Countdown ended.
		</code></pre>
	</section>
	<p>
		An interesting aspect of Rust we might not have seen with other languages is
		that loops can be given identifiers. For example, suppose we have an
		infinite loop inside an infinite loop, and we want to break out of outer
		loop if a condition in the inner loop is met. We can do so with the
		following:
	</p>
	<pre class="language-rust"><code>
		fn main() {
			let mut i = 5;
			let mut j = 5;
			'outer_loop: loop {
				println!("Inside outer loop, i = {}", i);
				println!("Entering inner loop with j = {}", j);
				i -= 1;
				loop {
					j -= 1;
					if j == 0 {
						println!("Final break out of inner loop, j == 0.");
						break 'outer_loop;
					}
					else if j % 2 == 0 {
						println!("Breaking out of inner loop, j % 2 == 0, j = {}", j);
						break;
					}
					else {
						println!("Inside inner loop, j = {}", j);
					}
				}
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		Inside outer loop, i = 5
		Entering inner loop with j = 5
		Breaking out of inner loop, j % 2 == 0, j = 4
		Inside outer loop, i = 4
		Entering inner loop with j = 4
		Inside inner loop, j = 3
		Breaking out of inner loop, j % 2 == 0, j = 2
		Inside outer loop, i = 3
		Entering inner loop with j = 2
		Inside inner loop, j = 1
		Final break out of inner loop, j == 0.
	</code></pre>
	<p>
		Notice how the condition <var>j == 0</var> results in breaking
		<var>'outer_loop</var>, the outer loop's identifier. The
		<var>loop</var> construct is really just syntactic sugar for a
		<i>while-true</i> loop. Although most introductory computer science courses
		heavily emphasize checking ourselves before considering the infinite loop,
		Rust provides syntactic sugar for it, encouraging us to learn to be
		comfortable with such loops. For example, suppose we want some procedure to
		continue executing, so long as the result of another procedure is true:
	</p>
	<pre class="language-rust"><code>
		fn main() {
			let mut i = 10; 
			let mut n = 0;
			let m = loop {
				i -= 1;
				if i % 3 == 0 {
					n += 1;
				}
				if i == 0 {
					break n;
				}
			};
			println!("m = {}", m);
		}
	</code></pre>
	<pre class="language-bash"><code>
		m = 4
	</code></pre>
	<p>
		In the code above, we have two mutating variables, <var>i</var> and
		<var>n</var>. Then, we have non-mutating variable, <var>m</var>, which
		stores the result of evaluating its loop expression. That loop expression
		performs the following: At each iteration, decrement <var>i</var>. Then test
		if <var>i</var> is divisible by ${3.}$ If it is, then increment
		<var>n</var>. Once we've decremented <var>i</var> to <var>0</var>, we break
		at the current value of <var>n</var>. That value is then bound to
		<var>m</var>. Executing this procedure tells us that there are four positive
		integers less than ${10}$ that are divisible by ${3}$ &mdash; ${3,}$ ${6,}$
		and ${9.}$
	</p>

	<section id="while_loop">
		<h3>While-loop</h3>
		<p>
			Although the infinite loop can be a clever way of iterating, it's often
			much easier to just use a while-loop. The same procedure we saw earlier
			can be written more concisely as:
		</p>
		<pre class="language-rust"><code>
			fn main() {
				let mut i = 10; 
				let mut m = 0;
				while i != 0 {
					if i % 3 == 0 {
						m += 1;
					}
					i -= 1;
				}
				println!("m = {}", m);
			}
		</code></pre>
		<pre class="language-bash"><code>
			m = 3
		</code></pre>
	</section>

	<section id="for_loop">
		<h3>For-loop</h3>
		<p>
			Like other languages, we can also iterate with a for-loop. This is done
			with the <var><mark>for</mark></var> keyword:
		</p>
		<pre class="language-rust"><code>
			fn main() {
				let arr = [1,2,3,4,5];
				for element in arr {
					println!("element: {}", element);
				}
			}
		</code></pre>
		<pre class="language-bash"><code>
			element: 1
			element: 2
			element: 3
			element: 4
			element: 5
		</code></pre>
		<p>
			Notice that the for-loop in rust doesn't require us to use the length
			syntax in languages like Java and C,
			<q><var>for (int i = 0</var> &hellip;</q> We don't have to worry about
			things like length and going out of bounds in an array &mdash; Rust takes
			care of that.
		</p>
		<p>
			But what if we want to only iterate a specified number of times? For that
			we use the <var><mark>Range</mark></var> function provided by the standard
			library. Calling this function can be done implicitly, by simply including
			two dots between the range:
		</p>
		<pre class="language-rust"><code>
			fn main() {
				let arr = [1,2,3,4,5];

				for i in 0..3 {
					println!("element at index {}: {}", i, arr[i]);
				}

				println!("\n"); // just to break the blocks

				for i in 1..4 {
					println!("element at index {}: {}", i, arr[i]);
				}
			}
		</code></pre>
		<pre class="language-bash"><code>
			element at index 0: 1
			element at index 1: 2
			element at index 2: 3


			element at index 1: 2
			element at index 2: 3
			element at index 3: 4
		</code></pre>
		<p>
			Note that when we write <var>i..n</var>, this specifies the range ${[i,
			n).}$ I.e., the range is from ${i}$ through ${n - 1.}$
		</p>
	</section>
</section>

<section id="ownership">
	<h2>Ownership</h2>
	<p>
		By far, the most unique aspect of Rust that separates it from other
		languages is its concept of <b>ownership</b>.
	</p>
</section>

{% endblock %}
