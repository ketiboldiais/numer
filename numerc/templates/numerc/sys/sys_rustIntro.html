{% extends '../layout.html' %} {% load static %} {% block description %}
<meta name="description" content="Notes on Rust" />
{% endblock %} {% block title %}
<title>Intro to Rust</title>
{% endblock %} {% block content %}
<h1>Introduction to Rust</h1>
<section id="intro">
	<p>
		<span class="drop">I</span>n this essay, we explore the Rust
		programming language. While most of the materials in this volume will
		use the C language, we will also use Rust to explore more high level
		concepts. We can think of Rust as the modern approach to low-level
		programming. We have low-level constructs like pointers, as well as
		high-level constructs like pattern matching. In a sense, where the C
		programmer is an Olympic gymnast, her Rust counterpart is a Cirque du
		Soleil performer with protective gear.
	</p>
	<p>
		Because Rust provides many protections for low-level programming
		&mdash; without taking away too much control on our part &mdash; we can
		focus more on concepts rather than implementation details. For example,
		automatic freeing of heap-allocated memory. Moreover, Rust's type
		system is partly inspired by the Hindley-Milner type system, similar to
		the type systems behind ML and OCaml. For example, Rust provides
		generics. And while they are not as expressive as Haskell (e.g., there
		is no higher-kinded polymorphism), they allow us to concisely write
		constructs like generalized functions with pointer parameters. All that
		said, let's proceed.
	</p>
</section>

<section id="first_program">
	<h2>First Program</h2>
	<p>As always, here is our first Rust program:</p>
	<pre class="language-rust"><code>
		// This is a comment.
		fn main() {
			println!("Hello world!");
		}
	</code></pre>
	<pre class="language-bash"><code>
		$ rustc hello.rs
		$ ./hello
		Hello world!
	</code></pre>
	<p>
		No surprises here, but there's wealth of useful information. First,
		Rust source code files use the extension
		<var><mark>.rs</mark></var
		>. To compile a <var>.rs</var> file, we run
		<var><mark>rustc</mark></var> with the file name passed. Then, to
		execute the resulting binary, we simply run <var>./hello</var>. This is
		no different from C and C++.
	</p>
	<p>
		Inside the source code file, we see the keyword
		<var><mark>fn</mark></var
		>. This indicates a function. Specifically, a function called
		<var><mark>main()</mark></var
		>. Similar to C and C++, the <var>main()</var> function will contain
		our driver code.
	</p>
</section>

<section id="variables">
	<h2>Variables</h2>
	<p>Let's rewrite our previous program as follows:</p>
	<pre class="language-rust"><code>
		fn main() {
			let message = "Hello world!";
			println!("{}", message);
		}
	</code></pre>
	<pre class="language-bash"><code>
		$ rustc hellor.s
		$ ./hello
		Hello world!
	</code></pre>
	<p>
		Notice that the keyword <var><mark>let</mark></var
		>. This is how we declare variables in Rust. Moreover, observe the use
		of <var>"{}"</var> inside the <var>println!()</var> call. This is
		similar to how <var>printf()</var> calls are made in C.
	</p>

	<section id="mutability">
		<h3>Mut Variables</h3>
		<p>
			In Rust, variables are, by default, <i>immutable</i>. Consider the
			following:
		</p>
		<pre class="language-rust"><code>
			fn main() {
				let message = "Hello world!";
				println!("{}", message);
				message = "Bye world!";
				println!("{}", message);
			}
		</code></pre>
		<pre class="language-bash"><code>
			error[E0384]: cannot assign twice to immutable variable `message`
			--> main.rs:4:2
				|
			2 |     let message = "Hello world!";
				|         -------
				|         |
				|         first assignment to `message`
				|         help: consider making this binding mutable: `mut message`
			3 |     println!("{}", message);
			4 |     message = "Bye world!";
				|     ^^^^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable

			error: aborting due to previous error

			For more information about this error, try `rustc --explain E0384`.
		</code></pre>
		<p>
			We're getting the compiler warning because we're attempting to mutate
			the value bound to the variable <var>message</var>, when in fact, we
			cannot. To actually change <var>message</var>, we must use the
			keyword <var>mut</var>:
		</p>
		<pre class="language-rust"><code>
			fn main() {
				let mut message = "Hello world!";
				println!("{}", message);
				message = "Bye world!";
				println!("{}", message);
			}
		</code></pre>
		<pre class="language-bash"><code>
			Hello world!
			Bye world!
		</code></pre>
	</section>
</section>

<section id="cargo">
	<h2>Cargo</h2>
	<p>
		Cargo is the Rust package manager, similar to how JavaScript has NPM.
		To determine if Cargo is installed, we run the command:
	</p>
	<pre class="language-bash"><code>
		cargo --version
	</code></pre>
	<p>
		If a version identifier is returned, then Cargo is installed. With
		Cargo installed, we can create a new Cargo package for our project by
		writing the following:
	</p>
	<pre class="language-bash"><code>
		cargo init
	</code></pre>
	<p>
		Running the command above, we should see a new file called
		<var><mark>Cargo.toml</mark></var
		>. The extension <var>.toml</var> is just a file format for
		configuration files.<sup></sup> If we look inside <var>toml</var> file,
		we see:
	</p>
	<div class="note">
		<p>
			<var>.toml</var> is short for
			<q>Tom's Obvious, Minimal Language,</q> after its creator, Tom
			Preston-Werner, the founder and former CEO of GitHub.
		</p>
	</div>
	<pre class="language-bash"><code>
		[package]
		name = "lab"
		version = "0.1.0"
		edition = "2021"

		# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

		[dependencies]

		[[bin]]
		name = "lab"
		path = "main.rs"
	</code></pre>
	<p>
		The file is straightforward. We the package's name is called
		<var>lab</var> (the name of the folder <var>cargo init</var> was run
		in), a version number, and an edition year. We also see a header for
		<var>dependencies</var>, and another header for binaries.
	</p>
	<p>
		Once we have a Cargo package, we no longer need to run files manually
		(i.e., running
		<var>rustc main.rs</var> then running <var>./main</var>). Instead, all
		we have to do is execute:
	</p>
	<pre class="language-bash"><code>
		$ cargo run
				Compiling lab v0.1.0 (/Users/ketiboldiais/My Drive/prj/rust/snake)
				Finished dev [unoptimized + debuginfo] target(s) in 4.17s
				Running `target/debug/lab`
		Hello world!
		Bye world!
	</code></pre>
	<p>
		In Rust, the individual packages comprising the Cargo package are
		called
		<b>crates</b>. Rust maintains a large registry of crates made by
		Rustaceans on
		<a href="https://crates.io/" target="_blank">crates.io</a>.
	</p>
</section>

<section id="functions">
	<h2>Functions</h2>
	<p>Here's a simple function in Rust:</p>
	<pre class="language-rust"><code>
		fn main() {
			let message = "Hello world!";
			greet_user(message);
		}
		
		fn greet_user(text: &str) {
			println!("{}", text);
		}
	</code></pre>
	<pre class="language-bash"><code>
		Hello world!
	</code></pre>
	<p>
		This is similar to writing functions in C and C++, with a few key
		differences. First, we can define the function anywhere. In this case,
		we've defined it after
		<var>main()</var>. We could have also defined it before
		<var>main()</var>. Second, notice the syntax:
	</p>
	<ul class="syntax">
		<li>fn ${n}$(${p}$: ${t}$) { ${body}$ };</li>
	</ul>
	<p>
		Above, ${n}$ is the function's name. Note that in Rust, the convention
		is to use pothole casing (separating multiple words with underscores).
		Next, the variable ${p}$ is a function parameter. That parameter is
		followed by a colon, then the parameter's type. We'll discuss types
		later. Finally, the function's ${body}$ is enclosed in curly braces.
	</p>
	<p>
		The syntax above is how we write functions with no returns. For
		functions with returns, we use the following syntax:
	</p>
	<ul class="syntax">
		<li>fn ${n}$(${p}$: ${t}$) -> ${r_t}$ { ${body}$ };</li>
	</ul>
	<p>
		The only difference here is the use of <var>-> ${r_t}$</var>, where
		${r_t}$ is the return type. For example, the
		<var>square()</var> function below squares its argument:
	</p>
	<pre class="language-rust"><code>
		fn main() {
			let x = 2;
			let y = square(x);
			println!("{}", y);
		}

		fn square(num: i32) -> i32 {
			let b = num * num;
			return b;
		}
	</code></pre>
	<pre class="language-bash"><code>
		4
	</code></pre>
	<p>
		A more common way to write the <var>square()</var> function is to omit
		the <var>return</var> keyword:
	</p>
	<pre class="language-rust"><code>
		fn square(num: i32) -> i32 {
			let b = num * num;
			b
		}
	</code></pre>
	<p>
		Importantly, if this approach is taken, we must also omit the
		semicolon. Otherwise, Rust will not interpret it as an implicit return.
		That said, the Rust programmer is more likely to just write:
	</p>
	<pre class="language-rust"><code>
		fn square(num: i32) -> i32 {
			num * num
		}
	</code></pre>
</section>

<section id="primitive_types">
	<h2>Primitive Types</h2>
	<p>
		Rust has several primitive types. The <b>primitives</b> are divided
		into two categories: <b>scalar types</b> and <b>compound types</b>.
	</p>

	<section id="signed_int">
		<h3>Signed Integers</h3>
		<p>
			Most languages have something along the lines of a generic
			<var>int</var> type. Not Rust &mdash; we're specific about memory. In
			this case, there are five <i>signed integer types</i> to choose from:
			<var>i8</var>, <var>i16</var>, <var>i32</var>, <var>i64</var>,
			<var>i128</var>, and <var>isize</var>:
		</p>
		<figure>
			<table>
				<thead>
					<th>Type</th>
					<th>Description</th>
					<th>Remark</th>
				</thead>
				<tbody>
					<tr>
						<td>
							<var><mark>i8</mark></var>
						</td>
						<td>8-bit integer type</td>
						<td>Minimum value of ${-128,}$ maximum value of ${127.}$</td>
					</tr>
					<tr>
						<td>
							<var><mark>i16</mark></var>
						</td>
						<td>16-bit integer type</td>
						<td>
							Minimum value of ${-32~768,}$ maximum value of ${32~767.}$
						</td>
					</tr>
					<tr>
						<td>
							<var><mark>i32</mark></var>
						</td>
						<td>32-bit integer type</td>
						<td>
							Minimum value of ${-2~147~483~648,}$ maximum value of
							${2~147~483~647.}$
						</td>
					</tr>
					<tr>
						<td>
							<var><mark>i64</mark></var>
						</td>
						<td>64-bit integer type</td>
						<td>
							Minimum value of ${-9~223~372~036~854~775~808,}$ maximum
							value of ${9~223~372~036~854~775~807.}$
						</td>
					</tr>
					<tr>
						<td>
							<var><mark>i128</mark></var>
						</td>
						<td>128-bit integer type</td>
						<td>
							Minimum value of
							${-170~141~183~460~469~231~731~687~303~715~884~105~728,}$
							maximum value of
							${170~141~183~460~469~231~731~687~303~715~884~105~727.}$
						</td>
					</tr>
				</tbody>
			</table>
		</figure>
		<p>
			The table above isn't all that surprising. The ranges are computed
			with the equation ${[-(2^{n-1}), 2^{n-1}-1].}$ If we're working with
			algorithms requiring the use of a type's minimum or maximum value, we
			can do so with the functions
			<var><mark>min_value()</mark></var> and
			<var><mark>max_value()</mark></var
			>. For example, <var>i8::max_value()</var> returns <var>127</var>.
		</p>
		<pre class="language-rust"><code>
			let n = 5; // defaults to i32
			let m: i32 = 15; 
		</code></pre>
	</section>

	<section id="unsigned_int">
		<h3>Unsigned Integers</h3>
		<p>
			Alongside the signed integers, we have the
			<b>unsigned integer types</b>. Because unsigned integers are just
			integers with the sign bit free to use, the ranges are determined as
			${[0, 2^{n}-1].}$
		</p>
		<figure>
			<table>
				<thead>
					<th>Type</th>
					<th>Description</th>
					<th>Remark</th>
				</thead>
				<tbody>
					<tr>
						<td>
							<var><mark>u8</mark></var>
						</td>
						<td>8-bit unsigned integer</td>
						<td>Minimum value of ${0,}$ maximum value of ${255.}$</td>
					</tr>
					<tr>
						<td>
							<var><mark>u16</mark></var>
						</td>
						<td>16-bit unsigned integer</td>
						<td>Minimum value of ${0,}$ maximum value of ${65~535.}$</td>
					</tr>
					<tr>
						<td>
							<var><mark>u32</mark></var>
						</td>
						<td>32-bit unsigned integer</td>
						<td>
							Minimum value of ${0,}$ maximum value of ${4~294~967~295.}$
						</td>
					</tr>
					<tr>
						<td>
							<var><mark>u64</mark></var>
						</td>
						<td>64-bit unsigned integer</td>
						<td>
							Minimum value of ${0,}$ maximum value of
							${18~446~744~073~709~551~615.}$
						</td>
					</tr>
					<tr>
						<td>
							<var><mark>u128</mark></var>
						</td>
						<td>128-bit unsigned integer</td>
						<td>
							Minimum value of ${0,}$ maximum value of
							${340~282~366~920~938~463~463~374~607~431~768~211~455.}$
						</td>
					</tr>
				</tbody>
			</table>
		</figure>
		<p>
			A common question asked by newcomers: Which integer type should we
			use? The truth is, there's no single right answer. It depends on what
			we're trying to do. This presents an opportunity for planning our
			work. What integer values might we expect? How important is memory?
			If this kind of planning can't be done, defaulting to
			<var>i32</var>, as Rust does automatically, or, if we know we're only
			working with positive values, <var>u32</var>. Either or, always keep
			the minimum and maximum values for the types when making a selection.
		</p>
		<pre class="language-rust"><code>
			let a = 100       // defaults to i32
			let b: u32 = 100  // explicit u32
		</code></pre>
	</section>

	<section id="isize_usize">
		<h3>isize & usize</h3>
		<p>
			The datatypes
			<var><mark>isize</mark></var> and <var><mark>usize</mark></var> are
			used for pointers. These are integer types, but they're more
			specifically <b>pointer size types</b>. Actual bit sizes depends on
			the compiler's targeted computer architecture. For example, if we're
			compiling for a 32-bit platform, <var>isize</var> is the same as
			<var>i32</var>. For a 64-bit platform, it's the same as
			<var>i64</var>. And for a 128-bit platform, it's the same as
			<var>i128</var>.
		</p>
		<p>
			The same idea extends to <var>usize</var>. The difference between
			<var>usize</var> and <var>isize</var>: <var>isize</var> can be
			negative, while <var>usize</var> is always zero or positive. Negative
			pointer size values (represented with <var>isize</var>) are useful
			for operations like offsets to addresses, positions, indices, or
			lengths. In comparison, because <var>usize</var> cannot be negative,
			it is generally used for memory addresses, positions, indices,
			lengths, or sizes.
		</p>
	</section>

	<section id="number_formats">
		<p>
			<span class="topic">Number Formats.</span> There are a number of ways
			to format numbers in Rust. Consider this code's output:
		</p>
		<pre class="language-rust"><code>
			fn main() {
				let separated_num = 2_124_393;
				let hex_num = 0xfa;
				let bin_num = 0b0010_1011;
				let byte_num = b'E';
				
				println!("{}", separated_num);
				println!("{}", hex_num);
				println!("{}", bin_num);
				println!("{}", byte_num);
			}
		</code></pre>
		<pre class="language-bash"><code>
			2124393
			250
			43
			69
		</code></pre>
		<p>
			With the first number, <var>2_124_393</var>, the underscore merely
			acts as a separator. Using underscores as separators traces its roots
			all the way back to Ada in 1979, and is present in Perl, C#, D,
			Haskell, Java, Kotlin, OCaml, Perl, Python, PHP, Ruby, Go, Rust,
			Julia, and Swift. Those coming from C++ can think of the underscore
			as akin to apostrophes (<var>2'124'393</var>).<sup></sup>
		</p>
		<div class="note">
			<p>
				Languages like Fortran are the true winners in this game; white
				spaces are entirely ignored in all contexts, so we can write things
				like
				<var>2 124 393</var>.
			</p>
		</div>
		<p>
			Next, the value <var>0xfa</var> is a hexadecimal number. To denote
			hexadecimals, we prepend to each number the symbol
			<var><mark>0x</mark></var
			>. The same goes for binary numbers &mdash; prepend a
			<var><mark>0b</mark></var
			>. Notice that with binary numbers, we can use underscores to as
			separators. Following some conventions in computer science academia,
			we separate every four binary digits.
		</p>
		<p>
			Last but not least, we can denote byte numbers by prepending a
			<var><mark>b</mark></var
			>, followed by an ASCII character in single quotes. Because a byte
			number consists of eight bits, byte numbers allow us to represent the
			numbers ${0}$ to ${256}$ with ASCII characters (a base-256 number
			system).
		</p>
	</section>

	<section id="floats">
		<h3>Floating Point Types</h3>
		<p>
			Rust has two floating point types,
			<var><mark>f32</mark></var> and <var><mark>f64</mark></var
			>. Following the pattern we've seen, <var>f32</var> corresponds to
			32-bit floating point numbers, and <var>f64</var> corresponds to
			64-bit floating point numbers (similar to a <var>double</var> in
			other languages).
		</p>
		<p>
			Unlike the integer types, we generally do not want to use
			<var>f32</var>, unless we're doing very low-level optimization or
			targetting architectures that do not support 64-bit floats. Following
			this convention, Rust defaults to <var>f64</var> if a type is not
			explicitly stated.
		</p>
		<pre class="language-rust"><code>
			let x = 3.14;       // default to f64
			let y: f64 = 2.17;  // explicitly stated
		</code></pre>
	</section>

	<section id="bool">
		<h3>Booleans</h3>
		<p>
			Boolean values in Rust are represented with the type
			<var><mark>bool</mark></var
			>:
		</p>
		<pre class="language-rust"><code>
			let p = true;
			let q: bool = false;
		</code></pre>
		<p>
			If we're coming from a language like C or C++, one habit we'll need
			to break away from is using <var>1</var> or <var>0</var> for
			Booleans. Rust is strict about what it considers a Boolean type
			&mdash; it's either <var><mark>true</mark></var> or
			<var><mark>false</mark></var
			>. It's not <var>1</var>, <var>0</var>, <var>TRUE</var>,
			<var>FALSE</var>, <var>True</var>, or <var>False</var>.
		</p>
	</section>

	<section id="char">
		<h3>Characters</h3>
		<p>
			Single characters in Rust are represented by the
			<var><mark>char</mark></var> datatype. As a modern language, Rust
			uses a single Unicode scalar value to represent characters. Following
			other languages like Java and C, Rust differentiates
			<var>char</var> values from strings with single quotes:
		</p>
		<pre class="language-rust"><code>
			let n = 'n';
			let allClear: char = 'ðŸ˜Ž';
		</code></pre>
	</section>
</section>

<section id="tuples">
	<h2>Tuples</h2>
	<p>
		The previous types we saw are called <b>scalar types</b>. Like many
		other languages, half of the primitives in Rust are scalars, while the
		other half consists of <b>compound types</b>. There are two primitive
		compound types in Rust: <b>tuples</b> and <b>arrays</b>. We consider
		the tuple first.
	</p>
	<p>
		The tuple data type, denoted with the keyword
		<var><mark>tup</mark></var
		>, is a general way of grouping various instances of a particular type
		into a single collection. Tuples are defined by the following
		properties:
	</p>
	<ol>
		<li>
			Tuples are of fixed size. Once declared, they cannot grow or shrink.
		</li>
		<li>
			Tuples are initialized by writing a comma-separated list of values
			within parentheses.
		</li>
		<li>Each element in the tuple can be of any type.</li>
		<li>
			Each position in the tuple has a type and an index, starting at zero.
		</li>
	</ol>
	<p>For example, here is a tuple:</p>
	<pre class="language-rust"><code>
		let tup = (100, 5.2, 'a');
	</code></pre>
	<p>
		The tuple above consists of an <var>i32</var>, a <var>f64</var>, and a
		<var>char</var>. We can also explicitly state the types:
	</p>
	<pre class="language-rust"><code>
		let tup: (i32, f64, char) = (100, 5.2, 'a');
	</code></pre>
	<p>
		Because tuples have indices, we can access each element by index. This
		is done with the syntax, <var><mark>${t}$.${i}$</mark></var
		>, where ${t}$ is the tuple's name and ${i}$ is a valid index:
	</p>
	<pre class="language-rust"><code>
		fn main() {
			let tup = (100, 5.2, 'a');
			
			println!("{}", tup.0);
			println!("{}", tup.1);
			println!("{}", tup.2);
		}
	</code></pre>
	<pre class="language-bash"><code>
		100
		5.2
		a
	</code></pre>
	<p>
		Alternatively, we can give each of the tuple's elements an identifier,
		or name, through <b>destructuring</b>:
	</p>
	<pre class="language-rust"><code>
		fn main() {
			let tup = (100, 5.2, 'a');
			let (x, y, z) = tup;
		
			println!("{}", x);
			println!("{}", y);
			println!("{}", z);
		}
	</code></pre>
	<pre class="language-bash"><code>
		100
		5.2
		a
	</code></pre>
	<p>
		In the example above, we <i>destructure</i> the tuple
		<var>tup</var> into three separate variables: <var>x</var> is bound to
		<var>100</var>, <var>y</var> is bound to <var>5.2</var>, and
		<var>z</var> is bound to <var>'a'</var>. This is an example of
		<b>pattern-matching</b>, and is found in many functional languages like
		ML and Haskell.
	</p>
	<p>
		Those coming from a functional programming background like ML will find
		that Rust also has the <b>unit type</b>, with the single value
		<var><mark>()</mark></var
		>, called the <b>unit value</b>. Expressions in Rust implicitly return
		the unit value if no value is returned.
	</p>
</section>

<section id="array">
	<h2>Arrays</h2>
	<p>
		The other primitive compound type is the <b>array</b>. Like the tuple,
		the array provides a means of grouping different values into a single
		collection. However, unlike the tuple, each value in the array must be
		of the same type. Alongside this property, there are a few others:
	</p>
	<ol>
		<li>Arrays are of fixed length. They cannot grow or shrink.</li>
		<li>
			Arrays are initialized by writing a comma-separated list of values
			within parentheses.
		</li>
		<li>Each element in the array must be of the same type.</li>
		<li>Each position in the array has an index, starting at zero.</li>
	</ol>
	<p>Illustrating, here is an array in Rust:</p>
	<pre class="language-rust"><code>
		let arr = [1,2,3,4,5];
	</code></pre>
	<p>We can als explicitly provide a type annotation:</p>
	<pre class="language-rust"><code>
		let arr: [i32; 5] = [1,2,3,4,5];
	</code></pre>
	<p>
		The type annotation tells us that the array <var>arr</var> has the type
		<var>[i32; 5]</var>, meaning &mdash; an array (denoted by the square
		brackets), with five elements (denoted by the <var>5</var>), each
		element of type <var>i32</var> (denoted by the <var>i32</var>).
	</p>
	<p>
		Some algorithms require initializing an array where each element in the
		array is set to <var>0</var>. For example, an array of size ten, each
		element zero, can be written concisely in Rust as follows:
	</p>
	<pre class="language-rust"><code>
		let arr = [0; 10];
	</code></pre>
	<p>The initialization above expands to:</p>
	<pre class="language-rust"><code>
		let arr = [0,0,0,0,0,0,0,0,0,0];
	</code></pre>
	<p>
		To access each element in the array <var>arr</var>, we use square
		bracket syntax, much like other languages:
	</p>
	<pre class="language-rust"><code>
		fn main() {
			let arr = [1,2,3,4,5];
		
			println!("{}", arr[0]);
			println!("{}", arr[1]);
			println!("{}", arr[2]);
			println!("{}", arr[3]);
			println!("{}", arr[4]);
		}
	</code></pre>
	<pre class="language-bash"><code>
		1
		2
		3
		4
		5
	</code></pre>
	<p>
		<span class="topic">Invalid Indices.</span> What happens when we enter
		an invalid index? Well, let's try it:
	</p>
	<pre class="language-rust"><code>
		fn main() {
			let arr = [1,2,3];
		
			println!("{}", arr[0]);
			println!("{}", arr[1]);
			println!("{}", arr[2]);
			println!("{}", arr[3]);
		}
	</code></pre>
	<pre class="language-bash"><code>
		error: this operation will panic at runtime
		--> main.rs:7:17
			|
		7 |     println!("{}", arr[3]);
			|                    ^^^^^^ index out of bounds: the length is 3 but the index is 3
			|
			= note: `#[deny(unconditional_panic)]` on by default
	</code></pre>
	<p>
		Above, we got a <b>out-of-bounds error</b>. This is a compiler error.
		If the array was initialized through user input at runtime, we would
		get a <i>runtime error</i>. Unlike other languages, however, Rust goes
		the extra step not to execute any further lines the moment it
		encounters a runtime error. This is one of the hallmarks of Rust's
		memory safety principles. Many other languages like C and C++ do not
		provide this kind of check at runtime.
	</p>
</section>

<section id="control_flow">
	<h2>Control Flow</h2>
	<p>
		A language's <b>control flow constructs</b> are the constructs that
		allow the programmer to run specified code if a particular condition is
		true. In Rust, we can achieve control flow through two means:
		<b>Conditional control</b>, and <b>iterative control</b>. Conditional
		control is done through <i>if-expressions</i>,
		<i>else-if-expressions</i>, <i>else-expressions</i>, and <i>loops</i>.
		Let's consider conditional control first.
	</p>

	<section id="conditional_control">
		<h3>Conditional Control</h3>
		<p>
			The <b>if-expression</b> executes a block of code if its condition is
			met. Usually, an if-expression is followed by an
			<b>else-expression</b>. If the if-expression's condition is not met,
			we proceed to the else-expression's block. The else-expression,
			however, is entirely optional. If an if-expression's condition is
			false, the if-expression's block of code &mdash; the
			<b>if-block</b> &mdash; is skipped entirely. For example:
		</p>
		<pre class="language-rust"><code>
			fn main() {
				let n = 2;
				if n % 2 == 0 {
					println!("Even!");
				} else {
					println!("Odd!");
				}
			}
		</code></pre>
		<pre class="language-bash"><code>
			Even!
		</code></pre>
		<p>
			Notice the lack of parentheses. In Rust, we can simply write the
			if-condition after the keyword <var>if</var>. Further, notice the
			indentation for the control structure. Rust follows the
			<b>1TBS</b> (<q>One True Brace Style</q>) convention, a variant of
			the K&R brace style in C. Separately, we used the
			<var>==</var> operator to check for equality. Rust provides the
			standard relational operators we're familiar with:
		</p>
		<pre class="language-rust"><code>
			n > 20     // n is greater than 20
			n < 20     // n is less than 20
			n >= 20    // n is greater than or equal to 20
			n >= 20    // n is less than or equal to 20
			n == 20    // n is equal to 20
			n != 20    // n is not equal to 20
		</code></pre>
		<p>
			Unsurprisingly, the conditions for Boolean expressions must be
			expressions that evaluate to type <var>bool</var>. Otherwise, we get
			a <b>mismatched type error</b>. Unlike languages like Ruby and
			JavaScript (which have <i>truthy</i> and <i>falsey</i> values), Rust
			does not implicitly cast non-Boolean types to Booleans.
		</p>
		<p>
			If our program branches into more than two paths, we can specify when
			a particular path is taken with an
			<b>else-if-expression</b>:
		</p>
		<pre class="language-bash"><code>
			fn main() {
				let n = 30;
				if n % 5 == 0 {
					println!("Divisible by 5.");
				} else if n < 100 {
					println!("Less than 100.");
				} else {
					println!("It's an integer.");
				}
			}
		</code></pre>
		<pre class="language-bash"><code>
			Divisible by 5
		</code></pre>
		<p>
			Notice that because the first condition is met, we see the
			corresponding output. The second condition is also true, but we don't
			execute that condition. Why? Because the if-expression's condition is
			true. Like most other programming languages, once Rust encounters a
			Boolean expression that evaluates to true in a conditional control
			block, it executes that line and continues, paying no heed to the
			remaining conditions.
		</p>
		<p>
			If we want to also evaluate the second condition, we can use the
			logical AND operator &mdash; <var><mark>&&</mark></var
			>:
		</p>
		<pre class="language-rust"><code>
			fn main() {
				let n = 30;
				if (n % 5 == 0) && (n < 100) {
					println!("Divisible by 5 and less than 100.");
				} else if n % 5 == 0 {
					println!("Divisible by 5.");
				} else {
					println!("It's an integer.");
				}
			}
		</code></pre>
		<pre class="language-bash"><code>
			Divisible by 5 and less than 100.
		</code></pre>
		<p>Rust has the usual logical operators found in other languages:</p>
		<pre class="language-rust"><code>
			x && y    // true iff both x and y are true; otherwise false
			x || y    // false iff both x and y are false; otherwise true
			!x        // if x is true, returns false; if x is false, returns true
		</code></pre>
	</section>

	<section id="iterative_control">
		<h3>Iterative Control</h3>
		<p>
			Iterative control is what allows us to execute blocks of code
			repeatedly. Rust has three forms of loops: an
			<b>infinite loop</b> (using the keyword <var><mark>loop</mark></var
			>), a <b>for-loop</b> (using the keyword <var><mark>for</mark></var
			>) and a <b>while-loop</b> (using the keyword
			<var><mark>while</mark></var
			>). Let's consider each loop.
		</p>
		<p>The infinite loop takes the following form:</p>
		<pre class="language-rust"><code>
			fn main() {
				loop {
					println!("Infinite loop!");
				}
			}
		</code></pre>
		<p>
			Running the code above, we see <var>Infinite loop!</var> print over
			and over again, stopping only if we enter an interrupt (on most
			computers, typing ctrl-c). Alternatively, we can exit the loop by
			using the <var><mark>break</mark></var> keyword.
		</p>
		<pre class="language-rust"><code>
			fn main() {
				let mut countdown = 5;
				println!("Countdown started.");
				loop {
					println!("{}", countdown);
					countdown -= 1;
					if countdown == 0 {
						break;
					}
				}
				println!("Countdown ended.");
			}
		</code></pre>
		<pre class="language-bash"><code>
			Countdown started.
			5
			4
			3
			2
			1
			Countdown ended.
		</code></pre>
	</section>
	<p>
		An interesting aspect of Rust we might not have seen with other
		languages is that loops can be given identifiers. For example, suppose
		we have an infinite loop inside an infinite loop, and we want to break
		out of outer loop if a condition in the inner loop is met. We can do so
		with the following:
	</p>
	<pre class="language-rust"><code>
		fn main() {
			let mut i = 5;
			let mut j = 5;
			'outer_loop: loop {
				println!("Inside outer loop, i = {}", i);
				println!("Entering inner loop with j = {}", j);
				i -= 1;
				loop {
					j -= 1;
					if j == 0 {
						println!("Final break out of inner loop, j == 0.");
						break 'outer_loop;
					}
					else if j % 2 == 0 {
						println!("Breaking out of inner loop, j % 2 == 0, j = {}", j);
						break;
					}
					else {
						println!("Inside inner loop, j = {}", j);
					}
				}
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		Inside outer loop, i = 5
		Entering inner loop with j = 5
		Breaking out of inner loop, j % 2 == 0, j = 4
		Inside outer loop, i = 4
		Entering inner loop with j = 4
		Inside inner loop, j = 3
		Breaking out of inner loop, j % 2 == 0, j = 2
		Inside outer loop, i = 3
		Entering inner loop with j = 2
		Inside inner loop, j = 1
		Final break out of inner loop, j == 0.
	</code></pre>
	<p>
		Notice how the condition <var>j == 0</var> results in breaking
		<var>'outer_loop</var>, the outer loop's identifier. The
		<var>loop</var> construct is really just syntactic sugar for a
		<i>while-true</i> loop. Although most introductory computer science
		courses heavily emphasize checking ourselves before considering the
		infinite loop, Rust provides syntactic sugar for it, encouraging us to
		learn to be comfortable with such loops. For example, suppose we want
		some procedure to continue executing, so long as the result of another
		procedure is true:
	</p>
	<pre class="language-rust"><code>
		fn main() {
			let mut i = 10; 
			let mut n = 0;
			let m = loop {
				i -= 1;
				if i % 3 == 0 {
					n += 1;
				}
				if i == 0 {
					break n;
				}
			};
			println!("m = {}", m);
		}
	</code></pre>
	<pre class="language-bash"><code>
		m = 4
	</code></pre>
	<p>
		In the code above, we have two mutating variables, <var>i</var> and
		<var>n</var>. Then, we have non-mutating variable, <var>m</var>, which
		stores the result of evaluating its loop expression. That loop
		expression performs the following: At each iteration, decrement
		<var>i</var>. Then test if <var>i</var> is divisible by ${3.}$ If it
		is, then increment <var>n</var>. Once we've decremented <var>i</var> to
		<var>0</var>, we break at the current value of <var>n</var>. That value
		is then bound to <var>m</var>. Executing this procedure tells us that
		there are four positive integers less than ${10}$ that are divisible by
		${3}$ &mdash; ${3,}$ ${6,}$ and ${9.}$
	</p>

	<section id="while_loop">
		<h3>While-loop</h3>
		<p>
			Although the infinite loop can be a clever way of iterating, it's
			often much easier to just use a while-loop. The same procedure we saw
			earlier can be written more concisely as:
		</p>
		<pre class="language-rust"><code>
			fn main() {
				let mut i = 10; 
				let mut m = 0;
				while i != 0 {
					if i % 3 == 0 {
						m += 1;
					}
					i -= 1;
				}
				println!("m = {}", m);
			}
		</code></pre>
		<pre class="language-bash"><code>
			m = 3
		</code></pre>
	</section>

	<section id="for_loop">
		<h3>For-loop</h3>
		<p>
			Like other languages, we can also iterate with a for-loop. This is
			done with the <var><mark>for</mark></var> keyword:
		</p>
		<pre class="language-rust"><code>
			fn main() {
				let arr = [1,2,3,4,5];
				for element in arr {
					println!("element: {}", element);
				}
			}
		</code></pre>
		<pre class="language-bash"><code>
			element: 1
			element: 2
			element: 3
			element: 4
			element: 5
		</code></pre>
		<p>
			Notice that the for-loop in rust doesn't require us to use the length
			syntax in languages like Java and C,
			<q><var>for (int i = 0</var> &hellip;</q> We don't have to worry
			about things like length and going out of bounds in an array &mdash;
			Rust takes care of that.
		</p>
		<p>
			But what if we want to only iterate a specified number of times? For
			that we use the <var><mark>Range</mark></var> function provided by
			the standard library. Calling this function can be done implicitly,
			by simply including two dots between the range:
		</p>
		<pre class="language-rust"><code>
			fn main() {
				let arr = [1,2,3,4,5];

				for i in 0..3 {
					println!("element at index {}: {}", i, arr[i]);
				}

				println!("\n"); // just to break the blocks

				for i in 1..4 {
					println!("element at index {}: {}", i, arr[i]);
				}
			}
		</code></pre>
		<pre class="language-bash"><code>
			element at index 0: 1
			element at index 1: 2
			element at index 2: 3


			element at index 1: 2
			element at index 2: 3
			element at index 3: 4
		</code></pre>
		<p>
			Note that when we write <var>i..n</var>, this specifies the range
			${[i, n).}$ I.e., the range is from ${i}$ through ${n - 1.}$
		</p>
	</section>
</section>

<section id="ownership">
	<h2>Ownership</h2>
	<p>
		By far, the most unique aspect of Rust that separates it from other
		languages is its concept of <b>ownership</b> &mdash; the set of rules
		dictating how memory is managed in a Rust program. There are three
		popular approaches to managing memory:
	</p>
	<ol>
		<li>
			<b>Manual memory management.</b> The programmer must explicitly
			allocate and free memory herself. This is the approach taken in
			languages like C and C++.
		</li>
		<li>
			<b>Garbage collecting.</b> This is a form of automatic memory
			management. A program called a <i>garbage collector</i> constantly
			looks for unused memory and deallocates as permitted. This is the
			approach taken by languages like Java.
		</li>
		<li>
			<b>Automatic reference counting.</b> This is also another form of
			automatic memory management. In automatic reference counting (ARC),
			the compiler counts the number of references to a particular class
			instance, deallocating <em>only if</em> no property, consant, or
			variable maintains a strong reference, or connection, to the class
			instance. This is the approach taken by languages like Objective-C
			and Swift.
		</li>
		<li>
			<b>Ownership rules.</b> This is the approach Rust takes. The
			ownership rules approach is a hybrid between manual memory management
			and automatic memory management. Instead of some program constantly
			running, whether to allocate or free memory is determined by a set of
			rules checked by the compiler. If any rule is violated, the program
			will not compile.
		</li>
	</ol>
	<p>
		The significance of the ownership rules approach is that memory errors
		and bugs are taken out of runtime and placed in compile time. By
		classifying memory issues as compiler errors, memory leaks are
		exceedingly rare in Rust programs.
	</p>
	<p>
		As we know, there are two places we can store our program's data: the
		<i>stack</i> and the <i>heap</i>. When we store values on the stack,
		the values are arranged in the order they enter, and removed in the
		opposite &mdash; last in, first out. We can think of it like placing
		forms one on top of another for some worker to stamp. The worker takes
		the topmost form, stamps it, takes the next, stamps it, on and on,
		until there are no more forms.
	</p>
	<p>
		The heap, however, is not so organized. To store values in the heap, we
		have to ask for a specific amount of memory from a program called the
		<i>memory allocator</i>. When we send that request, the memory
		allocator goes through the heap, searhing for an empty spot we can
		place our data in. If it finds space, it returns to us an address of
		the space it found. That address is called a <b>pointer</b>. It's like
		going to a busy restaurant. Space is spread unevenly, because some
		people eat alone, others in groups of three, and yet others in eight.
		When we get to the restaurant, we tell the maÃ®tre d' how many people
		are in our group. She checks to see which tables are open, and if she
		finds one, she gives us a table number, say, Table <var>0xFFAC2B</var>,
		and seats us. If someone in our group arrives later:
		<q>They're at Table <var>0xFFAC2B.</var></q>
	</p>
	<p>
		Now, compare this restaurant with say, a bar where customers are seated
		on after another, contiguously, on a single long table. In other words,
		no gaps between diners, all diners in a single line. This bar is akin
		toe the stack. Because eveything is nice and ordered in one long line,
		the stuff &mdash; the allocator &mdash; doesn't have to search for open
		spaces. She simply seats the group at the next open space. Accordingly,
		pushing to the stack is faster than allocating space on the heap.
	</p>
	<p>
		Extending the metaphor, the bar's servers are much faster at taking and
		delivering orders than the restaurant's. Why? Because the servers
		simply go up and down, one by one, along the long table. Contrast this
		with the restaurant, where the serves are potentially going from one
		end of the restaurant to the other, to the middle, to just a little
		left, to just a little right, and so on. This idea extends to the heap
		and the stack. Accessing data in the heap is slower than accessing data
		in the stack.
	</p>
	<p>
		Keeping these ideas in mind, let's start with the a few basic rules:
	</p>
	<ol>
		<li>Every value in Rust is <i>owned</i> by a variable.</li>
		<li>A value's variable is called that values <i>owner</i>.</li>
		<li>
			Every value in Rust has one, and only one, owner, at any given time.
		</li>
		<li>
			When a variable goes out of scope, the value is <b>dropped</b> (i.e.,
			cleared from memory).<sup></sup>
		</li>
	</ol>
	<div class="note">
		<p>
			The pattern of deallocating memory for a particular value after the
			value's variable goes out of scope is also called
			<b>resource acquisition is initialization (RAII)</b>. The pattern is
			central to memory management in many languages, most notably C++.
		</p>
	</div>
	<p>
		A variable's <b>scope</b> sets the boundaries of where in the program
		the owner is recognized as owning its value. For example:
	</p>
	<pre class="language-rust"><code>
		// s does not own 1 here      
				fn funct() {    // s does not own 1 here
					let s = 1;    // s validly owns 1 here 
												// s validly owns 1 here 
				};              // s does not own 1 here
		// s does not own 1 here
	</code></pre>
	<p>
		When our code calls a function, the values passed into that function
		(including pointer arguments to data on the heap) and that function's
		local variables are <i>pushed</i> onto the stack. When the function
		finishes executing, the values are <i>popped</i> off the stack. For
		example, suppose we have the following code:
	</p>
	<pre class="language-rust"><code>
		fn main() {
			let a = 4;
			let b = square(a);
		}
		fn square(a) {
			let result = a * a;
			result;
		}
	</code></pre>
	<p>
		The first function called is <var>main()</var>, so this creates a
		<i>stack frame</i> in the stack:
	</p>
	<div class="split">
		<pre class="language-rust"><code>
			fn main() {
				let a = 4;
				let b = square(a);
			}
			fn square(a) {
				let y = a * a;
				y;
			}
		</code></pre>
		<div class="trace">
			<div class="stack">
				<div class="call">
					<span>main()</span>
				</div>
			</div>
			<div class="heap"></div>
		</div>
	</div>
	<p>
		Inside <var>main()</var>, we have our first variable initialization,
		<var>let a = 4;</var>. That value gets pushed onto the stack, in
		<var>main()</var>'s frame:
	</p>
	<div class="split">
		<pre class="language-rust"><code>
			fn main() {
				let a = 4;
				let b = square(a);
			}
			fn square(a) {
				let y = a * a;
				y;
			}
		</code></pre>
		<div class="trace">
			<div class="stack">
				<div class="call">
					<span>main()</span>
					<ul>
						<li>a</li>
						<li>4</li>
					</ul>
				</div>
			</div>
			<div class="heap"></div>
		</div>
	</div>
	<p>
		On the next line, we have <var>let b = square(a)</var>. This is a
		function call, so another frame is created, with the value of
		<var>a</var> pushed on:
	</p>
	<div class="split">
		<pre class="language-rust"><code>
			fn main() {
				let a = 4;
				let b = square(a);
			}
			fn square(a) {
				let y = a * a;
				y;
			}
		</code></pre>
		<div class="trace">
			<div class="stack">
				<div class="call">
					<span>main()</span>
					<ul>
						<li>a</li>
						<li>4</li>
					</ul>
				</div>
				<div class="call">
					<span>square()</span>
					<ul>
						<li>a</li>
						<li>4</li>
					</ul>
				</div>
			</div>
			<div class="heap"></div>
		</div>
	</div>
	<p>
		Then, inside <var>square()</var>, we have another value,
		<var>y = a * a</var>. This value is also pushed:
	</p>
	<div class="split">
		<pre class="language-rust"><code>
			fn main() {
				let a = 4;
				let b = square(a);
			}
			fn square(a) {
				let y = a * a;
				y;
			}
		</code></pre>
		<div class="trace">
			<div class="stack">
				<div class="call">
					<span>main()</span>
					<ul>
						<li>a</li>
						<li>4</li>
					</ul>
				</div>
				<div class="call">
					<span>square()</span>
					<ul>
						<li>a</li>
						<li>4</li>
					</ul>
					<ul>
						<li>y</li>
						<li>16</li>
					</ul>
				</div>
			</div>
			<div class="heap"></div>
		</div>
	</div>
	<p>
		that value of <var>y</var> is then returned, <i>owned</i> by
		<var>b</var> in <var>main()</var>:
	</p>
	<div class="split">
		<pre class="language-rust"><code>
			fn main() {
				let a = 4;
				let b = square(a);
			}
			fn square(a) {
				let y = a * a;
				y;
			}
		</code></pre>
		<div class="trace">
			<div class="stack">
				<div class="call">
					<span>main()</span>
					<ul>
						<li>a</li>
						<li>4</li>
					</ul>
					<ul>
						<li>b</li>
						<li>16</li>
					</ul>
				</div>
				<div class="call">
					<span>square()</span>
					<ul>
						<li>a</li>
						<li>4</li>
					</ul>
					<ul>
						<li>y</li>
						<li>16</li>
					</ul>
				</div>
			</div>
			<div class="heap"></div>
		</div>
	</div>
	<p>
		Importantly, the stack frame for <var>square()</var> does not
		disappear. It stays as is. In other words, the memory in
		<var>square()</var> is not deallocated. However, if we were to call
		another function, say, <var>sqrt()</var>, that function's values will
		overwrite the <var>square()</var>'s frame.
	</p>
	<p>
		<span class="topic">Another Perspective.</span> In the diagrams above,
		the stack is presented as a pile of frames, with increasing function
		calls growing the pile. But what does a single stack frame look like?
		Say we had the following code:
	</p>
	<pre class="language-rust"><code>
		fn main() {
			let a = 2;
			let b = cube(a);
			let c = square(b);
		}
		fn cube(x) {
			let y = x * x * x;
			y;
		}
		fn square(n) {
			let m = n * n;
			m;
		}
	</code></pre>
	<p>In memory, the stack actually looks more like:</p>
	<table class="ram">
		<tbody>
			<tr class="label">
				<td colspan="3">main()</td>
				<td colspan="2">cube()</td>
				<td colspan="2">square()</td>
			</tr>
			<tr>
				<td>
					<ul>
						<li>a</li>
						<li class="rhl">2</li>
					</ul>
				</td>
				<td>
					<ul>
						<li>b</li>
						<li class="rhl">8</li>
					</ul>
				</td>
				<td class="seg">
					<ul>
						<li>c</li>
						<li class="rhl">64</li>
					</ul>
				</td>
				<td>
					<ul>
						<li>x</li>
						<li class="ghl">2</li>
					</ul>
				</td>
				<td class="seg">
					<ul>
						<li>y</li>
						<li class="ghl">8</li>
					</ul>
				</td>
				<td>
					<ul>
						<li>n</li>
						<li class="bhl">8</li>
					</ul>
				</td>
				<td>
					<ul>
						<li>m</li>
						<li class="bhl">64</li>
					</ul>
				</td>
			</tr>
		</tbody>
	</table>
	<p>
		Above, the red boxes belong to <var>main()</var>, the green boxes
		belong to <var>cube()</var>, and the blue boxes belong to
		<var>square()</var>. Recall what we said earlier about the restaurant
		analogy: Data pushed onto the stack is arranged contiguously. They're
		all seated in order. Now, for this to work, the data we push onto the
		stack must be of <em>fixed size</em>. This means data of types like
		<var>i32</var>, <var>u8</var>, <var>f32</var>, <var>bool</var> data,
		and <var>char</var> data. These primitive types all have a fixed size.
	</p>
	<p>
		Why does it have to be of fixed size? Because for the stack to provide
		its benefits &mdash; breathtakingly fast data storage and access
		&mdash; it has to ensure there aren't <i>fragments</i> in the stack. In
		other words, gaps between the bar's diners. And to do that, it must
		know ahead of time how much memory we're going to take. If we have
		something that can grow and shrink, we end up with gaps or data
		overwriting another, defeating the purpose of a stack in the first
		place.
	</p>
	<p>
		Now suppose we added another value to our code, in the function
		<var>main()</var>:
	</p>
	<pre class="language-rust"><code>
		fn main() {
			let a = 2;
			let b = cube(a);
			let c = square(b);
			let s = String::from("hi");
		}
		fn cube(x) {
			let y = x * x * x;
			y;
		}
		fn square(n) {
			let m = n * n;
			m;
		}
	</code></pre>
	<p>
		When we write <var>String::from("hi")</var>, we create a
		<b>mutable string</b> &mdash; a string that can be modified; i.e.,
		shortened, lengthened, characters swapped, or deleted entirely. The
		memory appears as such:
	</p>
	<table class="ram">
		<tbody>
			<tr class="label">
				<td colspan="6">main()</td>
				<td colspan="2">cube()</td>
				<td colspan="2">square()</td>
			</tr>
			<tr>
				<td colspan="9">S</td>
			</tr>
			<tr>
				<td>
					<ul>
						<li>a</li>
						<li class="rhl">2</li>
					</ul>
				</td>
				<td>
					<ul>
						<li>b</li>
						<li class="rhl">8</li>
					</ul>
				</td>
				<td>
					<ul>
						<li>c</li>
						<li class="rhl">64</li>
					</ul>
				</td>
				<td>
					<ul>
						<li>ptr</li>
						<li class="rhl">0x100</li>
					</ul>
				</td>
				<td>
					<ul>
						<li>capacity</li>
						<li class="rhl">3</li>
					</ul>
				</td>
				<td class="seg">
					<ul>
						<li>length</li>
						<li class="rhl">2</li>
					</ul>
				</td>
				<td>
					<ul>
						<li>x</li>
						<li class="ghl">2</li>
					</ul>
				</td>
				<td class="seg">
					<ul>
						<li>y</li>
						<li class="ghl">8</li>
					</ul>
				</td>
				<td>
					<ul>
						<li>n</li>
						<li class="bhl">8</li>
					</ul>
				</td>
				<td>
					<ul>
						<li>m</li>
						<li class="bhl">64</li>
					</ul>
				</td>
			</tr>
		</tbody>
	</table>
	<p>
		Look at the way <var>s</var> is allocated. The value we refer to as
		<var>s</var>, a <var>string</var>, actually consists of three data
		components: a pointer <var>ptr</var>, a <var>capacity</var>, and a
		<var>length</var>. The pointer <var>ptr</var> stores the address of
		some <i>buffer</i> &mdash; the address of some byte of memory in the
		heap. At that address is the start of the string value <var>"hi"</var>.
		The <var>capacity</var> component corresponds to the size of the buffer
		holding storing the <var>String</var> data. And the
		<var>length</var> component corresponds to the number of bytes stored
		in the buffer.
	</p>
	<p>Now consider the following code:</p>
	<pre class="language-rust"><code>
		fn main() {
			let a = 2;
			let b = String::from("hi");
			let c = b;
		}
	</code></pre>
	<p>Writing the code above, we get the following in memory:</p>
	<table class="ram">
		<tbody>
			<tr class="label">
				<td colspan="8">main()</td>
			</tr>
			<tr>
				<td colspan="4">b</td>
				<td colspan="4">c</td>
			</tr>
			<tr>
				<td class="seg">
					<ul>
						<li>a</li>
						<li class="rhl">2</li>
					</ul>
				</td>
				<td>
					<ul>
						<li>ptr</li>
						<li class="rhl">0x100</li>
					</ul>
				</td>
				<td>
					<ul>
						<li>capacity</li>
						<li class="rhl">3</li>
					</ul>
				</td>
				<td class="seg">
					<ul>
						<li>length</li>
						<li class="rhl">2</li>
					</ul>
				</td>
				<td>
					<ul>
						<li>ptr</li>
						<li class="rhl">0x100</li>
					</ul>
				</td>
				<td>
					<ul>
						<li>capacity</li>
						<li class="rhl">3</li>
					</ul>
				</td>
				<td>
					<ul>
						<li>length</li>
						<li class="rhl">2</li>
					</ul>
				</td>
			</tr>
			<tr>
				<td>${\vdots}$</td>
			</tr>
			<tr>
				<td>
					<ul>
						<li>0x100</li>
						<li>'h'</li>
					</ul>
				</td>
				<td>
					<ul>
						<li>0x101</li>
						<li>'i'</li>
					</ul>
				</td>
			</tr>
		</tbody>
	</table>
	<p>
		Notice what's happening here. We're not actually copying the string
		data value <var>"hi"</var>. Instead, we're copying the data components
		of <var>b</var>. Both <var>b</var> and <var>c</var> both have pointers
		to the same buffer address.
	</p>
	<p>
		Coming from C, C++, or Java, we may be familiar with this behavior as
		<i>shallow copying</i> (or <i>shallow cloning</i>) and
		<i>deep copying</i> (or <i>deep cloning</i>).
	</p>
	<figure>
		<img
			src="{% static 'images/shallow_v_deep_copy.svg' %}"
			alt="shallow versus deep copy"
			loading="lazy"
			width="170px"
			height="170px"
		/>
	</figure>
	<p>
		In those languages, both the original and the clone remain in memory.
		In languages like C and C++, both shallow and deep copying is a risky
		venture.<sup></sup> Why? Because with shallow copies, we can
		unintentionally (a) deallocate memory with the original, which
		deallocates the referent, and then (b) deallocate again with the copy.
		In languages like C, that second deallocation is called a
		<b>double free error</b>, and it's bad. We're deallocating memory
		potentially used by another function in our program. This leads to a
		whole host of issues like memory fragmentation. With deep copies, we
		might deallocate the original but forget to deallocate the copy &mdash;
		memory leaks.
	</p>
	<div class="note">
		<p>
			Today, this is moreso the case with C than with C++. Modern C++ has a
			whole host of libraries for reference counting, and smart pointers
			have made memory management safer. C, on the other hand, is a
			language that's about as close as we can get to Assembly without
			having to write Assembly &mdash; no hand-holding there.
		</p>
	</div>
	<p>
		Because of this risk, Rust takes an alternative approach. Consider the
		output of the following code:
	</p>
	<pre class="language-rust"><code>
		fn main() {
			let str1 = String::from("hi");
			let str2 = str1;
			println!("{}", str1);
		}
	</code></pre>
	<pre class="language-bash"><code>
		error[E0382]: borrow of moved value: `str1`
		--> main.rs:4:17
			|
		2 |     let str1 = String::from("hi");
			|         ---- move occurs because `str1` has type `String`, which does not implement the `Copy` trait
		3 |     let str2 = str1;
			|                ---- value moved here
		4 |     println!("{}", str1);
			|                    ^^^^ value borrowed here after move
	</code></pre>
	<p>
		Most languages would allow you to print <var>str1</var>. Why isn't Rust
		letting us do it? It's because of a feature in Rust called
		<b>moving</b>. When we first initialize <var>str1</var>, the memory
		looks like:
	</p>
	<table class="ram">
		<tbody>
			<tr class="label">
				<td colspan="3">main()</td>
			</tr>
			<tr>
				<td colspan="3">str1</td>
			</tr>
			<tr>
				<td>
					<ul>
						<li>ptr</li>
						<li class="rhl">0x100</li>
					</ul>
				</td>
				<td>
					<ul>
						<li>capacity</li>
						<li class="rhl">3</li>
					</ul>
				</td>
				<td>
					<ul>
						<li>length</li>
						<li class="rhl">2</li>
					</ul>
				</td>
			</tr>
			<tr>
				<td>${\vdots}$</td>
			</tr>
			<tr>
				<td>
					<ul>
						<li>0x100</li>
						<li>'h'</li>
					</ul>
				</td>
				<td>
					<ul>
						<li>0x101</li>
						<li>'i'</li>
					</ul>
				</td>
			</tr>
		</tbody>
	</table>
	<p>Then, when we initialize <var>str2</var>, the memory becomes:</p>
	<table class="ram">
		<tbody>
			<tr class="label">
				<td colspan="6">main()</td>
			</tr>
			<tr>
				<td colspan="3" class="deleted">str1</td>
				<td colspan="3">str2</td>
			</tr>
			<tr>
				<td class="deleted">
					<ul>
						<li>ptr</li>
						<li class="rhl">0x100</li>
					</ul>
				</td>
				<td class="deleted">
					<ul>
						<li>capacity</li>
						<li class="rhl">3</li>
					</ul>
				</td>
				<td class="deleted">
					<ul>
						<li>length</li>
						<li class="rhl">2</li>
					</ul>
				</td>
				<td>
					<ul>
						<li>ptr</li>
						<li class="rhl">0x100</li>
					</ul>
				</td>
				<td>
					<ul>
						<li>capacity</li>
						<li class="rhl">3</li>
					</ul>
				</td>
				<td>
					<ul>
						<li>length</li>
						<li class="rhl">2</li>
					</ul>
				</td>
			</tr>
			<tr>
				<td>${\vdots}$</td>
			</tr>
			<tr>
				<td>
					<ul>
						<li>0x100</li>
						<li>'h'</li>
					</ul>
				</td>
				<td>
					<ul>
						<li>0x101</li>
						<li>'i'</li>
					</ul>
				</td>
			</tr>
		</tbody>
	</table>

	<p>
		Notice that <var>str1</var> is blurred. This is because when we
		initialized <var>str2</var> &mdash; what we might think of as a
		<i>shallow copy</i> &mdash; Rust invalidates <var>str1</var>. The
		variable <var>str2</var> becomes what's called a <b>move</b>. By
		invalidating <var>str1</var>, Rust mitigates the risk of double
		freeing. When <var>str2</var> goes out ot scope, <var>str2</var>'s heap
		allocated memory is freed, and we don't have to worry about
		<var>str1</var>.
	</p>
	<p>
		Because of the concept of moving, Rust makes a critical design choice:
		It will never automatically create deep copies of the programmer's
		data. Whether we agree with this design choice or not, the impact is
		clear: automatic copying in Rust is cheap in terms of runtime.
	</p>
	<p>
		<span class="topic">Deep Copies.</span> But wait, does that mean we
		cannot make deep copies in Rust? Of course not. Many problems are
		better solved with deep copies, so Rust provides a method for doing so:
		<var><mark>clone()</mark></var
		>. Illustrating:
	</p>
	<pre class="language-rust"><code>
		fn main() {
			let str1 = String::from("hi");
			let str2 = str1.clone();
			println!("str1 = {}, str2 = {}", str1, str2);
		}
	</code></pre>
	<pre class="language-bash"><code>
		str1 = hi, str2 = hi
	</code></pre>
	<p>
		The code compiles just fine. As is the case in other languages, deep
		copying is much more expensive than shallow copying. We have to make
		new instances of the data <i>and</i> allocate memory for those
		instances.
	</p>
	<table class="ram">
		<tbody>
			<tr class="label">
				<td colspan="6">main()</td>
			</tr>
			<tr>
				<td colspan="3">str1</td>
				<td colspan="3">str2</td>
			</tr>
			<tr>
				<td>
					<ul>
						<li>ptr</li>
						<li class="rhl">0x100</li>
					</ul>
				</td>
				<td>
					<ul>
						<li>capacity</li>
						<li class="rhl">3</li>
					</ul>
				</td>
				<td>
					<ul>
						<li>length</li>
						<li class="rhl">2</li>
					</ul>
				</td>
				<td>
					<ul>
						<li>ptr</li>
						<li class="rhl">0x200</li>
					</ul>
				</td>
				<td>
					<ul>
						<li>capacity</li>
						<li class="rhl">3</li>
					</ul>
				</td>
				<td>
					<ul>
						<li>length</li>
						<li class="rhl">2</li>
					</ul>
				</td>
			</tr>
			<tr>
				<td>${\vdots}$</td>
			</tr>
			<tr>
				<td>
					<ul>
						<li>0x100</li>
						<li>'h'</li>
					</ul>
				</td>
				<td>
					<ul>
						<li>0x101</li>
						<li>'i'</li>
					</ul>
				</td>
				<td>${\ldots}$</td>
				<td>
					<ul>
						<li>0x200</li>
						<li>'h'</li>
					</ul>
				</td>
				<td>
					<ul>
						<li>0x201</li>
						<li>'i'</li>
					</ul>
				</td>
			</tr>
		</tbody>
	</table>
	<section id="heap_data_inside_a_function">
		<h3>Heap Data Inside a Function</h3>
		<p>
			In Rust, heap data inside a function follows the same scoping rules
			for stack data <i>and</i> the concept of moving applies. Once the
			variable owning the heap data goes out of the scope (e.g., the
			function finishes executing), the heap data inside that function is
			dropped. On top of this, the rules for moving apply.
		</p>
		<p>For example, consider the following code:</p>
		<pre class="language-rust"><code>
			fn main() {
				let x = String::from("hi");
				print(x);
				println!("x = {}", x);
			}
			
			fn print(a: String) {
				println!("{}", a);
			}
		</code></pre>
		<pre class="language-bash"><code>
			error[E0382]: borrow of moved value: `x`
			--> main.rs:4:21
				|
			2 |     let x = String::from("hi");
				|         - move occurs because `x` has type `String`, which does not implement the `Copy` trait
			3 |     print(x);
				|           - value moved here
			4 |     println!("x = {}", x);
				|                        ^ value borrowed here after move
		</code></pre>
		<p>
			We're getting this error because the value <var>x</var> is moved from
			<var>main()</var> to <var>print()</var>. And once
			<var>print()</var> finishes executing, <var>x</var>'s value is
			dropped. This means that in every line of <var>main()</var> after
			<var>print(x)</var>, <var>x</var> is invalid.
		</p>
	</section>
	<section id="stack_copy">
		<h3>Copying Data in the Stack</h3>
		<p>
			Making copies of data in the stack is different from making copies of
			data in the heap. Consider the following output:
		</p>
		<pre class="language-rust"><code>
			fn main() {
				let x = 1;
				let y = x;
				println!("x = {}, y = {}", x, y);
			}
		</code></pre>
		<pre class="language-bash"><code>
			x = 1, y = 1
		</code></pre>
		<p>
			Why is this behavior different? Because data inside the stack is of
			fixed size. And since it's of fixed size, making copies is cheap,
			which in turn means there's no reason to apply the same procedure for
			heap data (other than consistency in the language). In memory, the
			statements above are simple:
		</p>
		<table class="ram">
			<tbody>
				<tr class="label">
					<td colspan="2">main()</td>
					<td colspan="2">println!()</td>
				</tr>
				<tr>
					<td>
						<ul>
							<li>x</li>
							<li class="rhl">1</li>
						</ul>
					</td>
					<td class="seg">
						<ul>
							<li>y</li>
							<li class="rhl">1</li>
						</ul>
					</td>
					<td>
						<ul>
							<li>x</li>
							<li class="ghl">1</li>
						</ul>
					</td>
					<td>
						<ul>
							<li>y</li>
							<li class="ghl">1</li>
						</ul>
					</td>
				</tr>
			</tbody>
		</table>
	</section>

	<section id="borrowing">
		<h3>Borrowing</h3>
		<p>Consider the following code's output:</p>
		<pre class="language-rust"><code>
			fn main() {
				let x = String::from("hi");
				let y = &amp;x;
				println!("x={}, y={}", x, y);
			}
		</code></pre>
		<pre class="language-bash"><code>
			x = hi, y = hi
		</code></pre>
		<p>
			That's odd. Why does this code work? After our previous discussion,
			didn't the string value owned by <var>x</var> get moved to
			<var>y</var>? How are we allowed to use <var>x</var>? The difference
			is in that one character, the ampersand:
		</p>
		<pre class="language-rust"><code>
			fn main() {
				let x = String::from("hi");
				let y = <var><mark>&amp;</mark></var>x;
				println!("x={}, y={}", x, y);
			}
		</code></pre>
		<p>
			That character is actually an operator, called the
			<b>reference operator</b>, and it returns the address of some
			variable. To see that this is the case, let's look at some outputs:
		</p>
		<pre class="language-rust"><code>
			fn main() {
				let x = String::from("hi");
				let y = &amp;x;
				println!("Value owned by x: {}", x);
				println!("Value borrowed by y: {}", y);
				println!("Memory address of x: {:p}", &x);
				println!("Memory address of y: {:p}", &y);
				println!("Memory address IN y: {:p}", y);
			}
		</code></pre>
		<pre class="language-bash"><code>
			Value owned by x: hi
			Value borrowed by y: hi
			Memory address of x: 0x7ffee16b6a40
			Memory address of y: 0x7ffee16b6a58
			Memory address IN y: 0x7ffee16b6a40
		</code></pre>
		<p>
			Don't worry too much about the new code <var>{:p}</var>, we'll get to
			it when we discuss traits. For now, think of it as akin to format
			specifiers in C. The more important point is the output. What the
			output tells us is the following:
		</p>
		<ol>
			<li>
				<var><mark>&x -> 0x7ffee16b6a40</mark></var> The address of
				<var>x</var> is some address ending in <var>a40</var>.
			</li>
			<li>
				<var><mark>&y -> 0x7ffee16b6a58</mark></var> The address of
				<var>y</var> is some address ending in <var>a58</var>.
			</li>
			<li>
				<var><mark>y -> 0x7ffee16b6a40</mark></var> The address stored
				inside <var>y</var> is the address of <var>x</var>, the address
				ending in <var>a40</var>.
			</li>
		</ol>
		<p>Putting these observations together, when we write:</p>
		<pre class="language-rust"><code>
			fn main() {
				let x = String::from("hi");
				let y = &amp;x;
			}
		</code></pre>
		<p>The code is represented in memory as:</p>
		<table class="ram">
			<tbody>
				<tr class="label">
					<td colspan="4">main()</td>
				</tr>
				<tr>
					<td colspan="3">x</td>
				</tr>
				<tr>
					<td>
						<ul>
							<li>ptr</li>
							<li class="rhl">0xf10</li>
						</ul>
					</td>
					<td>
						<ul>
							<li>capacity</li>
							<li class="rhl">3</li>
						</ul>
					</td>
					<td>
						<ul>
							<li>length</li>
							<li class="rhl">2</li>
						</ul>
					</td>
					<td>
						<ul>
							<li>y</li>
							<li class="bhl">0xa40</li>
						</ul>
					</td>
				</tr>
				<tr>
					<td><span class="blueText">0xa40</span></td>
					<td></td>
					<td></td>
					<td><span class="greenText">0xa58</span></td>
				</tr>
				<tr>
					<td>${\vdots}$</td>
				</tr>
				<tr>
					<td>
						<ul>
							<li>0xf10</li>
							<li>'h'</li>
						</ul>
					</td>
					<td>
						<ul>
							<li>0xf11</li>
							<li>'i'</li>
						</ul>
					</td>
				</tr>
			</tbody>
		</table>
		<p>
			This means that <var>y</var> doesn't store a string, even if the
			output looks like a string. Instead, <var>y</var> stores a
			<b>reference</b>, which is the address of whatever variable we're
			performing the reference operator on. References are what allow us to
			refer to some value without having any ownership of it.<sup
			></sup> Thus, when we write:
		</p>
		<div class="note">
			<p>
				An important point: References are, in fact, pointers. Why not just
				call them pointers? Because references are a very basic kind of
				pointer. In Rust, they're pointers that do not actually own any
				data. Consider the differences:
			</p>
			<figure>
				<img
					src="{% static 'images/pointer_v_reference.svg' %}"
					alt="Pointer vs reference"
					loading="lazy"
					width="100px"
					height="80px"
				/>
			</figure>
			<p>
				In Scenarios ${A}$ and ${B,}$ we have the usual pointers. In ${A,}$
				we have <i>aliases</i> (multiple pointers to a single address
				containing data), and in ${B}$ we have pointers to different
				addresses, each with their own data. In ${C,}$ however, we have a
				<i>reference</i> &mdash; a pointer to an address that actually owns
				the data.
			</p>
		</div>
		<pre class="language-rust"><code>
			let y = &amp;x;
		</code></pre>
		<p>
			We are creating a reference to <var>x</var>, the reference being
			<var>y</var>. In Rustacean, this is called <b>borrowing</b>. It's
			similar to how we borrow things in the real world. Studying for an
			exam at the library, if we forgot our textbook at home, we might
			<i>borrow</i> the textbook from a friend. Now, if we were a bad
			friend, we might do things the true owner doesn't like, such as
			highlighting the textbook and making our own personal notes in the
			margins. In fact, this is precisely what languages like C allow us to
			do:
		</p>
		<pre class="language-c"><code>
			#include &lt;stdio.h&gt;

			int main() {
				int x = 10;
				printf("x = %d\n", x);
				int *y = &amp;x;
				*y = *y + 1;
				printf("x = %d\n", x);
				return 0;
			}
		</code></pre>
		<pre class="language-bash"><code>
			x = 10
			x = 11
		</code></pre>
		<p>
			Rust, however, sees this as just a bad thing to do. If you don't own
			something, you shouldn't be doing things to it:
		</p>
		<pre class="language-rust"><code>
			fn main() {
				let x = String::from("hi");
				let y = &amp;x;
				y.push_str(" world!");
			}
		</code></pre>
		<pre class="language-bash"><code>
			error[E0596]: cannot borrow `*y` as mutable, as it is behind a `&` reference
			--> main.rs:4:2
				|
			3 |     let y = &amp;x;
				|             -- help: consider changing this to be a mutable reference: `&mut x`
			4 |     y.push_str(" world!");
				|     ^^^^^^^^^^^^^^^^^^^^^ `y` is a `&` reference, so the data it refers to cannot be borrowed as mutable
		</code></pre>
	</section>

	<section id="mutable_borrow">
		<h3>Mutable Borrowing</h3>
		<p>Consider the code below:</p>
		<pre class="language-rust"><code>
			fn main() {
				let m = String::from("hi");
				let n: &String = &amp;m;
				n.push_str(" world");
			}
		</code></pre>
		<pre class="language-bash"><code>
			error[E0596]: cannot borrow `*n` as mutable, as it is behind a `&` reference
			--> main.rs:4:2
				|
			3 |     let n: &String = &amp;m;
				|                      -- help: consider changing this to be a mutable reference: `&mut m`
			4 |     n.push_str(" world");
				|     ^^^^^^^^^^^^^^^^^^^^ `n` is a `&` reference, so the data it refers to cannot be borrowed as mutable
		</code></pre>
		<p>
			Notice how the output is telling us that we cannot modify the
			original string, <var>m</var>, through the reference <var>n</var>. We
			can, however, modify our code to allow for mutation:
		</p>
		<pre class="language-rust"><code>
			fn main() {
				let mut m = String::from("hi");
				let n: &mut String = &mut m;
				n.push_str(" world");
				println!("{}", n);
			}
		</code></pre>
		<pre class="language-bash"><code>
			hi world
		</code></pre>
		<p>The changes we made:</p>
		<ol>
			<li>Changing <var>&m</var> to <var>&mut m</var>.</li>
			<li>
				Changing the type from <var>&String</var> to
				<var>&mut String</var>.
			</li>
		</ol>
		<p>
			In making the changes above, we effectively told Rust to treat
			<var>m</var>'s data as mutable through <var>n</var>.
		</p>
	</section>

	<section id="dereferencing">
		<h3>Dereferencing</h3>
		<p>
			When we attempt to modify a non-mutable reference, we might have
			noticed the following line in the resulting error message:
		</p>
		<pre class="language-bash"><code>
			cannot borrow `*n` as mutable, as it is behind a `&` reference
		</code></pre>
		<p>
			What does the <var>`*n`</var> mean? The <var>*</var> operator is the
			<b>dereference operator</b>, similar to what we'd see in C. The
			difference from C, however, is that Rust automatically dereferences
			pointers for us. When we write:
		</p>
		<pre class="language-rust"><code>
			let mut m = String::from("hi");
			let n: &mut String = &mut m;
			<mark>n.push_str(" world");</mark>
		</code></pre>
		<p>We are actually writing:</p>
		<pre class="language-rust"><code>
			let mut m = String::from("hi");
			let n: &mut String = &mut m;
			<mark>(*n).push_str(" world");</mark>
		</code></pre>
		<p>
			This is similar to how dereferencing works in languages like C. When
			we write, <var>*n</var>, we're saying,
			<q
				>Go to the address stored in <var>n</var>, and use the data that
				address points to.</q
			><sup></sup>
		</p>
		<div class="note">
			<p>For comparison, consider the following C code and its output:</p>
			<pre class="language-c"><code>
				#include &lt;stdio.h&gt;

				int main() {
					int a = 10;
					int* b = &amp;a;
					printf("&a : %p\n", &a);
					printf("&b : %p\n", &b);
					printf("*b : %d\n", *b);
					printf("a : %d\n", a);
					printf("b : %p\n", b);
					return 0;
				}
			</code></pre>
			<pre class="language-bash"><code>
				&a : 0x7ffee4720188
				&b : 0x7ffee4720180
				*b : 10
				a : 10
				b : 0x7ffee4720188
			</code></pre>
		</div>
	</section>
</section>

{% endblock %}
