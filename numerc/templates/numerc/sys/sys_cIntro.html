{% extends '../layout.html' %} {% load static %} {% block description %}
<meta
	name="description"
	content="Introduction to computer systems and C"
/>
{% endblock %} {% block title %}
<title>C Introduction</title>
{% endblock %} {% block content %}
<h1>The Basics of C</h1>
<section id="intro">
	<p>Nodding to tradition, here is our introductory C program:</p>
	<pre class="language-c"><code>
		#include &lt;stdio.h&gt;
		int main() {
			// Prints hello world
			printf("Hello, world\n");
			return 0;
		}

		/*
		 * The program above
		 * outputs "Hello, world" to the console
		*/
	</code></pre>
	<p>
		The program we've written above is called a
		<span class="term">source program</span>, and it's stored in a
		<span class="term">source file</span> (in the example above, the source
		program is stored in a file named <var>Hello.c</var>). The entire
		program is a collection of bytes, which are chunks of 8 bits. Every bit
		has a <span class="term">state</span>, which can be only one of two
		values: 0 or 1. Accordingly, every program, across all languages, is a
		sequence of 0s and 1s.
	</p>
	<p>
		Every character in the source program above is represented by unique
		integer, as proscribed by the ASCII standard (or, in most modern
		standards, UNICODE). For example, the character <var>#</var> is
		represented by the integer 35, <var>i</var> by 105, <var>\n</var> by
		10, and whitespace (denoted <var>SP</var>) by 32. The program also
		contains a <span class="italicsText">comment</span>, the text preceded
		by two forward slashes, <var>//</var>. By appending <var>//</var> to a
		line of text, we instruct the compiler to ignore the text. For comments
		spanning multiple lines, we use <var>/* */</var>.
	</p>
	<p>
		Files like <var>Hello.c</var> are called
		<span class="italicsText">text files</span> &mdash; files that consist
		exclusively of ASCII characters. All other files are called
		<span class="italicsText">binary files</span>. For reasons we will see
		later, this is a helpful distinction to keep in mind.
	</p>
</section>

<section id="arithmetic_operators">
	<h2>Basic Operators</h2>
	<p>
		C provides the typical primitive operators we would expect from a
		programming language: Addition, subtraction, multiplication, division,
		and the remainder operation.
	</p>
	<pre class="language-c"><code>
		#include &lt;stdio.h&gt;

		int main() {
			// addition
			int sum = 12 + 10;
			printf("12 + 10 = %i\n", sum);
		
			// subtraction
			int difference = 12 - 10;
			printf("12 - 10 = %i\n", difference);
		
			// multiplication
			int product = 12 * 12;
			printf("12 * 12 = %i\n", product);
		
			// division
			int quotient = 20 / 10;
			printf("20 / 10 = %i\n", quotient);
		
			// remainder operation
			int remainder = 15 % 2;
			printf("15 %% 2 = %i\n", remainder);
		
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		12 + 10 = 22
		12 - 10 = 2
		12 * 10 = 144
		20 / 10 = 2
		15 % 2 = 1
	</code></pre>
	<p>
		Because C is a relatively old language, the API of native operators is
		fairly small. The most important operators are presented in the table
		below.
	</p>
	<div class="twoColumn">
		<table class="alg">
			<thead>
				<th colspan="2">Arithmetic Operators</th>
			</thead>
			<tbody>
				<tr>
					<td>+</td>
					<td>Add</td>
				</tr>
				<tr>
					<td>-</td>
					<td>Subtract</td>
				</tr>
				<tr>
					<td>*</td>
					<td>Multiply</td>
				</tr>
				<tr>
					<td>/</td>
					<td>Divide</td>
				</tr>
				<tr>
					<td>%</td>
					<td>Remainder operator</td>
				</tr>
				<tr>
					<td>++</td>
					<td>Increment</td>
				</tr>
				<tr>
					<td>++</td>
					<td>Decrement</td>
				</tr>
			</tbody>
		</table>
		<table class="alg">
			<thead>
				<th colspan="2">Relational Operators</th>
			</thead>
			<tbody>
				<tr>
					<td>==</td>
					<td>Equal</td>
				</tr>
				<tr>
					<td>!=</td>
					<td>Not equal</td>
				</tr>
				<tr>
					<td>></td>
					<td>Greater than</td>
				</tr>
				<tr>
					<td><</td>
					<td>Less than</td>
				</tr>
				<tr>
					<td>>=</td>
					<td>Greater than or equal to</td>
				</tr>
				<tr>
					<td><=</td>
					<td>Less than or equal to</td>
				</tr>
			</tbody>
		</table>
		<table class="alg">
			<thead>
				<th colspan="2">Logical Operators</th>
			</thead>
			<tbody>
				<tr>
					<td>&&</td>
					<td>Logical and</td>
				</tr>
				<tr>
					<td>||</td>
					<td>Logical or</td>
				</tr>
				<tr>
					<td>!</td>
					<td>Logical not</td>
				</tr>
				<tr>
					<td>? :</td>
					<td>Logical ternary</td>
				</tr>
			</tbody>
		</table>
		<table class="alg">
			<thead>
				<th colspan="2">Bitwise Operators</th>
			</thead>
			<tbody>
				<tr>
					<td>&</td>
					<td>Bitwise and</td>
				</tr>
				<tr>
					<td>|</td>
					<td>Bitwise or</td>
				</tr>
				<tr>
					<td>^</td>
					<td>Bitwise xor</td>
				</tr>
				<tr>
					<td>~</td>
					<td>Bitwise one's complement</td>
				</tr>
				<tr>
					<td><<</td>
					<td>Bitwise shift left</td>
				</tr>
				<tr>
					<td>>></td>
					<td>Bitwise shift right</td>
				</tr>
			</tbody>
		</table>

		<table class="alg">
			<thead>
				<th colspan="2">Data Operators</th>
			</thead>
			<tbody>
				<tr>
					<td>sizeof()</td>
					<td>Get the size of</td>
				</tr>
				<tr>
					<td>${A}$[]</td>
					<td>Array subscript, where ${A}$ is an array identifier</td>
				</tr>
				<tr>
					<td>&</td>
					<td>The address of</td>
				</tr>
				<tr>
					<td>*</td>
					<td>The value of</td>
				</tr>
				<tr>
					<td>-></td>
					<td>Structure dereference</td>
				</tr>
				<tr>
					<td>${S}$.${x}$</td>
					<td>
						Structure reference, where ${S}$ is some structure and ${x}$ is
						some field within the structure ${S.}$
					</td>
				</tr>
			</tbody>
		</table>

		<table class="alg">
			<thead>
				<th colspan="2">Assignment Operators</th>
			</thead>
			<tbody>
				<tr>
					<td>=</td>
					<td>Assign equal</td>
				</tr>
				<tr>
					<td>+=</td>
					<td>Assign plus-equal</td>
				</tr>
				<tr>
					<td>-=</td>
					<td>Assign minus-equal</td>
				</tr>
				<tr>
					<td>*=</td>
					<td>Assign multiply-equal</td>
				</tr>
				<tr>
					<td>/=</td>
					<td>Assign divide-equal</td>
				</tr>
				<tr>
					<td>%=</td>
					<td>Assign modulus-equal</td>
				</tr>
				<tr>
					<td><<=</td>
					<td>Assign shift-left-equal</td>
				</tr>
				<tr>
					<td>>=</td>
					<td>Assign shift-right-equal</td>
				</tr>
				<tr>
					<td>&=</td>
					<td>Assign and-equal</td>
				</tr>
				<tr>
					<td>^=</td>
					<td>Assign xor-equal</td>
				</tr>
				<tr>
					<td>|=</td>
					<td>Assign or-equal</td>
				</tr>
			</tbody>
		</table>
	</div>
</section>

<section id="variables">
	<h2>Variables</h2>
	<p>
		In the ancient Greek saga
		<i>The Twelve Labors</i>, the Greek demigod Hercules travels throught
		the far reaches of the Greco-Roman world, completing various tasks. As
		remarkable and brave Hercules is, he does not complete these tasks
		alone. Throught the saga, he obtains information and assistance from
		various persons. In the first task, killing the Nemean lion, a boy
		provides Hercules some data: If he slew the Nemean lion and returned
		alive within 30 days, the town would sacrifice a lion to Zeus, but if
		he did not, the boy would sacrifice himself. In the eleventh task, when
		Hercules must steal three golden apples from the Garden of the
		Hesperides, Hercules abducts the Old Man of the Sea and compels him to
		reveal the location of the garden.
	</p>
	<p>
		Variables in C are akin to the minor characters of the Herculean saga.
		They hold information, and that information can be one of two things:
		(1) A literal value, or (2) an address. The C programmer, however, is
		much more powerful than Hercules &mdash; she can create these lesser
		characters at her bidding. This is done through
		<span class="term">variable declaration</span> and
		<span class="term">assignment</span>, which can both be done
		simultaneously in a process called
		<span class="term">variable initialization</span>:
	</p>
	<pre class="language-c"><code>
		#include &lt;stdio.h&gt;
		int main() {
			int x; // variable declaration
			x = 2; // variable assignment
			int y = 3; // variable initialization
			return 0;
		}
	</code></pre>
	<p>To initialize a variable in C, we employ the following syntax:</p>
	<figure class="math-display">
		<ul class="syntax">
			<li>${t}$ ${n}$ = ${val}$</li>
		</ul>
		<figcaption>
			where ${t}$ is a data type, ${n}$ is the variable's name, and ${val}$
			is the data we assign to ${n}$
		</figcaption>
	</figure>
</section>

<section id="data_types">
	<h2>Data Types</h2>
	<p>
		C is a statically- and explicitly-typed language. In the context of
		variables, this means we must explicitly state what type of data a
		particular variable will hold. In C, there several primitive data types
		(data types built in to the language). We provide an explicit data type
		in C to instruct the compiler how much memory should be allocated in
		memory for the data. How much memory a data type takes, however,
		depends on the compiler, or more generally, on the system architecture
		(i.e., 32b compiler vs. 64b compiler).
	</p>
	<p>
		Examining the table below, it's helpful recall the units of computer
		memory. One byte (denoted ${1~\text{B}}$) is made of eight bits
		(denoted ${8~\text{b}}$). And a single bit is one of two values: ${0}$
		or ${1.}$ An
		<b>unsigned 8-bit variable</b> is a variable that can take on values
		between ${0}$ and ${2^8 - 1 = 255.}$ A <b>signed 8-bit variable</b> can
		take on values between ${\texttt{-}127}$ and ${\texttt{+}127.}$ Thus,
		when a variable is <i>signed</i>, half of its total range is spread
		below zero, the other half above zero.
	</p>
	<ol>
		<li><var>char</var></li>
		<ul>
			<li>Single textual characters</li>
			<li>1B</li>
			<li>Has a value range of ${[-128, 127]}$ or ${[0, 255]}$</li>
		</ul>
		<li><var>unsigned char</var></li>
		<ul>
			<li>Single textual characters</li>
			<li>1B</li>
			<li>Has a value range of ${[0, 255]}$</li>
		</ul>
		<li><var>signed char</var></li>
		<ul>
			<li>Single textual characters</li>
			<li>1B</li>
			<li>Has a value range of ${[-128, 127]}$</li>
		</ul>
		<li><var>int</var></li>
		<ul>
			<li>Integers</li>
			<li>2B on a 32-bit compiler, 4B on a 64-bit.</li>
			<li>
				On a 32-bit compiler, ${[-32768, \space 32767].}$ And on a 64-bit
				compiler, ${[-2147483648, \space 2147483647].}$
			</li>
		</ul>
		<li><var>unsigned int</var></li>
		<ul>
			<li>Positive integers</li>
			<li>On a 32-bit compiler, 2B, and on a 64-bit compiler, 4B.</li>
			<li>
				On a 32-bit compiler, ${[0, \space 65535],}$ and on a 64-bit
				compiler, ${[0, \space 4294967295].}$
			</li>
		</ul>
		<li><var>short</var></li>
		<ul>
			<li>Short integers</li>
			<li>2B</li>
			<li>${[-32768, 32767]}$</li>
		</ul>
		<li><var>unsigned short</var></li>
		<ul>
			<li>Short positive integers</li>
			<li>2B</li>
			<li>${[0, 65535]}$</li>
		</ul>
		<li><var>long</var></li>
		<ul>
			<li>long integers</li>
			<li>On a 32-bit compiler, 4B, and on a 64-bit compiler, 8B.</li>
			<li>${[-9223372036854775808, 9223372036854775807]}$</li>
		</ul>
		<li><var>unsigned long</var></li>
		<ul>
			<li>long positve integers</li>
			<li>8B</li>
			<li>${[0, 18446744073709551615]}$</li>
		</ul>
		<li><var>float</var></li>
		<ul>
			<li>floating-point numbers (numbers with a decimal point)</li>
			<li>4B</li>
			<li>
				${[1.2 \times 10^{-38}, 3.4 \times 10^{38}]}$ (6 decimal places)
			</li>
		</ul>
		<li><var>double</var></li>
		<ul>
			<li>double-precision floating point numbers</li>
			<li>8B</li>
			<li>
				${[2.3 \times 10^{-308}, 1.7 \times 10^{308}]}$ (15 decimal places)
			</li>
		</ul>
		<li><var>long double</var></li>
		<ul>
			<li>floating point numbers</li>
			<li>10B</li>
			<li>
				${[3.4 \times 10^{-4932}, 1.1 \times 10^{4932}]}$ (19 decimal
				places)
			</li>
		</ul>
	</ol>

	<p>
		Of note, C does not have a built-in data type for Boolean values.
		Instead, any nonzero value is equivalent to
		<var>true</var>, and 0 is equivalent to <var>false</var>. Because of
		this approach, the result of applying a relational or logical operator
		is always a ${0}$ (false) or a ${1}$ (true). We can, however, include
		the header file <var>&lt;stdboo.h&gt;</var>, in which case the data
		type <var>bool</var> is provided.
	</p>
	<pre class="language-c"><code>
		#include &lt;stdbool.h&gt;
		int main() {
			bool x = true;
			bool y = false;
		}
	</code></pre>

	<section id="size_test">
		<h3>Machine Size Test</h3>
		<p>
			We can determine the memory allocations for a given machine by
			running the code below:
		</p>
		<pre class="language-c"><code>
			#include &lt;stdio.h&gt;

			int main(int argc, char *argv[]) {
				printf("a char is %ld bytes\n", sizeof(char));
				printf("an int is %ld bytes\n", sizeof(int));
				printf("an float is %ld bytes\n", sizeof(float));
				printf("a double is %ld bytes\n", sizeof(double));
				printf("a short int is %ld bytes\n", sizeof(short int));
				printf("a long int is %ld bytes\n", sizeof(long int));
				printf("a long double is %ld bytes\n", sizeof(long double));

				return 0;
			}
		</code></pre>
		<pre class="language-bash"><code>
			a char is 1 bytes
			an int is 4 bytes
			an float is 4 bytes
			a double is 8 bytes
			a short int is 2 bytes
			a long int is 8 bytes
			a long double is 16 bytes
		</code></pre>
	</section>
</section>

<section id="binary_and_hex">
	<h2>Binary & Hexadecimal</h2>
	<p>As we know, there are three number systems we use in computing:</p>
	<ol>
		<li>decimal</li>
		<li>binary</li>
		<li>hexadecimal</li>
	</ol>
	<p>
		In decimal, we use the number ${10}$ as a base, corresponding to ${10}$
		digits:
	</p>
	<figure>$$ \{ 0,1,2,3,4,5,6,7,8,9 \} $$</figure>
	<p>
		In binary, we use the number ${2}$ as a base, corresponding to ${2}$
		digits for representation:
	</p>
	<figure>$$ \{ 0,1 \} $$</figure>
	<p>
		For computers, each binary place is called a <b>bit</b>. There are
		${8}$ bits in a byte. Although standard C does not define binary
		constants, GNU C, clang, and other popular compilers allow us to denote
		binary numbers with the modern <var><mark>0b</mark></var> or
		<var><mark>0B</mark></var> prefixes:
	</p>
	<pre class="language-c"><code>
		#include &lt;stdio.h&gt;

		int main() {
			int x = 0b01;
			int y = 0b10;
			int z = x + y;
			printf("%d + %d = %d \n", x, y, z);
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		1 + 2 = 3
	</code></pre>
	<p>
		Because we're limited to two digits, binary numbers can quickly grow
		too long for practical use. This is worsened by the fact that the
		numbers we need to interact with hardware on modern computers are big,
		big numbers. Accordingly, we have an even more concise way of
		expressing numbers: hexadecimal. In hex, we use a base of ${16:}$
	</p>
	<figure>$$ \{ 0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F \} $$</figure>
	<p>
		In terms of computer memory, ${2}$ hex digits make one byte (8 bits). A
		single hex digit (${4}$ bits, or half a byte) is called a
		<i>nibble</i>.<sup></sup> Like binary numbers, most modern compilers
		allow us to write hexadecimal numbers by prepending the prefix
		<var>0x</var>:
	</p>
	<div class="note">
		<p>Also spelled <q>nybble.</q></p>
	</div>
	<pre class="language-c"><code>
		#include &lt;stdio.h&gt;

		int main() {
			int x = 0xA57;
			int y = 0xB85;
			int z = x + y;
			printf("%d + %d = %d \n", x, y, z);
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		2647 + 2949 = 5596
	</code></pre>
	<p>
		In Assembly, hex numbers are often indicated by
		<var><mark>$</mark></var> prefix.
	</p>
</section>

<section id="casting">
	<h2>Casting</h2>
	<p>Consider the following code:</p>
	<pre class="language-c"><code>
		#include &lt;stdio.h&gt;

		int main() {
			double n = 3;
			double m = 2;
			int result = n / m;
			printf("result = %d\n", result);
			return 0;
		}
	</code></pre>
	<p>
		We would expect the value of <var>result</var> to be ${1.5.}$ But
		notice the output:
	</p>
	<pre class="language-bash"><code>
		1
	</code></pre>
	<p>
		In C, operations performed on arguments of the same type ${t}$ will
		output a return of type ${t.}$ An <var>int</var> times an
		<var>int</var> is an <var>int</var>, a <var>float</var> divided by a
		<var>float</var> is a <var>float</var>. However, if we assign a value
		of type <var>double</var> to a variable of type <var>int</var>, we will
		<b>implicitly cast</b> the <var>double</var> value to an
		<var>int</var>. This is what we're seeing above. To get back ${1.5,}$
		we must ensure <var>result</var> is of type <var>double</var>:
	</p>
	<pre class="language-c"><code>
		#include &lt;stdio.h&gt;

		int main() {
			double n = 3;
			double m = 2;
			double result = n / m;
			printf("result = %f\n", result);
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		result = 1.500000
	</code></pre>
</section>

<section id="loops">
	<h2>Loops</h2>
	<p>
		Loops in C are very much like other languages. Here is the for-loop:
	</p>
	<pre class="language-c"><code>
		#include &lt;stdio.h&gt;
		int main() {
			int SUM = 0;
			for (int i = 0; i < 5; i++) {
				SUM += i;
			}
			printf("Sum from 0 to 5 = %i\n", SUM);
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		Sum from 0 to 5 = 10
	</code></pre>
	<p>And here is the while-loop:</p>
	<pre class="language-c"><code>
		#include &lt;stdio.h&gt;
		int main() {
			int SUM = 0;
			int count = 0;
			while (count < 5) {
				SUM += count;
				count++;
			} 
			printf("Sum from 0 to 5 = %i\n", SUM);
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		Sum from 0 to 5 = 10
	</code></pre>
</section>

<section id="symbolic_constants">
	<h2>Symbolic Constants</h2>
	<p>
		When writing programs, we want to avoid writing magic numbers. This is
		particularly true for C programs, since we aren't afforded the same
		level of safety as we would in languages like Java. Remember, C is a
		low-level language. Magic numbers reduce readability, and readability
		is paramount in C programming &mdash; we don't have nearly as much
		syntactic sugar or idioms as other languages, so C programs tend to be
		verbose and longer. And the longer the program, the more valuable is
		readability.
	</p>
	<p>
		Suppose we want to sum the ages 12 through 30. We could use the same
		summing procedure above:
	</p>
	<pre class="language-c"><code>
		#include &lt;stdio.h&gt;
		int main() {
			int sum = 0;
			for (int i = 12; i <= 30; i++) {
				sum += i;
			}
			printf("age sum = %i\n", sum);
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		age sum = 399
	</code></pre>
	<p>
		The problem, however, is that the code isn't very readable. Why 12? Why
		30? To make it more readable, we want to use
		<span class="term">symbolic constants</span>:
	</p>
	<pre class="language-c"><code>
		#include &lt;stdio.h&gt;

		#define YOUNGEST_AGE 12
		#define OLDEST_AGE 30
		
		int main() {
			int sum_of_ages = 0;
			for (int age = YOUNGEST_AGE; age <= OLDEST_AGE; age++) {
				sum_of_ages += age;
			}
			printf("age sum = %i\n", sum_of_ages);
			return 0;
		}
	</code></pre>
	<pre class="language-bash"><code>
		age sum = 399
	</code></pre>
	<p>
		Symbolic constants are essentially symbols for specified values.
		Wherever the C compiler encounters a symbolic constant, it will replace
		it with the value we've specified. In this case,
		<var>YOUNGEST_AGE</var> is replaced with <var>12</var>, and
		<var>OLDEST_AGE</var> is replaced with 30.
	</p>
</section>

<section id="streams">
	<h2>Streams</h2>
	<p>
		C provides constructs for <span class="term">streams</span>. Such
		streams include, for example, user and file I/O. Each construct is
		presented.
	</p>
	<p>
		<span class="topic">User Input.</span> Recall that when we obtain input
		from a user, we <span class="italicsText">read</span> data from the
		user. For example, suppose we wanted to write a program that averages
		two grades. We could do so with the following:
	</p>
	<pre class="language-c"><code>
		#include &lt;stdlib&gt;

		int main() {
			int grade1 = 90;
			int grade2 = 85;
			int average = (grade1 + grade2) / 2;
			printf("average: %d\n", average);
			return 0;
		}
	</code></pre>
	<p>
		The program above works fine, but it isn't
		<span class="italicsText">general</span> &mdash; the program only works
		for a specific set of inputs. A more general program would be that one
		works for any arbitrary set of inputs. One way to implement such a
		program would be to read data from the user:
	</p>
	<pre class="language-c"><code>
		#include &lt;stdlib&gt;

		int main() {
			int grade1;
			int grade2;
			scanf("%d", &grade1);
			scanf("%d", &grade2);
			int average = (grade1 + grade2) / 2;
			printf("average: %d\n", average);
			return 0;
		}
	</code></pre>
</section>

<!-- <section id="casting">
	<h2>Casting</h2>
	<p></p>
</section> -->
{% endblock %}
