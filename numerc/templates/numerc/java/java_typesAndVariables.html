{% extends '../layout.html' %} {% load static %} {% block description %}
<meta name="description" content="Types and variables in Java" />
{% endblock %} {% block title %}
<title>Java Types and Variables</title>
{% endblock %} {% block content %}
<h1>Variables & Types</h1>

<section id="types_and_variables_in_java">
	<p>
		Programs need data. To give our programs that data, they must be stored
		somewhere in memory. But before we store any data in Java, we must tell Java
		beforehand that you are going to store data. To do so, we need
		<span class="term">variables</span> &mdash; an entity that holds a data-type
		value. In Java, every variable has a <span class="term">name</span> and a
		<span class="term">type</span>.
	</p>
	<pre class="language-java"><code>
		// Declare variable named c of type char
		char c;

		// Declare variable named num of type int
		int num;

		// Declare variable named isPresent of type boolean  
		boolean isPresent;
	</code></pre>

	<p></p>

	<p>
		In the example above, there are <span class="italicsText">comments</span>,
		denoted by two forward slashes (<span class="monoText">//</span>). Every
		other statement is called a <span class="term">declaration</span>. The left
		side is the variable's <span class="term">type</span>, and the right side
		the variable's <span class="term">name</span>. Simply put, variable
		declaration is the act of creating a variable.
	</p>
	<p>
		In programming, a
		<span class="boldItalics">comment</span> is a statement ignored by the
		compiler. Because they're ignored by the compiler, we can use them to
		annotate our code. Comments are valuable in programming. They tell readers
		what a particular statement means or does. But, they also take up space and
		too many comments can clutter a program, making it unreadable.
	</p>
	<p>
		Comments should be concise and descriptive. They should not be simply
		identical to the actual code (since that would simply be a waste of space).
	</p>
	<p>
		A brief note on terminology: There are different kinds of variables in Java.
		Variables that store primitive type values are called
		<span class="term">primitive variables</span> (or,
		<span class="term">primitive constants</span>). Variables that store objects
		are called <span class="term">object references</span>. With an object
		reference, the variable doesn't actually hold the object &mdash; it instead
		holds a reference to the object.
	</p>

	<section id="constants">
		<h3>Constants</h3>
		<p>
			Variables fall into two categories: (1) variables, and (2) constants. In
			languages like Java, the values we store in a variable can be mutated.
			Accordingly, the term variable, on its own, usually implies that the value
			stored in the variable can be mutated (again, in the context of Java; some
			languages do not permit such mutation). When we use the term
			<span class="italicsText">constant</span>, however, we are referring to a
			variable whose stored value <span class="underlineText">cannot</span> be
			changed.
		</p>
	</section>

	<section id="java_types">
		<h2>Types</h2>
		<p>
			Data comes in many forms. The "Call me Ishmael" and "WARNING" are textual
			data. The number of users visiting this page is numeric data. These data
			all take a different form, and there are things we can and cannot do with
			them. We can add 4 and 7, but we cannot divide "love" by "children" (at
			least not logically). Because of this fact, Java (and many other
			programming languages) classify data by
			<span class="boldItalics">type</span>.
		</p>
		<p>
			While a program runs, and while a file is open, it is stored in a hardware
			component called the
			<span class="boldItalics">RAM</span> ("Random Access Memory"). When you
			install programs and save files (and they are not running or open), they
			are stored in a different hardware component, the
			<span class="monoText">hard drive</span> (or
			<span class="italicsText">hard disk</span> or
			<span class="italicsText">solid state disk</span>; or a CD; or a USB;
			devices that store data, other than RAM). Devices like hard drives do not
			require electricity to store data. RAM, however, does. It is much faster
			than a hard drive, because it is a purely electronic device &mdash; unlike
			hard drives, there are no moving parts. With RAM, we have the ability to
			very quickly open files and execute programs, because everything is
			electric. This is why we lose data when our computer suddenly dies midway
			through writing a Word Document or a C program. The data is stored in RAM,
			and without electricity coming from the computer's power source,
			everything is lost.
		</p>
		<p>At a very high level overview, the RAM can be understood as:</p>
		<figure>
			<img
				src="{% static 'images/ram_allocation.svg' %}"
				alt="diagram of ram"
				loading="lazy"
			/>
			<figcaption>Visualizing RAM</figcaption>
		</figure>
		<p>
			Whenever we declare a variable in Java, we must explicitly state the
			variable's type. This is an instruction to the compiler that the
			particular variable will store a value of a particular type. We will see
			later why Java's designers decided to implement this feature.
		</p>
		<p>
			Now, once we declare a variable to be of a particular type, that
			variable's type can never change. For example, when write
			<span class="monoText">int x;</span> the variable
			<span class="monoText">x</span> will always store some value of type
			<span class="monoText">int</span>. That value may change later, but the
			variable's type <span class="monoText">int</span> can never be changed to
			<span class="monoText">double</span> or
			<span class="monoText">char</span>. Because of this trait &mdash; the
			prohibition of changing a variable's type after declaration &mdash; Java
			is described as a
			<span class="term">statically-typed language</span> (i.e., the language's
			types are &#8220;static&#8221;).
			<label for="typeCheck" class="margin-toggle">&#8853;</label>
			<input type="checkbox" id="typeCheck" class="margin-toggle" />
			<span class="marginnote"
				>The other end of the spectrum are the
				<span class="term">dynamically-typed languages</span> like JavaScript;
				in these languages, a variable can store an integer, then later store a
				Boolean, then later store a string. Furthermore, type checking is done
				at runtime &mdash;
				<span class="term">dynamic type checking</span>.</span
			>
		</p>
		<p>
			Whenever we compile Java source code, the
			<span class="monoText">javac</span> compiler will check all of our source
			code to ensure we are complying with Java's type-checking rules. Because
			type checking is done at compile time, we say that Java employs a
			<span class="term">static type checking</span> system.
		</p>
		<p>
			With few exceptions relating to scope &mdash; in Java, once you have
			declared a variable name of a particular type, you cannot redeclare it
			later down the program:
		</p>
		<pre class="language-java"><code>
			// Declare variable named c of type char
			char c;
	
			// Variable is already declared, this will return an error
			char c;
	
			// This also won't work, even if it's of different type
			int c;
		</code></pre>
		<p>
			Even if the last example worked, it would be a stark example of
			<span class="italicsText">dirty code</span>, poor programming hygiene. How
			will our future selves or other coders tell the two apart?
		</p>
		<p>
			In Java, there are eight
			<span class="term">primitive data types</span>. All other data in Java is
			represented by some combination of these eight primitive types. The types
			fall into four broad categories:
		</p>
		<figure class="math-display">
			<div class="rule">
				<ol>
					<li>integers</li>
					<li>floating point numbers</li>
					<li>text</li>
					<li>boolean</li>
				</ol>
			</div>
		</figure>

		<section id="int_and_binary">
			<h3>Integer Type</h3>
			<p>
				Integers are the whole numbers and their negative counterparts (e.g., 0,
				5, -11, 27, etc.). In Java, these numbers can be represented by any one
				of these four types:
			</p>
			<pre class="language-java"><code>
				byte
				short
				int
				long
			</code></pre>
			<p>
				We will later discuss why there are 4 different types. For now, let's
				review some representation. As we know, the computer doesn't actually
				know what <span class="monoText">2</span> or
				<span class="monoText">17</span> are &mdash; the computer only
				understands 1s and 0s. As such, integers, written in Hindu-Arabic
				numerals, must be translated to binary form for the computer to process.
			</p>

			<section id="twos_comlement">
				<h4>Two's-Complement</h4>
				<p>
					With the natural numbers, we can convert these easily. The number
					${2}$ is ${10_{[0]}}$ in binary, and ${17}$ is ${10001_{[0]}.}$ But
					how do we deal with negative integers?
				</p>
				<p>
					Let's consider the data type <span class="monoText">byte</span>. As
					its name implies, a <span class="monoText">byte</span> can only hold 8
					bits. With 8 bits, we can represent ${2^n}$ unique bit patterns,
					starting from ${00000000_{[0]}}$ (0 in decimal) through
					${01111111_{[0]}}$ (127 in decimal). Hang on. Why is is there ${0}$
					there? Shouldn't it be ${01111111_{[0]}}$ (128)? That ${0}$ is called
					the <span class="term">sign bit</span>. If the number is positive, the
					sign bit is ${0,}$ and if it's negative, the sign bit is ${1.}$
				</p>
				<p>
					The next question, however, is how does the computer
					<span class="italicsText">store</span> negative integers? For example,
					if we wrote ${-5,}$ how does the computer go from this literal to
					binary? The answer is through
					<span class="term">two's-complement</span>. The idea is fairly
					straightforward. Let's start with the number ${5,}$ stored in a
					<span class="monoText">byte</span>, and work our way to negative
					${5.}$ First, we represent the number ${5}$ in binary:
				</p>
				<figure>
					<div>
						<p>${00000101_{[0]}}$</p>
					</div>
				</figure>
				<p>
					Next, we take what we call the
					<span class="term">one's-complement</span>. Essentially, we, invert,
					or change, all of the digits into their opposites:
				</p>
				<figure class="math-display">
					<div>
						<p>${11111010_{[0]}}$</p>
					</div>
				</figure>
				<p>Then, we add ${1}$ to the one's-complement:</p>
				<figure class="math-display">
					<div>
						$$ \begin{align*} 11111010_{[0]} \\ + 00000001_{[0]} \\ \hline
						11111011_{[0]} \end{align*} $$
					</div>
				</figure>
				<p>
					This result, ${11111011_{[0]},}$ is called
					<span class="term">two's-complement</span>. Notice that we now have a
					${1}$ as the sign-bit. This is a negative number, but it's not ${-5,}$
					as read. We need the ${5.}$ To get the ${5,}$ we simply take the
					two's-complement of ${11111011_{[0]},}$ while keeping the sign bit in
					place.
				</p>
				<p>
					As an aside, notice that when we add the binary representation of
					${5}$ to the binary representation of ${-5,}$ we get ${0:}$
				</p>
				<figure class="math-display">
					<div>
						$$ \begin{align*} 00000101_{[0]} \space &(5_{[10]}) \\ +
						11111011_{[0]} \space &(-5_{[10]}) \\ \hline 00000000_{[0]} \space
						&(0_{[10]}) \end{align*} $$
					</div>
				</figure>
			</section>
		</section>

		<section id="floating_points">
			<h3>Floating Point Types</h3>
			<p>
				Floating point numbers are those numbers with fractional parts, or
				decimal points (i.e., 0.0, 12.9, 3.14, -1.29, etc.) We can represent
				these numbers with any one of these two types:
			</p>
			<pre class="language-java"><code>
				float pi = 3.14;
				double e = 0.577;
			</code></pre>
		</section>

		<section id="textual_data">
			<p>
				<span class="topic">Text.</span> There are two ways to represent textual
				data in Java: with the primitive type
				<span class="monoText">char</span> or with the abstract data type
				<span class="monoText">String</span>. We will investigate what the
				differences between a primitive type and an abstract data type are in
				later sections, but for now, it suffices to understand that
				<span class="monoText">char</span> is a primitive, but
				<span class="monoText">String</span> is not.
			</p>
			<p>
				The <span class="monoText">char</span> type represents individual
				alphanumeric characters for symbols. There are ${2^16}$ different
				possible <span class="monoText">char</span> values; this includes
				letters, numbers, symbols, and whitespace characters like single-space,
				tab, and newline.
			</p>
			<pre class="language-java"><code>
				char x = 'x';
				String n = "Hello";
			</code></pre>
			<p>
				The <span class="monoText">String</span> type represents
				<span class="underlineText">sequences</span> of characters. In Java, we
				denote strings by enclosing a sequence of characters in double quotes.
			</p>
		</section>

		<section id="boolean">
			<p>
				<span class="topic">Boolean.</span> Boolean values are the binary values
				<span class="monoText">true</span> and
				<span class="monoText">false</span>. These are the only two values under
				the type.
			</p>
			<pre class="language-java"><code>
				boolean a = true;
				boolean b = false;
			</code></pre>
		</section>

		<p>With just these eight types:</p>
		<ul>
			<li><span class="monoText">byte, short, int, long</span></li>
			<li><span class="monoText">float, double</span></li>
			<li><span class="monoText">char</span></li>
			<li><span class="monoText">boolean</span></li>
		</ul>
		<p>we can represent any data that a computer can work with.</p>
		<p>
			<span class="topic">Initialization.</span> Once we have declared a
			variable, we can assign it data. In doing so, we
			<span class="term">initialize</span> the variable (we give the variable an
			<span class="italicsText">initial</span> value):
		</p>
		<pre class="language-java"><code>
			// declaration
			float increment;
	
			// initialization
			increment = 0.1;
	
			// inline-initialization: declare and initialize in one line
			boolean isItSnowing = false;
			long weightBlueWhale = 330000;  
		</code></pre>
		<p>
			In the example above, notice that we can declare and initialize variables
			in one line. This is called
			<span class="term">inline-initialization</span>.
		</p>
		<p>
			Note that every statement in Java ends with a semicolon (<span
				class="monoText"
				>;</span
			>). Java is a <span class="term">semicolon-delimited language</span>.
		</p>
		<p>
			To use variables in Java, they <span class="underlineText">must</span> be
			initialized:
		</p>
		<pre class="language-java"><code>
			double x;
			System.out.println(x);
		</code></pre>
		<pre class="language-bash"><code>
			Line 3: error: variable x might not have been initialized
			System.out.println(x);
												^
			1 error
		</code></pre>
		<p>
			A <span class="term">literal</span> is the Java source code representation
			of a data-type value. The number or value we explicitly assign to a
			variable is called a literal. In programs, there are values that change as
			the program runs; an <span class="italicsText">incrementer</span> or
			<span class="italicsText">accumulator</span>, for example. Literals are
			those values that are not computed; they are explicitly written. They
			might be manipulated, but the value we explicitly wrote always appears
			directly in our source code.
		</p>
		<p>
			The opposite of a literal is an <span class="term">expression</span>. An
			expression is a combination of literals, variables, and operations that
			Java must <span class="underlineText">evaluate</span> to produce a single
			value. We can also think of the expression as the Java source code
			representation of a computation.
		</p>
		<pre class="language-java"><code>
			// These are literals
			char tic = 'x';
			char tac = 'o'; 
	
			// Note the L suffix; this is how we tell Java that this is big number
			long bigNum = 10000L;
	
			boolean isComplete = true;
			boolean isIncomplete = false;
	
			// These are expressions, not a literal
			int foo = 1 + 1;
			long biggerNum = bigNum + 10000L;
		</code></pre>

		<section id="modifying_variables">
			<p>
				<span class="topic">Modifying Variables.</span> Once a value is assigned
				to a variable, we can modify it as the program runs:
			</p>
			<pre class="language-java"><code>
				int changing = 10; 
		
				changing = 20; // assign a new value
		
				changing = 20 + 20; // Arithmetic is ok right of =
		
				changing += 1; // Add 1, assign it the result
		
				changing -= 1; // Subtract 1, assign it the result
		
				changing *= 2; // Multiply by 2, assign it the result
		
				changing /= 2; // Divide by 2, assign it the result 
			</code></pre>
			<p>
				We can also modify variables by assigning existing variables. Always
				read assignments from right to left:
			</p>
			<pre class="language-java"><code>
				double first = 10.0;
				double second = 5.0;
				first = second // assignment, right to left
				second = 20.0;
				first = second + 10.0;
				double third = 2.0;
				first = second + third; // arithmetic with variables on right is ok
		
				int z = 10;
				z = z + 1; // z is now 11
			</code></pre>
			<p>
				The last example reveals a crucial point about assignment, and why we
				want to always read them from right to left. The value assigned to
				<span class="monoText">z</span> at the very last line is first computed
				&mdash; <span class="monoText">z + 1</span> &mdash; then assigned. The
				value stored in <span class="monoText">z</span> when
				<span class="monoText">z + 1</span> is computed is
				<span class="monoText">10</span>, so the value assigned to
				<span class="monoText">z</span> at the very last line is
				<span class="monoText">11</span>.
			</p>
		</section>

		<section id="type_safety">
			<p>
				<span class="topic">Type Safety.</span> Once we declare a variable in
				that variable must maintain its type. We cannot, say, declare a variable
				<span class="monoText">num</span> of type
				<span class="monoText">int</span>, and thereafter assign to it data of
				type <span class="monoText">float</span>:
			</p>
			<pre class="language-java"><code>
				int num = 10;
				num = 10.0; // error is returned
			</code></pre>
			<p>Failure to remember this rule can lead to unexpected results:</p>
			<pre class="language-java"><code>
				int num = 35;
				num /= 2;
				System.out.println(num);
			</code></pre>
			<pre class="language-bash"><code>
				11
			</code></pre>
			<p>
				The correct answer to the above should be ${11.\overline{6}.}$ (The
				overline, called a <span class="italicsText">vinculum</span>, indicates
				repeating digits). We're getting
				<span class="monoText">11</span> because
				<span class="monoText">num</span> was declared to store data of type
				<span class="monoText">int</span>. Note that there is no rounding
				occurring here. Java is simply dropping the fractional digits.
			</p>
			<p>Note that Strings in Java must be enclosed in double quotes:</p>
			<pre class="language-java"><code>
				System.out.println("Hello, world!'); // causes an error
				System.out.println("Hello, world!"); // no error
			</code></pre>
			<p>
				<span class="topic">Why &#8220;Primitive&#8221; Type?</span> The eight
				types above are referred to as &#8220;primitive&#8221; types because
				they can all be represented by numbers. The numeric data types
				<span class="monoText">byte, short, int, long, float, double</span> can
				obviously all be represented by numbers. But what about
				<span class="monoText">char</span> and
				<span class="monoText">boolean</span>? Well,
				<span class="monoText">boolean</span> is simply a binary value &mdash;
				we can represent <span class="monoText">false</span> with
				<span class="monoText">0</span> and
				<span class="monoText">true</span> with <span class="monoText">1</span>.
				<span class="monoText">char</span> is more interesting. In programming,
				English characters have a corresponding numeric code called an
				<span class="term">ASCII code</span>, found in the ASCII table. Because
				each letter is encoded in ASCII with numbers, they too can be
				represented as numbers. ASCII has generally gone along the wayside,
				replaced by the much larger UNICODE enconding system. This is due to
				ASCII encoding only English characters &mdash; obviously English isn't
				the only language we speak. UNICODE encodes a large set of characters,
				from &#x627;&#x644;&#x641;&#x628;&#x627;&#x6CC;
				&#x641;&#x627;&#x631;&#x633;&#x6CC; to &#129313;.
			</p>
			<p>
				<span class="topic">Strongly-typed v. Weakly-typed Languages</span> In
				many languages, like Python and JavaScript, we, the programmers, are not
				required to explicitly state what types our data are. These are called
				<span class="italicsText">weakly-typed languages</span>. Java and C,
				however, are <span class="italicsText">strongly-typed</span> languages
				&mdash; we must explicitly provide a datum's type. The benefit of
				strongly-typed languages: It forces us to specify how much space we need
				to store data. This means we have no choice but to be efficient.
				Moreover, it helps us catch some of the most common programming errors.
			</p>
		</section>
	</section>

	<section id="type_numbers_why">
		<h3>Why are there are so many types?</h3>
		<p>
			Java provides a variety of types to manage memory and to respond to
			hardware advances. Each of the types takes up a certain amount of memory.
			Here's an API:
		</p>
		<figure class="table">
			<table class="api">
				<thead>
					<th>Java Primitive Type</th>
					<th>Bytes Required</th>
					<th>Range</th>
					<th>Default</th>
				</thead>
				<tbody>
					<tr>
						<td>boolean</td>
						<td rowspan="2">1 byte</td>
						<td>
							<span class="monoText">true</span>,
							<span class="monoText">false</span>
						</td>
						<td><span class="monoText">false</span></td>
					</tr>
					<tr>
						<td>byte</td>
						<td>${[-128..127]}$</td>
						<td><span class="monoText">0</span></td>
					</tr>
					<tr>
						<td>char</td>
						<td rowspan="2">2 bytes</td>
						<td>${[0..65535]}$</td>
						<td><span class="monoText">\u0000</span></td>
					</tr>
					<tr>
						<td>short</td>
						<td>${[-32768..32767]}$</td>
						<td><span class="monoText">0</span></td>
					</tr>
					<tr>
						<td>int</td>
						<td rowspan="2">4 bytes</td>
						<td>${[-2147483649..2147483647]}$</td>
						<td><span class="monoText">0</span></td>
					</tr>
					<tr>
						<td>float</td>
						<td>${[-1.4 \times 10^{-45}..3.4 \times 10^{38}]}$</td>
						<td><span class="monoText">0.0f</span></td>
					</tr>
					<tr>
						<td>long</td>
						<td rowspan="2">8 bytes</td>
						<td></td>
						<td><span class="monoText">0</span></td>
					</tr>
					<tr>
						<td>double</td>
						<td>${[-4.39 \times 10^{-324}..1.7 \times 10^{308}]}$</td>
						<td><span class="monoText">0.0d</span></td>
					</tr>
				</tbody>
			</table>
		</figure>
		<p>
			But why so many? For example, <span class="monoText">byte</span>,
			<span class="monoText">int</span>, <span class="monoText">short</span>,
			and <span class="monoText">long</span> all represent integers. But why are
			there four separate types? The answer is a combination of history and
			economics.
		</p>
		<p>
			First, all of the computations done by a computer are ultimately done by
			the computer's CPU. Without the CPU, a computer would just be a metal
			brick. Now, we might have heard of various terms like &#8220;64-bit
			processors&#8221; or &#8220;32-bit processors&#8221;. At the time of
			writing, mainstream processors are 64-bit processors. Before this, we had
			32-bit processors, and before that, 16-bit processors. There were, and
			are, 12-bit, 8-bit, and 4-bit processors. What do these terms mean?
		</p>
		<p>
			In our early years, we learned to count with our fingers. 5 for five
			fingers, and 10 for ten fingers. Computers also have to count, but they
			don't have fingers. However, recall our discussion on representation. All
			the computer really needs is two fingers to represent 0 and 1. The word
			&#8220;bit,&#8221; as used in &#8220;64-bit&#8221; communicates how many
			fingers the computer has to count. With a 4-bit processor, the computer
			only has four fingers, and it can only count up to the binary number
			${1111_{[0]}}$ (15 in decimal). With a 32-bit processor, the computer has
			32 fingers, and it can count up to the binary number
			${11111111111111111111111111111111_{[0]}}$ (4,294,967,296 in decimal).
		</p>
		<p>
			Now, recall that when we execute programs, we are really sending
			instructions to the CPU. Those instructions are in 0s and 1s. The CPU,
			however, has a fundamental constraint: It has a fixed size for how many 0s
			and 1s it can process at once (or more formally, in one
			<span class="italicsText">cycle</span>). With a 64-bit processor, the CPU
			can process 64-bits of data in a single cycle. With a 32-bit processor, 32
			bits, 16-bit 16 bits, and so on. This limitation impacts how well the
			computer handles large computations. For example, we can quickly compute
			${2 + 2 = 4.}$ However, with something like ${298 + 769,}$ we have to
			perform carry-overs. The same idea extends to CPUs. With numbers beyond
			what it can handle in a single cycle, the CPU must perform more than 1
			step to complete the computation.
		</p>
		<p>
			This limitation extends to another important part of the computer: RAM.
			Recall the RAM diagram earlier. Each square in the grid has a
			<span class="term">memory address</span>, and that address is named as an
			integer. For example, consider a 3-bit processor. With 3 bits, the
			computer can only count up to ${111.}$ This in turn means that the
			computer can only generate 8 possible patterns of bits: 000, 001, 010,
			011, 100, 101, 110, or 111. In terms of memory, the computer would only be
			able to understand these 8 addresses. Reference anything beyond these
			addresses, and the computer won't know what we're talking about. And with
			that limitation, our programs can only be so large and complex &mdash;
			memory is everything.
		</p>
		<p>
			How does this all relate to Java's types? At the time Java was introduced,
			mainstream processors were 32-bit processors. Accordingly, Java used 4
			bytes to represent integers (8 bits in a byte, 4 bytes yields 32 bits).
			This also explains why compilers for older languages like C use 2 bytes to
			represent integers &mdash; at the time, 16-bit processors were the norm.
			To allow programmers to write programs for older machines &mdash; called
			<span class="term">backwards compatibility</span> &mdash; Java provides
			<span class="monoText">byte</span> and
			<span class="monoText">short</span>. And in response to newer machines
			&mdash; using 64-bit processors &mdash; Java provided
			<span class="monoText">long</span>.
		</p>
		<p>
			Knowing these limitations is critical when we're working with data types
			of small value ranges. Failing to recall them can lead to unexpected
			results:
		</p>
		<pre class="language-java"><code>
			class Overflow {
				public static void main(String[] args) {
					byte num = 10;
					num += 256;
					System.out.println(num);
				}
			}
		</code></pre>
		<pre class="language-bash"><code>
			10
		</code></pre>
		<p>
			Why isn't the console displaying <span class="monoText">356</span>?
			Because the type <span class="monoText">byte</span> is restricted to
			exactly 1 byte &mdash; it can only store integers up to 256. Once we go
			beyond <span class="monoText">256</span>, go back to
			<span class="monoText">0</span>. In programming, this is called
			<span class="term">overflow</span>. We can prevent encountering overflows
			by testing for the type's <span class="monoText">MIN_VALUE</span> and
			<span class="monoText">MAX_VALUE</span>.
		</p>
	</section>
</section>

<section id="arithmetic_operators">
	<h2>Operators</h2>
	<p>
		Operators are evaluated in a specific order. Parentheses are always
		evaluated first. Inside the parentheses or otherwise, operators are
		evaluated left-to-right. Going from left to right, multiplication (<span
			class="monoText"
			>*</span
		>) and modulus (<span class="monoText">%</span>) are evaluated before
		addition (<span class="monoText">+</span>) and subtraction (<span
			class="monoText"
			>-</span
		>). Below is an API of the various operators in Java, where ${a}$ and ${b}$
		are variables or literals.
	</p>
	<figure class="table">
		<table class="api">
			<thead>
				<th>Operator</th>
				<th>Description</th>
				<th>Comment</th>
			</thead>
			<tbody>
				<tr>
					<td>${a}$ + ${b}$</td>
					<td>Addition; computes ${a + b}$</td>
					<td>
						${a}$ and ${b}$ are numeric types or
						<span class="monoText">char</span>. If ${a}$ and ${b}$ are strings,
						then the <a href="">strings</a> are <a href="">concatenated</a>.
					</td>
				</tr>
				<tr>
					<td>${a}$ - ${b}$</td>
					<td>Subtraction; computes ${a - b}$</td>
					<td>
						${a}$ and ${b}$ are numeric types or
						<span class="monoText">char</span>.
					</td>
				</tr>
				<tr>
					<td>${a}$ * ${b}$</td>
					<td>Multiplication; computes ${a \cdot b}$</td>
					<td>
						${a}$ and ${b}$ are numeric types or
						<span class="monoText">char</span>.
					</td>
				</tr>
				<tr>
					<td>${a}$ / ${b}$</td>
					<td>Division; computes ${\dfrac{a}{b}}$</td>
					<td>
						${a}$ and ${b}$ are numeric types or
						<span class="monoText">char</span>.
					</td>
				</tr>
				<tr>
					<td>${a}$ % ${b}$</td>
					<td>
						Remainder operator; computes ${\dfrac{a}{b}}$, or
						${b)\hspace{-0.25em}\overline{\hspace{0.5em} a},}$ and returns the
						remainder
					</td>
					<td>${a}$ and ${b}$ are numeric types.</td>
				</tr>
				<tr>
					<td>${a}$++</td>
					<td>Increment operator; computes ${a + 1}$</td>
					<td>${a}$ is a numeric type</td>
				</tr>
				<tr>
					<td>${a}$--</td>
					<td>Decrement operator; computes ${a - 1}$</td>
					<td>${a}$ is a numeric type</td>
				</tr>
				<tr>
					<td>${a}$ < ${b}$</td>
					<td>
						Relational operator; returns <span class="monoText">true</span> if
						${a < b,}$ other wise false
					</td>
					<td>${a}$ is a numeric type</td>
				</tr>
				<tr>
					<td>${a}$ > ${b}$</td>
					<td>
						Relational operator; returns <span class="monoText">true</span> if
						${a > b,}$ other wise false
					</td>
					<td>${a}$ and ${b}$ are numeric types</td>
				</tr>
				<tr>
					<td>${a}$ <= ${b}$</td>
					<td>
						Relational operator; returns <span class="monoText">true</span> if
						${a < b}$ or ${a = b,}$ other wise false
					</td>
					<td>${a}$ and ${b}$ are numeric types</td>
				</tr>
				<tr>
					<td>${a}$ >= ${b}$</td>
					<td>
						Relational operator; returns <span class="monoText">true</span> if
						${a > b}$ or ${a = b,}$ other wise false
					</td>
					<td>${a}$ and ${b}$ are numeric types</td>
				</tr>
				<tr>
					<td>${a}$ == ${b}$</td>
					<td>
						Relational operator; returns <span class="monoText">true</span> if
						${a = b,}$ other wise false
					</td>
					<td>${a}$ and ${b}$ are numeric types</td>
				</tr>
				<tr>
					<td>${a}$ == ${b}$</td>
					<td>
						Relational operator; returns <span class="monoText">true</span> if
						${a = b,}$ other wise false
					</td>
					<td>${a}$ is a numeric type</td>
				</tr>
				<tr>
					<td>${a}$ != ${b}$</td>
					<td>
						Relational operator; returns <span class="monoText">true</span> if
						${a \neq b,}$ other wise false
					</td>
					<td>${a}$ is a numeric type</td>
				</tr>
				<tr>
					<td>${a}$ &amp;&amp; ${b}$</td>
					<td>
						Logical operator AND; returns
						<span class="monoText">true</span> if ${a}$ is
						<span class="monoText">true</span> and
						<span class="monoText">b</span> is
						<span class="monoText">true</span>; otherwise false
					</td>
					<td>
						${a}$ and ${b}$ are of type <span class="monoText">bool</span>
					</td>
				</tr>
				<tr>
					<td>${a}$ || ${b}$</td>
					<td>
						Logical operator OR; returns <span class="monoText">true</span> if
						${a}$ is <span class="monoText">true</span> or
						<span class="monoText">b</span> is
						<span class="monoText">true</span>; otherwise false
					</td>
					<td>
						${a}$ and ${b}$ are of type <span class="monoText">bool</span>
					</td>
				</tr>
				<tr>
					<td>!${a}$</td>
					<td>
						Logical operator NOT; returns
						<span class="monoText">false</span> if ${a}$ is
						<span class="monoText">true</span>, returns
						<span class="monoText">true</span> if ${a}$ is
						<span class="monoText">false</span>
					</td>
					<td>
						${a}$ and ${b}$ are of type <span class="monoText">bool</span>
					</td>
				</tr>
			</tbody>
		</table>
	</figure>
	<p>
		<span class="topic">Idioms.</span> Many computer science newcomers are
		unfamiliar with the remainder operator. This operator simply returns the
		remainder from dividing some number $a$ by ${b.}$
	</p>
	<p>
		The remainder operator is a particularly useful operation. For example, if
		${a \bmod 2}$ returns a remainder of 0, then we know that $a$ is an even
		number. If ${a \bmod 2}$ returns a remainder greater than 0, then we know
		that $a$ is an odd number. For example:
	</p>
	<pre class="language-java"><code>
		public class Demo {
			public static void main(String[] args) {
				int x = 4;
				int y = 5;
				boolean xIsEven = (x % 2 == 0); // xIsEven is true
				boolean yIsEven = (y % 2 == 0); // yIsEven is false
				System.out.println(xIsEven);
				System.out.println(yIsEven);
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		true
		false
	</code></pre>
	<p>
		Examining this use of the modulus operator, we can see that we can
		generalize this pattern even more &mdash; write
		<span class="monoText">x % 3</span>, and we check if
		<span class="monoText">x</span> is a multiple 3,
		<span class="monoText">x % 4</span>, a multiple of 4,
		<span class="monoText">x % 11</span> a multiple of 11, and so on.
	</p>
	<p>
		In computer science, this is an example of a
		<span class="term">idiom</span>. An idiom is just a programming pattern. In
		this case, we have some pattern <span class="monoText">${x}$ % ${n}$</span>,
		where ${x}$ is some variable, and <span class="monoText">${n}$</span> is a
		positive integer. Learning and recognizing idioms is a core skill in
		programming; with it, we can identify and solve smaller problems quickly.
		And as we'll see with functions, the best way to approach a problem is to
		break it down into smaller problems.
	</p>

	<section id="bitwise_operators">
		<h3>Bitwise Operators</h3>
		<p>
			The bitwise operators operate on bits of data. Because these operators
			operate on bits, they are the fastest of all operators. Below is an API of
			the operators. We will present examples separately.
		</p>
		<figure class="table">
			<table class="api">
				<thead>
					<th>Operator</th>
					<th>Meaning</th>
				</thead>
				<tbody>
					<tr>
						<td>&</td>
						<td>
							Bitwise <span class="monoText">AND</span>; corresponds to the
							logical ${\land}$
						</td>
					</tr>
					<tr>
						<td>|</td>
						<td>
							Bitwise <span class="monoText">OR</span>; corresponds to the
							logical ${\lor}$
						</td>
					</tr>
					<tr>
						<td>~</td>
						<td>
							Bitwise <span class="monoText">NOT</span>; corresponds to the
							logical ${\neg}$
						</td>
					</tr>
					<tr>
						<td>^</td>
						<td>
							Bitwise <span class="monoText">XOR</span>; corresponds to the
							logical ${\oplus}$
						</td>
					</tr>
					<tr>
						<td>>></td>
						<td>Bitwise <span class="monoText">RIGHT SHIFT</span></td>
					</tr>
					<tr>
						<td>>>></td>
						<td>Bitwise <span class="monoText">UNSIGNED RIGHT SHIFT</span></td>
					</tr>
					<tr>
						<td><<</td>
						<td>Bitwise <span class="monoText">LEFT SHIFT</span></td>
					</tr>
				</tbody>
			</table>
		</figure>
		<p>
			The bitwise operators are analogous to computing truth tables. Let's say
			we had two literals, <span class="monoText">a</span> and
			<span class="monoText">b.</span> Let's further say that
			<span class="monoText">a</span> and <span class="monoText">b</span> are
			represented in binary by just a single bit. Thus,
			<span class="monoText">a</span> and <span class="monoText">b</span> can
			only be <span class="monoText">1</span> or
			<span class="monoText">0</span>. The bitwise
			<span class="monoText">AND</span>
			<span class="monoText">&</span> performs as such:
		</p>
		<figure class="table">
			<table class="truth_table monoCell">
				<thead>
					<th>a</th>
					<th>b</th>
					<th>a && b</th>
				</thead>
				<tbody>
					<tr>
						<td>0</td>
						<td>0</td>
						<td>0</td>
					</tr>
					<tr>
						<td>0</td>
						<td>1</td>
						<td>0</td>
					</tr>
					<tr>
						<td>1</td>
						<td>0</td>
						<td>0</td>
					</tr>
					<tr>
						<td>1</td>
						<td>1</td>
						<td>1</td>
					</tr>
				</tbody>
			</table>
		</figure>
	</section>
	<p>
		The bitwise <span class="monoText">OR</span>,
		<span class="monoText">|</span>,
	</p>
	<figure class="table">
		<table class="truth_table monoCell">
			<thead>
				<th>a</th>
				<th>b</th>
				<th>a | b</th>
			</thead>
			<tbody>
				<tr>
					<td>0</td>
					<td>0</td>
					<td>0</td>
				</tr>
				<tr>
					<td>0</td>
					<td>1</td>
					<td>1</td>
				</tr>
				<tr>
					<td>1</td>
					<td>0</td>
					<td>1</td>
				</tr>
				<tr>
					<td>1</td>
					<td>1</td>
					<td>1</td>
				</tr>
			</tbody>
		</table>
	</figure>
	<p>
		The bitwise <span class="monoText">XOR</span>,
		<span class="monoText">^</span>,
	</p>
	<figure class="table">
		<table class="truth_table monoCell">
			<thead>
				<th>a</th>
				<th>b</th>
				<th>a | b</th>
			</thead>
			<tbody>
				<tr>
					<td>0</td>
					<td>0</td>
					<td>0</td>
				</tr>
				<tr>
					<td>0</td>
					<td>1</td>
					<td>1</td>
				</tr>
				<tr>
					<td>1</td>
					<td>0</td>
					<td>1</td>
				</tr>
				<tr>
					<td>1</td>
					<td>1</td>
					<td>0</td>
				</tr>
			</tbody>
		</table>
	</figure>
	<p>
		and the bitwise <span class="monoText">NOT</span>,
		<span class="monoText">~</span>,
	</p>
	<figure class="table">
		<table class="truth_table monoCell">
			<thead>
				<th>a</th>
				<th>~a</th>
			</thead>
			<tbody>
				<tr>
					<td>0</td>
					<td>1</td>
				</tr>
				<tr>
					<td>1</td>
					<td>0</td>
				</tr>
			</tbody>
		</table>
	</figure>
</section>

<section id="naming">
	<h2>Naming</h2>
	<p>
		A
		<span class="term">name</span>, or more formally, an
		<span class="term">identifier</span>, is a sequence of characters in source
		code used to label a particular entity (for example, a variable). In Java,
		names must begin with either Unicode letters and digits, the dollar sign
		(<span class="monoText">$</span>), or the underscore (<span class="monoText"
			>_</span
		>). By convention, however, names should always begin with a letter. Names
		in Java also follow camelCasing (capitalizing every other word to indicate
		spacing), rather than pothole_casing (using underscores to indicating
		spacing). The exception to this convention is with constants &mdash; very
		letter in a constant should be in upper case, with spaces indicated by
		undercores. Finally, Java places heavy emphasis on
		<span class="underlineText">descriptive</span> and
		<span class="underlineText">concise</span> variable names, erring on the
		side of <span class="underlineText">descriptive</span>.
	</p>
	<pre class="language-java"><code>
		// This is good
		int age = 22;

		// These are good
		int NUM_ATTENDEES = 87;
		boolean ATTENDED = true;

		// This is bad
		float $pi = 3.14;

	</code></pre>
	<p>
		In general, there are three guidelines we should follow when creating
		variable names:
	</p>
	<ol>
		<li>The variable name should describe the data stored in the variable.</li>
		<li>
			Our code is read more times than it is written (whether by ourselves or
			others). Our priority should be &#8220;easy to understand,&#8221; not
			&#8220;easy to write.&#8221;
		</li>
		<li>
			If there are standard conventions, follow them; else, create a name and be
			consistent.
		</li>
	</ol>
	<p>
		Additionally, like any other programming language, there are certain words
		we cannot use as names in Java. These are called
		<span class="term">reserved words</span>:
	</p>

	<pre class="language-pseudo"><code>
		abstract, assert
		boolean, break, byte
		case, catch, char, class, const, continue
		default, do, double
		else, extends
		false, final, finally, float, for
		goto
		if, implements, import, instanceof, int, interface
	</code></pre>
	<pre class="language-pseudo"><code>
		long
		native, new, null
		package, private, protected, public
		return
		short, static, strictfp, super, switch, synchronized
		this, throw, throws, transient, true, try
		void, volatile, while
	</code></pre>
</section>

<section id="library_methods_and_apis">
	<h2>Library Methods & APIs</h2>
	<p>In the examples above, we wrote the following:</p>
	<pre class="language-java"><code>
		System.out.print(/* some expression or value */)
	</code></pre>
	<p>
		This is a <span class="term">library method</span> &mdash; a method provided
		by the Java library. There are numerous library methods in Java; methods for
		mathematics, printing, input and output, etc. Because of how many library
		methods there are, we will not list and explain them all at once. Instead,
		we will use and elaborate on them as needed.
	</p>
</section>
{% endblock %}
