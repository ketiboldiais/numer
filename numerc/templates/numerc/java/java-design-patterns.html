{% extends '../layout.html' %} {% load static %} {% block description %}
<meta name="description" content="Notes on design patterns in Java." />
{% endblock %} {% block title %}
<title>Java Design Patterns</title>
{% endblock %} {% block content %}
<h1>Design Patterns</h1>
<section id="intro">
	<p>
		<span class="drop">W</span>hen Sisyphus cheated death, Hades compelled
		him to roll a boulder up a steep hill. At some point near the crest,
		the stone would return to the foot, consigning Sisyphus to eternal
		repetition. As draconian as Sisyphus's punishment may be, his toil
		illustrates the principle of <span class="term">pattern</span> &mdash;
		if we see the king of Ephyra maneuvering a boulder up a hill long
		enough, we can identify exactly when the boulder begins rolling back
		down.
	</p>
	<p>
		This phenomenon exists in programming. Many programming problems have
		common forms, both in statement and solution. Because of these
		commonalities, there are <b>design patterns</b> &mdash; recurring sets
		of rules for implementing programming solutions.
	</p>
	<p>Design patterns are organized into three <i>families</i>:</p>
	<figure>
		<ul>
			<li>
				<b>Creational patterns</b> concern the process of creating objects.
			</li>
			<li>
				<b>Structural patterns</b> deal with the composition of classes or
				objects.
			</li>
			<li>
				<b>Behavioral patterns</b> characterize how classes or objects
				interact and distribute responsibility.
			</li>
		</ul>
	</figure>
	<p>
		Within each of the families above, there are two sub-families of
		patterns:
	</p>
	<figure>
		<ul>
			<li>
				<b>Class patterns</b> concern relations between classes and their
				subclasses &mdash; e.g., inheritance.
			</li>
			<li>
				<b>Object patterns</b> deal with object relationships, which are
				more dynamic, given that they can be changed at runtime. Object
				patterns describe how objects can be composed into larger
				structures using object composition or by including objects within
				other objects.
			</li>
		</ul>
	</figure>
</section>

<section id="builder_pattern">
	<h2>Builder Pattern</h2>
	<p>
		The <b>build pattern</b> is used to build objects. An object could be
		simple, but it could also be complex, consisting of numerous component
		objects. As we know, instances of a class are generally created with a
		constructor. E.g., for some class called <var>Sphere</var>, we might
		have a constructor <var>newSphere()</var> or <var>initSphere()</var>.
		We can think of a <b>builder</b> as a much more sophisticated
		constructor. It's a module that builds a <i>complex</i> or
		<i>aggregate</i> object (in the diagram above, <var>Obj1</var>). The
		builder encapsulates the processes for building the complex object,
		separating the representation and its construction.
	</p>
	<p>
		By separating representation and construction, we can use a builder to
		instantiate complicated classes that share the same manufacturing
		process. The builder is itself contained in a class, and appears as
		follows:
	</p>
	<div id="builder_flow_chart"></div>
	<p>The builder pattern is useful when:</p>
	<ol class="checklist">
		<li>We have an object with different versions.</li>
		<li>
			All the different versions are made through the same process, but
			with different inputs.
		</li>
	</ol>
	<p>
		The builder pattern addresses a few problems. Suppose we're writing a
		piece of software that models different aircrafts. We start with some
		class aircraft:
	</p>
	<pre class="language-dir"><code>
		class Aircraft
	</code></pre>
	<p>
		From this class aircraft, we use inheritance to create several
		subclasses:
	</p>
	<pre class="language-dir"><code>
		.
		└── class Aircraft
				├── class F16
				└── class Boeing747
	</code></pre>
	<p>
		The problem with this approach, however, is that any significant
		variation in aircrafts will push us to create a new subclass. This
		eventually leads to an inordinate amount of subclasses:
	</p>
	<pre class="language-dir"><code>
		.
		└── class Aircraft
				├── class F16
				├── class Boeing747
				├── class Stratolaunch
				├── class Boeing777_9
				├── class BoeingB52
				└── class R100
	</code></pre>
	<p>
		We could avoid this problem by just creating a very large
		<var>Aircraft</var> class. But if we took that approach, we'd have an
		extremely large constructor:
	</p>
	<pre class="language-dir"><code>
		.
		└── class Aircraft
				└── constructor(id:string, color:string, wingCount: int, ...)
	</code></pre>
	<p>
		The problem with this approach is that many of the parameters go
		unusued. The <i>builder pattern</i> suggests that we create a separate
		class to store all of the different constructors.
	</p>
</section>

<section id="singleton_pattern">
	<h2>Singleton Pattern</h2>
	<p>
		The <i>singleton pattern</i> isn't used all that often, at least in
		comparison to the other design patterns.
	</p>
</section>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script type="module" src="../../../static/numerc/csmd/csmd.mjs"></script>
<script
	type="module"
	src="../../../static/numerc/scripts/java_designPatterns.js"
></script>

{% endblock %}
