{% extends '../layout.html' %} {% load static %} {% block description %}
<meta name="description" content="Notes on design patterns in Java." />
{% endblock %} {% block title %}
<title>Java Design Patterns</title>
{% endblock %} {% block content %}
<h1>Design Patterns</h1>
<section id="intro">
	<p>
		<span class="drop">W</span>hen Sisyphus cheated death, Hades compelled
		him to roll a boulder up a steep hill. At some point near the crest,
		the stone would return to the foot, consigning Sisyphus to eternal
		repetition. As draconian as Sisyphus's punishment may be, his toil
		illustrates the principle of <span class="term">pattern</span> &mdash;
		if we see the king of Ephyra maneuvering a boulder up a hill long
		enough, we can identify exactly when the boulder begins rolling back
		down.
	</p>
	<p>
		This phenomenon exists in programming. Many programming problems have
		common forms, both in statement and solution. Because of these
		commonalities, there are <b>design patterns</b> &mdash; recurring sets
		of rules for implementing programming solutions.
	</p>
	<p>Design patterns are organized into three <i>families</i>:</p>
	<figure>
		<ul>
			<li>
				<b>Creational patterns</b> concern the process of creating objects.
			</li>
			<li>
				<b>Structural patterns</b> deal with the composition of classes or
				objects.
			</li>
			<li>
				<b>Behavioral patterns</b> characterize how classes or objects
				interact and distribute responsibility.
			</li>
		</ul>
	</figure>
	<p>
		Within each of the families above, there are two sub-families of
		patterns:
	</p>
	<figure>
		<ul>
			<li>
				<b>Class patterns</b> concern relations between classes and their
				subclasses &mdash; e.g., inheritance.
			</li>
			<li>
				<b>Object patterns</b> deal with object relationships, which are
				more dynamic, given that they can be changed at runtime. Object
				patterns describe how objects can be composed into larger
				structures using object composition or by including objects within
				other objects.
			</li>
		</ul>
	</figure>
</section>

<section id="builder_pattern">
	<h2>Builder Pattern</h2>
	<p>
		The <b>build pattern</b> is used to build objects. An object could be
		simple, but it could also be complex, consisting of numerous component
		objects.
	</p>
	<figure>
		<img
			src="{% static 'images/complex-object_v_simple-object.svg' %}"
			alt="A complex object versus a simple object"
			loading="lazy"
			style="width: 200px"
		/>
		<figcaption>A complex object versus a simple object.</figcaption>
	</figure>
	<p>
		As we know, instances of a class are generally created with a
		constructor. E.g., for some class called <var>Sphere</var>, we might
		have a constructor <var>newSphere()</var> or <var>initSphere()</var>.
		We can think of a <b>builder</b> as a much more sophisticated
		constructor. It's a module that builds a <i>complex</i> or
		<i>aggregate</i> object (in the diagram above, <var>Obj1</var>). The
		builder encapsulates the processes for building the complex object,
		separating the representation and its construction.
	</p>
	<p>
		By separating representation and construction, we can use a builder to
		instantiate complicated classes that share the same manufacturing
		process. The builder is itself contained in a class, and appears as
		follows:
	</p>
	<figure>
		<img
			src="{% static 'images/builder_pattern.svg' %}"
			alt="The builder pattern"
			loading="lazy"
			style="width:400px"
		/>
	</figure>
</section>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
<script type="module" src="../../../static/numerc/csmd.mjs"></script>

{% endblock %}
