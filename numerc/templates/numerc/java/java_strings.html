{% extends '../layout.html' %} {% load static %} {% block content %}
<section id="strings_in_java">
	<h3>Strings in Java</h3>
	<p>
		A significant amount of data is
		<span class="italicsText">textual data</span>. This text constitutes textual
		data. Text messages, Wikipedia articles, tweets, Google results, instagram
		captions, these all constitute textual data. In computers, textual data is
		represented by a <span class="boldText">string</span> &mdash; a sequence of
		characters.
	</p>
	<p>
		Textual data is so important that Java provides a unique type for it, the
		data type <span class="monoText">String</span>. Just like any of other data
		types, we can initialize variables of type
		<span class="monoText">String</span>:
	</p>
	<pre class="language-java"><code>
		String greeting = "Hello, world!";
		System.out.println(greeting);
	</code></pre>
	<pre class="language-bash"><code>
		Hello, world!
	</code></pre>
	<p>
		In Java, data of type <span class="monoText">String</span> are
		<span class="italicsText">always</span> enclosed in double quotes, whereas
		data of type <span class="monoText">char</span> are always enclosed in
		single quotes. In actuality, strings in Java are an array of characters.
		<span class="monoText">String</span> itself is not a primitive type.
		However, it is composed of a primitive type,
		<span class="monoText">char</span>. This means that we can apply to strings
		many of the actions we would perform with arrays. For example:
	</p>
	<pre class="language-java"><code>
		String name = "Marcus Aurelius Antoninus";
		System.out.println(name.length());
		System.out.println(name.equals("Lucius Aurelius Verus"));
	</code></pre>
	<pre class="language-bash"><code>
		25
		false
	</code></pre>
	<p>
		Notice the difference between the way we obtain a string's length and that
		of typical arrays. It appears as though we called functions,
		<span class="monoText">length()</span> and
		<span class="monoText">equals()</span>. We can see that
		<span class="monoText">length()</span> returns the string's length, and
		<span class="monoText">equals()</span> appears to check whether two strings
		are equivalent.Indeed, that is what both these
		<span class="italicsText">functions</span> do.
	</p>
	<p>
		<span class="topic">Objects.</span> The fact that we used a
		<span class="italicsText">function</span>, rather than a
		<span class="italicsText">property</span>, is evidence of the fact that
		strings are <span class="boldText">objects</span>. Objects are a special
		kind of data. Unlike the primitive types, objects combine both
		<span class="italicsText">state</span> (as primitive types do) and
		<span class="italicsText">behavior</span> (as functions do). This means that
		they have data values bound to them, and at the same time, provide functions
		associated with those values. Strings are the clearest and simplest example
		of an object. They have data values (the actual textual data) and they have
		functions associated with those data values (e.g.,
		<span class="monoText">length()</span> and
		<span class="monoText">equals()</span>). Those functions are called
		<span class="boldText">methods</span>, and we call them with
		<span class="boldText">dot notation</span>.
	</p>
	<p>
		Every string has a <span class="boldText">state</span> &mdash; the array of
		characters bound to the string. Every string also has
		<span class="boldText">behavior</span> &mdash; the functions (methods) we
		can call to operate on the <span class="monoText">String</span>'s state.
		With strings, there are numerous such methods. State and behavior are the
		two things we always ask about when deal with objects.
	</p>
	<ol>
		<li>
			State &rarr; What does the object <span class="italicsText">store</span>?
		</li>
		<li>
			Behavior &rarr; What does the object <span class="italicsText">do</span>?
		</li>
	</ol>
	<p>
		<span class="topic">Objects v. Primitives.</span> Objects are different from
		primitives. Primitives only <span class="italicsText">store</span> data
		values that can be presented as a
		<span class="italicsText">single number</span>. In Java, they are indicated
		by the fact that their names <span class="italicsText">always</span> start
		with a lower case letter:
		<span class="monoText">float, int, char, boolean, etc.</span> Primitive
		types also do not have behavior &mdash; they do not come with functions or
		methods we can use with their stored data values.
	</p>
	<p>
		In contrast, objects can both store data values
		<span class="italicsText">and</span> provide methods we can use on those
		data values. In contrast to primitives, object type names
		<span class="italicsText">always</span> start with an uppercase letter
		(e.g., <span class="monoText">String</span>). Every object, however, boils
		down to primitives. An object may be composed of other objects, but at the
		end of it all are primitives. For example, arrays in Java are actually
		objects. Those arrays, however, boil down to primitives &mdash; an array of
		<span class="monoText">char</span>, or an array of
		<span class="monoText">int</span>, etc.
	</p>
	<p>
		<span class="topic">Initializing Strings.</span> Normally, to initialize a
		string in Java, we must use the <span class="monoText">new</span> keyword.
		We saw this with arrays.
	</p>
	<pre class="language-java"><code>
		// an array object
		int[] array = new int[8]; 

		// string objects
		String salutate = new String("Hi!");
		String valedict = new String("Bye!"); 
	</code></pre>
	<p>
		However, strings are so important and common that Java allows us to
		initialize them as though they were literals:
	</p>
	<pre class="language-java"><code>
		String salutate = "Hi!";
		String valedict = "Bye!";
	</code></pre>
	<p>
		<span class="topic">Concatenation.</span> We can combine separate strings
		into a single string. In doing so, we
		<span class="italicsText">concatenate</span> the strings:
	</p>
	<pre class="language-java"><code>
		String firstName = "David";
		String lastName = "Hume";
		String fullName = firstName + " " + lastName;

		System.out.println(fullName);
	</code></pre>
	<pre class="language-bash"><code>
		David Hume
	</code></pre>
	<p>
		Notice that in the example above, we included what appears to be an empty
		string. It is not empty. That string contains a space. This reveals a
		crucial fact for when we handle strings: Spaces count as characters.
		Furthermore, the <span class="monoText">+</span> operator does not work as
		addition. It concatenates. Because the
		<span class="monoText">+</span> operator can either compute addition or
		concatenate strings, we say that the
		<span class="monoText">+</span> operator is
		<span class="italicsText">overloaded</span>.
	</p>
	<p>
		<span class="topic">Dot Notation.</span> Whenever we have an object, we
		always access that object's state and methods using
		<span class="italicsText">dot notation</span>:
	</p>
	<pre class="language-java"><code>
		String word = "sad";

		int lengthOfWord = word.length();
		String replaceLetter = word.replace('s', 'm');
		String upperCaseWord = word.toUpperCase();

		System.out.println(lengthOfWord);
		System.out.println(replaceLetter);
		System.out.println(upperCaseWord);
	</code></pre>
	<pre class="language-bash"><code>
		3
		mad
		SAD
	</code></pre>
	<p>
		Observe the way we called the methods above:
		<span class="monoText">variableName.method()</span>. Also observe what the
		methods above do. <span class="monoText">.replace()</span> will replace
		characters inside a string, and
		<span class="monoText">.toUpperCase()</span> will transform characters in
		the string from lower case to upper case. As can be seen from
		<span class="monoText">.replace()</span>, some methods have parameters, so
		we must pass arguments to use them. The
		<a href="https://docs.oracle.com/javase/7/docs/api/java/lang/String.html"
			>Java documentation</a
		>
		provides an exhaustive list of these methods.
	</p>
	<p>
		Note, however, that once we initialize a string, that string will never
		change. This is a significant difference between Java and many other
		languages like Python. Once a string is initialized, we cannot modify it. If
		we want the modified string, we must separately initialize it.
	</p>
	<pre class="language-java"><code>
		String blurt = "hey";
		blurt.toUpperCase();
		System.out.println(blurt);
	</code></pre>
	<pre class="language-bash"><code>
		hey
	</code></pre>
	<p>
		<span class="topic">Chaining Methods with Dot Notation.</span> We can
		execute multiple methods in dot notation by chaining the methods together:
	</p>
	<pre class="language-java"><code>
		String stringX = "hehe";
		String stringY = stringX.replace("e", "a").toUpperCase(); 

		System.out.println(stringX);
		System.out.println(stringY);
	</code></pre>
	<pre class="language-bash"><code>
		hehe
		HAHA
	</code></pre>
	<p>
		Whenever we work with strings and want to accomplish a particular task, we
		should always check the documentation first. More likely than not, there's a
		method for whatever it is we'd like to do.
	</p>
	<p>
		<span class="topic">Testing for Equality of Strings.</span> One idiosyncracy
		with Java is the way it tests the equality of
		<span class="italicsText">objects</span> (more on objects later). Because
		strings are objects, we should never test whether two given strings are
		equal with the <span class="monoText">==</span> operator. Instead, we must
		use the <span class="monoText">.equals()</span> method.
	</p>
	<pre class="language-java"><code>
		String one = "hello";
		String two = "hello";
		System.out.println(one == two);

		String three = new String("bye");
		String four = new String("bye");
		System.out.println(three == four);

		String five = new String("sup");
		String six = new String("sup");
		System.out.println(five.equals(six));
	</code></pre>
	<pre class="language-bash"><code>
		true
		false
		true
	</code></pre>
	<p>
		<span class="exh">Exercise.</span> For the following string, print a
		character in the string if, and only if, a consecutive character is the same
		character.
	</p>
	<pre class="language-java"><code>
		String stringX = "Massachusetts";
	</code></pre>
	<details class="answer">
		<summary>Solution</summary>
		<p>Here is one possible implementation:</p>
		<pre class="language-java"><code>
				String stringX = "Massachusetts"; 
				for (int i = 0; i < stringX.length() - 1; i++) {
					if (stringX.charAt(i) == stringX.charAt(i + 1)) {
						System.out.println(stringX.charAt(i));
					}
				}
			</code></pre>
		<pre class="language-bash"><code>
				s
				t
			</code></pre>
	</details>
	<p>
		<span class="topic"
			><span class="monoText">char</span> v.
			<span class="monoText">int</span>.</span
		>
		There are some unique characteristics of the primitive type
		<span class="monoText">char</span> that we cannot do with strings. For
		starters, every <span class="monoText">char</span> is mapped to an integer
		value internally (called the <span class="monoText">char</span>'s
		<span class="italicsText">ASCII</span> value). For example, the
		<span class="monoText">char</span> value
		<span class="monoText">'A'</span> is mapped to the integer 65;
		<span class="monoText">'a'</span> to 97;
		<span class="monoText">'B'</span> to 66;
		<span class="monoText">'b'</span> to 98,
		<span class="monoText">'C'</span> to 67;
		<span class="monoText">'C'</span> to 99, etc.
	</p>
	<p>
		This means we can convert <span class="monoText">char</span> values to
		<span class="monoText">int</span> values:
	</p>
	<pre class="language-java"><code>
		System.out.println('a' + 10);
		System.out.println('A' + 'A');
	</code></pre>
	<pre class="language-bash"><code>
		107
		103
	</code></pre>
	<p>
		This is not something we do often, but we can use this fact to encode
		strings:
	</p>
	<pre class="language-java"><code>
		public class foo {
			public static void main(String[] unused) {
				String secretMessage = "Chicken ribs";
				System.out.println("The secret message: " + secretMessage);
				String encoded = "";
				for (int i = 0; i < secretMessage.length(); i++) {
					char ch = secretMessage.charAt(i);
					ch++;
					encoded += ch;
				}
				System.out.println("The encoded message: " + encoded);
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		The secret message: Chicken ribs
		The encoded message: Dijdlfo!sjct
	</code></pre>
	<p>
		In the code above, we looped through each of the characters in the string
		<span class="monoText">secretMessage</span>, an incremented by 1. This
		effectively changes the current character to the next character in the ASCII
		table.
	</p>
	<p>
		The encoding approach of shifting every character in a string by a given
		amount is called a <span class="italicsText">rotation cipher</span>. One
		famous rotation cipher is the
		<span class="italicsText">Caesar cipher</span>, named after its famous user,
		Julius Caesar. In a Caesar cipher, every character in the string is shifted
		by exactly 13 units (half the Roman alphabet).
	</p>
	<p>
		Using this idea, we might help Julius Caesar encode his messages with a
		function:
	</p>
	<pre class="language-java"><code>
		public class foo {
			public static void main(String[] args) {
				String message = "In vino veritas";
				String messageEncoded = encode(message, 13);
				System.out.println(messageEncoded);
			}
			static String encode(String message, int key) {
				String encoded = "";
				for (int i = 0; i < message.length(); i++) {
					char ch = message.charAt(i);
					ch += key;
					encoded += ch;
				}
				return encoded;
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		V{-v{|-rvn
	</code></pre>
	<p>
		Suppose we do not want to convert the spaces in the message. We can do so by
		simply redefining our method: Include an
		<span class="monoText">if</span> statement. Here, we want to only shift
		letters that run from <span class="monoText">'a'</span> to
		<span class="monoText">'Z'</span>. Since
		<span class="monoText">char</span> values are integers, we can use the
		comparison operators. Let's also change the encoding
		<span class="monoText">key</span> to 5:
	</p>
	<pre class="language-java"><code>
		public class foo {
			public static void main(String[] args) {
				String message = "In vino veritas";
				String messageEncoded = encode(message, 5);
				System.out.println(messageEncoded);
			}
			static String encode(String message, int key) {
				String encoded = "";
				for (int i = 0; i < message.length(); i++) {
					char ch = message.charAt(i);
					if ('a' <= ch && ch <= 'z') {
						ch += key;
					}
					encoded += ch;
				}
				return encoded;
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		Is {nst {jwnyfx
	</code></pre>
	<p>
		Now, Julius Caesar might not have had curly braces at the time, so let's
		rewrite our method to ensure only characters appear in the encoded message.
		Well, we want to keep the characters inside the 26 letters of the Roman
		alphabet. This means: If the changed character is greater than
		<span class="monoText">'z'</span>, then we need to go back to
		<span class="monoText">'a'</span>. How do we do that? Well, there are 26
		letters, so &#8220;wrapping around&#8221; implies subtracting 26. Let's also
		use 13 for <span class="monoText">key</span>, true to spirit:
	</p>
	<pre class="language-java"><code>
		public class foo {
			public static void main(String[] args) {
				String message = "In vino veritas";
				String messageEncoded = encode(message, 13);
				System.out.println(messageEncoded);
			}
			static String encode(String message, int key) {
				String encoded = "";
				for (int i = 0; i < message.length(); i++) {
					char ch = message.charAt(i);
					if ('a' <= ch && ch <= 'z') {
						ch += key;
						if (ch > 'z') {
							ch -= 26;
						}
					}
					encoded += ch;
				}
				return encoded;
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		Ia ivab irevgnf
	</code></pre>
	<p>Great, now we only see Roman letters.</p>
</section>
{% endblock %}
