{% extends '../layout.html' %} {% load static %} {% block description %}
<meta name="description" content="Java classes" />
{% endblock %} {% block title %}
<title>Java Classes</title>
{% endblock %} {% block content %}
<h1>Object-Oriented Programming</h1>
<section id="intro">
	<p>
		<span class="drop">A</span>ll of the topics covered thus far are concepts we
		can collect into our programming toolbox and use as needed. Indeed, a
		substantial part of being a programmer is discovering new concepts to add to
		that toolbox. We now introduce another concept &mdash;
		<span class="italicsText">objects</span>.
	</p>
	<p>
		Objects are placed in the tool slot for data structures &mdash; objects are
		one possible approach for organizing data. More specifically, they allow us
		to create custom <span class="italicsText">types</span>. So far, we have
		only used primitive types &mdash; the types Java provides by default.
		Objects give us a way to have more types.
	</p>
	<p>
		Recall: How do we structure good programs? So far, we've seen one approach:
		Using <span class="italicsText">functions</span> &mdash; break down the
		program into smaller, reusable, testable, and understandable pieces. Objects
		give us a second approach: Combining
		<span class="italicsText">state</span> and
		<span class="italicsText">behavior</span> &mdash; modeling data (state) and
		what we can do with that data (behavior).
	</p>
	<p>
		Creating objects is a strenous exercise of creativity, imagination, holistic
		thinking, and intuition. This is in contrast to implementing functions,
		which often involves logic, fact analysis, and computation. This is because
		implementing objects depends much more heavily on design, rather than
		sequences of steps. This method of programming is called
		<span class="term">object-oriented programming</span> (often shortened to
		OOP). In this volume's preface, we gave a brief glimpse of what
		object-oriented programming is. We will now perform a more thorough and
		rigorous investigation.
	</p>
</section>

<section id="principles_of_object_oriented_programming">
	<h2>Principles of Object-oriented Programming</h2>
	<p>
		In object-oriented programming, we write code according to four key
		principles: abstraction, encapsulation, inheritance, and polymorphism. To
		understand what all of these terms mean, we will use various analogies.
	</p>
	<section id="abstraction">
		<p>
			<span class="topic">Abstraction.</span> The Oxford dictionary defines
			<span class="italicsText">abstraction</span> as &#8220;the process of
			considering something independently of its associations, attributes, or
			concrete accompaniments.&#8221; This is a good starting point, but let's
			see some examples of this process in action.
		</p>
		<p>
			Consider the microwave. Not very many people know how a microwave works.
			In fact, if you really think about it, it's a fairly strange machine. We
			open its door, place our food, set a timer, and it just rotates a tray.
			There's a lightbulb on and some humming, but there's no fire or obvious
			source of heat. Yet once the timer's done, our food is heated. Despite the
			fact that few people know how the microwave actuall works, it's a fairly
			commonplace appliance &mdash; we find it houses, apartments, gas stations,
			offices, and various locations. And it's a fairly commonplace appliance
			because people can use it without knowing the internal details. We push
			one button and the door opens. We enter digits, hit start, and a timer
			ensures. All of this is done without the user knowing how the button leads
			to the door opening, or how the digits correspond to a timer. The
			microwave is an abstraction of all the pieces that comprise it &mdash; the
			control panel, high voltage transformer, capacitor, magnetron, antenna,
			cooling fan, wave guide, wave stirrer, and a plethora of other components.
		</p>
		<p>
			The microwave is just one example of an abstraction. We can use, or
			&#8220;consider,&#8221; the microwave without knowing anything about how
			it works or its internal details. Another example: the cellphone. Very few
			peole know how a cellphone works, yet it's used across the world and
			across cultures. It's an abstraction of transistors, machine code, an
			operating system, a file system, source code for applications, etc.
		</p>
		<p>
			Abstraction is a core principle of object-oriented programming. In writing
			code to be used by another, we want the user to be able to use the program
			without having to think about how the code works. And by user, we don't
			necessarily mean people. This idea also extends to other code, other
			programs. When we write some piece of code ${x}$ to be used by another
			piece of code ${y,}$ ${y}$ shouldn't have to consider how ${x}$ is
			implemented. It should be able to just use ${x}$ as is.
		</p>
	</section>

	<section id="encapsulation">
		<p>
			<span class="topic">Encapsulation.</span> Encapsulation is exactly what it
			sounds like &mdash; everything is contained in a single entity.
			Essentially, whatever the program needs is contained in a single place.
			When we use a TV, we don't have to install a screen everytime we use it.
			The screen is just there. In programming terms, this does
			<span class="underlineText">not</span> mean that we write all of our code
			in a single file. Instead, it means that everything the program needs is
			connected in such a way that they all work together a single unit.
		</p>
		<p>
			Encapsulation, however, goes a bit further than this in programming terms.
			It also implies <span class="italicsText">isolation</span>. Large programs
			often consist of many small modules. For example, if we wrote a program
			that provides text editing, we might have a module for saving files,
			another to output text, another to italicize text, another to recover
			files. These are all separate modules that are
			<span class="italicsText">encapsulated</span>. Encapsulation tells us that
			we must isolate these modules. Why? To prevent one module from accessing,
			and modifying, the other. We want the modules to work together, but we
			don't want one module interfering with, or even accessing, the internal
			work of another. For example, the federal government is a giant
			encapsulation. However, the Constitution places barriers on the various
			branches &mdash; the Supreme Court, Congress, and the President &mdash;
			interfering with one another. And even within the branches, there are
			barriers. Homeland Security can't dictate orders to the NSA, nor can the
			Ninth Circuit go snooping into the Seventh Circuit's files.
		</p>
	</section>

	<section id="inheritance">
		<p>
			<span class="topic">Inheritance.</span> Inheritance embodies the principle
			of reusing existing work. For example, consider the iPhone. The iPhone, as
			a single entity, is an Apple mobile phone. It has a distinct appearance
			&mdash; rounded corners, large screen realty, and a slim form factor.
			However, the iPhone has various models: iPhone SE, iPhone X, iPhone iPhone
			XR, etc. They are, however, all iPhones. Their distinguishing features lie
			in various optimizations. One phone might have a more expensive processor,
			another a better camera. Nevertheless, much of the existing work is reused
			&mdash; the general form factor, the operating system, the machine code,
			etc.
		</p>
		<p>
			OOP applies this principle to programming. Suppose we wrote a program that
			simulates various doctors working in a hospital. We write one program that
			simulates a cardiothoracic surgeon. The cardiothoracic surgeon uses a
			stethoscope on a patient, so we write some code simulating this action.
			The cardiothoracic surgeon then performs an angioplasty, and we write
			another piece of code to simulate this action. We then write another
			program that simulates a neurosurgeon. The neurosurgeon also uses a
			stethoscope, so we copy-and-paste the code from the cardiothoracic surgeon
			in the neurosurgeon's program the code for this action. The neurosurgeon
			also performs a craniotomy, so we include the code for this action as
			well. Because of encapsulation, we keep the cardiologist and the
			neursurgeon's code separate. After all, we don't want the neurosurgeon
			interfering with open-heart surgery.
		</p>
		<p>
			The problem, however, is that copy-and-paste for the stethoscope code. We
			only have two doctors, but what happens when we start having all kinds of
			doctors: anesthesiologists, pediatricians, radiologists, endocrinologists;
			they will all likely use a stethoscope at some point. All of these doctors
			will also likely have to request a test, physically examine patients, take
			notes, and so on. We do not want to copy-and-paste all of this code. But,
			we can't put them all in one place either because of encapsulation.
		</p>
		<p>
			Inheritance is the medicament. What an OOP language like Java allows us to
			do is to write a more general module of code containing all of the common
			pieces of code between the various doctors, and give it a name, say
			<span class="monoText">Doctor</span>. We can then write code that says,
			&#8220;See all that <span class="monoText">Doctor</span>? Place it in this
			code named <span class="monoText">Dermatologist</span>.&#8221; The code
			simulating a dermatologist essentially
			<span class="italicsText">inherits</span> everything that
			<span class="monoText">Doctor</span> contains. We can use the same
			instruction for all the other categories, thereby ridding ourselves of
			copy-and-paste.
		</p>
		<p>
			<span class="topic">Polymorphism.</span> The principle of
			<span class="italicsText">polymorphism</span> provides that entities can
			look, be used, or behave like one thing, but also another. For example,
			the cast iron skillet can be used as a cooking utensil, but also a weapon.
			The company CEO can be cold and unforgiving, but also a loving mother. The
			pet tiger can be just as loving, but also dangerous.
		</p>
		<p>
			In OOP, we apply polymorphism to write more customized code. The idea is
			that the different modules in our program should react to our instructions
			or inputs as needed, even if the modules share similarities with other
			pieces of code. Returning to our doctor-simulation example, suppose a
			large disaster occurs near the hospital, and a
			<span class="italicsText">Code Triage</span> is sent out. That code is an
			input to all of the doctors, regardless of what kind of doctors they are.
			But, we want all of them to have different responses to that input. The
			cardiologists do one thing, the neurologists another, etc. Polymorphism is
			what allows us to accomplish this. The
			<span class="monoText">Code Triage</span> is received by
			<span class="monoText">Doctor</span>, but every kind of
			<span class="monoText">Doctor</span> responds to it differently.
		</p>
	</section>
</section>

<section id="what_is_an_object">
	<h2>What is an object?</h2>
	<p>
		Objects are data structures that combine
		<span class="italicsText">state</span> (e.g., variables; storing
		information) and <span class="italicsText">behavior</span> (e.g., functions;
		what things we can do with that stored information).
	</p>
	<p>
		For something to be an object, it must answer the following questions: (1)
		What does it store? In other words, what
		<span class="italicsText">state</span>, or information, does this thing
		store? (2) What does it do? What sort of functionality does the thing
		provide?
	</p>
	<p>
		We've seen one object repeatedly, strings. Strings have a state: They store
		values of type <span class="monoText">char</span>, along with those values'
		respective indices. Strings also have functions (called
		<span class="italicsText">methods</span>) that operate on all strings:
		indexing, concatentation, slicing, upper-casing, etc. Thus, strings satisfy
		the definition of an object: (1) they store data, and (2) they implement
		algorithms.
	</p>
	<p>
		<span class="topic">Objects in Java.</span> In the discussion above, we used
		the term &#8220;object&#8221; loosely. To be very specific, an
		<span class="italicsText">object</span> is an instance of a
		<span class="term">class</span> &mdash; a representation of real-world
		objects. An object is simply one instance of that class. For example,
		<span class="monoText">reptile</span> is a class, and
		<span class="monoText">crocodile</span> is an instance of that class. Of
		course, <span class="monoText">crocodile</span> itself can be a class, with
		<span class="monoText">Nile crocodile</span> and
		<span class="monoText">Saltwater crocodiles</span> as instances of that
		class. An individual saltwater crocodile would be instance of
		<span class="monoText">Saltwater crocodiles</span>. Thus, as a matter of
		logic, classes are objects, but not all objects are classes.
	</p>
</section>

<section id="java_classes">
	<h2>Classes</h2>
	<p>
		A
		<span class="term">class</span> in Java determines how a particular
		<span class="italicsText">type</span> of object will behave. We can think of
		a class as a blueprint that creates object instances of a particular type.
	</p>
	<p>
		Analogously, we can think of a class as a statute that defines certain
		persons. For example, metaphysically, there is no such thing as an
		&#8220;asylum seeker&#8221; (epistemology and philosophy of language aside).
		Such an entity exists only because of the definition provided by 8 U.S.C. ยง
		1158. Absent that statute, there are no asylum seekers. If a person is an
		asylum seeker, there are certain things we can do with that person,
		separating it from other persons &mdash; we can allow them to obtain certain
		visas, they can follow special tracks to obtaining a Green Card, there are
		certain things the federal government cannot do with them, etc. The same
		concept underlies classes in programming.
	</p>
	<p>
		Here is an example of a
		<span class="italicsText">class declaration</span> creating a new type
		called <span class="monoText">Person</span>:
	</p>
	<pre class="language-java"><code>
			class Person {
				String name;
				int age;
				void printName() {
					System.out.println(this.name);
				}
			}
		</code></pre>
	<p>
		When we define a class, we start with the special keyword
		<span class="monoText">class</span>. Then we give it a name, in this case,
		<span class="monoText">Person</span>. As a matter of convention, class names
		are capitalized. Note further that assignments in Java cannot be done at the
		class level. For example, this simply won't work:
	</p>
	<pre class="language-java"><code>
			class Person {
				String name = "Dan"; // illegal
				int age;
				void printName() {
					System.out.println(this.name);
				}
			}
		</code></pre>
	<p>
		After the name, we have a block, the class definition's body. Inside that
		block, we have pieces of data and algorithms. In the example above, the body
		says: every instance of <span class="monoText">Person</span>, i.e., every
		object of type <span class="monoText">Person</span>, has a
		<span class="monoText">name</span>, a piece of data of type
		<span class="monoText">String</span>, and an
		<span class="monoText">age</span>, a piece of data of type
		<span class="monoText">int</span>. This is the
		<span class="italicsText">state</span> that every object of type
		<span class="monoText">Person</span> stores.
	</p>
	<p>
		Furthermore, every object of type <span class="monoText">Person</span> can
		perform an algorithm called <span class="monoText">printName()</span>. This
		is the <span class="italicsText">behavior</span> that every object of type
		<span class="monoText">Person</span> stores. In the method's definition, we
		indicate that the method takes no arguments, and returns nothing (<span
			class="monoText"
			>void</span
		>). Recall that <span class="monoText">void</span> is a special type, used
		only with method declarations to indicate the method does not return
		anything.
	</p>
	<p>
		A word of caution: Unlike languages like Python and JavaScript, Java classes
		<span class="underlineText">cannot</span> be modified after the program is
		compiled. This means that if we needed to make a change to a class
		definition, we must recompile the program before execution. This can be
		frustrating when writing smaller pieces of code, but it is particularly
		useful once we start dealing with very large programs.
	</p>
</section>

<section id="keyword_new">
	<h3>The <span class="monoText">new</span> Keyword.</h3>
	<p>
		In the previous sections, we often used the keyword
		<span class="monoText">new</span>, and we stated we would discuss it in
		later sections. Now that we've introduced objects, we can begin that
		discussion. An <span class="term">instance</span> of a class is an object of
		the type created by that class. To create an instance, we must use the
		<span class="monoText">new</span> keyword:
	</p>
	<pre class="language-java"><code>
			// create a new type called Person

			class Person {
				String name;
				int age;
				void printName() {
					System.out.println(this.name);
				}
			}

			// create an object of type Person
			
			Person adam = new Person();
		</code></pre>
	<p>
		The type <span class="monoText">Person</span> can be used just like how an
		<span class="monoText">int</span> or <span class="monoText">char</span> is
		are used, but we must use the keyword <span class="monoText">new</span>.
	</p>
</section>

<section id="getters_and_setters">
	<h3>Getters & Setters</h3>
	<p>
		Like many other object-oriented languages, the states and behaviors of Java
		objects are accessed and set using
		<span class="term">dot notation</span>:
	</p>
	<pre class="language-java"><code>
			// create a new type called Person
			class Person {
				String name;
				int age;
				void printName() {
					System.out.println(this.name);
				}
			}

			// create an object of type Person
			Person adam = new Person();

			// set the instance variables
			adam.age = 40;
			adam.name = "Adam";

			// use the instance variables
			System.out.println(adam.age);

			// call the method
			adam.printName();
		</code></pre>
	<pre class="language-bash"><code>
			40
			Adam
		</code></pre>
</section>

<section id="instance_variables">
	<p>
		<span class="topic">Instance Variables.</span> With classes, we can use
		instance variables that are of
		<span class="italicsText">primitive types</span> or of
		<span class="italicsText">types we've created</span>. This ability allows us
		to create classes of varying complexity:
	</p>
	<pre class="language-java"><code>
			class Dimensions {
				int length;
				int width;
				int height;
			}
			class Room {
				String name;
				Dimensions dimensions;
			}
			Room diningRoom = new Room();
			diningRoom.dimensions = new Dimensions();
			diningRoom.dimensions.length = 50;
			diningRoom.dimensions.width = 20;
			diningRoom.dimensions.height = 40;
		</code></pre>
	<p>
		Why might we write a separate class for dimensions? Well, rooms aren't the
		only things with dimensions. Windows, tables, cabinets, closets, these all
		have dimensions. We don't want to repeat ourselves.
	</p>
	<p>
		<span class="topic"
			>Class Instances and the Value <span class="monoText">null</span>.</span
		>
		If we create a new class instance without initializing its instance
		variables, those instance variables have a default value of
		<span class="monoText">null</span>. This is a common Java feature that
		confuses those new to the language.
	</p>
	<pre class="language-java"><code>
			class Dimensions {
				int width;
				int height;
			}
			class Room {
				String name;
				Dimensions dimensions;
			}
			Room diningRoom = new Room();
			System.out.println(diningRoom.dimensions.width);
		</code></pre>
	<pre class="language-bash"><code>
			null
		</code></pre>
</section>

<section id="java_methods">
	<p>
		<span class="topic">Methods.</span> The methods we define in a class have
		access to the variables defined <span class="italicsText">inside</span> that
		class; i.e., the instance variables. Thus:
	</p>
	<pre class="language-java"><code>
			class Dimensions {
				int width;
				int height;

				int area() {
					System.out.println(width);
					return width * height;
				}
			}
			Dimensions example = new Dimensions();
			example.width = 10;
			example.height = 20;
			Dimensions second = new Dimensions();
			second.width = 20;
			second.height = 20;
			System.out.println(example.area());
			System.out.println(second.area());
		</code></pre>
	<pre class="language-bash"><code>
			10
			200
			20
			400
		</code></pre>
</section>

<section id="this_keyword">
	<p>
		<span class="topic">The <span class="monoText">this</span> Keyword.</span>
		The <span class="monoText">this</span> keyword is a special variable used to
		refer to the instance of the class. Thus, when we define a method, we use
		<span class="monoText">this</span> to refer to the instance's instance
		variables.
	</p>
	<pre class="language-java"><code>
			class Dimensions {
				int width;
				int height;

				int area() {
					return this.width * this.height;
				}
			}
		</code></pre>
	<p>
		Unlike many other programming languages, we do not
		<span class="italicsText">have</span> to use the
		<span class="monoText">this</span> keyword. We can, but because the method
		has access to the instance variables, the keyword is not necessary.
	</p>
</section>

{% endblock %}
