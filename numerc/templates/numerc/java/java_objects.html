{% extends '../layout.html' %} {% load static %} {% block description %}
<meta name="description" content="Java classes" />
{% endblock %} {% block title %}
<title>Java Classes</title>
{% endblock %} {% block content %}
<h1>Object-Oriented Programming</h1>

<section id="intro">
	<p>
		<span class="drop">A</span>ll of the topics covered thus far are
		concepts we can collect into our programming toolbox and use as needed.
		Indeed, a substantial part of being a programmer is discovering new
		concepts to add to that toolbox. We now introduce another concept
		&mdash; <i>objects</i>.
	</p>
	<p>
		Objects are placed in the tool slot for data structures &mdash; objects
		are one possible approach for organizing data. More specifically, they
		allow us to create custom <i>types</i>. So far, we have only used
		primitive types &mdash; the types Java provides by default. Objects
		give us a way to have more types.
	</p>
	<p>
		Recall: How do we structure good programs? So far, we've seen one
		approach: Using <i>functions</i> &mdash; break down the program into
		smaller, reusable, testable, and understandable pieces. Objects give us
		a second approach: Combining <i>state</i> and <i>behavior</i> &mdash;
		modeling data (state) and what we can do with that data (behavior).
	</p>
	<p>
		Creating objects is a strenous exercise of creativity, imagination,
		holistic thinking, and intuition. This is in contrast to implementing
		functions, which often involves logic, fact analysis, and computation.
		This is because implementing objects depends much more heavily on
		design, rather than sequences of steps. This method of programming is
		called
		<b>object-oriented programming</b> (often shortened to OOP). In this
		volume's preface, we gave a brief glimpse of what object-oriented
		programming is. We will now perform a more thorough and rigorous
		investigation.
	</p>
</section>

<section id="principles_of_object_oriented_programming">
	<h2>Principles of Object-oriented Programming</h2>
	<p>
		In object-oriented programming, we write code according to four key
		principles: abstraction, encapsulation, inheritance, and polymorphism.
		To understand what all of these terms mean, we will use various
		analogies.
	</p>
	<section id="abstraction">
		<p>
			<span class="topic">Abstraction.</span> The Oxford dictionary defines
			<i>abstraction</i> as &#8220;the process of considering something
			independently of its associations, attributes, or concrete
			accompaniments.&#8221; This is a good starting point, but let's see
			some examples of this process in action.
		</p>
		<p>
			Consider the microwave. Not very many people know how a microwave
			works. In fact, if you really think about it, it's a fairly strange
			machine. We open its door, place our food, set a timer, and it just
			rotates a tray. There's a lightbulb on and some humming, but there's
			no fire or obvious source of heat. Yet once the timer's done, our
			food is heated. Despite the fact that few people know how the
			microwave actuall works, it's a fairly commonplace appliance &mdash;
			we find it houses, apartments, gas stations, offices, and various
			locations. And it's a fairly commonplace appliance because people can
			use it without knowing the internal details. We push one button and
			the door opens. We enter digits, hit start, and a timer ensures. All
			of this is done without the user knowing how the button leads to the
			door opening, or how the digits correspond to a timer. The microwave
			is an abstraction of all the pieces that comprise it &mdash; the
			control panel, high voltage transformer, capacitor, magnetron,
			antenna, cooling fan, wave guide, wave stirrer, and a plethora of
			other components.
		</p>
		<p>
			The microwave is just one example of an abstraction. We can use, or
			&#8220;consider,&#8221; the microwave without knowing anything about
			how it works or its internal details. Another example: the cellphone.
			Very few peole know how a cellphone works, yet it's used across the
			world and across cultures. It's an abstraction of transistors,
			machine code, an operating system, a file system, source code for
			applications, etc.
		</p>
		<p>
			Abstraction is a core principle of object-oriented programming. In
			writing code to be used by another, we want the user to be able to
			use the program without having to think about how the code works. And
			by user, we don't necessarily mean people. This idea also extends to
			other code, other programs. When we write some piece of code ${x}$ to
			be used by another piece of code ${y,}$ ${y}$ shouldn't have to
			consider how ${x}$ is implemented. It should be able to just use
			${x}$ as is.
		</p>
	</section>

	<section id="encapsulation">
		<p>
			<span class="topic">Encapsulation.</span> Encapsulation is exactly
			what it sounds like &mdash; everything is contained in a single
			entity. Essentially, whatever the program needs is contained in a
			single place. When we use a TV, we don't have to install a screen
			everytime we use it. The screen is just there. In programming terms,
			this does <span class="underlineText">not</span> mean that we write
			all of our code in a single file. Instead, it means that everything
			the program needs is connected in such a way that they all work
			together a single unit.
		</p>
		<p>
			In OOP, we apply encapsulation by bundling, or packaging,
			<i>properties</i> and <i>behaviors</i>. At its core, data is a
			representation of real world information. With sufficiently complex
			information, a program can grow gargantuan. Such large programs are
			examples of <b>monolithic programming</b>. With functions and
			collections, we can modularize parts of the large program into
			smaller, more manageable pieces. However, with more and more modules,
			it can become difficult to keep track of all the different pieces.
			Encapsulation is OOP's response to this problem. We look at all the
			different pieces, determine their relationships, and bundle them
			together into a single package accordingly.
		</p>
		<p>
			Encapsulation, however, goes a bit further than this in programming
			terms. It also implies <i>isolation</i>. Large programs often consist
			of many small modules. For example, if we wrote a program that
			provides text editing, we might have a module for saving files,
			another to output text, another to italicize text, another to recover
			files. These are all separate modules that are <i>encapsulated</i>.
			Encapsulation tells us that we must isolate these modules. Why? To
			prevent one module from accessing, and modifying, the other. We want
			the modules to work together, but we don't want one module
			interfering with, or even accessing, the internal work of another.
			For example, the federal government is a giant encapsulation.
			However, the Constitution places barriers on the various branches
			&mdash; the Supreme Court, Congress, and the President &mdash;
			interfering with one another. And even within the branches, there are
			barriers. Homeland Security can't dictate orders to the NSA, nor can
			the Ninth Circuit go snooping into the Seventh Circuit's files.
		</p>
	</section>

	<section id="inheritance">
		<p>
			<span class="topic">Inheritance.</span> Inheritance embodies the
			principle of reusing existing work. For example, consider the iPhone.
			The iPhone, as a single entity, is an Apple mobile phone. It has a
			distinct appearance &mdash; rounded corners, large screen realty, and
			a slim form factor. However, the iPhone has various models: iPhone
			SE, iPhone X, iPhone iPhone XR, etc. They are, however, all iPhones.
			Their distinguishing features lie in various optimizations. One phone
			might have a more expensive processor, another a better camera.
			Nevertheless, much of the existing work is reused &mdash; the general
			form factor, the operating system, the machine code, etc.
		</p>
		<p>
			OOP applies this principle to programming. Suppose we wrote a program
			that simulates various doctors working in a hospital. We write one
			program that simulates a cardiothoracic surgeon. The cardiothoracic
			surgeon uses a stethoscope on a patient, so we write some code
			simulating this action. The cardiothoracic surgeon then performs an
			angioplasty, and we write another piece of code to simulate this
			action. We then write another program that simulates a neurosurgeon.
			The neurosurgeon also uses a stethoscope, so we copy-and-paste the
			code from the cardiothoracic surgeon in the neurosurgeon's program
			the code for this action. The neurosurgeon also performs a
			craniotomy, so we include the code for this action as well. Because
			of encapsulation, we keep the cardiologist and the neursurgeon's code
			separate. After all, we don't want the neurosurgeon interfering with
			open-heart surgery.
		</p>
		<p>
			The problem, however, is that copy-and-paste for the stethoscope
			code. We only have two doctors, but what happens when we start having
			all kinds of doctors: anesthesiologists, pediatricians, radiologists,
			endocrinologists; they will all likely use a stethoscope at some
			point. All of these doctors will also likely have to request a test,
			physically examine patients, take notes, and so on. We do not want to
			copy-and-paste all of this code. But, we can't put them all in one
			place either because of encapsulation.
		</p>
		<p>
			Inheritance is the medicament. What an OOP language like Java allows
			us to do is to write a more general module of code containing all of
			the common pieces of code between the various doctors, and give it a
			name, say
			<var>Doctor</var>. We can then write code that says, &#8220;See all
			that <var>Doctor</var>? Place it in this code named
			<var>Dermatologist</var>.&#8221; The code simulating a dermatologist
			essentially <i>inherits</i> everything that
			<var>Doctor</var> contains. We can use the same instruction for all
			the other categories, thereby ridding ourselves of copy-and-paste.
		</p>
		<p>
			<span class="topic">Polymorphism.</span> The principle of
			<i>polymorphism</i> provides that entities can look, be used, or
			behave like one thing, but also another. For example, the cast iron
			skillet can be used as a cooking utensil, but also a weapon. The
			company CEO can be cold and unforgiving, but also a loving mother.
			The pet tiger can be just as loving, but also dangerous.
		</p>
		<p>
			In OOP, we apply polymorphism to write more customized code. The idea
			is that the different modules in our program should react to our
			instructions or inputs as needed, even if the modules share
			similarities with other pieces of code. Returning to our
			doctor-simulation example, suppose a large disaster occurs near the
			hospital, and a
			<i>Code Triage</i> is sent out. That code is an input to all of the
			doctors, regardless of what kind of doctors they are. But, we want
			all of them to have different responses to that input. The
			cardiologists do one thing, the neurologists another, etc.
			Polymorphism is what allows us to accomplish this. The
			<var>Code Triage</var> is received by <var>Doctor</var>, but every
			kind of <var>Doctor</var> responds to it differently.
		</p>
	</section>
</section>

<section id="what_is_an_object">
	<h2>What is an object?</h2>
	<p>
		Objects are data structures that combine
		<i>state</i> (e.g., variables; storing information) and
		<i>behavior</i> (e.g., functions; what things we can do with that
		stored information).<sup></sup> For something to be an object, it must
		answer the following questions: (1) What does it store? In other words,
		what <i>state</i>, or information, does this thing contain? (2) What
		does it do? What sort of functionality does the thing provide?
	</p>
	<div class="note">
		<p>
			From a Java perspective, an object is an instance of a class, and the
			class defines the object. We can also think of an object as a pill:
		</p>
		<figure>
			<img
				src="{% static 'images/encapsulationJava.svg' %}"
				alt=""
				loading="lazy"
				width="200px"
				height="200px"
			/>
		</figure>
	</div>
	<p>
		We've seen one object repeatedly &mdash; the string. Strings have a
		state: They store values of type <var>char</var>, along with those
		values' respective indices. Strings also have functions (called
		<i>methods</i>) that operate on all strings: indexing, concatentation,
		slicing, upper-casing, etc. Thus, strings satisfy the definition of an
		object: (1) they store data, and (2) they implement algorithms.
	</p>
	<p>
		<span class="topic">Objects in Java.</span> In the discussion above, we
		used the term &#8220;object&#8221; loosely. To be very specific, an
		<i>object</i> is an instance of a <b>class</b> &mdash; a representation
		of real-world objects. An object is simply one instance of that class.
		For example, <var>reptile</var> is a class, and <var>crocodile</var> is
		an instance of that class. Of course, <var>crocodile</var> itself can
		be a class, with <var>Nile crocodile</var> and
		<var>Saltwater crocodiles</var> as instances of that class. An
		individual saltwater crocodile would be instance of
		<var>Saltwater crocodiles</var>. Thus, as a matter of logic, classes
		are objects, but not all objects are classes.
	</p>
</section>

<section id="java_classes">
	<h2>Classes</h2>
	<p>
		The word &#8220;class&#8221; has many multiple meanings in programming.
		In Java, the class is a cornerstone of the language implementation. All
		Java programs are defined as classes. Based on this premise, we can
		think of programs that extend programs as
		<i>subclasses</i>.<sup></sup>
	</p>
	<div class="note">
		<p>
			Roughly, classes are what we use to create our own types. Such types
			are called <i>user-defined data types.</i>
		</p>
	</div>
	<p>
		Classes, however, are also the implementations of a data type &mdash;
		blueprints, or templates, for producing objects. If this all seems
		confusing, do not worry. We will explore each of these ideas in turn.
		These points are raised now as an alert to the fact that the word class
		has many different meanings. And like many words with multiple
		meanings, which meaning we use depends on context. The simplest way to
		think about a class is that it's just another way to package related
		code, much like a function. However, unlike the function, the class
		packages a specific kind of code: Code that produces packages of code.
	</p>
	<p>
		The class is a blueprint that creates instances of the class. These
		instances are called objects. The objects themselves are packages of
		code. Inside these packages of code, there are two types of code: (1)
		Code that represents <b>state</b>, and (2) code that represents
		<b>behavior</b>.<sup></sup>
	</p>
	<div class="note">
		<p>
			At a more abstract level, a class is the specification for a data
			type. And as such, objects are just instaces of a type, which is
			implemented by a class. We will see what this means in later
			sections.
		</p>
	</div>
	<p>
		This essentially means that a class is a way to group, or bundle,
		related
		<i>properties</i> and <i>behaviors</i>. This in turn means that classes
		allow us to implement our own <i>data types</i>. For example, here's a
		<i>class declaration</i> creating a new type called <var>Person</var>:
	</p>
	<pre class="language-java"><code>
			class Person {
				String name;
				int age;
				void printName() {
					System.out.println(this.name);
				}
			}
		</code></pre>
	<p>
		When we define a class, we start with the special keyword
		<var>class</var>. Then we give it a name, in this case,
		<var>Person</var>. As a matter of convention, class names are
		capitalized. Note further that assignments in Java cannot be done at
		the class level. For example, this simply won't work:
	</p>
	<pre class="language-java"><code>
			class Person {
				String name = "Dan"; // illegal
				int age;
				void printName() {
					System.out.println(this.name);
				}
			}
		</code></pre>
	<p>
		After the name, we have a block, the class definition's body. Inside
		that block, we have pieces of data and algorithms. In the example
		above, the body says: every instance of <var>Person</var>, i.e., every
		object of type <var>Person</var>, has a <var>name</var>, a piece of
		data of type <var>String</var>, and an <var>age</var>, a piece of data
		of type <var>int</var>. The variables <var>name</var> and
		<var>age</var> constitute <b>properties</b> of the class
		<var>Person</var>. All of these properties in turn represent the
		<b>state</b> that every object of type <var>Person</var> stores.
	</p>
	<p>
		Furthermore, every object of type <var>Person</var> can perform an
		algorithm called <var>printName()</var>. This algorithm is defined in a
		<b>method</b>. All of the methods a the class
		<var>Person</var> contains constitutes the <b>behavior</b> stored by
		instances, or <b>objects</b>, of type <var>Person</var>. In the
		method's definition, we indicate that the method takes no arguments,
		and returns nothing (<span class="monoText">void</span>). Recall that
		<var>void</var> is a special type, used only with method declarations
		to indicate the method does not return anything.
	</p>
	<p>
		A word of caution: Unlike languages like Python and JavaScript, Java
		classes
		<span class="underlineText">cannot</span> be modified after the program
		is compiled. This means that if we needed to make a change to a class
		definition, we must recompile the program before execution. This can be
		frustrating when writing smaller pieces of code, but it is particularly
		useful once we start dealing with very large programs.
	</p>
</section>

<section id="keyword_new">
	<p>
		<span class="topic">The <var>new</var> Keyword.</span>
		In the previous sections, we often used the keyword
		<var>new</var>, and we stated we would discuss it in later sections.
		Now that we've introduced objects, we can begin that discussion. An
		<b>instance</b> of a class is an object of the type created by that
		class. To create an instance, we must use the <var>new</var> keyword:
	</p>
	<pre class="language-java"><code>
			// create a new type called Person

			class Person {
				String name;
				int age;
				void printName() {
					System.out.println(this.name);
				}
			}

			// create an object of type Person
			
			Person adam = new Person();
		</code></pre>
	<p>
		The type <var>Person</var> can be used just like how an
		<var>int</var> or <var>char</var> are used, but do so, we must use the
		keyword <var>new</var>.
	</p>
</section>

<section id="dot_notation">
	<p>
		<span class="topic">Dot Notation</span>
		Like many other object-oriented languages, the states and behaviors of
		Java objects are accessed and set using
		<b>dot notation</b>:
	</p>
	<pre class="language-java"><code>
			// create a new type called Person
			class Person {
				String name;
				int age;
				void printName() {
					System.out.println(this.name);
				}
			}

			// create an object of type Person
			Person adam = new Person();

			// set the instance variables
			adam.age = 40;
			adam.name = "Adam";

			// use the instance variables
			System.out.println(adam.age);

			// call the method
			adam.printName();
		</code></pre>
	<pre class="language-bash"><code>
			40
			Adam
		</code></pre>
</section>

<section id="instance_variables">
	<h3>Instance Variables</h3>
	<p>
		With classes, we can use instance variables that are of
		<i>primitive types</i> or of <i>types we've created</i>. This ability
		allows us to create classes of varying complexity:
	</p>
	<pre class="language-java"><code>
			class Dimensions {
				int length;
				int width;
				int height;
			}
			class Room {
				String name;
				Dimensions dimensions;
			}
			Room diningRoom = new Room();
			diningRoom.dimensions = new Dimensions();
			diningRoom.dimensions.length = 50;
			diningRoom.dimensions.width = 20;
			diningRoom.dimensions.height = 40;
		</code></pre>
	<p>
		Why might we write a separate class for dimensions? Well, rooms aren't
		the only things with dimensions. Windows, tables, cabinets, closets,
		these all have dimensions. We don't want to repeat ourselves.
	</p>
	<p>
		<span class="topic"
			>Class Instances and the Value <var>null</var>.</span
		>
		If we create a new class instance without initializing its instance
		variables, those instance variables have a default value of
		<var>null</var>. This is a common Java feature that confuses those new
		to the language.
	</p>
	<pre class="language-java"><code>
			class Dimensions {
				int width;
				int height;
			}
			class Room {
				String name;
				Dimensions dimensions;
			}
			Room diningRoom = new Room();
			System.out.println(diningRoom.dimensions.width);
		</code></pre>
	<pre class="language-bash"><code>
			null
		</code></pre>
</section>

<section id="java_methods">
	<h3>Methods</h3>
	<p>
		The methods we define in a class have access to the variables defined
		<i>inside</i> that class; i.e., the instance variables. Thus:
	</p>
	<pre class="language-java"><code>
		class Dimensions {
			int width;
			int height;

			int area() {
				System.out.println(width);
				return width * height;
			}
		}
		Dimensions example = new Dimensions();
		example.width = 10;
		example.height = 20;
		Dimensions second = new Dimensions();
		second.width = 20;
		second.height = 20;
		System.out.println(example.area());
		System.out.println(second.area());
	</code></pre>
	<pre class="language-bash"><code>
		10
		200
		20
		400
	</code></pre>
</section>

<section id="constructors_and_visibility">
	<h3>Constructors</h3>
	<p>
		Up until this point, we've been purposefully hiding certain parts of
		the Java program:
	</p>
	<pre class="language-java"><code>
		public class foo {
			public static void main(String[] unused) {
				System.println("Hello, world!")
			}
		}
	</code></pre>
	<p>
		We avoided discussing things like <var>class</var>, <var>public</var>,
		and <var>static</var> to prevent overcomplicating introductory matters.
		Now that we've seen classes, however, we can address these mysterious
		symbols.
	</p>
	<p>
		In Java, everything we write <span class="underlineText">must</span> be
		inside a class. In the code above, we have class called <var>foo</var>.
		The name <var>foo</var> is the name of the <var>.java</var> file
		containing the code. Inside the class <var>foo</var>, we have a method
		called <var>main</var>. The method is called <var>main</var> because
		that is where all of our actual, executed code is placed. It
		effectively tells Java, &#8220;Start here.&#8221;
	</p>
	<p>
		When we actually define classes, we place them outside the
		<var>foo</var> class:
	</p>
	<pre class="language-java"><code>
		class Dimensions {
			public int width;
			public int height;

			public int area() {
				return width * height;
			}
		}

		public class foo {
			public static void main(String[] args[]) {
				Dimensions firstRoom = new Dimensions();
				firstRoom.width = 10;
				firstRoom.height = 20;

				Dimensions secondRoom = new Dimensions();
				secondRoom.width = 8;
				secondRoom.height = 4;

				System.out.println(firstRoom.area());
				System.out.println(secondRoom.area());
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		200
		32
	</code></pre>
	<p>
		What exactly is <var>String[]</var> and <var>args[]</var>? These
		parameters must be placed inside the <var>main()</var> method because
		we they serve as placeholder variables for when arguments are passed
		into the overall program itself. Those arguments are placed in an
		array. We will further develop this point in later sections. We will
		also speak at greater lengths in later sections what the symbol
		<var>public</var> means, but for now: The <var>public</var> keyword
		tells Java that a particular object is visible to all other classes
		(i.e., all other classes can access that particular object, whether its
		a variable or a method). Again, we will elaborate on these points as we
		continue.
	</p>

	<section id="this_keyword">
		<p>
			<span class="topic">The <var>this</var> Keyword.</span>
			To understand the <var>this</var> keyword, it's helpful to think
			about what actually happens in memory when we define and instantiate
			classes. When we define a class, our definition statements are stored
			in a place in the JVM called the <b>permanent generation area</b>.
			When we instantiate a class, i.e., create a <var>new</var> object,
			the object is created in heap memory. Because our program cannot
			access heap memory, <var>new ${constructor}$()</var> returns a
			reference to that object. When we call a method, that method is
			placed in an area of the JVM called the <b>method area</b>, or more
			generally, stack memory. Thus, whatever variables are used inside a
			method, such as <var>main(string[] args)</var>, are stored in the
			stack. Thus, a reference variable inside <var>main()</var> lives in
			the stack, but the variable holds a reference to an object stored in
			the heap.
		</p>
		<p>
			The <var>this</var> keyword is a special variable used to refer to
			the instance of the class. Thus, when we define a method, we use
			<var>this</var> to refer to the instance's instance variables.
		</p>
		<pre class="language-java"><code>
				class Dimensions {
					int width;
					int height;
	
					int area() {
						return this.width * this.height;
					}
				}
			</code></pre>
		<p>
			Unlike many other programming languages, we do not
			<i>have</i> to use the <var>this</var> keyword. We can, but because
			the method has access to the instance variables, the keyword is not
			necessary.
		</p>
	</section>

	<p>
		<span class="topic">Default Values for Instance Variables.</span> Note
		that we can set default values for instance variables. This is
		particularly useful when we know an instance variable should have a
		value, but for whatever reason, either we or a user fail to provide
		that value:
	</p>
	<pre class="language-java"><code>
		class Dimensions {
			public int width = 1;
			public int height = 1;

			public int area() {
				return width * height;
			}
		}

		public class foo {
			public static void main(String[] args[]) {
				Dimensions firstRoom = new Dimensions();
				firstRoom.width = 10;
				firstRoom.height = 20;

				Dimensions secondRoom = new Dimensions();

				System.out.println(firstRoom.area());
				System.out.println(secondRoom.area());
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		200
		1
	</code></pre>
	<p>
		Notice that we did not define instance variables for the object
		<var>secondRoom</var>, but an area was returned because the instance
		variables are assigned the value <var>1</var> by default.
	</p>
	<p>
		<span class="topic"
			>Constructors: What Happens when an Object is Created?</span
		>
		Whenever we create a new instance of a class, we use the keyword
		<var>new</var>. Notice, however, that when we create the instance, it
		almost looks like a method call:
	</p>
	<pre class="language-java"><code>
		Dimensions example = new Dimensions();
	</code></pre>
	<p>
		The parentheses are included because calling a method is precisely what
		happens when we create an object. Every new object is created through a
		special method in Java called a <b>constructor</b>. When a new class is
		created, the constructor in the code below is executed:
	</p>
	<pre class="language-java"><code>
		class Course {
			String name;

			// This is a constructor
			Course(String setName) {
				name = setName;
			}
		}
	</code></pre>
	<p>
		A constructor is called
		<span class="underlineText">exactly once</span> &mdash; when the class
		is first created. There is no way to call it again later. It also does
		not explicitly return anything other than the instance of the class.
	</p>
	<p>
		There is something odd about the constructor method: There is no return
		type. The method does not have a return type because it will always
		return just one thing &mdash; an instance of the class. As such, there
		is no reason or need for the constructor to have a return type.
		Furthermore, the method shares the same name as the class. This is a
		syntax requirement for constructors.
	</p>
	<p>
		We use constructors because they allow us to be much more specific when
		we initialize a class. For those familiar with Python, constructors are
		the Java equivalent of <i>default arguments</i>. Java's approach to
		this feature is undoubtedly much worse than Python's, but we must make
		do.
	</p>
	<p>
		If we do not define a constructor, Java will define a constructor for
		us:
	</p>
	<pre class="language-java"><code>
		class Course {
			String name;
		}

		// The above is the same as:

		class Course {
			String name;
			Course() {

			}
		}
	</code></pre>
	<p>
		The most important point with respect to constructors: The constructor
		<span class="underlineText">must</span> return a new instance of the
		class.
	</p>
	<pre class="language-java"><code>
		class Course {
			String name;
			Course(String setName) {
				name = setName;
				// But what if name is invalid?
			}
		}
	</code></pre>
	<p>
		Because of this requirement, under no circumstances can a constructor
		fail. This is a point of more than mild annoyance for Java programmers,
		because it effectively means there is no way to perform argument
		validation within a constructor itself other than with errors and
		exceptions.
	</p>
	<p>
		Constructors, however, provide a useful way to ensure arguments are
		provided:
	</p>
	<pre class="language-java"><code>
		class Person {
			String name;
			double age;
		}

		public class foo {
			public static void main(String[] args[]) {
				Person bill = new Person();
				System.out.println(bill.name);
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		null
	</code></pre>
	<p>
		We get back <var>null</var> because we did not initialize the instance
		variable <var>name</var>. To ensure this does not occur, we can use a
		constructor:
	</p>
	<pre class="language-java"><code>
		class Person {
			String name;
			double age;

			Person() {
				name = "name_uninitialized";
			}
		}

		public class foo {
			public static void main(String[] args[]) {
				Person bill = new Person();
				System.out.println(bill.name);
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		name_uninitialized
	</code></pre>
	<p>
		Notice that in the examples above, we've had to reference the static
		variable each time for initialization:
	</p>
	<pre class="language-java"><code>
		class Person {
			String name;
			double age;

			Person() {
				name = "name_uninitialized";
			}
		}

		public class foo {
			public static void main(String[] args[]) {
				Person bill = new Person();
				bill.name = "Bill";
				System.out.println(bill.name);
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		Bill
	</code></pre>
	<p>
		It would be much easier if we could just pass that name as an argument
		when we first create the instance. Something that looks like this:
	</p>
	<pre class="language-java"><code>
		Person bill = new Person("Billy");
	</code></pre>
	<p>
		To do so, we must use a constructor that takes a name as an argument:
	</p>
	<pre class="language-java"><code>
		class Person {
			String name;
			double age;

			Person(String setName) {
				name = setName;
			}
		}

		public class foo {
			public static void main(String[] args[]) {
				Person bill = new Person("Bill");
				System.out.println(bill.name);
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		Bill
	</code></pre>
	<p>
		Great, it worked. As we can see, if we want to create new instances
		with their instance variables initialized by passing arguments into the
		method, we can do so with a constructor.
	</p>
	<p>
		Note that if we do not pass an argument into
		<var>Person()</var> when we create a new instance, we will see an error
		message:
	</p>
	<pre class="language-java"><code>
		class Person {
			String name;
			double age;

			Person(String setName) {
				name = setName;
			}
		}

		public class foo {
			public static void main(String[] args[]) {
				Person bill = new Person("Bill");
				System.out.println(bill.name);
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		foo.java:10: error: constructor Person in class Person cannot be applied to given types;
				Person bill = new Person();
								^
		required: String
		found:    no arguments
		reason: actual and formal argument lists differ in length
		1 error
	</code></pre>
	<p>
		This is a very helpful error message, because it tells us where we went
		wrong &mdash; we forget to pass a necessary argument into
		<var>Person()</var>. This feature also shows another aspect of
		constructors: As we soon as we define a constructor, we automatically
		lose the default constructor.
	</p>
	<p>
		Since our <var>Person</var> class also has an instance variable
		<var>age</var>, we should probably also require an
		<var>age</var> argument:
	</p>
	<pre class="language-java"><code>
		class Person {
			String name;
			double age;

			Person(String setName, double setAge) {
				name = setName;
				age = setAge;
			}
		}

		public class foo {
			public static void main(String[] args[]) {
				Person bill = new Person("Bill", 32.5);

				System.out.println(bill.name);
				System.out.println(bill.age);
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		Bill
		32.5
	</code></pre>
	<p>
		<span class="topic">Default Values for Instance Variables.</span>
		Suppose we want to allow creating a new instance of
		<var>Person</var> even if an <var>age</var> argument is not provided.
		To do so, we can simply write another constructor without the
		<var>age</var> parameter:
	</p>
	<pre class="language-java"><code>
		class Person {
			String name;
			double age;

			Person(String setName, double setAge) {
				name = setName;
				age = setAge;
			}
			Person(String setName) {
				name = setName;
				age = 0.0;
			}
		}

		public class foo {
			public static void main(String[] args[]) {
				Person bill = new Person("Bill");

				System.out.println(bill.name);
				System.out.println(bill.age);
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		Bill
		0.0
	</code></pre>
	<p>We can shorten the code above by simply writing:</p>
	<pre class="language-java"><code>
		class Person {
			String name;
			double age;

			Person(String setName, double setAge) {
				name = setName;
				age = setAge;
			}
			Person(String setName) {
				this(setName, 0.0);
			}
		}

		public class foo {
			public static void main(String[] args[]) {
				Person bill = new Person("Bill");

				System.out.println(bill.name);
				System.out.println(bill.age);
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		Bill
		32.0
	</code></pre>
</section>

<section id="getters_and_setters">
	<h2>Data Hiding</h2>
	<p>
		Let's continue our study of objects by further refining what we've
		learned so far. Here, we will address the notions of
		<i>access modifiers</i>, <i>getters</i>, and <i>setters</i>. These
		idioms are ubiquitous in object-oriented programming because they
		embody a general principle of object-oriented design: Hide data
		whenever possible.
	</p>
	<p>
		The idea behind hiding data is closely related to encapsulation. With
		encapsulation, we bundle related properties and methods together. With
		data hiding, we hide the implementations of classes, methods, and
		properties as much as possible. Why? Because it allows us to truly
		treat modules of code as blackboxes. We want to use modules without
		knowing anything about how the modules work. Think about all of the
		different Java library methods we use. We use the
		<var>.length</var> property without even batting an eye. We never stop
		to worry about what it outputs or how it works. We just use it. And
		when stop having these concerns, we program on much higher levels of
		abstraction. We can use <var>Random()</var>, Java's random number
		generator, to create a complex poker game program. We use Java's
		<var>Scanner()</var> to construct large programs that read inputs. All
		of this is done without ever really thinking about what these things
		do.
	</p>
	<p>
		This is only possible if the code we write hides its implementations as
		much as possible. And to ensure the details are tucked away and safely
		hidden, we use <b>access modifiers</b>.
	</p>
	<section id="access_modifiers_intro">
		<h3>Access Modifiers</h3>
		<p>Consider the following code:</p>
		<pre class="language-java"><code>
			class Person {
				public String name;
				private int age;

				private void printName() {
					System.out.println(name);
				}
				
				public int getAge() {
					return age;
				}
			}
		</code></pre>
		<p>
			There are a few symbols in the code above that we have been actively
			avoiding &mdash; <var>public</var> and <var>private</var>. What are
			these symbols and what do they mean?
		</p>
		<p>
			These symbols are called <b>access modifiers</b>. They are provided
			by Java as a way to control <i>access</i> to a class's instance
			variables and methods.
		</p>
		<p>
			Access modifiers are provided because is often the case that (a) we
			do want certain information hidden, or (b) we do not want the
			information accessed unless the seeker undergoes a particular
			process. Accordingly, the two main kinds of access modifiers are (i)
			<i>variable access modifiers</i> and (ii)
			<i>method access modifiers</i>. In Java, access modifiers
			<span class="underlineText">always</span> go to the left of the type
			as a matter of convention.
		</p>
	</section>

	<section id="public_keyword">
		<p>
			<span class="topic"><var>public.</var></span> The symbol
			<var>public</var>, when used as a variable access modifier, tells
			Java that the relevant variable can be modified by anyone. In the
			context of our <var>Person</var> class, we wrote:
			<var>public String name</var>. This essentially tells Java,
			&#8220;Anything anyone can modify the instance variable
			<var>name</var> using dot notation.&#8221;
		</p>
	</section>

	<section id="private_keyword">
		<p>
			<span class="topic"><var>private.</var></span> In contrast, when the
			symbol <var>private</var> is used as a variable access modifier, then
			the relevant variable can be accessed and modified
			<span class="underlineText">only if</span> the access or modification
			is done with a method defined on that class. Thus, when we wrote
			<var>private int age</var>, we told Java: &#8220;The instance
			variable <var>age</var> is <var>private</var> &mdash; stop anyone
			that tries to access or modify <var>age</var> with anything other
			than a <var>Person</var> method.&#8221;
		</p>
		<p>
			Thus, if we or another user want to modify the instance variable
			<var>age</var>, we must include a method in <var>person</var> that
			allows accessing and modifying <var>age.</var> Accordingly, the code
			below will not work:
		</p>
		<pre class="language-java"><code>
			class Person {
				// anyone and anything can modify name
				public String name;

				// age can only be read and written with this class's methods
				private int age;
			}

			public class foo {
				public static void main(String[] unused) {
					Person lukas = new Person();
					lukas.name = "Lukas";

					// this returns a compilation error
					System.out.println(lukas.age);
				}
			}
		</code></pre>
		<pre class="language-bash"><code>
			foo.java:9: error: age has private access in Person
					System.out.println(lukas.age);
													^
			1 error
		</code></pre>
		<p>
			Believe it or not, it is rare for Java programs to have public
			variables. We will see why in later sections. Thus, in summary:
		</p>
		<figure class="table">
			<table class="api">
				<thead>
					<th colspan="2"></th>
				</thead>
				<tbody>
					<tr>
						<td><span class="monoText boldText">public</span></td>
						<td>Every person can read and write the variable.</td>
					</tr>
					<tr>
						<td><span class="monoText boldText">private</span></td>
						<td>
							A person can read and write the variable
							<span class="underlineText">only if</span> the person uses a
							method defined for the variable's class.
						</td>
					</tr>
				</tbody>
			</table>
		</figure>
	</section>

	<section id="method_access_modifiers">
		<p>
			<span class="topic">Method Access Modifiers.</span> Access modifiers
			work the same way with methods. The difference: Rather than reading
			and writing, the privilege is whether we can call the method. A
			<b>public method</b> is one that we can call at any time. However, a
			<b>private method</b> cannot be called unless another method in the
			class is used to call it. In other words, we can call a private
			method <span class="underlineText">only if</span> we use another
			method in the class. Thus, if we are in another method in the class
			marked as <var>public</var> that allows calling the
			<var>private</var> method, then we can call the
			<var>private</var> method.
		</p>
	</section>

	<section id="getting_around_private">
		<p>
			<span class="topic"
				>Getting Around <var>private</var> Access Modifiers.</span
			>
			Suppose we have the following code:
		</p>
		<pre class="language-java"><code>
			class Patient {
				private String name;
				private int age;
			}

			public class foo {
				public static void main(String[] unused) {
					Patient jekyll_hyde = new Patient();
				}
			}
		</code></pre>
		<p>
			We want to keep the two variables, <var>name</var> and
			<var>age</var>, private. However, we also want to be able to quickly
			set the <var>name</var> and <var>age</var> when we create the new
			instance of <var>Patient</var>, <var>jekyll_hyde</var>. One way to do
			so is to use a constructor:
		</p>
		<pre class="language-java"><code>
			class Patient {
				private String name;
				private int age;

				Patient(String setName, int setAge) {
					name = setName;
					age = setAge;
				}
			}

			public class foo {
				public static void main(String[] unused) {
					Patient jekyll_hyde = new Patient("Jekyll Hyde", 50);
				}
			}
		</code></pre>
		<p>
			The code above compiles successfully. However, the
			<var>name</var> and <var>age</var> are still hidden because they are
			private. Suppose we want to be able to verify
			<var>jekyll_hyde</var>'s name. One way to do so is to use a public
			method:
		</p>
		<pre class="language-java"><code>
			class Patient {
				private String name;
				private int age;

				Patient(String setName, int setAge) {
					name = setName;
					age = setAge;
				}

				public void printPatientInfo() {
					System.out.println("Patient name: " + name);
					System.out.println("Patient age: " + age);
				}
			}

			public class foo {
				public static void main(String[] unused) {
					Patient jekyll_hyde = new Patient("Jekyll Hyde", 50);
					jekyll_hyde.printPatientInfo();
				}
			}
		</code></pre>
		<pre class="language-bash"><code>
			Patient name: Jekyll Hyde
			Patient age: 50
		</code></pre>
		<p>
			Because we can work around private access variables with methods, we
			can obtain the values bound to variable access variables with public
			methods:
		</p>
		<pre class="language-java"><code>
			class Patient {
				private String name;
				private int age;

				Patient(String setName, int setAge) {
					name = setName;
					age = setAge;
				}

				public String getName() {
					return name;
				}
			}

			public class foo {
				public static void main(String[] unused) {
					Patient jekyll_hyde = new Patient("Jekyll Hyde", 50);
					String jekyll_hyde_name = jekyll_hyde.getName();
					System.out.println(jekyll_hyde_name);
				}
			}
		</code></pre>
		<pre class="language-bash"><code>
			Jekyll Hyde
		</code></pre>
		<p>
			We might note this seems like a lot of work just to obtain the name.
			Why go through the trouble of writing a method just for obtaining the
			name when we can just use dot notation? We go through this trouble to
			ensure we keep two actions separate as possible:
			<i>setting</i> an instance variable, and <i>getting</i> an instance
			variable. By marking an instance variable <var>private</var>, we
			place a hurdle on attempts to modify the value bound to that instance
			variable.
		</p>
		<p>
			Why place a hurdle? Because we generally do not want instance
			variables to change as the program runs. The issue is not so much
			with a user modifying the variable directly as it is writing code
			that will affect, or indirectly modify, the value bound to the
			instance variable. Indirect and unintended modifications can easily
			lead to bugs that are difficult to pinpoint.
		</p>
		<p>
			If, for whatever reason, we want to have the ability to modify the
			name
			<i>after</i> its been set, we can write another public method:
		</p>
		<pre class="language-java"><code>
			class Patient {
				private String name;
				private int age;

				Patient(String setName, int setAge) {
					name = setName;
					age = setAge;
				}

				public String getName() {
					return name;
				}

				public void setName(String setName) {
					name = setName;
				}
			}

			public class foo {
				public static void main(String[] unused) {
					Patient jekyll_hyde = new Patient("Jekyll Hyde", 50);
					System.out.println(jekyll_hyde.getName());

					jekyll_hyde.setName("Harvey Dent");
					System.out.println(jekyll_hyde.getName());
				}
			}
		</code></pre>
		<pre class="language-bash"><code>
			Jekyll Hyde
			Harvey Dent
		</code></pre>
		<p>
			The distinction between setting an instance variable and getting a
			value bound to an instance variable introduces the distinction
			between
			<b>getters</b> and <b>setters</b>.
		</p>
	</section>

	<section id="qualifying_setters">
		<p>
			<span class="topic">Qualfying Setters.</span> If we provide methods
			that allow modifying initialized variable instances, we might want to
			further restrict the modification. We can do so inside the setter.
			For example, unless the patient is Benjamin Button, we might want to
			ensure negative numbers are not passed into an <var>age</var> setting
			method:
		</p>
		<pre class="language-java"><code>
			class Patient {
				private String name;
				private int age;

				Patient(String setName, int setAge) {
					name = setName;
					age = setAge;
				}

				public String getName() {
					return name;
				}
				public int getAge() {
					return age;
				}

				public void setName(String setName) {
					name = setName;
				}

				public void setAge(int setAge) {
					if (setAge > 0) {
						age = setAge;
					}
				}
			}

			public class foo {
				public static void main(String[] unused) {
					Patient jekyll_hyde = new Patient("Jekyll Hyde", 50);
					jekyll_hyde.setAge(-85);
					System.out.println(jekyll_hyde.getAge());
					jekyll_hyde.setAge(55);
					System.out.println(jekyll_hyde.getAge());
				}
			}
		</code></pre>
		<pre class="language-bash"><code>
			50
			55
		</code></pre>
		<p>
			Notice <var>setAge(-85)</var> did not actually set the age to
			<var>-85</var>. We qualified the setter with a conditional: Java, set
			the age only if the provided argument is greater than <var>0</var>.
		</p>
		<p>
			Getters and setters are the way we get around hurdles
			<var>public</var> and <var>private</var>. Good style in Java: always
			use <var>private</var> for instance variables, and use
			<var>public</var> methods to access the instance variables.
			<i>Getters</i> are the methods we use to read, or retrieve, values
			bound to instance variables, and <i>setters</i> are the methods we
			use to bind new values to instance variables.
		</p>
		<p>
			Getters and setters allow us to create
			<i>reactive objects</i> &mdash; objects that react to changes made to
			its instance variables. They also allow us to create read- and
			write-only variables:
		</p>
		<pre class="language-java"><code>
			class Patient {
				private String name;
				private String firstName;
				private String lastName;
			
				public void setName(String setName) {
					String[] nameParts = setName.split(" ");
					name = setName;
					firstName = nameParts[0];
					lastName = nameParts[1];
				}
			
				public String getName() {
					return name;
				}
				public String getFirstName() {
					return firstName;
				}
				public String getLastName() {
					return lastName;
				}
			
			}
			
			public class foo {
				public static void main(String[] unused) {
					Patient jekyll_hyde = new Patient();
					jekyll_hyde.setName("Jekyll Hyde");
					System.out.println(jekyll_hyde.getFirstName());
					System.out.println(jekyll_hyde.getLastName());
					System.out.println(jekyll_hyde.getName());
				}
			}
		</code></pre>
		<pre class="language-bash"><code>
			Jekyll
			Hyde
			Jekyll Hyde
		</code></pre>
		<p>
			The code above, of course, is flawed (names do not just consist of
			first and last; there are middle names, suffixes, ordinals, and
			eponyms).
		</p>
	</section>

	<section id="static_keyword">
		<p>
			<span class="topic">The <var>static</var> Keyword.</span>
			When we prepend the <var>static</var> symbol to an instance variable
			or method, we tell Java: &#8220;This variable or method belongs to
			the <i>class</i>, not to a specific instance of this class.&#8221;
			For example, we might see the following:
		</p>
		<pre class="language-java"><code>
			class Philosopher {
				private String name;
				private String field_of_study;
				private static int count = 0;
				Philosopher(String setName, String set_field_of_study) {
					name = setName;
					field_of_study = set_field_of_study;
				}
				public void printNameAndField() {
					System.out.println("Name: " + name);
					System.out.println("Field: " + field_of_study);
				}
			}
			
			public class foo {
				public static void main(String[] unused) {
					Philosopher kant = new Philosopher("Immanuel Kant", "metaphysics");
					kant.printNameAndField();
				}
			}
		</code></pre>
		<pre class="language-bash"><code>
			Name: Immanuel Kant
			Field: metaphysics
		</code></pre>
		<p>
			We've seen the symbol <var>static</var> numerous times. This symbol
			is similar to <var>public</var> and <var>private</var> in that it
			acts as an access modifier. The difference: When attach the
			<var>static</var> modifier to a variable or method, there is one, and
			only one, &#8220;copy&#8221; of that variable or method. That copy
			exists only inside the class itself, not with any instance of the
			class.
		</p>
		<p>
			There is a specific order for where to include the symbol
			<var>static</var>. Access modifiers like <var>private</var> and
			<var>public</var> are placed leftmost, then the modifier
			<var>static</var>, then the <var>type</var>.
		</p>
	</section>

	<section id="static_methods">
		<p>
			<span class="topic">Static Methods.</span> One of the most common
			uses for <var>static</var> is with <i>static methods</i>. For those
			familiar with JavaScript, we might have noticed tutorials referring
			to JavaScript's primitive math object as containing
			<i>static properties</i> and <i>static methods</i>. These correspond
			to Java's static variables and static methods.
		</p>
		<p>
			A <b>static method</b> is a method that can be called
			<span class="underlineText">without</span> an instance of that class.
			For example, in the code below, we have a static variable called
			<var>count</var>, and at every new instance of the class
			<var>Philosopher</var>, we increment <var>count</var>. Then, we have
			a static method called <var>printPhilosopherCount()</var> that prints
			the current value bound to <var>count</var>.
		</p>
		<pre class="language-java"><code>
			class Philosopher {
				private String name;
				private String field_of_study;
				private static int count = 0;
				Philosopher(String setName, String set_field_of_study) {
					name = setName;
					field_of_study = set_field_of_study;
					count++;
				}
				public void printNameAndField() {
					System.out.println("Name: " + name);
					System.out.println("Field: " + field_of_study);
				}
			}
			
			public class foo {
				public static void main(String[] unused) {
					Philosopher kant = new Philosopher("Immanuel Kant", "metaphysics");
					kant.printNameAndField();
					Philosopher.printPhilosopherCount();
				}
			}
		</code></pre>
		<pre class="language-bash"><code>
			Name: Immanuel Kant
			Field: metaphysics
			1
		</code></pre>
		<p>
			Notice that the static method
			<var>printPhilosopherCount()</var> executed without referencing a
			particular instance of the class <var>Philosopher</var>. This is
			because it is a method that belongs only to the class
			<var>Philosopher</var>, and as such, does not depend on an instance
			to execute. If we create multiple instances:
		</p>
		<pre class="language-java"><code>
			class Philosopher {
				private String name;
				private String field_of_study;
				private static int count = 0;
				Philosopher(String setName, String set_field_of_study) {
					name = setName;
					field_of_study = set_field_of_study;
					count++;
				}
				public static void printPhilosopherCount() {
					System.out.println(count);
				}
				public void printNameAndField() {
					System.out.println("Name: " + name);
					System.out.println("Field: " + field_of_study);
				}
			}
			
			public class foo {
				public static void main(String[] unused) {
					Philosopher kant = new Philosopher("Immanuel Kant", "metaphysics");
					Philosopher godel = new Philosopher("Kurt Godel", "logic");
					Philosopher locke = new Philosopher("John Locke", "political theory");
					Philosopher kierkegaard = new Philosopher("Soren Kierkegaard", "existentialism");
					Philosopher hart = new Philosopher("Herbert Hart", "jurisprudence");
					Philosopher.printPhilosopherCount();
				}
			}
		</code></pre>
		<pre class="language-bash"><code>
			5
		</code></pre>
		<p>And if we create no instances:</p>
		<pre class="language-java"><code>
			class Philosopher {
				private String name;
				private String field_of_study;
				private static int count = 0;
				Philosopher(String setName, String set_field_of_study) {
					name = setName;
					field_of_study = set_field_of_study;
					count++;
				}
				public static void printPhilosopherCount() {
					System.out.println(count);
				}
				public void printNameAndField() {
					System.out.println("Name: " + name);
					System.out.println("Field: " + field_of_study);
				}
			}
			
			public class foo {
				public static void main(String[] unused) {
					Philosopher.printPhilosopherCount();
				}
			}
		</code></pre>
		<pre class="language-bash"><code>
			0
		</code></pre>

		<p>
			The static method is a method that can be called without any instance
			of its class. This ability implies a limitation: Because static
			methods work outside of instances, they
			<span class="underlineText">cannot access</span> non-static instance
			variables. This in turn means we cannot use the keyword
			<var>this</var>.
		</p>
		<p>
			Static methods are found throughout not just Java, but
			object-oriented languages as a whole. In Java, there are numerous
			<b>packages</b> (Java's equivalent for <i>libraries</i> in C and
			<i>modules</i> in Python) containing static methods. One such package
			is the <var>Math</var> package, which contains static methds like
			<var>Math.sqrt(${n}$)</var>, where ${n}$ is the radicand.
		</p>
	</section>

	<section id="static_variables">
		<p>
			<span class="topic">Static Variables.</span> Like, but somewhat
			different, to static methods, <b>static variables</b> are variables
			shared by <i>all</i> instances of a given class. Thus, in our example
			<var>Philosopher</var> class, the variable <var>count</var> is shared
			by every instance of <var>Philosopher</var>.
		</p>
		<p>
			As aforementioned, languages like JavaScript refer to these as
			<i>static properties</i>. For example, the value ${\sqrt{2}}$ is so
			commonly used in computation that we might want to provide it as a
			static variable. Indeed, Java has packages that provide such quick
			access. However, static variables are by and large extremely uncommon
			in Java programming. Generally, a task that requires a static
			variable can more than likely be accomplished through another means.
			One use for a static variable is something like a <var>count</var>,
			intended to track how many instances of a given class there are.
		</p>
		<p>
			<span class="topic"
				>Not Marking a Method or Variable <var>static.</var></span
			>
			If we do not indicate that a variable of method is
			<var>static</var>, then by default, every instance of the class (a)
			has a copy of that variable, and (b) the method will only work on a
			particular instance of that class.
		</p>
	</section>

	<section id="use_cases_static_variables">
		<p>
			<span class="topic">Use Cases for Static Variables.</span> The most
			common use case for static variables is creating constants. In Java
			programs, this use case is often identifiable when the
			<var>static</var> symbol is used alongside the
			<var>final</var> symbol:
		</p>
		<pre class="language-java"><code>
			class Physics {
				public static final float ACCELERATION_GRAVITY = 9.807;
			}
		</code></pre>
		<p>
			The symbol <var>final</var> tells Java: Under absolutely no
			circumstances can the variable <var>ACCELERATION_GRAVITY</var> be
			modified. Any attempt, direct or indirect, to modify a final variable
			will return an error.
		</p>
		<p>
			Thus, the variable declaration above essentially communicates: (1)
			This is a public variable, so you can access, but because it is a
			final variable, you cannot modify. (2) This is a static variable, so
			there is only one copy, and it stays here in <var>Physics</var>. If
			you want to use it, you will have to call <var>Physics</var> first.
		</p>
		<p>
			Notice further that in Java, final variables (i.e., constants) are
			written in snake casing (underscores indicating spaces).
		</p>
	</section>
</section>

<section id="inheritance_in_java">
	<h2>Inheritance</h2>
	<p>
		In this section, we study the concept of
		<i>inheritance</i>. Inheritance provides a means of accomplishing two
		useful outcomes: (1) avoiding duplicated code, and (2) expressing real
		world relationships between data.
	</p>
	<p>
		Across languages that support inheritance, there are several types:
	</p>
	<figure>
		<img
			src="{% static 'images/inheritanceTypes.svg' %}"
			alt="Inheritance types"
			loading="lazy"
			width="400px"
			height="400px"
		/>
	</figure>
	<p>Consider the following code:</p>
	<pre class="language-java"><code>
		class MythChar { };

		public class foo {
			public static void main(String[] unused) {
				MythChar hera = new MythChar(); 
				System.out.println(hera.toString());
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		MythChar@7344699f
	</code></pre>
	<p>
		There was no error &mdash; it compiled and ran correctly, even if we
		neglected to explicitly define the body of the class
		<var>MythChar</var>. No error is returned because of Java's principle
		of <b>inheritance</b> &mdash; every object, or instance, inherits both
		<i>state</i> and <i>behavior</i> from another class. Inheritance exists
		because in the real world, data follows hierarchy &mdash; Every koala
		is a marsupial, every marsupial is a mammal, every mammal is an animal,
		etc.
	</p>
	<p>So, for example:</p>
	<pre class="language-java"><code>
		class MythChar {
			protected String name;
			protected String type;
		
			public void printMetadata() {
				System.out.println("This is an object of type " + type + " named " + name);
			}
		}
		
		class GreekMythChar extends MythChar {
			GreekMythChar(String setName) {
				name = setName;
				type = "GreekMythChar";
			}
		}
		
		
		public class foo {
			public static void main(String[] unused) {
				GreekMythChar hera = new GreekMythChar("Hera"); 
				hera.printMetadata();
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		This is an object of type GreekMythChar named Hera
	</code></pre>
	<p>
		There are some new symbols in the code above, and we will address them
		in a moment. For now, observe that (1) every new instance of
		<var>MythChar</var> has an instance variable called <var>name</var> and
		another instance variable called <var>type</var>; (2) every new
		instance of <var>MythChar</var> has an instance method called
		<var>printMetadata()</var>, which prints a string communicating the
		instance's <var>name</var> and <var>type</var>.
	</p>
	<p>
		Then, we have another class definition. This class is called
		<var>GreekMythChar</var>, followed by <var>extends MythChar</var>.
		Then, we have a constructor. But, there is something unusual about this
		constructor: We do not have any instance variables before the
		constructor, but we are initializing variables inside the constructor.
		How is this possible? Again, inheritance.
	</p>
	<p>
		By including <var>extends</var> to the class definition for
		<var>GreekMythChar</var>, we are effectively telling Java that
		<var>GreekMythChar</var> is a subclass of <var>MythChar</var>. Because
		<var>GreekMythChar</var> is a subclass of <var>MythChar</var>, all the
		instance and class variables and methods contained in
		<var>MythChar</var> are available for <var>GreekMythChar</var>. They
		are <i>inherited</i> from <var>MythChar</var>.
	</p>
	<p>
		Notice that <var>GreekMythChar</var> has a special relationship to
		<var>MythChar</var> &mdash; it is a subset of mythological figures. We
		might have another subclass called <var>NorseMythChar</var> and another
		one called <var>CelticMythChar</var>. These two classes are
		collectively referred to as the <i>children</i> of <var>MythChar</var>,
		and <var>MythChar</var> is said to be the <i>parent</i> of the
		subclasses. The keyword we use for establishing these relationships is
		<var>extends</var>.
	</p>
	<p>
		Java allows multiple inheritance. All of the classes shifted towards
		the left inherit all of the instance and class variables and methods of
		the classes to the right. All of the classes that a subclass inherits
		from are collectively called the subclass's
		<i>ancestors</i>, and all of the classes that a parent class provides
		behaviors to as the parent class's <i>descendants</i>:
	</p>
	<pre class="language-java"><code>
		public class MythChar {}
			public class GreekMythChar extends MythChar {}
				public class Olympian extends GreekMythChar {}
				public class Titan extends GreekMythChar {}
					public class Titanide extends Titan {}
					public class Titaness extends Titan {}
				public class Gigantes extends GreekMythChar {}
	</code></pre>
	<p>
		In Java, a class can only extend
		<span class="underlineText">one</span> parent class. In other words, we
		cannot have a subclass with two parent classes. We will revisit this
		concept and limitation again in later sections.
	</p>
	<p>
		A word of warning: If we ever find ourselves writing deeply nested
		classes like the above, we must ask ourselves whether inheritance is
		the proper approach to the problem, or whether the distinctions between
		parent and child are meaningful. Particularly tall inheritance trees
		can very easily open the gates to <i>inheritance hell</i> &mdash; the
		point where so many subclasses are created that the programmer loses
		track of an object's behavior and the states it stores.
	</p>
	<p>
		<span class="topic">What Does <var>protected</var> Mean?</span>
		One new access modifier we saw from the example above is
		<var>protected</var>. Recall that a public variable can be read or
		written by anyone, and a private variable can only be read or written
		using methods defined by the private variable's class. A
		<i>protected variable</i> is a variable that can only be read or
		written using methods that are (a) defined by the protected variable's
		class, or (b) defined by a descendent of the protected variable's
		class.
	</p>
</section>

<section id="polymorphism">
	<h2>Polymorphism</h2>
	<p>
		In the previous sections, we saw how objects provide us a way to
		package state and behavior, and organize it into a hierarchy. A fair
		question to ask: Why organize objects into hierarchy? Because humans
		generally prefer viewing and understanding things in terms of sets and
		subsets. Humans are in the category of mammals, some humans are in the
		category of doctors, others mechanics, carpenters, stay-at-home
		parents, students, teachers, etc. Within doctors there are
		cardiologists, pathologists, neurosurgeons, and more. Within students
		there are those that study physics and those that study theology.
		Organizing objects hierarchically is an attempt to mimic this
		preference.
	</p>
	<p>
		In the real world, when a set contains multiple subsets, there is
		usually something members of the subsets have in common that warrants
		their membership in the superset other than being a subset. For
		example, a <i>shape</i> can be throught of as a geometric figure. And
		as a geometric figure, a <i>shape</i> can be many things. For example,
		it could be a <i>square</i>, a <i>circle</i>, an <i>ellipse</i>, and so
		on. Squares, triangles, pentagons, circles, ellipses, and the like are
		all <i>shapes</i>, but they all have different properties. This
		phenomenon &mdash; a shape can be a square, or a circle, or a polygon
		and so on &mdash; is called <b>polymorphism</b>.<sup></sup>
	</p>
	<div class="note">
		<p>
			Note that in Java, classes are <b>parthenogenetic</b> &mdash; a
			subclass can only extend one parent class; no subclass can ever have
			more than one parent. How then do we accomplish the preceding
			phenomenon, where objects of one class might <i>behave</i> like the
			objects of another class? Through <i>polymorphism</i>.
		</p>
	</div>
	<p>For example, consider the classes below:</p>
	<pre class="language-java"><code>
		class EuclidShape {
			public double getArea() {
				return 0;
			};
		}
		
		class Rectangle extends EuclidShape {
			private double width;
			private double height;
			public Rectangle(double width, double height) {
				this.width = width;
				this.height = height;
			}
			public double getArea() {
				return width * height;
			}
		}
		
		class Circle extends EuclidShape {
			private double PI = 3.14159;
			private double radius;
			public Circle(double radius) {
				this.radius = radius;
			}
			public double getArea() {
				return radius * radius * PI;
			}
		}
		
		public class Main {
			public static void main(String[] args) {
				Rectangle r = new Rectangle(10, 2);
				Circle c = new Circle(1.2);
				double rArea = r.getArea();
				double cArea = c.getArea();
				System.out.println(rArea);
				System.out.println(cArea);
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		20.0
		4.5238895999999995
	</code></pre>
	<p>
		Instances of the class <var>EuclidShape</var> are said to be
		polymorphic. They're either a <var>Circle</var> or a
		<var>Rectangle</var>.
	</p>

	<h3>The Java Object</h3>
	<p>
		To understand polymorphism, we need to clarify a common point of
		confusion. As we've stated before, everything in Java must be wrapped
		in a class. Now, because classes can only extend one parent class,
		there necessarily must be something at the very root of it all. It
		cannot be turtles all the way down. Indeed, there is a root &mdash; the
		Java Object. Every class in Java inherits from the Java Object. We will
		discuss in more detail what this Object is in later sections, but for
		now, the key point is: When we use the term Object with a capital "O,"
		we are referring to the Java Object, rather than object we have
		created.
	</p>
	<pre class="language-java"><code>
		public class Chemicals { }

		// The class declaration above is equivalent to:
		
		public class Chemicals extends Object { }

		// We do not have to write this^ line
		// Java assumes this is the case when we do not include an extends symbol
	</code></pre>
	<p>
		This means that every state and method of a newly declared class
		inherits from Object. Does it inherit all of Object's states and
		methods? No. The class inherits a small number of the states and
		methods. Some of the most important methods inherited from Object are
		the following:
	</p>
	<figure class="table">
		<table class="loop_table">
			<thead>
				<th>Object Method</th>
				<th>Description</th>
			</thead>
			<tbody>
				<tr>
					<td><var>String toString()</var></td>
					<td>
						Return a <var>String</var> representing the instance. This is
						used primarily for debugging.
					</td>
				</tr>
				<tr>
					<td>
						<var>boolean equals(object_1 object_2)</var>
					</td>
					<td>
						Return a <var>boolean</var> indicating whether
						<var>object_1</var> is the same as <var>object_2</var>.
					</td>
				</tr>
				<tr>
					<td><var>int hashCode()</var></td>
					<td>
						Return an <var>int</var> uniquely representing an object's
						contents (more on this later).
					</td>
				</tr>
			</tbody>
		</table>
	</figure>
	<p>
		The methods inherited from <var>Object</var> are very rarely used. This
		is because classes can <i>override</i> methods inherited from their
		ancestors, using their own instead.
	</p>
	<pre class="language-java"><code>
		public class bar {
			public static void main(String[] args) {
				Apache geronimo = new Apache();
				geronimo.name = "Geronimo";
				System.out.println(geronimo.toString());
			}
		}

		class NativeAmerican {}

		class SouthwestNative extends NativeAmerican {
			public String name;
		}

		class Apache extends SouthwestNative {
			public String toString() {
				return name + " is an Apache.";
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		Geronimo is an Apache.
	</code></pre>
	<p>
		Notice that we created an instance of the class
		<var>Apache</var>, and initialized its instance variable
		<var>name</var> to <var>"Geronimo"</var>. How are we allowed to do this
		when there is no such instance variable in the class <var>Apache</var>?
		Because <var>Apache</var> inherits everything from its ancestors. The
		class <var>SouthwestNative</var> is an ancestor of <var>Apache</var>,
		and as such, all instances of <var>Apache</var> have an instance
		variable called <var>name</var> that can be initialized.
	</p>
	<p>
		The same goes for the <var>toString()</var> method. When we called that
		method with the instance <var>geronimo</var>, Java went and checked if
		the <var>Apache</var> class contained such a method and verified that
		it is <var>public</var>. If no such method existed, then Java would
		check the parent, <var>SouthwestNative</var>; otherwise
		<var>NativeAmerican</var>; otherwise <var>Object</var>.
	</p>
	<p>
		What this means then is that if we included another
		<var>toString()</var> method definition in a parent class (while
		keeping the <var>toString()</var> method inside the subclass, Java will
		not go any further to execute the <var>toString()</var> method in the
		parent class. Java stops and runs either (a) the method's definition in
		the instance's class itself, or (b) the nearest ancestor defining the
		method. In other words, it stops the moment it encounters a
		<var>toString()</var> method it can use.
	</p>
	<p>
		On the other hand, this also means that a parent class cannot access
		variables in its child classes. Suppose for example we had the
		following:
	</p>
	<pre class="language-java"><code>
		public class bar {
			public static void main(String[] args) {
				NativeAmerican geronimo = new NativeAmerican();
				geronimo.name = "Geronimo";
				System.out.println(geronimo.bisonHunting);
			}
		}
		class NativeAmerican {}
		class SouthwestNative extends NativeAmerican {
			public String name;
		}
		class Apache extends SouthwestNative {
			public boolean bisonHunting = true;
			public String toString() {
				return name + " is an Apache.";
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		bar.java:4: error: cannot find symbol
							geronimo.name = "Geronimo";
										^
		symbol:   variable name
		location: variable geronimo of type NativeAmerican
		bar.java:5: error: cannot find symbol
							System.out.println(geronimo.bisonHunting);
																^
		symbol:   variable bisonHunting
		location: variable geronimo of type NativeAmerican
		2 errors
	</code></pre>
	<p>
		We see two compilation errors: (1) Java cannot find the variable
		<var>name</var>; (2) Java cannot find the variable
		<var>bisonHunting</var>. This is because <var>geronimo</var> is an
		instance of <var>NativeAmerican</var>, but the variables
		<var>name</var> and <var>bisonHunting</var> are part of the
		<var>Apache</var> class. If we wanted to see these variables, then we
		must use the <var>Apache</var> class:
	</p>
	<pre class="language-java"><code>
		public class bar {
			public static void main(String[] args) {
				Apache geronimo = new Apache();
				geronimo.name = "Geronimo";
				System.out.println(geronimo.bisonHunting);
			}
		}
		class NativeAmerican {}
		class SouthwestNative extends NativeAmerican {
			public String name;
		}
		class Apache extends SouthwestNative {
			public boolean bisonHunting = true;
			public String toString() {
				return name + " is an Apache.";
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		true
	</code></pre>
	<p>
		We learn a key less from these examples and principles: If we have more
		instance variables at the top of the inheritance tree, then we have
		more subclasses in the hierarchy. If we have more instance variables at
		the bottom of the inheritance tree, then we must provide more specific
		behaviors (methods) for the subclasses.
	</p>

	<p>
		<span class="topic">The <var>super</var> Keyword.</span>
		Subclasses can access a constructor inside their parent class. This is
		done by using the <var>super</var> keyword:
	</p>

	<pre class="language-java"><code>
		public class bar {
			public static void main(String[] args) {
				Gas argon = new Gas("argon");
				System.out.println(argon.name);
			}
		}
		
		class Inorganic {
			protected String type;
			Inorganic(String setType) {
				type = setType;
			}
		}
		class Gas extends Inorganic {
			public String name;
			Gas(String setName) {
				super("Gas");
				name = setName;
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		argon
	</code></pre>

	<p>
		In the code above, we called the constructor defined in
		<var>Inorganic</var>, the superclass of <var>Gas</var>. When we use the
		symbol <var>super</var>, it <span class="underlineText">must</span> be
		the first thing we do.
	</p>

	<p>
		<span class="topic">Polymorphism.</span>
		<i>Polymorphism</i> is the provision of a single interface to entities
		of different types. In others, polymorphism is the phenomenon where a
		single entity of one type, such as an object, can act as if it were an
		entity of another, or multiple other, types. We see this all the time.
		A pet tiger may be loving and caring, acting truly like a domesticated
		animal in one moment, but then turning to their wild side and
		slaughtering their owner the next. Some ethnicities are the majority
		population in one area, while being a minority in another. A person is
		a student by day and a bartender by night.
	</p>
	<p>
		<span class="topic">Subtype Polymorphism.</span> Necessarily, in order
		to be a member of two different types, the entity must actually
		<i>be</i> a member of two different types. In Java, every object
		(except for <var>Object</var>) is an instance of at least two types:
		(1) whatever class we have defined the object to be in; and (2) an
		object of <var>Object</var> (the <var>Java Object</var>). Of course, a
		particular object can be more than that if it is part of an
		<i>class tree</i>. For example:
	</p>

	<pre class="language-java"><code>
		class Animal {
			public void drinkWater() {
				System.out.println("gulp gulp gulp")
			}
		}
		class Reptile extends Animal {
			public void layEgg() {
				System.out.println("bloop bloop")
			}
		}

		/* 

		We can think of the above as: 
			Reptile extends Animal extends Object

		Thus:
			Reptile behaves like an Animal, and
			Reptile also behaves like an Object 

		*/
	</code></pre>

	<p>
		Every object of type <var>reptile</var> is an instance of three
		different types: (1) the class <var>Object</var>; (2) the class
		<var>Animal</var>; and the class <var>Reptile</var>. Given an object of
		type <var>Reptile</var>, it has a method called <var>layEgg()</var>. As
		an <var>Animal</var>, it has a method called <var>drinkWater()</var>.
		As an <var>Object</var>, it has a method called <var>toString()</var>.
	</p>

	<p>
		<span class="topic">Upcasting.</span> Because objects can be a member
		of multiple classes, Java provides the ability to <b>upcast</b> &mdash;
		automatically allowing an object to behave like an object of an
		ancestor type:
	</p>
	<pre class="language-java"><code>
		class Animal {}
		class Reptile extends Animal {
			public String toString() {
				return "Reptilian";
			}
		}
		public class bar {
			public static void main(String[] args) {
				Reptile gator = new Reptile();
				Animal dragon = new Animal();
				bar.printAnything(gator);
				bar.printAnything(dragon);
			}
			public static void printAnything(Object toPrint) {
				System.out.println(toPrint.toString());
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		Reptilian
		Animal@6b95977
	</code></pre>

	<p>
		Pay close attention to the output. Those are the outputs from the
		statements
		<var>bar.printAnything(gator)</var> and
		<var>bar.printAnythng(dragon)</var>. We passed as arguments into those
		methods the objects <var>gator</var> and <var>dragon</var>. What is the
		method <var>printAnything()</var>? It is the method defined inside the
		class <var>bar</var>. And in that definition, we pass it one argument:
		an object <var>toPrint</var> of type <var>Object</var>. Let's focus
		first on <var>gator</var>.
	</p>
	<p>
		The object <var>gator</var> is an instance of <var>Reptile</var>, but
		here it is being used as an object of type <var>Object</var>.
		Nevertheless, it is also an object of type <var>Reptile</var>. Inside
		the class definition for <var>Reptile</var>, we overrode the
		<var>toString()</var> method: Rather than follow <var>Object</var>'s
		default definition, return the string <var>"Reptilian"</var>. So, when
		we pass in <var>gator</var> into the <var>printAnything()</var> method,
		we really wrote <var>gator.toString()</var>. This is why we see the
		output <var>Reptilian</var>.
	</p>

	<p>
		Now, let's look at <var>dragon</var>. When we pass in
		<var>dragon</var> as an argument, we really wrote
		<var>dragon.toString()</var>. The object <var>dragon</var> is an object
		of type <var>Object</var>. But, it is also an object of type
		<var>Animal</var>. The class <var>Animal</var> provides no override of
		the <var>toString()</var> method. So, Java moves up the class tree, and
		goes to <var>Object</var>. There, it applies the
		<var>toString()</var> method as defined there, and we get back
		<var>Animal@6b95977</var>. This is the default definition of
		<var>toString()</var> &mdash; it tells us that there is an instance of
		<var>Animal</var> at the memory reference <var>6b95977</var>.
	</p>

	<p>
		Notice that we wrote <var>bar.printAnything()</var> to call the method
		<var>printAnything()</var>. Why? Because <var>printAnything()</var> is
		a method defined in the class <var>bar</var>. This is all evidence of
		<i>polymorhpism</i>.
	</p>
	<p>
		As an aside, we might ask, how is the
		<var>printAnything()</var> method called when it is below the
		<var>main()</var> method? This is a perfectly fair question,
		particularly for those coming from a Python background. In Python, a
		program structured in this manner is almost certain to return an error.
		This is because Python's evaluation model interprets then executes code
		line-by-line, top to bottom. In languages like Java, however, the code
		is first compiled then executed. Thus, the positioning of methods and
		classes alone will not prohibit execution. (Note that compiling is not
		necessarily what allows Java to avoid relative positioning; C, for
		example, requires the use of prototypes for <var>struct</var>s defined
		at the bottom of a source code file).
	</p>

	<p>
		<span class="topic">Downcasting.</span> Where <i>upcasting</i> allows
		an object to behave as if it were an object of an ancestor type,
		<b>downcasting</b> allows an object to behave as if it were an object
		of a descendent type. <span class="underlineText">But</span> only if
		the instance is actually the appropriate subtype. If the instance is
		not an appropriate subtype, then Java will return a runtime error.
	</p>
	<pre class="language-java"><code>
		class Animal {}
		class Reptile extends Animal {
			public String toString() {
				return "Reptilian";
			}
		}
		public class bar {
			public static void main(String[] args) {
				Object gator = new Reptile();
				bar.printAnything(gator);
				Animal gatorAsAnimal = (Animal) gator;
				bar.printAnything(gatorAsAnimal);
			}
			public static void printAnything(Object toPrint) {
				System.out.println(toPrint.toString());
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		Reptilian
		Reptilian
	</code></pre>
	<p>
		Here, we created an object named <var>gator</var> of type
		<var>Reptile</var> (whenever we are unsure of what type an object is,
		we always look to the right of the symbol <var>new</var>). Notice,
		however, that we declared the variable <var>gator</var> to be of type
		<var>Object</var>. What is going on here?
	</p>
	<p>
		This is an example of performing an immediate upcast. We create an
		instance of <var>Reptile()</var>, but we save it in a variable of type
		<var>Object</var>. This is perfectly valid because it is an upcast
		&mdash; every instance <var>Reptile</var> is an instance of
		<var>Object</var>.
	</p>
	<p>
		The more interesting point is our creation of
		<var>gatorAsAnimal</var>. That variable is of type <var>Animal</var>.
		We assign to that variable the object <var>gator</var>, but we prepend
		it with <var>(Animal)</var>. This is a downcast. Why are we allowed to
		do this? Because <var>gator</var> is an instance of <var>Object</var>.
		And since it is an instance of <var>Object</var>, an ancestor of
		<var>Animal</var>, we can cast <var>gator</var> downwards as an
		instance of <var>Animal</var>.
	</p>
	<p>
		The tool: If we upcast an object, we can always downcast the object
		back to where we started. But, we can only cast an object that the
		casted object is related to. We cannot cast a <var>String</var> object
		into an <var>Animal</var> or <var>Reptile</var> object, because
		<var>Animal</var> and <var>Reptile</var> are unrelated to
		<var>String</var>.
	</p>
	<p>
		<span class="topic">Verifying an Instance's Class.</span> A useful
		operator provided by Java is the <var>instanceOf</var> operator, which
		returns a Boolean value to the question: Is this particular instance an
		instance of this particular class? Thus:
	</p>
	<pre class="language-java"><code>
		class Animal {}
		class Reptile extends Animal {
			public String toString() {
				return "Reptilian";
			}
		}
		public class bar {
			public static void main(String[] args) {
				Reptile gator = new Reptile();
				Animal dragon = new Animal(); 
				System.out.println(gator instanceof Animal);
				System.out.println(gator instanceof Reptile);
				System.out.println(dragon instanceof Reptile);
				System.out.println(dragon instanceof Animal);
			}
			public static void printAnything(Object toPrint) {
				System.out.println(toPrint.toString());
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		true
		true
		false
		true
	</code></pre>
	<p>
		<span class="topic">Inheritance and Methods.</span> Consider the
		following:
	</p>
	<pre class="language-java"><code>
		class Animal {}
		class Lion extends Animal {
			public void roar() {
				System.out.println("roar");
			}
		}
		class Cobra extends Animal {
			public void hiss() {
				System.out.println("hiss");
			}
		}

		public class bar {
			public static void main(String[] args) {
				Animal bubu = new Animal();
				Lion lulu = new Lion();
				Cobra momo = new Cobra();
			}
		}
	</code></pre>
	<p>
		In the code above, we have two methods called
		<var>roar()</var> and <var>hiss()</var>. The <var>roar()</var> method
		is defined in the subclass <var>Lion</var>, and the
		<var>hiss()</var> method is defined in the subclass <var>Cobra</var>.
		Both <var>Cobra</var> and <var>Lion</var> are subclasses of
		<var>Animal</var>. Of the instances we created, <var>bubu</var> cannot
		call these methods. Why? Because <var>bubu</var> is of class
		<var>Animal</var>, and <var>Animal</var> has no methods
		<var>roar()</var> and <var>hiss()</var>. But what if we want
		<var>momo</var> to be an instace of <var>Lion</var>, but at the same
		time, we want to keep the variable containing <var>momo</var> to remain
		<var>Animal</var>? Well, we can use a conditional:
	</p>
	<pre class="language-java"><code>
		class Animal {
			public void speak() {
				if (this instanceof Lion) {
					Lion me = (Lion) this;
					me.roar();
				} else if (this instanceof Cobra) {
					Cobra me = (Cobra) this;
					me.hiss();
				}
			}
		}
		class Lion extends Animal {
			public void roar() {
				System.out.println("roar");
			}
		}
		class Cobra extends Animal {
			public void hiss() {
				System.out.println("hiss");
			}
		}
		
		public class bar {
			public static void main(String[] args) {
				Animal bubu = new Lion();
				bubu.speak();
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		roar
	</code></pre>
	<p>
		In the code above, we created a new method called
		<var>speak()</var>. That method behaves differently depending on what
		object is passed into it as an argument. That object, however, is an
		instance of <var>Animal</var>. This means that the symbol
		<var>this</var> refers to an instance of <var>Animal</var>, so to call
		the <var>roar()</var> and <var>hiss()</var> methods, we must
		<i>downcast</i> the object argument. This is why we create a new
		variable (and by convention, naming the variable <var>me</var>).
	</p>
</section>

<section id="object_references">
	<h2>Object References</h2>
	<p>
		The idea of a <i>reference</i> is not unique to Java. It occurs across
		many programming languages. References are also a useful way to clarify
		any vagueness in polymorphism.
	</p>
	<p>Consider the following code and its output:</p>
	<pre class="language-java"><code>
		class PhysConst {
			public String name;
			public double val;
			PhysConst(String setName, double setValue) {
				name = setName;
				val = setValue;
			}
			public String toString() {
				return name;
			}
		}
		
		public class bar {
			public static void main(String[] args) {
				// block (a)
				int first = 0;
				int second = first;
				second = 8;
				System.out.println(first + " " + second);
		
				// block (b)
				PhysConst otherConst = new PhysConst("Gas Constant", 8.31);
				PhysConst gasConst = otherConst;
				gasConst.name = "Molar Gas Constant";
				System.out.println(otherConst + " " + gasConst);
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		0 8
		Molar Gas Constant Molar Gas Constant
	</code></pre>
	<p>
		How does this code work? In <var>block (a)</var>, we declare a variable
		called <var>first</var>, of type <var>int</var>. Then, we assign to
		that variable the integer value <var>0</var>. Next, we declare a
		variable called <var>second</var>, also of type <var>int</var>, and we
		initialize it to the value <var>first</var>, which is itself
		initialized to <var>0</var>. Then, we changed the value bound to
		<var>second</var> now it is <var>8</var>. As expected, when we print
		the values, we see <var>0</var> and <var>8</var>. This is in line with
		what we know about assignment.
	</p>
	<p>
		But it seems that <var>block (b)</var> works differently, even though
		it looks similar. We declared a variable of type <var>PhysConst</var>,
		then assigned to it the object created by calling the
		<var>PhysConst()</var> constructor. Then, on the next line, we declared
		a variable called <var>gasConst</var>, of type <var>PhysConst</var>,
		and assigned to <var>otherConst</var>. Then, we initializd the
		<var>name</var> instance variable of <var>gasConst</var> to
		<var>"Molar Gas Constant"</var>. After all of this, when print
		<var>otherConst</var> and <var>gasConst</var>, it looks like they have
		the same name &mdash; <var>Molar Gas Const</var>. Why? It seems that in
		<var>block (b)</var>, the change made to <var>gasConst</var>, which was
		assigned <var>otherConst</var>, had an effect on <var>otherConst</var>.
		This is evidence of a <i>reference</i> at work.
	</p>
	<p>
		<span class="topic">About Variables.</span> When we discussed
		variables, we repeatedly said that a variable &#8220;stores&#8221; a
		value. This is incorrect when it comes to <i>objects</i> in Java. When
		we assign an object to a variable, the variable does not actually
		&#8220;store&#8221; the object. Instead, that variable stores a
		<b>reference</b> to that object. We call such a variable a
		<i>reference variable</i>.
	</p>
	<p>
		A reference is a value representing a particular piece of data's
		location in the computer's memory. That reference
		<i>refers</i> to the data, and accessing the data is called
		<i>dereferencing</i> the reference. References are what allow a program
		to <span class="underlineText">indirectly</span> access a particular
		piece of data (e.g., an object). We emphasize &#8220;indirectly&#8221;
		because references are <span class="underlineText">not</span>
		<i>pointers</i>. Pointers provide direct access to the referenced data;
		a reference does not.
	</p>
	<p>
		There is a difference between a
		<i>reference</i> and the actual object the reference refers to. For
		example, a social security number. That number <i>refers</i> to a
		particular person, but the number itself is different from the object.
		Another example: A street address. The address is a reference to a
		physical location, say, an unlocked building filled with gold. If one
		person gains access to that address, they can go to that address and
		steal the boot. If another person knows that address, they can go and
		watch the looting or participate themselves. The thieves all make
		changes to the physical location, but the address nevertheless remains
		the same.
	</p>
	<p>
		This same phenomenon occurs with reference variables: Make an object
		<var>x</var>. Assign <var>x</var> to a reference variable called
		<var>y</var>. We can make changes to <var>x</var> by using the
		reference <var>y</var>. If we make changes to <var>y</var>, then those
		changes are reflected in <var>x</var>, and are visible to every entity
		that has access to <var>y</var> or <var>x</var>.
	</p>
	<pre class="language-java"><code>
		class Fish { }

		// bass refers to an object of type Fish
		// but, bass currently refers to nothing
		
		Fish bass;

		// initializing an instance to null tells Java: 
			// this instance refers to nothing

		Fish trout = null;

		// now bass refers to a new Fish object

		Fish bass = new Fish();

		// now bass and trout refer to same Fish object

		trout = bass;             

		// returns true; bass and trout refer to the same Fish object 

		trout == bass;

		// now trout refers to new Fish object

		trout = new Fish(); 

		// false; bass and trout store refer to different Fish objects

		trout == bass;                 
	</code></pre>
	<p>
		When you assign an object to a reference variable in Java, you do not
		copy the object. You are copying the reference. If you do not see
		<var>new</var>, you are not creating a new object. If we deleted
		everything after <var>trout = bass</var>, we can make changes to the
		object <var>bass</var> refers to by using <var>trout</var>.
	</p>
	<p>
		The first <var>trout == bass</var> returns <var>true</var> because the
		two objects <var>trout</var> and <var>bass</var> refer to the same
		object. This is why we cannot use the <var>==</var> operator to test
		whether two variables, both storing a string with the same exact
		characters, are equivalent. We cannot do so because the the two
		variables are <i>reference variables</i> &mdash; they refer to
		different objects, even if they appear the same.
	</p>
	<p>Another example:</p>
	<pre class="language-java"><code>
		class Seafood {
			public int quantity;
		}
		public class bar {
			public static void main(String[] args) {
				Seafood prawn;
				prawn = new Seafood();
				Seafood shrimp = prawn; 
				prawn.quantity = 100;
				System.out.println(shrimp.quantity);
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		100
	</code></pre>
	<p>
		Both <var>prawn</var> and <var>shrimp</var> are referring to the same
		object, so when we made a change with <var>prawn</var>, we can see the
		changes with <var>shrimp</var>.
	</p>

	<p>
		<span class="topic">Swapping References.</span> Suppose the following
		code:
	</p>
	<pre class="language-java"><code>
		class Chemical {
			public String name;
			Chemical(String setName) {
				name = setName;
			}
		}
		public class bar {
			public static void main(String[] args) {
				Chemical Na = new Chemical("iron");
				Chemical Fe = new Chemical("sodium");
			}
		}
	</code></pre>
	<p>
		We want to switch the objects the reference variables are referring to
		in the code above. In making this switch, we
		<span class="underlineText">must</span> be careful. This is because the
		moment we lose a reference, the moment that object is lost. And once it
		is lost, it effectively no longer exists (Java's garbage collector
		spares no one).
	</p>
	<p>
		To ensure the reference is never lost, we need a temporary reference
		variable, in this case a variable named <var>tmp</var>:
	</p>
	<pre class="language-java"><code>
		class Chemical {
			public String name;
			Chemical(String setName) {
				name = setName;
			}
		}
		public class bar {
			public static void main(String[] args) {
				Chemical Na = new Chemical("iron");
				Chemical Fe = new Chemical("sodium");
				Chemical tmp = Na;
				Na = Fe;
				Fe = tmp;
			}
		}
	</code></pre>

	<p>
		<span class="topic">Pass By Reference.</span> Why do we use references
		in the first place? Why don't we just store the objects themselves in
		the variables? One of the reasons is because of the way methods work in
		Java. When we pass an object into a method, the method receives a
		<i>copy of the reference</i> to the object argument. This in turn
		allows the method to modify the referenced object.
	</p>
	<pre class="language-java"><code>
		class Grain {
			public String name;
			public int amount;
			Grain(String setName, int setAmount) {
				name = setName;
				amount = setAmount;
			}
		}
		
		public class bar {
			public static void main(String[], args) {
				Grain wheat = new Grain("wheat", 10);
				System.out.println("amount before: " + wheat.amount);
				newShipment(wheat);
				System.out.println("amount after: " + wheat.amount);
			}
			public static int newShipment(Grain toIncrease) {
				toIncrease.amount++;
				return toIncrease.amount;
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		amount before: 10
		amount after: 11
	</code></pre>
	<p>
		In the code above, the function
		<var>newShipment()</var> receives a copy of the reference to the object
		created in the line <var>Grain wheat = new Grain("wheat", 10)</var>.
		Thus, that reference is used by <var>newShipment()</var> to modify the
		object.
	</p>

	<p>
		<span class="topic">Another Look: Arrays.</span> Arrays in Java store
		object references. Thus, when we copy an array, we are only copying th
		object references, not the objects themselves.
	</p>
	<pre class="language-java"><code>
		class Weapon {
			public int amount;
			Weapon(int setAmount) {
				amount = setAmount;
			}
		}
		public class bar {
			public static void main(String[] unused) {

				// array can hold 4 references
				Weapon[] guns = new Weapon[4];
				for (int i=0; i < guns.length; i++) {
					guns[i] = new Weapon(10+i);
				}
		
				// another array holding 4 references to the same objects
				Weapon[] sameGuns = new Weapon[4];
				for (int i=0; i < guns.length; i++) {
					sameGuns[i] = guns[i]; 
				}

				// increment each referenced object in first array
				for (int i = 0; i < guns.length; i++) {
					guns[i].amount++;
				}
		
				// print each referenced object in second array
				for (int i = 0; i < sameGuns.length; i++) {
					System.out.println(sameGuns[i].amount);
				}
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		11
		12
		13
		14
	</code></pre>
</section>

<section id="references_and_polymorphism">
	<p>
		<span class="topic">References and Polymorphism</span>
		Recall that every object in Java is a part of the
		<i>Java inheritance tree</i> &mdash; every object has a parent class,
		all the way up to the only object without a class, the
		<var>Object</var>. Thus, every object in Java inherits the methods
		defined by <var>Object</var>. These methods, however, are rarely
		useful, so we often override them.
	</p>
	<p>
		Additionally, recall that when we use a particular method or variable
		associated with a class, Java first looks at the object's class, and if
		it is not there, then it looks at the object's parent class. Java will
		continue until it reaches <var>Object</var>, and if it isn't there,
		then it returns an error.
	</p>
	<p>
		<i>Subtype polymorphism</i> tells us that every object can be referred
		to as at least two types: the class defining it, and the type
		<var>Object</var>. The object, of course, can morph into its ancestors,
		if any. Consider the following:
	</p>
	<pre class="language-java"><code>
		class Fruit { }
		class Berry extends Fruit {
			public String toString() {
				return "this is a berry!";
			}
		}

		public class bar {
			public static void main(String[] args) {
				Fruit banana = new Fruit();
				Berry blueberry = new Berry();
				bar.printIsType(banana);
				bar.printIsType(blueberry);
			}
			public static void printIsType(Object target) {
				System.out.println(target.toString());
			}  
		}
	</code></pre>
	<pre class="language-bash"><code>
		Fruit@6b95977
		this is a berry!
	</code></pre>
	<p>
		The first output line is the name of the class followed by a hashcode.
		This is the default definition for the
		<var>toString()</var> method provided by <var>Java.lang.Object</var>.
		Why do we see this output? Because we created an instance of
		<var>Fruit</var>, and <var>banana</var> stores a reference to that
		instance. The class <var>Fruit</var>, however, does not define
		<var>toString()</var>, so Java looks to <var>Java.lang.Object</var>,
		<var>Fruit</var>'s parent class, for a definition. Java found that
		definition, so it applied it accordingly.
	</p>
	<p>
		In contrast, with <var>blueberry</var>, we created an instance of
		<var>Berry</var>, and stored the reference to that instance in
		<var>blueberry</var>. We overrode <var>Java.lang.Object</var>'s
		definition of <var>toString()</var> inside the class <var>Berry</var>,
		so when we called that method, Java went and looked for a definition in
		<var>Berry</var>. It found such a definition and applied it
		accordingly.
	</p>
	<p>Now, consider the following alteration:</p>
	<pre class="language-java"><code>
		class Fruit { }
		class Berry extends Fruit {
			public String toString() {
				return "this is a berry!";
			}
		}

		public class bar {
			public static void main(String[] args) {
				Fruit banana = new Berry();
				Berry blueberry = new Berry();
				bar.printIsType(banana);
				bar.printIsType(blueberry);
			}
			public static void printIsType(Object target) {
				System.out.println(target.toString());
			}  
		}
	</code></pre>
	<pre class="language-bash"><code>
		this is a berry!
		this is a berry!
	</code></pre>
	<p>
		Notice the change made: The reference variable
		<var>banana</var> remains as a variable of type <var>Fruit</var>, but
		it now holds a reference to an instance of <var>Berry</var>. Thus, when
		we passed <var>banana</var> to the <var>printIsType()</var> method,
		Java went and looked at the class <var>Berry</var>, rather than
		<var>Fruit</var> (after all, the referrent is an instance of type
		<var>Berry</var>). Java found a definition for <var>toString()</var>,
		and evaluated accordingly. This example evidences the relationship
		between polymorphism &mdash; an object morphing, or behaving, as if it
		were a member of another class &mdash; and references. We can store a
		reference to an instance of <var>Berry</var> to a reference variable of
		type <var>Fruit</var>. Why? Because <var>Berry</var> extends
		<var>Fruit</var>. Any <var>Berry</var> can behave like a
		<var>Fruit</var> &mdash; but, not all <var>Fruit</var> can behave like
		a <var>Berry</var>. The general rule for polymorphism: An object can
		morph into an object of its superclasses, but it cannot morph into an
		object of its subclasses. If we want to <i>downcast</i>, we must do so
		explicitly:
	</p>
	<pre class="language-java"><code>
		class Fruit { }
		class Berry extends Fruit {
			public String toString() {
				return "this is a berry!";
			}
		}

		public class bar {
			public static void main(String[] args) {
				Object acai = new Berry();

				System.out.println(acai);

				Fruit acaiFruit = (Fruit) acai;

				System.out.println(acaiFruit);

				Berry acaiBerry = (Berry) acai;

				System.out.println(acaiBerry);

			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		this is a berry!
		this is a berry!
		this is a berry!
	</code></pre>
	<p>
		<span class="topic">How to Copy an Object.</span> Suppose we want to
		create a copy of an object, <i>not</i> a copy of the reference to that
		object. We have several options to accomplish this. The
		<var>Java.lang.Object</var> class provides a method called
		<var>clone</var>. But, we should not use this method to create copies
		of an object. It does not exactly work in the way we expect (more on
		this later).
	</p>
	<p>
		A better way is to implement a
		<i>copy constructor</i>:
	</p>
	<pre class="language-java"><code>
		class Employee {
			public int age;
			Employee(int setAge) {
				age = setAge;
			}
			Employee(Employee other) {
				age = other.age;
			}
		}
	</code></pre>
	<p>
		Here, we have class called <var>Employee</var> with a single field
		called <var>age</var>. Then, we have two constructors. The first
		constructor allows us to create a new instance of
		<var>Employee</var> and set their <var>age</var>. Then we have a second
		constructor: It takes as an argument a reference to another instance of
		<var>Employee</var>, referred to with the dummy variable
		<var>other</var>. In doing so, we copy all of the fields of
		<var>other</var> (we can limit the copy) into the new instance of
		<var>Employee</var>. Thus, what we get back is a copy.
	</p>
	<p>
		<span class="topic">Instance v. Reference Types.</span> When we create
		an object and assign its reference to a variable, there are effectively
		two types: (1) the instance type, and (2) the reference type. The
		instance type is what is to the right of the symbol <var>new</var>. The
		reference type is to the right of the reference variable name. It will
		store a reference to any instance that can behave like the reference
		variable's type.
	</p>
	<pre class="language-java"><code>
		class Court { }
		class FederalCourt extends Court { }
		class AppellateCourt extends FederalCourt { }
		class CircuitCourt extends FederalCourt { }

		public class bar {
			public static void main(String[] unused) {
				Court NDCal = new Court();
				Object NDIll = new FederalCourt();
				FederalCourt NinthCir = new AppellateCourt();
			}
		}
	</code></pre>
	<p>
		In the example above, the reference variable
		<var>NDCal</var> can store a reference to any object that behaves like
		a <var>Court</var>. Thus, it can store a reference to
		<var>new FederalCourt()</var>, <var>new AppellateCourt()</var>, or
		<var>new CircuitCourt()</var>. Similarly, <var>NDIll</var> can store a
		reference to any object that behaves like a
		<var>Java.lang.Object</var>.
	</p>
	<p>
		In Java, the reference type is what determines whether an instance can
		access particular methods or variables.
	</p>
	<pre class="language-java"><code>
		class GovEntity {}
		class Executive extends GovEntity {
			public void act() {
				System.out.println('I refused a law');
			}
		} 
		class Legislative extends GovEntity {} 
		class Judicial extends GovEntity {} 

		public class bar {
			public static void main(String[] args) {
				Executive potus = new Executive();
				potus.act(); // works
				Object potusAsObj = potus;
				potus.act(); // doesn't work
				Object stringObj = new String("I am a string");
				stringObject.act(); // doesn't work
				System.out.println(stringObject.toString()); // works
			}
		} 

	</code></pre>
	<p>
		This is an absolutely critical point to understand. It is not the class
		of the instance that determines what methods or variables that instance
		may access, it is the reference variable's class that determines what
		methods or variables that instance may access.
	</p>
	<pre class="language-java"><code>
		class GovEntity {}
		class Executive extends GovEntity {
			public void act() {
				System.out.println("I refused a law");
			}
		} 
		class Legislative extends GovEntity {
			public void legislate() {
				System.out.println("I made a law");
			}
		} 
		class Judicial extends GovEntity {
			public void judge() {
				System.out.println("I struck down a law");
			}
		} 

		public class bar {
			public static void main(String[] args) {
				Executive potus = new Executive();
				potus.act(); // works
				Legislative congress = new Legislative();
				congress.legislate(); // works
				Judicial scotus = new Judicial();
				scotus.judge(); // works
				GovEntity scotusGov = scotus;
				scotusGov.judge(); // doesn't work
				GovEntity potusGov = potus;
				potusGov.act(); // doesn't work
				GovEntity congressGov = congress;
				congressGov.legislate(); // doesn't work

				GovEntity whiteHouse = new Executive();
				whiteHouse.act(); // doesn't work -- reference type controls
			}
		} 
	</code></pre>
	<p>
		Why doesn't the last line work? Didn't we create an instance of
		<var>Executive</var>? It doesn't work because the reference type is
		<var>GovEntity</var>, and <var>GovEntity</var> can store any one of
		three types: <var>Executive</var>, <var>Legislative</var>, and
		<var>Judicial</var>.
	</p>

	<p>
		This is a characteristic of Java that separates it from other
		object-oriented languages. Java enforces this rule because not every
		<var>GovEntity</var> has a method called <var>act()</var>. In languages
		like Python, the rule is <i>duck typing</i> &mdash; if it walks like an
		<var>Executive</var>, quacks like an <var>Executive</var>, then it is
		an <var>Executive</var>.
	</p>

	<p>
		<span class="topic">Why Polymorphism?</span> A fair question regarding
		all this complexity is <i>why</i>? Why organize things in a hierarchy?
		Why create so many rules implicating inheritance? These questions
		directly strike the heart of Java's type system. Java's motivations are
		reasonable: First, by focusing on class extension (inheritance),
		descendant classes can implement or override ancestor behavior while
		keeping desirable ancestor properties. This is a natural result of
		implementing hierarchy in the first place &mdash; if we follow strict
		hierarchy, there is no possibility of refusing methods and variables
		inherited from an ancestor. Indeed, Java does not allow such actions;
		if an object does not want <var>toString()</var>, we must override.
	</p>

	<p>
		Second, by focusing on hierarchy relationships (polymorphism), we can
		write method that work for <i>any</i> descendant class &mdash; even
		those that we may not have explicitly defined within the particular
		descendant class. This is a powerful way to <i>generalize</i> &mdash;
		we can create elaborate methods without actually knowing anything about
		the objects they might operate on. This provides fertile ground for
		large, complex data structures as well as extensive libraries.
	</p>

	<p>
		<span class="topic"><var>final</var> and Classes.</span>
		As a brief aside, appending the symbol
		<var>final</var> to a class tells Java that the class
		<span class="underlineText">cannot</span> be extended.
	</p>
	<pre class="language-java"><code>
		public class Crustacean { }
		public final class Crab { }
		public class MangroveCrab extends Crab { } // this shall not pass
	</code></pre>
	<p>
		<span class="topic"><var>abstract</var> and Classes.</span>
		When we append the symbol <var>abstract</var> to a class, we tell Java
		the class can only be extended
		<span class="underlineText">but not instantiated</span> (make an
		instance of).
	</p>
	<pre class="language-java"><code>
		public abstract Bird { }
		public class Penguin extends Bird { } 
		Bird winglet = new Bird(); // this doesn't work
		Penguin penguini = new Penguin(); // this works
	</code></pre>
	<p>
		<span class="topic"><var>private</var> and Classes.</span>
		We cannot use the symbol <var>private</var> with classes. If a class
		were <var>private</var>, we would not be able to use it at all. But,
		there are situations where we might want to limit a class. To do so, we
		use <i>inner classes</i>:
	</p>
	<pre class="language-java"><code>
		public class Organ {
			class Heart {
				public String toString() {
					return "This is part of the heart"
				}
				private Heart foo;
				Organ() {
					foo = new Heart();
				}
			}
		}
	</code></pre>
	<p>
		Inside the <var>Organ</var> class, we have a definition for the
		<var>Heart</var> class. Inside the <var>Organ</var> class, we can use
		the <var>Heart</var> class.
	</p>
	<p>
		<span class="topic">Generality v. Capability.</span> But, polymorphism
		has its tradeoffs. The higher a class is on the object hierarchy, the
		more general, and the more general, the fewer its capabilities. On the
		other hand, the lower a class is on the object hierarchy, the more
		specific it is, and the more specific, the more capabilities. The
		problem: The more specific a class is, the narrower its use cases.
		Narrow use cases are prone to abuse. Polymorphism, as we have seen, can
		easily become enormously complex, and any good programmer will tell you
		that large, deeply nested classes can lead to
		<i>inheritance hell</i> &mdash; adding further classes only makes the
		program look more like <i>Dante's Inferno</i>.
	</p>
</section>

<section id="interfaces">
	<h2>Interfaces</h2>
	<p>Suppose we create program that peels potatoes. We write the following:</p>
	<pre class="language-java"><code>
		class Peeler {
			Potato peelPotato(Potato p) {
				return p.removeSkin();
			}
		}
	</code></pre>
	<p>
		The program works well, until we're thrown an apple to peel. Well, it's just
		an apple, so maybe we can write another method:
	</p>
	<pre class="language-java"><code>
		class Peeler {
			Potato peelPotato(Potato p) {
				return p.removeSkin();
			}
			Apple peelApple(Apple a) {
				return a.removeSkin();
			}
		}
	</code></pre>
	<p>
		We keep peeling, and suddenly we're thrown a kiwi. Now we're starting to
		think about all the other things that might come our way: yams, oranges,
		tomatoes, taro, rambutan &mdash; we cannot possibly write all these classes.
		We could write a separate parent class, called
		<span class="monoText">Peelable</span>, under which all these foods inherit
		a method called <span class="monoText">peel()</span>. But maybe there are
		situations where a <span class="monoText">Potato</span> should not be
		peeled. Furthermore, there are foods that would be odd to come up with
		<span class="monoText">peel()</span> methods &mdash; kale, broccoli, rice,
		popcorn, etc. Ok, so maybe we create a class called
		<span class="monoText">Peelable</span> and
		<span class="monoText">NonPeelable</span>, and write separate food classes
		for each of them. But that's even worse! Now we would have two
		<span class="monoText">Potato</span> classes to write &mdash;
		<span class="monoText">PotatoPeelable</span> and
		<span class="monoText">PotatoNonPeelable</span>.
	</p>
	<p>
		Fortunately, there is a solution &mdash; an
		<span class="italicsText">interface</span>. With an interface, we write:
	</p>
	<pre class="language-java"><code>
		public interface Peel {
			Food peel(Food f);
		}
		public class Peelable implements Peel {
			public Food peel(Food f) {
				return removeSkin(f);
			}
		}
	</code></pre>
	<p>
		With the interface <span class="monoText">Peel</span>, the method
		<span class="monoText">peel()</span> can work for any
		<span class="monoText">Food</span> object without having to know what
		specific class the object is an instance of. Interfaces exist because some
		part ${x}$ of the program needs some entity ${y}$ to do something specific,
		but ${x}$ doesn't care how ${y}$ does it &mdash; as long as ${y}$ gets it
		done. This is most often the case when we have many different classes all
		using the same methods and variables. In such situations, we want to use
		interfaces or abstract classes so we do not have to declare the same methods
		over and over again.
	</p>
	<p>
		An <span class="italicsText">interface</span> is a point, or place, where
		separate components of a computer system meet and exchange information. It
		is effectively a shared boundary betweeen two different entities. What are
		these two entities? Anything really: library and our source code; software
		and software; software and hardware; computer and user; etc. A screen, for
		example, is an interface. A printer's driver is an interface. The keyboard
		is an interface.
	</p>
	<p>
		Because interfaces are what enable different parts of a system to interact
		with one another, it is imperative that we design interfaces carefully. We
		can only do so if we have an understanding of interfaces, which is what this
		section concerns. A designing an interface is like drafting a contract to
		exchange information under particular terms. To construct that contract, we
		have to define what the two entities know about each other. What does my
		entity need to know about your entity, and what does your entity need to
		know about my entity? The end-game of well-designed interface is to ensure
		that only the most absolutely necessary things are shared &mdash; everything
		else is hidden.
	</p>
	<p>
		Interfaces are not unique to Java, but Java gives interfaces special
		treatment. The word <span class="monoText">interface</span> is a keyword in
		Java. In other languages like Python and JavaScript, interfaces are treated
		with special conventions.
	</p>
	<p>
		Every class in Java has an interface. The interface of a Java class is the
		set of methods it provides. Because every Java class has an interface, every
		Java object has interface (since every Java object inherits the methods of
		<span class="monoText">Java.lang.Object</span>).
	</p>
	<p>
		<span class="topic">Java Interfaces.</span> Here is an example of a Java
		interface:
	</p>
	<pre class="language-java"><code>
		public interface Add {
			int add(int first, int second);
		}
	</code></pre>
	<p>
		This looks very much like a method declaration, but there is no body. Java
		interfaces look like empty objects, all we see is a method signature.
		Interfaces can declare both methods and variables, just like a class, but
		with a catch &mdash; interface variables
		<span class="underlineText">must</span> be
		<span class="monoText">public static final</span>; they are only useful for
		declaring constants.
	</p>
	<p>
		The interface above has only been declared; it has not be implemented. To
		actually implement the interface, we write the following:
	</p>
	<pre class="language-java"><code>
		public interface Add {
			int add(int first, int second);
		}
		public class Adder implements Add {
			public int add(int first, int second) {
				return first + second;
			}
		}
	</code></pre>
	<p>
		As we can see in the code above, the class
		<span class="monoText">Adder</span> is what implements the interface
		<span class="monoText">Add</span>. This is done by using the
		<span class="monoText">implement</span> symbol. Furthermore, to implement
		the interface, we must implement <span class="italicsText">all</span> of the
		methods the interface declares. Finally, when we implement an interface, we
		should have documentation explaining what the interface is supposed to do.
		The class implementing the interface should try to follow that.
	</p>
	<p>
		If we try to use an interface without implementing it, we will see an error:
	</p>
	<pre class="language-java"><code>
		interface Add {
			int add(int first, int second);
		}
		class Adder { }
		public class bar {
			public static void main(String[] unused) {
				Add add = new Adder();
				System.out.println(add.add(10, 12));
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		bar.java:7: error: incompatible types: Adder cannot be converted to Add
							Add add = new Adder();
										^
		1 error
	</code></pre>
	<p>Once we implement, then it works:</p>
	<pre class="language-java"><code>
		interface Add {
			int add(int first, int second);
		}
		class Adder implements Add {
			/** 
				* Return the sum of first and second
				*
			*/
			public int add(int first, int second) {
				return first + second;
			}
		}
		public class bar {
			public static void main(String[] unused) {
				Add add = new Adder();
				System.out.println(add.add(10, 12));
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		22
	</code></pre>
	<p>
		Notice that the interface is documented. Whenever we write interfaces, we
		<span class="underlineText">must</span> include documentation. If we have an
		interface containing multiple methods, then
		<span class="underlineText">all</span> of those methods must be implemented:
	</p>
	<pre class="language-java"><code>
		interface Logic {
			boolean nand(boolean p, boolean q);
			boolean neitherNor(boolean p, boolean q);
		}
		class LogicOperator implements Logic {
			public boolean nand(boolean p, boolean q) {
				return !(p && q); 
			}
		}
		public class bar {
			public static void main(String[] unused) {
				Logic isSweetAndSpicy = new LogicOperator(); 
				System.out.println(isSweetAndSpicy.nand(true, true));
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		bar.java:5: error: LogicOperator is not abstract and does not override abstract method neitherNor(boolean,boolean) in Logic
		class LogicOperator implements Logic {
		^
		1 error
	</code></pre>
	<p>
		Above, we neglected to define the method
		<span class="monoText">neitherNor()</span>. Once we do so, the source code
		compiles:
	</p>
	<pre class="language-java"><code>
		interface Logic {
			boolean nand(boolean p, boolean q);
			boolean neitherNor(boolean p, boolean q);
		}
		class LogicOperator implements Logic {
			public boolean nand(boolean p, boolean q) {
				return !(p && q); 
			}
			public boolean neitherNor(boolean p, boolean q) {
				return !(p || q);
			}
		}
		public class bar {
			public static void main(String[] unused) {
				Logic isSweetAndSpicy = new LogicOperator(); 
				System.out.println(isSweetAndSpicy.nand(true, true));
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		false
	</code></pre>
	<p>
		For every change we make to the interface, the implementing class must keep
		up and be updated accordingly.
	</p>
	<p>
		Notice that when we called an interface method, we created an instance of
		class, then assigned the reference to that instance to a reference variable
		of the type <span class="monoText">⟨interface name⟩</span>. We saw this with
		classes and reference variables in general. The same exact idea applies with
		interfaces.
	</p>
	<p>
		<span class="topic">Interface v. Inheritance.</span> One question we might
		ask is why use an interface instead of a parent class from which other
		classes inherit the methods? The answer is partly because of the distinction
		between the two concepts. Establishing inheritance describes an
		<span class="italicsText">is-a</span> relationship. Implementing an
		interface describes a <span class="italicsText">can-do</span> relationship.
		With inheritance, all an ancestor class's implementations are inherited by
		its descendant classes. The more methods we include in the ancestor class,
		the more likely it is that we must override those methods by modifying them
		in the descendant classes. With enough descendants, we start seeing the
		method have so many exceptions and modifications that we enter inheritance
		hell, losing track of how a method operates for a particular descendant
		class instance.
	</p>
	<p>
		Really, interfaces are very similar to
		<span class="term">abstract methods</span> &mdash; methods defined by
		<span class="italicsText">abstract classes</span>:
	</p>
	<pre class="language-java"><code>
		abstract class Proposition {
			public abstract boolean nxor(boolean p, boolean q);
		}
		class BooleanExpression extends Proposition {
			public boolean nxor(boolean p, boolean q) {
				return !((p && !q) || (!p && q));
			}
		}
		
		public class bar {
			public static void main(String[] unused) {
				Proposition isSweetAndSour = new BooleanExpression();
				boolean is_not_sweet_and_not_sour = isSweetAndSour.nxor(false, false);
				boolean is_sweet_but_not_sour = isSweetAndSour.nxor(true, false);
		
				System.out.println(is_not_sweet_and_not_sour);
				System.out.println(is_sweet_but_not_sour);
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		true
		false
	</code></pre>
	<p>
		<span class="topic">Multiple Inheritance.</span> Classes can implement
		multiple inferfaces:
	</p>
	<pre class="language-java"><code>
		interface Add {
			int add(int first, int second);
		}
		interface Subtract {
			int subtract(int first, int second); 
		}
		interface MathOp implements Add, Subtract {
			public int add(int first, int second) {
				return first + second;
			}
			public int subtract(int first, int second) {
				return first - second;
			}
		}
	</code></pre>
	<p>
		<span class="topic">Well-designed Interfaces.</span> A well-designed
		interface is akin to an ambassador. (We are deliberately avoiding the common
		analogy of a contract; contracts are an abstract concept with a very
		specific legal meaning, carrying numerous connotations among lay persons.).
		Like a good ambassador, a well-designed interface serves as the shared
		contact between the two entities, ensuring and allow both entities to work
		together, while also keeping everything in check &mdash; only the most
		relevant information is passed between the two; the two entites follow the
		relationship's underlying assumptions; all for the end goal of ensuring that
		both entities are kept entirely separate and independent, while working
		together.
	</p>
	<p>
		One heavily used interface is <span class="monoText">comparable</span>. If
		we implement the <span class="monoText">comparable</span> interface, then we
		imply that there is an ordering for our class.
	</p>
	<pre class="language-java"><code>
		/**
			* Compares this object with the specified object for order
			*
			* Returns a negative integer, zero, or a positive integer as
			* this object is less than, equal to, or greater than 
			* the specified object
			*/
			public interface Comparable {
				int CompareTo(Object otherObject);
			}
	</code></pre>
	<p>
		The value of <span class="monoText">Comparable</span> tells us what order
		<span class="monoText">Object</span> and
		<span class="monoText">otherObject</span> are relative to each other. Why
		would we want to use the <span class="monoText">Comparable</span> interface?
		Because by committing to using the
		<span class="monoText">Comparable</span> interface, we in turn commit to
		ordering our classes. And if we commit to ordering our classes, we can do
		certain things: sorting arrays containing instances of our class; we can
		find the maximum or minimum value of multiple instances of the class; we can
		organize class instances into a binary tree.
	</p>

	<p>
		The <span class="monoText">Comparable</span> interface allows us to compare
		instances. And if we can compare instances, then we can
		<span class="italicsText">sort</span> instances. And if we can sort
		instances, we can <span class="italicsText">search</span> for a particular
		instance.
	</p>

	<p>Here is an implementation of <span class="monoText">Comparable</span>:</p>

	<pre class="language-java"><code>
		interface Comparable {
			int compareTo(Object other);
		}
		class StringLength implements Comparable {
			private String string;
			StringLength(String setString) {
				string = setString;
			}
			public int compareTo(Object other) {
				if (other == null || !(other instanceof StringLength)) {
					return -1;
				}
				StringLength otherStringLength = (StringLength) other;
				if (string.length() < otherStringLength.string.length()) {
					return 1;
				} else if (string.length() > otherStringLength.string.length()) {
					return -1;
				} else {
					return 0;
				}
			}
		}
		public class bar {
			public static void main(String[] unused) {
				StringLength first = new StringLength("test"); 
				StringLength second = new StringLength("examination");
				System.out.println(first.compareTo(second));
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		-1
	</code></pre>

	<p>
		<span class="topic">.equals() versus .compareTo()</span>. The
		<span class="monoText">Comparable</span> interface is provided because we
		cannot accomplish sorting with <span class="monoText">.equals()</span>. The
		<span class="monoText">.equals()</span> method is a binary method: Either
		one is equal or not equal to the other. The
		<span class="monoText">.compareTo()</span> method is a ternary method: One
		object goes before the other, one object goes after the other, or both
		object's are equal.
	</p>

	<p>
		<span class="topic">Interface Casting.</span> We can cast interfaces just as
		we would cast class instances:
	</p>

	<pre class="language-java"><code>
		interface add {
			int add(int first, int second);
		}
		class Adder implements Add {
			public int add(int first, int second) {
				return first + second;
			}
			public int multiply(int first, int second) {
				return first * second;
			}
		}
		public class bar {
			public static void main(String[] unused) {
				Add add = new Adder();
				System.out.println(add.add(10, 20)); // works
				System.out.println(add.multiply(10, 20)) // does not work
			}
		}
	</code></pre>

	<p>
		The last line does not work because
		<span class="monoText">multiply</span> is not a part of the
		<span class="monoText">Add</span> interface, and we are storing the
		reference to <span class="monoText">Adder</span> inside an
		<span class="italicsText">interface variable</span>.
	</p>

	<p>
		<span class="topic">Why interfaces?</span> Interfaces should be used when we
		want to implement a method that should be accessible to objects regardless
		of their positions in the inheritance tree.
	</p>
</section>

<section id="class_examples">
	<h2>Examples</h2>
	<p>Here's an example of a <var>circle</var> class in Java:</p>
	<pre class="language-java"><code>
		class Console {
			public static void log(int x) {
				System.out.println(x);
			}
			public static void log(double x) {
				System.out.println(x);
			}
		}
		
		class Circle {
			private double _pi = 3.14159265359;
			private double _radius;
			private double _circumference;
		
			public Circle(double radius) {
				this._radius = radius;
				this._circumference = 2 * radius * this._pi;
			}
			double circumference() {
				return _circumference;
			}
			double radius() {
				return _radius;
			}
		}
		
		class Main {
			public static void main(String[] args) {
				double r = 5;
				Circle obj = new Circle(r); 
				Console.log(obj.circumference());
				Console.log(obj.radius());
			}
		}
	</code></pre>
</section>

{% endblock %}
