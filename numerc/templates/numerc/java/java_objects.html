{% extends '../layout.html' %} {% load static %} {% block description %}
<meta name="description" content="Java classes" />
{% endblock %} {% block title %}
<title>Java Classes</title>
{% endblock %} {% block content %}
<h1>Object-Oriented Programming</h1>

<section id="intro">
	<p>
		<span class="drop">A</span>ll of the topics covered thus far are concepts we
		can collect into our programming toolbox and use as needed. Indeed, a
		substantial part of being a programmer is discovering new concepts to add to
		that toolbox. We now introduce another concept &mdash;
		<span class="italicsText">objects</span>.
	</p>
	<p>
		Objects are placed in the tool slot for data structures &mdash; objects are
		one possible approach for organizing data. More specifically, they allow us
		to create custom <span class="italicsText">types</span>. So far, we have
		only used primitive types &mdash; the types Java provides by default.
		Objects give us a way to have more types.
	</p>
	<p>
		Recall: How do we structure good programs? So far, we've seen one approach:
		Using <span class="italicsText">functions</span> &mdash; break down the
		program into smaller, reusable, testable, and understandable pieces. Objects
		give us a second approach: Combining
		<span class="italicsText">state</span> and
		<span class="italicsText">behavior</span> &mdash; modeling data (state) and
		what we can do with that data (behavior).
	</p>
	<p>
		Creating objects is a strenous exercise of creativity, imagination, holistic
		thinking, and intuition. This is in contrast to implementing functions,
		which often involves logic, fact analysis, and computation. This is because
		implementing objects depends much more heavily on design, rather than
		sequences of steps. This method of programming is called
		<span class="term">object-oriented programming</span> (often shortened to
		OOP). In this volume's preface, we gave a brief glimpse of what
		object-oriented programming is. We will now perform a more thorough and
		rigorous investigation.
	</p>
</section>

<section id="principles_of_object_oriented_programming">
	<h2>Principles of Object-oriented Programming</h2>
	<p>
		In object-oriented programming, we write code according to four key
		principles: abstraction, encapsulation, inheritance, and polymorphism. To
		understand what all of these terms mean, we will use various analogies.
	</p>
	<section id="abstraction">
		<p>
			<span class="topic">Abstraction.</span> The Oxford dictionary defines
			<span class="italicsText">abstraction</span> as &#8220;the process of
			considering something independently of its associations, attributes, or
			concrete accompaniments.&#8221; This is a good starting point, but let's
			see some examples of this process in action.
		</p>
		<p>
			Consider the microwave. Not very many people know how a microwave works.
			In fact, if you really think about it, it's a fairly strange machine. We
			open its door, place our food, set a timer, and it just rotates a tray.
			There's a lightbulb on and some humming, but there's no fire or obvious
			source of heat. Yet once the timer's done, our food is heated. Despite the
			fact that few people know how the microwave actuall works, it's a fairly
			commonplace appliance &mdash; we find it houses, apartments, gas stations,
			offices, and various locations. And it's a fairly commonplace appliance
			because people can use it without knowing the internal details. We push
			one button and the door opens. We enter digits, hit start, and a timer
			ensures. All of this is done without the user knowing how the button leads
			to the door opening, or how the digits correspond to a timer. The
			microwave is an abstraction of all the pieces that comprise it &mdash; the
			control panel, high voltage transformer, capacitor, magnetron, antenna,
			cooling fan, wave guide, wave stirrer, and a plethora of other components.
		</p>
		<p>
			The microwave is just one example of an abstraction. We can use, or
			&#8220;consider,&#8221; the microwave without knowing anything about how
			it works or its internal details. Another example: the cellphone. Very few
			peole know how a cellphone works, yet it's used across the world and
			across cultures. It's an abstraction of transistors, machine code, an
			operating system, a file system, source code for applications, etc.
		</p>
		<p>
			Abstraction is a core principle of object-oriented programming. In writing
			code to be used by another, we want the user to be able to use the program
			without having to think about how the code works. And by user, we don't
			necessarily mean people. This idea also extends to other code, other
			programs. When we write some piece of code ${x}$ to be used by another
			piece of code ${y,}$ ${y}$ shouldn't have to consider how ${x}$ is
			implemented. It should be able to just use ${x}$ as is.
		</p>
	</section>

	<section id="encapsulation">
		<p>
			<span class="topic">Encapsulation.</span> Encapsulation is exactly what it
			sounds like &mdash; everything is contained in a single entity.
			Essentially, whatever the program needs is contained in a single place.
			When we use a TV, we don't have to install a screen everytime we use it.
			The screen is just there. In programming terms, this does
			<span class="underlineText">not</span> mean that we write all of our code
			in a single file. Instead, it means that everything the program needs is
			connected in such a way that they all work together a single unit.
		</p>
		<p>
			In OOP, we apply encapsulation by bundling, or packaging,
			<span class="italicsText">properties</span> and
			<span class="italicsText">behaviors</span>. At its core, data is a
			representation of real world information. With sufficiently complex
			information, a program can grow gargantuan. Such large programs are
			examples of <span class="term">monolithic programming</span>. With
			functions and collections, we can modularize parts of the large program
			into smaller, more manageable pieces. However, with more and more modules,
			it can become difficult to keep track of all the different pieces.
			Encapsulation is OOP's response to this problem. We look at all the
			different pieces, determine their relationships, and bundle them together
			into a single package accordingly.
		</p>
		<p>
			Encapsulation, however, goes a bit further than this in programming terms.
			It also implies <span class="italicsText">isolation</span>. Large programs
			often consist of many small modules. For example, if we wrote a program
			that provides text editing, we might have a module for saving files,
			another to output text, another to italicize text, another to recover
			files. These are all separate modules that are
			<span class="italicsText">encapsulated</span>. Encapsulation tells us that
			we must isolate these modules. Why? To prevent one module from accessing,
			and modifying, the other. We want the modules to work together, but we
			don't want one module interfering with, or even accessing, the internal
			work of another. For example, the federal government is a giant
			encapsulation. However, the Constitution places barriers on the various
			branches &mdash; the Supreme Court, Congress, and the President &mdash;
			interfering with one another. And even within the branches, there are
			barriers. Homeland Security can't dictate orders to the NSA, nor can the
			Ninth Circuit go snooping into the Seventh Circuit's files.
		</p>
	</section>

	<section id="inheritance">
		<p>
			<span class="topic">Inheritance.</span> Inheritance embodies the principle
			of reusing existing work. For example, consider the iPhone. The iPhone, as
			a single entity, is an Apple mobile phone. It has a distinct appearance
			&mdash; rounded corners, large screen realty, and a slim form factor.
			However, the iPhone has various models: iPhone SE, iPhone X, iPhone iPhone
			XR, etc. They are, however, all iPhones. Their distinguishing features lie
			in various optimizations. One phone might have a more expensive processor,
			another a better camera. Nevertheless, much of the existing work is reused
			&mdash; the general form factor, the operating system, the machine code,
			etc.
		</p>
		<p>
			OOP applies this principle to programming. Suppose we wrote a program that
			simulates various doctors working in a hospital. We write one program that
			simulates a cardiothoracic surgeon. The cardiothoracic surgeon uses a
			stethoscope on a patient, so we write some code simulating this action.
			The cardiothoracic surgeon then performs an angioplasty, and we write
			another piece of code to simulate this action. We then write another
			program that simulates a neurosurgeon. The neurosurgeon also uses a
			stethoscope, so we copy-and-paste the code from the cardiothoracic surgeon
			in the neurosurgeon's program the code for this action. The neurosurgeon
			also performs a craniotomy, so we include the code for this action as
			well. Because of encapsulation, we keep the cardiologist and the
			neursurgeon's code separate. After all, we don't want the neurosurgeon
			interfering with open-heart surgery.
		</p>
		<p>
			The problem, however, is that copy-and-paste for the stethoscope code. We
			only have two doctors, but what happens when we start having all kinds of
			doctors: anesthesiologists, pediatricians, radiologists, endocrinologists;
			they will all likely use a stethoscope at some point. All of these doctors
			will also likely have to request a test, physically examine patients, take
			notes, and so on. We do not want to copy-and-paste all of this code. But,
			we can't put them all in one place either because of encapsulation.
		</p>
		<p>
			Inheritance is the medicament. What an OOP language like Java allows us to
			do is to write a more general module of code containing all of the common
			pieces of code between the various doctors, and give it a name, say
			<span class="monoText">Doctor</span>. We can then write code that says,
			&#8220;See all that <span class="monoText">Doctor</span>? Place it in this
			code named <span class="monoText">Dermatologist</span>.&#8221; The code
			simulating a dermatologist essentially
			<span class="italicsText">inherits</span> everything that
			<span class="monoText">Doctor</span> contains. We can use the same
			instruction for all the other categories, thereby ridding ourselves of
			copy-and-paste.
		</p>
		<p>
			<span class="topic">Polymorphism.</span> The principle of
			<span class="italicsText">polymorphism</span> provides that entities can
			look, be used, or behave like one thing, but also another. For example,
			the cast iron skillet can be used as a cooking utensil, but also a weapon.
			The company CEO can be cold and unforgiving, but also a loving mother. The
			pet tiger can be just as loving, but also dangerous.
		</p>
		<p>
			In OOP, we apply polymorphism to write more customized code. The idea is
			that the different modules in our program should react to our instructions
			or inputs as needed, even if the modules share similarities with other
			pieces of code. Returning to our doctor-simulation example, suppose a
			large disaster occurs near the hospital, and a
			<span class="italicsText">Code Triage</span> is sent out. That code is an
			input to all of the doctors, regardless of what kind of doctors they are.
			But, we want all of them to have different responses to that input. The
			cardiologists do one thing, the neurologists another, etc. Polymorphism is
			what allows us to accomplish this. The
			<span class="monoText">Code Triage</span> is received by
			<span class="monoText">Doctor</span>, but every kind of
			<span class="monoText">Doctor</span> responds to it differently.
		</p>
	</section>
</section>

<section id="what_is_an_object">
	<h2>What is an object?</h2>
	<p>
		Objects are data structures that combine
		<span class="italicsText">state</span> (e.g., variables; storing
		information) and <span class="italicsText">behavior</span> (e.g., functions;
		what things we can do with that stored information). For something to be an
		object, it must answer the following questions: (1) What does it store? In
		other words, what <span class="italicsText">state</span>, or information,
		does this thing store? (2) What does it do? What sort of functionality does
		the thing provide?
	</p>
	<p>
		We've seen one object repeatedly, strings. Strings have a state: They store
		values of type <span class="monoText">char</span>, along with those values'
		respective indices. Strings also have functions (called
		<span class="italicsText">methods</span>) that operate on all strings:
		indexing, concatentation, slicing, upper-casing, etc. Thus, strings satisfy
		the definition of an object: (1) they store data, and (2) they implement
		algorithms.
	</p>
	<p>
		<span class="topic">Objects in Java.</span> In the discussion above, we used
		the term &#8220;object&#8221; loosely. To be very specific, an
		<span class="italicsText">object</span> is an instance of a
		<span class="term">class</span> &mdash; a representation of real-world
		objects. An object is simply one instance of that class. For example,
		<span class="monoText">reptile</span> is a class, and
		<span class="monoText">crocodile</span> is an instance of that class. Of
		course, <span class="monoText">crocodile</span> itself can be a class, with
		<span class="monoText">Nile crocodile</span> and
		<span class="monoText">Saltwater crocodiles</span> as instances of that
		class. An individual saltwater crocodile would be instance of
		<span class="monoText">Saltwater crocodiles</span>. Thus, as a matter of
		logic, classes are objects, but not all objects are classes.
	</p>
</section>

<section id="java_classes">
	<h2>Classes</h2>
	<p>
		The word &#8220;class&#8221; has many multiple meanings in programming. In
		Java, the class is a cornerstone of the language implementation. All Java
		programs are defined as classes. Based on this premise, we can think of
		programs that extend programs as
		<span class="italicsText">subclasses</span>. Classes, however, are also the
		implementations of a data type &mdash; blueprints, or templates, for
		producing objects. If this all seems confusing, do not worry. We will
		explore each of these ideas in turn. These points are raised now as an alert
		to the fact that the word class has many different meanings. And like many
		words with multiple meanings, which meaning we use depends on context. The
		simplest way to think about a class is that it's just another way to package
		related code, much like a function. However, unlike the function, the class
		packages a specific kind of code: Code that produces packages of code.
	</p>
	<p>
		The class is a blueprint that creates instances of the class. These
		instances are called objects. The objects themselves are packages of code.
		Inside these packages of code, there are two types of code: (1) Code that
		represents <span class="term">state</span>, and (2) code that represents
		<span class="term">behavior</span>.<sup></sup>
	</p>
	<div class="note">
		<p>
			At a more abstract level, a class is the specification for a data type.
			And as such, objects are just instaces of a type, which is implemented by
			a class. We will see what this means in later sections.
		</p>
	</div>
	<p>
		This essentially means that a class is a way to group, or bundle, related
		<span class="italicsText">properties</span> and
		<span class="italicsText">behaviors</span>. This in turn means that classes
		allow us to implement our own <span class="italicsText">data types</span>.
		For example, here's a
		<span class="italicsText">class declaration</span> creating a new type
		called <span class="monoText">Person</span>:
	</p>
	<pre class="language-java"><code>
			class Person {
				String name;
				int age;
				void printName() {
					System.out.println(this.name);
				}
			}
		</code></pre>
	<p>
		When we define a class, we start with the special keyword
		<span class="monoText">class</span>. Then we give it a name, in this case,
		<span class="monoText">Person</span>. As a matter of convention, class names
		are capitalized. Note further that assignments in Java cannot be done at the
		class level. For example, this simply won't work:
	</p>
	<pre class="language-java"><code>
			class Person {
				String name = "Dan"; // illegal
				int age;
				void printName() {
					System.out.println(this.name);
				}
			}
		</code></pre>
	<p>
		After the name, we have a block, the class definition's body. Inside that
		block, we have pieces of data and algorithms. In the example above, the body
		says: every instance of <span class="monoText">Person</span>, i.e., every
		object of type <span class="monoText">Person</span>, has a
		<span class="monoText">name</span>, a piece of data of type
		<span class="monoText">String</span>, and an
		<span class="monoText">age</span>, a piece of data of type
		<span class="monoText">int</span>. The variables
		<span class="monoText">name</span> and
		<span class="monoText">age</span> constitute
		<span class="term">properties</span> of the class
		<span class="monoText">Person</span>. All of these properties in turn
		represent the <span class="term">state</span> that every object of type
		<span class="monoText">Person</span> stores.
	</p>
	<p>
		Furthermore, every object of type <span class="monoText">Person</span> can
		perform an algorithm called <span class="monoText">printName()</span>. This
		algorithm is defined in a <span class="term">method</span>. All of the
		methods a the class <span class="monoText">Person</span> contains
		constitutes the <span class="term">behavior</span> stored by instances, or
		<span class="term">objects</span>, of type
		<span class="monoText">Person</span>. In the method's definition, we
		indicate that the method takes no arguments, and returns nothing (<span
			class="monoText"
			>void</span
		>). Recall that <span class="monoText">void</span> is a special type, used
		only with method declarations to indicate the method does not return
		anything.
	</p>
	<p>
		A word of caution: Unlike languages like Python and JavaScript, Java classes
		<span class="underlineText">cannot</span> be modified after the program is
		compiled. This means that if we needed to make a change to a class
		definition, we must recompile the program before execution. This can be
		frustrating when writing smaller pieces of code, but it is particularly
		useful once we start dealing with very large programs.
	</p>
</section>

<section id="keyword_new">
	<p>
		<span class="topic">The <span class="monoText">new</span> Keyword.</span>
		In the previous sections, we often used the keyword
		<span class="monoText">new</span>, and we stated we would discuss it in
		later sections. Now that we've introduced objects, we can begin that
		discussion. An <span class="term">instance</span> of a class is an object of
		the type created by that class. To create an instance, we must use the
		<span class="monoText">new</span> keyword:
	</p>
	<pre class="language-java"><code>
			// create a new type called Person

			class Person {
				String name;
				int age;
				void printName() {
					System.out.println(this.name);
				}
			}

			// create an object of type Person
			
			Person adam = new Person();
		</code></pre>
	<p>
		The type <span class="monoText">Person</span> can be used just like how an
		<span class="monoText">int</span> or <span class="monoText">char</span> are
		used, but do so, we must use the keyword <span class="monoText">new</span>.
	</p>
</section>

<section id="dot_notation">
	<p>
		<span class="topic">Dot Notation</span>
		Like many other object-oriented languages, the states and behaviors of Java
		objects are accessed and set using
		<span class="term">dot notation</span>:
	</p>
	<pre class="language-java"><code>
			// create a new type called Person
			class Person {
				String name;
				int age;
				void printName() {
					System.out.println(this.name);
				}
			}

			// create an object of type Person
			Person adam = new Person();

			// set the instance variables
			adam.age = 40;
			adam.name = "Adam";

			// use the instance variables
			System.out.println(adam.age);

			// call the method
			adam.printName();
		</code></pre>
	<pre class="language-bash"><code>
			40
			Adam
		</code></pre>
</section>

<section id="instance_variables">
	<h3>Instance Variables</h3>
	<p>
		With classes, we can use instance variables that are of
		<span class="italicsText">primitive types</span> or of
		<span class="italicsText">types we've created</span>. This ability allows us
		to create classes of varying complexity:
	</p>
	<pre class="language-java"><code>
			class Dimensions {
				int length;
				int width;
				int height;
			}
			class Room {
				String name;
				Dimensions dimensions;
			}
			Room diningRoom = new Room();
			diningRoom.dimensions = new Dimensions();
			diningRoom.dimensions.length = 50;
			diningRoom.dimensions.width = 20;
			diningRoom.dimensions.height = 40;
		</code></pre>
	<p>
		Why might we write a separate class for dimensions? Well, rooms aren't the
		only things with dimensions. Windows, tables, cabinets, closets, these all
		have dimensions. We don't want to repeat ourselves.
	</p>
	<p>
		<span class="topic"
			>Class Instances and the Value <span class="monoText">null</span>.</span
		>
		If we create a new class instance without initializing its instance
		variables, those instance variables have a default value of
		<span class="monoText">null</span>. This is a common Java feature that
		confuses those new to the language.
	</p>
	<pre class="language-java"><code>
			class Dimensions {
				int width;
				int height;
			}
			class Room {
				String name;
				Dimensions dimensions;
			}
			Room diningRoom = new Room();
			System.out.println(diningRoom.dimensions.width);
		</code></pre>
	<pre class="language-bash"><code>
			null
		</code></pre>
</section>

<section id="java_methods">
	<h3>Methods</h3>
	<p>
		The methods we define in a class have access to the variables defined
		<span class="italicsText">inside</span> that class; i.e., the instance
		variables. Thus:
	</p>
	<pre class="language-java"><code>
		class Dimensions {
			int width;
			int height;

			int area() {
				System.out.println(width);
				return width * height;
			}
		}
		Dimensions example = new Dimensions();
		example.width = 10;
		example.height = 20;
		Dimensions second = new Dimensions();
		second.width = 20;
		second.height = 20;
		System.out.println(example.area());
		System.out.println(second.area());
	</code></pre>
	<pre class="language-bash"><code>
		10
		200
		20
		400
	</code></pre>
</section>

<section id="constructors_and_visibility">
	<h3>Constructors</h3>
	<p>
		Up until this point, we've been purposefully hiding certain parts of the
		Java program:
	</p>
	<pre class="language-java"><code>
		public class foo {
			public static void main(String[] unused) {
				System.println("Hello, world!")
			}
		}
	</code></pre>
	<p>
		We avoided discussing things like <span class="monoText">class</span>,
		<span class="monoText">public</span>, and
		<span class="monoText">static</span> to prevent overcomplicating
		introductory matters. Now that we've seen classes, however, we can address
		these mysterious symbols.
	</p>
	<p>
		In Java, everything we write <span class="underlineText">must</span> be
		inside a class. In the code above, we have class called
		<span class="monoText">foo</span>. The name
		<span class="monoText">foo</span> is the name of the
		<span class="monoText">.java</span> file containing the code. Inside the
		class <span class="monoText">foo</span>, we have a method called
		<span class="monoText">main</span>. The method is called
		<span class="monoText">main</span> because that is where all of our actual,
		executed code is placed. It effectively tells Java, &#8220;Start
		here.&#8221;
	</p>
	<p>
		When we actually define classes, we place them outside the
		<span class="monoText">foo</span> class:
	</p>
	<pre class="language-java"><code>
		class Dimensions {
			public int width;
			public int height;

			public int area() {
				return width * height;
			}
		}

		public class foo {
			public static void main(String[] args[]) {
				Dimensions firstRoom = new Dimensions();
				firstRoom.width = 10;
				firstRoom.height = 20;

				Dimensions secondRoom = new Dimensions();
				secondRoom.width = 8;
				secondRoom.height = 4;

				System.out.println(firstRoom.area());
				System.out.println(secondRoom.area());
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		200
		32
	</code></pre>
	<p>
		What exactly is <span class="monoText">String[]</span> and
		<span class="monoText">args[]</span>? These parameters must be placed inside
		the <span class="monoText">main()</span> method because we they serve as
		placeholder variables for when arguments are passed into the overall program
		itself. Those arguments are placed in an array. We will further develop this
		point in later sections. We will also speak at greater lengths in later
		sections what the symbol <span class="monoText">public</span> means, but for
		now: The <span class="monoText">public</span> keyword tells Java that a
		particular object is visible to all other classes (i.e., all other classes
		can access that particular object, whether its a variable or a method).
		Again, we will elaborate on these points as we continue.
	</p>

	<section id="this_keyword">
		<p>
			<span class="topic">The <span class="monoText">this</span> Keyword.</span>
			To understand the <span class="monoText">this</span> keyword, it's helpful
			to think about what actually happens in memory when we define and
			instantiate classes. When we define a class, our definition statements are
			stored in a place in the JVM called the
			<span class="term">permanent generation area</span>. When we instantiate a
			class, i.e., create a <span class="monoText">new</span> object, the object
			is created in heap memory. Because our program cannot access heap memory,
			<span class="monoText">new ${constructor}$()</span> returns a reference to
			that object. When we call a method, that method is placed in an area of
			the JVM called the <span class="term">method area</span>, or more
			generally, stack memory. Thus, whatever variables are used inside a
			method, such as <span class="monoText">main(string[] args)</span>, are
			stored in the stack. Thus, a reference variable inside
			<span class="monoText">main()</span> lives in the stack, but the variable
			holds a reference to an object stored in the heap.
		</p>
		<p>
			The <span class="monoText">this</span> keyword is a special variable used
			to refer to the instance of the class. Thus, when we define a method, we
			use <span class="monoText">this</span> to refer to the instance's instance
			variables.
		</p>
		<pre class="language-java"><code>
				class Dimensions {
					int width;
					int height;
	
					int area() {
						return this.width * this.height;
					}
				}
			</code></pre>
		<p>
			Unlike many other programming languages, we do not
			<span class="italicsText">have</span> to use the
			<span class="monoText">this</span> keyword. We can, but because the method
			has access to the instance variables, the keyword is not necessary.
		</p>
	</section>

	<p>
		<span class="topic">Default Values for Instance Variables.</span> Note that
		we can set default values for instance variables. This is particularly
		useful when we know an instance variable should have a value, but for
		whatever reason, either we or a user fail to provide that value:
	</p>
	<pre class="language-java"><code>
		class Dimensions {
			public int width = 1;
			public int height = 1;

			public int area() {
				return width * height;
			}
		}

		public class foo {
			public static void main(String[] args[]) {
				Dimensions firstRoom = new Dimensions();
				firstRoom.width = 10;
				firstRoom.height = 20;

				Dimensions secondRoom = new Dimensions();

				System.out.println(firstRoom.area());
				System.out.println(secondRoom.area());
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		200
		1
	</code></pre>
	<p>
		Notice that we did not define instance variables for the object
		<span class="monoText">secondRoom</span>, but an area was returned because
		the instance variables are assigned the value
		<span class="monoText">1</span> by default.
	</p>
	<p>
		<span class="topic"
			>Constructors: What Happens when an Object is Created?</span
		>
		Whenever we create a new instance of a class, we use the keyword
		<span class="monoText">new</span>. Notice, however, that when we create the
		instance, it almost looks like a method call:
	</p>
	<pre class="language-java"><code>
		Dimensions example = new Dimensions();
	</code></pre>
	<p>
		The parentheses are included because calling a method is precisely what
		happens when we create an object. Every new object is created through a
		special method in Java called a <span class="term">constructor</span>. When
		a new class is created, the constructor in the code below is executed:
	</p>
	<pre class="language-java"><code>
		class Course {
			String name;

			// This is a constructor
			Course(String setName) {
				name = setName;
			}
		}
	</code></pre>
	<p>
		A constructor is called
		<span class="underlineText">exactly once</span> &mdash; when the class is
		first created. There is no way to call it again later. It also does not
		explicitly return anything other than the instance of the class.
	</p>
	<p>
		There is something odd about the constructor method: There is no return
		type. The method does not have a return type because it will always return
		just one thing &mdash; an instance of the class. As such, there is no reason
		or need for the constructor to have a return type. Furthermore, the method
		shares the same name as the class. This is a syntax requirement for
		constructors.
	</p>
	<p>
		We use constructors because they allow us to be much more specific when we
		initialize a class. For those familiar with Python, constructors are the
		Java equivalent of <span class="italicsText">default arguments</span>.
		Java's approach to this feature is undoubtedly much worse than Python's, but
		we must make do.
	</p>
	<p>
		If we do not define a constructor, Java will define a constructor for us:
	</p>
	<pre class="language-java"><code>
		class Course {
			String name;
		}

		// The above is the same as:

		class Course {
			String name;
			Course() {

			}
		}
	</code></pre>
	<p>
		The most important point with respect to constructors: The constructor
		<span class="underlineText">must</span> return a new instance of the class.
	</p>
	<pre class="language-java"><code>
		class Course {
			String name;
			Course(String setName) {
				name = setName;
				// But what if name is invalid?
			}
		}
	</code></pre>
	<p>
		Because of this requirement, under no circumstances can a constructor fail.
		This is a point of more than mild annoyance for Java programmers, because it
		effectively means there is no way to perform argument validation within a
		constructor itself other than with errors and exceptions.
	</p>
	<p>
		Constructors, however, provide a useful way to ensure arguments are
		provided:
	</p>
	<pre class="language-java"><code>
		class Person {
			String name;
			double age;
		}

		public class foo {
			public static void main(String[] args[]) {
				Person bill = new Person();
				System.out.println(bill.name);
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		null
	</code></pre>
	<p>
		We get back <span class="monoText">null</span> because we did not initialize
		the instance variable <span class="monoText">name</span>. To ensure this
		does not occur, we can use a constructor:
	</p>
	<pre class="language-java"><code>
		class Person {
			String name;
			double age;

			Person() {
				name = "name_uninitialized";
			}
		}

		public class foo {
			public static void main(String[] args[]) {
				Person bill = new Person();
				System.out.println(bill.name);
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		name_uninitialized
	</code></pre>
	<p>
		Notice that in the examples above, we've had to reference the static
		variable each time for initialization:
	</p>
	<pre class="language-java"><code>
		class Person {
			String name;
			double age;

			Person() {
				name = "name_uninitialized";
			}
		}

		public class foo {
			public static void main(String[] args[]) {
				Person bill = new Person();
				bill.name = "Bill";
				System.out.println(bill.name);
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		Bill
	</code></pre>
	<p>
		It would be much easier if we could just pass that name as an argument when
		we first create the instance. Something that looks like this:
	</p>
	<pre class="language-java"><code>
		Person bill = new Person("Billy");
	</code></pre>
	<p>To do so, we must use a constructor that takes a name as an argument:</p>
	<pre class="language-java"><code>
		class Person {
			String name;
			double age;

			Person(String setName) {
				name = setName;
			}
		}

		public class foo {
			public static void main(String[] args[]) {
				Person bill = new Person("Bill");
				System.out.println(bill.name);
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		Bill
	</code></pre>
	<p>
		Great, it worked. As we can see, if we want to create new instances with
		their instance variables initialized by passing arguments into the method,
		we can do so with a constructor.
	</p>
	<p>
		Note that if we do not pass an argument into
		<span class="monoText">Person()</span> when we create a new instance, we
		will see an error message:
	</p>
	<pre class="language-java"><code>
		class Person {
			String name;
			double age;

			Person(String setName) {
				name = setName;
			}
		}

		public class foo {
			public static void main(String[] args[]) {
				Person bill = new Person("Bill");
				System.out.println(bill.name);
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		foo.java:10: error: constructor Person in class Person cannot be applied to given types;
				Person bill = new Person();
								^
		required: String
		found:    no arguments
		reason: actual and formal argument lists differ in length
		1 error
	</code></pre>
	<p>
		This is a very helpful error message, because it tells us where we went
		wrong &mdash; we forget to pass a necessary argument into
		<span class="monoText">Person()</span>. This feature also shows another
		aspect of constructors: As we soon as we define a constructor, we
		automatically lose the default constructor.
	</p>
	<p>
		Since our <span class="monoText">Person</span> class also has an instance
		variable <span class="monoText">age</span>, we should probably also require
		an <span class="monoText">age</span> argument:
	</p>
	<pre class="language-java"><code>
		class Person {
			String name;
			double age;

			Person(String setName, double setAge) {
				name = setName;
				age = setAge;
			}
		}

		public class foo {
			public static void main(String[] args[]) {
				Person bill = new Person("Bill", 32.5);

				System.out.println(bill.name);
				System.out.println(bill.age);
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		Bill
		32.5
	</code></pre>
	<p>
		<span class="topic">Default Values for Instance Variables.</span> Suppose we
		want to allow creating a new instance of
		<span class="monoText">Person</span> even if an
		<span class="monoText">age</span> argument is not provided. To do so, we can
		simply write another constructor without the
		<span class="monoText">age</span> parameter:
	</p>
	<pre class="language-java"><code>
		class Person {
			String name;
			double age;

			Person(String setName, double setAge) {
				name = setName;
				age = setAge;
			}
			Person(String setName) {
				name = setName;
				age = 0.0;
			}
		}

		public class foo {
			public static void main(String[] args[]) {
				Person bill = new Person("Bill");

				System.out.println(bill.name);
				System.out.println(bill.age);
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		Bill
		0.0
	</code></pre>
	<p>We can shorten the code above by simply writing:</p>
	<pre class="language-java"><code>
		class Person {
			String name;
			double age;

			Person(String setName, double setAge) {
				name = setName;
				age = setAge;
			}
			Person(String setName) {
				this(setName, 0.0);
			}
		}

		public class foo {
			public static void main(String[] args[]) {
				Person bill = new Person("Bill");

				System.out.println(bill.name);
				System.out.println(bill.age);
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		Bill
		32.0
	</code></pre>
</section>

<section id="getters_and_setters">
	<h2>Data Hiding</h2>
	<p>
		Let's continue our study of objects by further refining what we've learned
		so far. Here, we will address the notions of
		<span class="italicsText">access modifiers</span>,
		<span class="italicsText">getters</span>, and
		<span class="italicsText">setters</span>. These idioms are ubiquitous in
		object-oriented programming because they embody a general principle of
		object-oriented design: Hide data whenever possible.
	</p>
	<p>
		The idea behind hiding data is closely related to encapsulation. With
		encapsulation, we bundle related properties and methods together. With data
		hiding, we hide the implementations of classes, methods, and properties as
		much as possible. Why? Because it allows us to truly treat modules of code
		as blackboxes. We want to use modules without knowing anything about how the
		modules work. Think about all of the different Java library methods we use.
		We use the <span class="monoText">.length</span> property without even
		batting an eye. We never stop to worry about what it outputs or how it
		works. We just use it. And when stop having these concerns, we program on
		much higher levels of abstraction. We can use
		<span class="monoText">Random()</span>, Java's random number generator, to
		create a complex poker game program. We use Java's
		<span class="monoText">Scanner()</span> to construct large programs that
		read inputs. All of this is done without ever really thinking about what
		these things do.
	</p>
	<p>
		This is only possible if the code we write hides its implementations as much
		as possible. And to ensure the details are tucked away and safely hidden, we
		use <span class="term">access modifiers</span>.
	</p>
	<section id="access_modifiers_intro">
		<h3>Access Modifiers</h3>
		<p>Consider the following code:</p>
		<pre class="language-java"><code>
			class Person {
				public String name;
				private int age;

				private void printName() {
					System.out.println(name);
				}
				
				public int getAge() {
					return age;
				}
			}
		</code></pre>
		<p>
			There are a few symbols in the code above that we have been actively
			avoiding &mdash; <span class="monoText">public</span> and
			<span class="monoText">private</span>. What are these symbols and what do
			they mean?
		</p>
		<p>
			These symbols are called <span class="term">access modifiers</span>. They
			are provided by Java as a way to control
			<span class="italicsText">access</span> to a class's instance variables
			and methods.
		</p>
		<p>
			Access modifiers are provided because is often the case that (a) we do
			want certain information hidden, or (b) we do not want the information
			accessed unless the seeker undergoes a particular process. Accordingly,
			the two main kinds of access modifiers are (i)
			<span class="italicsText">variable access modifiers</span> and (ii)
			<span class="italicsText">method access modifiers</span>. In Java, access
			modifiers <span class="underlineText">always</span> go to the left of the
			type as a matter of convention.
		</p>
	</section>

	<section id="public_keyword">
		<p>
			<span class="topic"><span class="monoText">public.</span></span> The
			symbol <span class="monoText">public</span>, when used as a variable
			access modifier, tells Java that the relevant variable can be modified by
			anyone. In the context of our <span class="monoText">Person</span> class,
			we wrote: <span class="monoText">public String name</span>. This
			essentially tells Java, &#8220;Anything anyone can modify the instance
			variable <span class="monoText">name</span> using dot notation.&#8221;
		</p>
	</section>

	<section id="private_keyword">
		<p>
			<span class="topic"><span class="monoText">private.</span></span> In
			contrast, when the symbol <span class="monoText">private</span> is used as
			a variable access modifier, then the relevant variable can be accessed and
			modified <span class="underlineText">only if</span> the access or
			modification is done with a method defined on that class. Thus, when we
			wrote <span class="monoText">private int age</span>, we told Java:
			&#8220;The instance variable <span class="monoText">age</span> is
			<span class="monoText">private</span> &mdash; stop anyone that tries to
			access or modify <span class="monoText">age</span> with anything other
			than a <span class="monoText">Person</span> method.&#8221;
		</p>
		<p>
			Thus, if we or another user want to modify the instance variable
			<span class="monoText">age</span>, we must include a method in
			<span class="monoText">person</span> that allows accessing and modifying
			<span class="monoText">age.</span> Accordingly, the code below will not
			work:
		</p>
		<pre class="language-java"><code>
			class Person {
				// anyone and anything can modify name
				public String name;

				// age can only be read and written with this class's methods
				private int age;
			}

			public class foo {
				public static void main(String[] unused) {
					Person lukas = new Person();
					lukas.name = "Lukas";

					// this returns a compilation error
					System.out.println(lukas.age);
				}
			}
		</code></pre>
		<pre class="language-bash"><code>
			foo.java:9: error: age has private access in Person
					System.out.println(lukas.age);
													^
			1 error
		</code></pre>
		<p>
			Believe it or not, it is rare for Java programs to have public variables.
			We will see why in later sections. Thus, in summary:
		</p>
		<figure class="table">
			<table class="api">
				<thead>
					<th colspan="2"></th>
				</thead>
				<tbody>
					<tr>
						<td><span class="monoText boldText">public</span></td>
						<td>Every person can read and write the variable.</td>
					</tr>
					<tr>
						<td><span class="monoText boldText">private</span></td>
						<td>
							A person can read and write the variable
							<span class="underlineText">only if</span> the person uses a
							method defined for the variable's class.
						</td>
					</tr>
				</tbody>
			</table>
		</figure>
	</section>

	<section id="method_access_modifiers">
		<p>
			<span class="topic">Method Access Modifiers.</span> Access modifiers work
			the same way with methods. The difference: Rather than reading and
			writing, the privilege is whether we can call the method. A
			<span class="term">public method</span> is one that we can call at any
			time. However, a <span class="term">private method</span> cannot be called
			unless another method in the class is used to call it. In other words, we
			can call a private method <span class="underlineText">only if</span> we
			use another method in the class. Thus, if we are in another method in the
			class marked as <span class="monoText">public</span> that allows calling
			the <span class="monoText">private</span> method, then we can call the
			<span class="monoText">private</span> method.
		</p>
	</section>

	<section id="getting_around_private">
		<p>
			<span class="topic"
				>Getting Around <span class="monoText">private</span> Access
				Modifiers.</span
			>
			Suppose we have the following code:
		</p>
		<pre class="language-java"><code>
			class Patient {
				private String name;
				private int age;
			}

			public class foo {
				public static void main(String[] unused) {
					Patient jekyll_hyde = new Patient();
				}
			}
		</code></pre>
		<p>
			We want to keep the two variables, <span class="monoText">name</span> and
			<span class="monoText">age</span>, private. However, we also want to be
			able to quickly set the <span class="monoText">name</span> and
			<span class="monoText">age</span> when we create the new instance of
			<span class="monoText">Patient</span>,
			<span class="monoText">jekyll_hyde</span>. One way to do so is to use a
			constructor:
		</p>
		<pre class="language-java"><code>
			class Patient {
				private String name;
				private int age;

				Patient(String setName, int setAge) {
					name = setName;
					age = setAge;
				}
			}

			public class foo {
				public static void main(String[] unused) {
					Patient jekyll_hyde = new Patient("Jekyll Hyde", 50);
				}
			}
		</code></pre>
		<p>
			The code above compiles successfully. However, the
			<span class="monoText">name</span> and
			<span class="monoText">age</span> are still hidden because they are
			private. Suppose we want to be able to verify
			<span class="monoText">jekyll_hyde</span>'s name. One way to do so is to
			use a public method:
		</p>
		<pre class="language-java"><code>
			class Patient {
				private String name;
				private int age;

				Patient(String setName, int setAge) {
					name = setName;
					age = setAge;
				}

				public void printPatientInfo() {
					System.out.println("Patient name: " + name);
					System.out.println("Patient age: " + age);
				}
			}

			public class foo {
				public static void main(String[] unused) {
					Patient jekyll_hyde = new Patient("Jekyll Hyde", 50);
					jekyll_hyde.printPatientInfo();
				}
			}
		</code></pre>
		<pre class="language-bash"><code>
			Patient name: Jekyll Hyde
			Patient age: 50
		</code></pre>
		<p>
			Because we can work around private access variables with methods, we can
			obtain the values bound to variable access variables with public methods:
		</p>
		<pre class="language-java"><code>
			class Patient {
				private String name;
				private int age;

				Patient(String setName, int setAge) {
					name = setName;
					age = setAge;
				}

				public String getName() {
					return name;
				}
			}

			public class foo {
				public static void main(String[] unused) {
					Patient jekyll_hyde = new Patient("Jekyll Hyde", 50);
					String jekyll_hyde_name = jekyll_hyde.getName();
					System.out.println(jekyll_hyde_name);
				}
			}
		</code></pre>
		<pre class="language-bash"><code>
			Jekyll Hyde
		</code></pre>
		<p>
			We might note this seems like a lot of work just to obtain the name. Why
			go through the trouble of writing a method just for obtaining the name
			when we can just use dot notation? We go through this trouble to ensure we
			keep two actions separate as possible:
			<span class="italicsText">setting</span> an instance variable, and
			<span class="italicsText">getting</span> an instance variable. By marking
			an instance variable <span class="monoText">private</span>, we place a
			hurdle on attempts to modify the value bound to that instance variable.
		</p>
		<p>
			Why place a hurdle? Because we generally do not want instance variables to
			change as the program runs. The issue is not so much with a user modifying
			the variable directly as it is writing code that will affect, or
			indirectly modify, the value bound to the instance variable. Indirect and
			unintended modifications can easily lead to bugs that are difficult to
			pinpoint.
		</p>
		<p>
			If, for whatever reason, we want to have the ability to modify the name
			<span class="italicsText">after</span> its been set, we can write another
			public method:
		</p>
		<pre class="language-java"><code>
			class Patient {
				private String name;
				private int age;

				Patient(String setName, int setAge) {
					name = setName;
					age = setAge;
				}

				public String getName() {
					return name;
				}

				public void setName(String setName) {
					name = setName;
				}
			}

			public class foo {
				public static void main(String[] unused) {
					Patient jekyll_hyde = new Patient("Jekyll Hyde", 50);
					System.out.println(jekyll_hyde.getName());

					jekyll_hyde.setName("Harvey Dent");
					System.out.println(jekyll_hyde.getName());
				}
			}
		</code></pre>
		<pre class="language-bash"><code>
			Jekyll Hyde
			Harvey Dent
		</code></pre>
		<p>
			The distinction between setting an instance variable and getting a value
			bound to an instance variable introduces the distinction between
			<span class="term">getters</span> and <span class="term">setters</span>.
		</p>
	</section>

	<section id="qualifying_setters">
		<p>
			<span class="topic">Qualfying Setters.</span> If we provide methods that
			allow modifying initialized variable instances, we might want to further
			restrict the modification. We can do so inside the setter. For example,
			unless the patient is Benjamin Button, we might want to ensure negative
			numbers are not passed into an <span class="monoText">age</span> setting
			method:
		</p>
		<pre class="language-java"><code>
			class Patient {
				private String name;
				private int age;

				Patient(String setName, int setAge) {
					name = setName;
					age = setAge;
				}

				public String getName() {
					return name;
				}
				public int getAge() {
					return age;
				}

				public void setName(String setName) {
					name = setName;
				}

				public void setAge(int setAge) {
					if (setAge > 0) {
						age = setAge;
					}
				}
			}

			public class foo {
				public static void main(String[] unused) {
					Patient jekyll_hyde = new Patient("Jekyll Hyde", 50);
					jekyll_hyde.setAge(-85);
					System.out.println(jekyll_hyde.getAge());
					jekyll_hyde.setAge(55);
					System.out.println(jekyll_hyde.getAge());
				}
			}
		</code></pre>
		<pre class="language-bash"><code>
			50
			55
		</code></pre>
		<p>
			Notice <span class="monoText">setAge(-85)</span> did not actually set the
			age to <span class="monoText">-85</span>. We qualified the setter with a
			conditional: Java, set the age only if the provided argument is greater
			than <span class="monoText">0</span>.
		</p>
		<p>
			Getters and setters are the way we get around hurdles
			<span class="monoText">public</span> and
			<span class="monoText">private</span>. Good style in Java: always use
			<span class="monoText">private</span> for instance variables, and use
			<span class="monoText">public</span> methods to access the instance
			variables. <span class="italicsText">Getters</span> are the methods we use
			to read, or retrieve, values bound to instance variables, and
			<span class="italicsText">setters</span> are the methods we use to bind
			new values to instance variables.
		</p>
		<p>
			Getters and setters allow us to create
			<span class="italicsText">reactive objects</span> &mdash; objects that
			react to changes made to its instance variables. They also allow us to
			create read- and write-only variables:
		</p>
		<pre class="language-java"><code>
			class Patient {
				private String name;
				private String firstName;
				private String lastName;
			
				public void setName(String setName) {
					String[] nameParts = setName.split(" ");
					name = setName;
					firstName = nameParts[0];
					lastName = nameParts[1];
				}
			
				public String getName() {
					return name;
				}
				public String getFirstName() {
					return firstName;
				}
				public String getLastName() {
					return lastName;
				}
			
			}
			
			public class foo {
				public static void main(String[] unused) {
					Patient jekyll_hyde = new Patient();
					jekyll_hyde.setName("Jekyll Hyde");
					System.out.println(jekyll_hyde.getFirstName());
					System.out.println(jekyll_hyde.getLastName());
					System.out.println(jekyll_hyde.getName());
				}
			}
		</code></pre>
		<pre class="language-bash"><code>
			Jekyll
			Hyde
			Jekyll Hyde
		</code></pre>
		<p>
			The code above, of course, is flawed (names do not just consist of first
			and last; there are middle names, suffixes, ordinals, and eponyms).
		</p>
	</section>

	<section id="static_keyword">
		<p>
			<span class="topic"
				>The <span class="monoText">static</span> Keyword.</span
			>
			When we prepend the <span class="monoText">static</span> symbol to an
			instance variable or method, we tell Java: &#8220;This variable or method
			belongs to the <span class="italicsText">class</span>, not to a specific
			instance of this class.&#8221; For example, we might see the following:
		</p>
		<pre class="language-java"><code>
			class Philosopher {
				private String name;
				private String field_of_study;
				private static int count = 0;
				Philosopher(String setName, String set_field_of_study) {
					name = setName;
					field_of_study = set_field_of_study;
				}
				public void printNameAndField() {
					System.out.println("Name: " + name);
					System.out.println("Field: " + field_of_study);
				}
			}
			
			public class foo {
				public static void main(String[] unused) {
					Philosopher kant = new Philosopher("Immanuel Kant", "metaphysics");
					kant.printNameAndField();
				}
			}
		</code></pre>
		<pre class="language-bash"><code>
			Name: Immanuel Kant
			Field: metaphysics
		</code></pre>
		<p>
			We've seen the symbol <span class="monoText">static</span> numerous times.
			This symbol is similar to <span class="monoText">public</span> and
			<span class="monoText">private</span> in that it acts as an access
			modifier. The difference: When attach the
			<span class="monoText">static</span> modifier to a variable or method,
			there is one, and only one, &#8220;copy&#8221; of that variable or method.
			That copy exists only inside the class itself, not with any instance of
			the class.
		</p>
		<p>
			There is a specific order for where to include the symbol
			<span class="monoText">static</span>. Access modifiers like
			<span class="monoText">private</span> and
			<span class="monoText">public</span> are placed leftmost, then the
			modifier <span class="monoText">static</span>, then the
			<span class="monoText">type</span>.
		</p>
	</section>

	<section id="static_methods">
		<p>
			<span class="topic">Static Methods.</span> One of the most common uses for
			<span class="monoText">static</span> is with
			<span class="italicsText">static methods</span>. For those familiar with
			JavaScript, we might have noticed tutorials referring to JavaScript's
			primitive math object as containing
			<span class="italicsText">static properties</span> and
			<span class="italicsText">static methods</span>. These correspond to
			Java's static variables and static methods.
		</p>
		<p>
			A <span class="term">static method</span> is a method that can be called
			<span class="underlineText">without</span> an instance of that class. For
			example, in the code below, we have a static variable called
			<span class="monoText">count</span>, and at every new instance of the
			class <span class="monoText">Philosopher</span>, we increment
			<span class="monoText">count</span>. Then, we have a static method called
			<span class="monoText">printPhilosopherCount()</span> that prints the
			current value bound to <span class="monoText">count</span>.
		</p>
		<pre class="language-java"><code>
			class Philosopher {
				private String name;
				private String field_of_study;
				private static int count = 0;
				Philosopher(String setName, String set_field_of_study) {
					name = setName;
					field_of_study = set_field_of_study;
					count++;
				}
				public void printNameAndField() {
					System.out.println("Name: " + name);
					System.out.println("Field: " + field_of_study);
				}
			}
			
			public class foo {
				public static void main(String[] unused) {
					Philosopher kant = new Philosopher("Immanuel Kant", "metaphysics");
					kant.printNameAndField();
					Philosopher.printPhilosopherCount();
				}
			}
		</code></pre>
		<pre class="language-bash"><code>
			Name: Immanuel Kant
			Field: metaphysics
			1
		</code></pre>
		<p>
			Notice that the static method
			<span class="monoText">printPhilosopherCount()</span> executed without
			referencing a particular instance of the class
			<span class="monoText">Philosopher</span>. This is because it is a method
			that belongs only to the class <span class="monoText">Philosopher</span>,
			and as such, does not depend on an instance to execute. If we create
			multiple instances:
		</p>
		<pre class="language-java"><code>
			class Philosopher {
				private String name;
				private String field_of_study;
				private static int count = 0;
				Philosopher(String setName, String set_field_of_study) {
					name = setName;
					field_of_study = set_field_of_study;
					count++;
				}
				public static void printPhilosopherCount() {
					System.out.println(count);
				}
				public void printNameAndField() {
					System.out.println("Name: " + name);
					System.out.println("Field: " + field_of_study);
				}
			}
			
			public class foo {
				public static void main(String[] unused) {
					Philosopher kant = new Philosopher("Immanuel Kant", "metaphysics");
					Philosopher godel = new Philosopher("Kurt Godel", "logic");
					Philosopher locke = new Philosopher("John Locke", "political theory");
					Philosopher kierkegaard = new Philosopher("Soren Kierkegaard", "existentialism");
					Philosopher hart = new Philosopher("Herbert Hart", "jurisprudence");
					Philosopher.printPhilosopherCount();
				}
			}
		</code></pre>
		<pre class="language-bash"><code>
			5
		</code></pre>
		<p>And if we create no instances:</p>
		<pre class="language-java"><code>
			class Philosopher {
				private String name;
				private String field_of_study;
				private static int count = 0;
				Philosopher(String setName, String set_field_of_study) {
					name = setName;
					field_of_study = set_field_of_study;
					count++;
				}
				public static void printPhilosopherCount() {
					System.out.println(count);
				}
				public void printNameAndField() {
					System.out.println("Name: " + name);
					System.out.println("Field: " + field_of_study);
				}
			}
			
			public class foo {
				public static void main(String[] unused) {
					Philosopher.printPhilosopherCount();
				}
			}
		</code></pre>
		<pre class="language-bash"><code>
			0
		</code></pre>

		<p>
			The static method is a method that can be called without any instance of
			its class. This ability implies a limitation: Because static methods work
			outside of instances, they
			<span class="underlineText">cannot access</span> non-static instance
			variables. This in turn means we cannot use the keyword
			<span class="monoText">this</span>.
		</p>
		<p>
			Static methods are found throughout not just Java, but object-oriented
			languages as a whole. In Java, there are numerous
			<span class="term">packages</span> (Java's equivalent for
			<span class="italicsText">libraries</span> in C and
			<span class="italicsText">modules</span> in Python) containing static
			methods. One such package is the
			<span class="monoText">Math</span> package, which contains static methds
			like <span class="monoText">Math.sqrt(${n}$)</span>, where ${n}$ is the
			radicand.
		</p>
	</section>

	<section id="static_variables">
		<p>
			<span class="topic">Static Variables.</span> Like, but somewhat different,
			to static methods, <span class="term">static variables</span> are
			variables shared by <span class="italicsText">all</span> instances of a
			given class. Thus, in our example
			<span class="monoText">Philosopher</span> class, the variable
			<span class="monoText">count</span> is shared by every instance of
			<span class="monoText">Philosopher</span>.
		</p>
		<p>
			As aforementioned, languages like JavaScript refer to these as
			<span class="italicsText">static properties</span>. For example, the value
			${\sqrt{2}}$ is so commonly used in computation that we might want to
			provide it as a static variable. Indeed, Java has packages that provide
			such quick access. However, static variables are by and large extremely
			uncommon in Java programming. Generally, a task that requires a static
			variable can more than likely be accomplished through another means. One
			use for a static variable is something like a
			<span class="monoText">count</span>, intended to track how many instances
			of a given class there are.
		</p>
		<p>
			<span class="topic"
				>Not Marking a Method or Variable
				<span class="monoText">static.</span></span
			>
			If we do not indicate that a variable of method is
			<span class="monoText">static</span>, then by default, every instance of
			the class (a) has a copy of that variable, and (b) the method will only
			work on a particular instance of that class.
		</p>
	</section>

	<section id="use_cases_static_variables">
		<p>
			<span class="topic">Use Cases for Static Variables.</span> The most common
			use case for static variables is creating constants. In Java programs,
			this use case is often identifiable when the
			<span class="monoText">static</span> symbol is used alongside the
			<span class="monoText">final</span> symbol:
		</p>
		<pre class="language-java"><code>
			class Physics {
				public static final float ACCELERATION_GRAVITY = 9.807;
			}
		</code></pre>
		<p>
			The symbol <span class="monoText">final</span> tells Java: Under
			absolutely no circumstances can the variable
			<span class="monoText">ACCELERATION_GRAVITY</span> be modified. Any
			attempt, direct or indirect, to modify a final variable will return an
			error.
		</p>
		<p>
			Thus, the variable declaration above essentially communicates: (1) This is
			a public variable, so you can access, but because it is a final variable,
			you cannot modify. (2) This is a static variable, so there is only one
			copy, and it stays here in <span class="monoText">Physics</span>. If you
			want to use it, you will have to call
			<span class="monoText">Physics</span> first.
		</p>
		<p>
			Notice further that in Java, final variables (i.e., constants) are written
			in snake casing (underscores indicating spaces).
		</p>
	</section>
</section>

<section id="inheritance_in_java">
	<h2>Inheritance</h2>
	<p>
		In this section, we study the concept of
		<span class="italicsText">inheritance</span>. Inheritance provides a means
		of accomplishing two useful outcomes: (1) avoiding duplicated code, and (2)
		expressing real world relationships between data.
	</p>
	<p>Consider the following code:</p>
	<pre class="language-java"><code>
		class MythChar { };

		public class foo {
			public static void main(String[] unused) {
				MythChar hera = new MythChar(); 
				System.out.println(hera.toString());
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		MythChar@7344699f
	</code></pre>
	<p>
		There was no error &mdash; it compiled and ran correctly, even if we
		neglected to explicitly define the body of the class
		<span class="monoText">MythChar</span>. No error is returned because of
		Java's principle of <span class="term">inheritance</span> &mdash; every
		object, or instance, inherits both
		<span class="italicsText">state</span> and
		<span class="italicsText">behavior</span> from another class. Inheritance
		exists because in the real world, data follows hierarchy &mdash; Every koala
		is a marsupial, every marsupial is a mammal, every mammal is an animal, etc.
	</p>
	<p>So, for example:</p>
	<pre class="language-java"><code>
		class MythChar {
			protected String name;
			protected String type;
		
			public void printMetadata() {
				System.out.println("This is an object of type " + type + " named " + name);
			}
		}
		
		class GreekMythChar extends MythChar {
			GreekMythChar(String setName) {
				name = setName;
				type = "GreekMythChar";
			}
		}
		
		
		public class foo {
			public static void main(String[] unused) {
				GreekMythChar hera = new GreekMythChar("Hera"); 
				hera.printMetadata();
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		This is an object of type GreekMythChar named Hera
	</code></pre>
	<p>
		There are some new symbols in the code above, and we will address them in a
		moment. For now, observe that (1) every new instance of
		<span class="monoText">MythChar</span> has an instance variable called
		<span class="monoText">name</span> and another instance variable called
		<span class="monoText">type</span>; (2) every new instance of
		<span class="monoText">MythChar</span> has an instance method called
		<span class="monoText">printMetadata()</span>, which prints a string
		communicating the instance's <span class="monoText">name</span> and
		<span class="monoText">type</span>.
	</p>
	<p>
		Then, we have another class definition. This class is called
		<span class="monoText">GreekMythChar</span>, followed by
		<span class="monoText">extends MythChar</span>. Then, we have a constructor.
		But, there is something unusual about this constructor: We do not have any
		instance variables before the constructor, but we are initializing variables
		inside the constructor. How is this possible? Again, inheritance.
	</p>
	<p>
		By including <span class="monoText">extends</span> to the class definition
		for <span class="monoText">GreekMythChar</span>, we are effectively telling
		Java that <span class="monoText">GreekMythChar</span> is a subclass of
		<span class="monoText">MythChar</span>. Because
		<span class="monoText">GreekMythChar</span> is a subclass of
		<span class="monoText">MythChar</span>, all the instance and class variables
		and methods contained in <span class="monoText">MythChar</span> are
		available for <span class="monoText">GreekMythChar</span>. They are
		<span class="italicsText">inherited</span> from
		<span class="monoText">MythChar</span>.
	</p>
	<p>
		Notice that <span class="monoText">GreekMythChar</span> has a special
		relationship to <span class="monoText">MythChar</span> &mdash; it is a
		subset of mythological figures. We might have another subclass called
		<span class="monoText">NorseMythChar</span> and another one called
		<span class="monoText">CelticMythChar</span>. These two classes are
		collectively referred to as the <span class="italicsText">children</span> of
		<span class="monoText">MythChar</span>, and
		<span class="monoText">MythChar</span> is said to be the
		<span class="italicsText">parent</span> of the subclasses. The keyword we
		use for establishing these relationships is
		<span class="monoText">extends</span>.
	</p>
	<p>
		Java allows multiple inheritance. All of the classes shifted towards the
		left inherit all of the instance and class variables and methods of the
		classes to the right. All of the classes that a subclass inherits from are
		collectively called the subclass's
		<span class="italicsText">ancestors</span>, and all of the classes that a
		parent class provides behaviors to as the parent class's
		<span class="italicsText">descendants</span>:
	</p>
	<pre class="language-java"><code>
		public class MythChar {}
			public class GreekMythChar extends MythChar {}
				public class Olympian extends GreekMythChar {}
				public class Titan extends GreekMythChar {}
					public class Titanide extends Titan {}
					public class Titaness extends Titan {}
				public class Gigantes extends GreekMythChar {}
	</code></pre>
	<p>
		In Java, a class can only extend
		<span class="underlineText">one</span> parent class. In other words, we
		cannot have a subclass with two parent classes. We will revisit this concept
		and limitation again in later sections.
	</p>
	<p>
		A word of warning: If we ever find ourselves writing deeply nested classes
		like the above, we must ask ourselves whether inheritance is the proper
		approach to the problem, or whether the distinctions between parent and
		child are meaningful. Particularly tall inheritance trees can very easily
		open the gates to <span class="italicsText">inheritance hell</span> &mdash;
		the point where so many subclasses are created that the programmer loses
		track of an object's behavior and the states it stores.
	</p>
	<p>
		<span class="topic"
			>What Does <span class="monoText">protected</span> Mean?</span
		>
		One new access modifier we saw from the example above is
		<span class="monoText">protected</span>. Recall that a public variable can
		be read or written by anyone, and a private variable can only be read or
		written using methods defined by the private variable's class. A
		<span class="italicsText">protected variable</span> is a variable that can
		only be read or written using methods that are (a) defined by the protected
		variable's class, or (b) defined by a descendent of the protected variable's
		class.
	</p>
</section>

<section id="polymorphism">
	<h2>Polymorphism</h2>
	<p>
		In the previous sections, we saw how objects provide us a way to package
		state and behavior, and organize it into a hierarchy. A fair question to
		ask: Why organize objects into hierarchy? Because humans generally prefer
		viewing and understanding things in terms of sets and subsets. Humans are in
		the category of mammals, some humans are in the category of doctors, others
		mechanics, carpenters, stay-at-home parents, students, teachers, etc. Within
		doctors there are cardiologists, pathologists, neurosurgeons, and more.
		Within students there are those that study physics and those that study
		theology. Organizing objects hierarchically is an attempt to mimic this
		preference.
	</p>
	<p>
		In the real world, when a set contains multiple subsets, there is usually
		something members of the subsets have in common that warrants their
		membership in the superset other than being a subset. For example, an LLC
		and a C Corporation are all subsets of business entities, but both entities
		are citizens of a particular jurisdiction (e.g., a C Corporation
		incorporated in Delaware is a Delaware citizen, while an LLC formed in New
		York is a New York citizen). Similarly, an LLC and a general partnership are
		business entities, and while they differ in how they are formed, they are
		generally taxed in a similar manner (passthrough entities).
	</p>
	<p>
		Because of these shared characteristics, we often want a member of one
		subset to be able to act as if they were members of another subset. A
		California-born student at the University of Washington at Tacoma should be
		able to vote in California once they become a resident of the state. That
		particular student is a member of many subclasses &mdash; University of
		Washington at Tacoma students; California-born persons; American citizens;
		Washington citizens, etc.
	</p>
	<p>
		However, recall that in Java, classes are parthenogenetic &mdash; a subclass
		can only extend one parent class; no subclass can ever have more than one
		parent. How then do we accomplish the preceding phenomenon, where objects of
		one class might <span class="italicsText">behave</span> like the objects of
		another class? Through <span class="italicsText">polymorphism</span>.
	</p>
	<p>
		<span class="topic">The Java Object.</span> To understand polymorphism, we
		need to clarify a common point of confusion. As we've stated before,
		everything in Java must be wrapped in a class. Now, because classes can only
		extend one parent class, there necessarily must be something at the very
		root of it all. It cannot be turtles all the way down. Indeed, there is a
		root &mdash; the Java Object. Every class in Java inherits from the Java
		Object. We will discuss in more detail what this Object is in later
		sections, but for now, the key point is: When we use the term Object with a
		capital "O," we are referring to the Java Object, rather than object we have
		created.
	</p>
	<pre class="language-java"><code>
		public class Chemicals { }

		// The class declaration above is equivalent to:
		
		public class Chemicals extends Object { }

		// We do not have to write this^ line
		// Java assumes this is the case when we do not include an extends symbol
	</code></pre>
	<p>
		This means that every state and method of a newly declared class inherits
		from Object. Does it inherit all of Object's states and methods? No. The
		class inherits a small number of the states and methods. Some of the most
		important methods inherited from Object are the following:
	</p>
	<figure class="table">
		<table class="loop_table">
			<thead>
				<th>Object Method</th>
				<th>Description</th>
			</thead>
			<tbody>
				<tr>
					<td><span class="monoText">String toString()</span></td>
					<td>
						Return a <span class="monoText">String</span> representing the
						instance. This is used primarily for debugging.
					</td>
				</tr>
				<tr>
					<td>
						<span class="monoText">boolean equals(object_1 object_2)</span>
					</td>
					<td>
						Return a <span class="monoText">boolean</span> indicating whether
						<span class="monoText">object_1</span> is the same as
						<span class="monoText">object_2</span>.
					</td>
				</tr>
				<tr>
					<td><span class="monoText">int hashCode()</span></td>
					<td>
						Return an <span class="monoText">int</span> uniquely representing an
						object's contents (more on this later).
					</td>
				</tr>
			</tbody>
		</table>
	</figure>
	<p>
		The methods inherited from <span class="monoText">Object</span> are very
		rarely used. This is because classes can
		<span class="italicsText">override</span> methods inherited from their
		ancestors, using their own instead.
	</p>
	<pre class="language-java"><code>
		public class bar {
			public static void main(String[] args) {
				Apache geronimo = new Apache();
				geronimo.name = "Geronimo";
				System.out.println(geronimo.toString());
			}
		}

		class NativeAmerican {}

		class SouthwestNative extends NativeAmerican {
			public String name;
		}

		class Apache extends SouthwestNative {
			public String toString() {
				return name + " is an Apache.";
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		Geronimo is an Apache.
	</code></pre>
	<p>
		Notice that we created an instance of the class
		<span class="monoText">Apache</span>, and initialized its instance variable
		<span class="monoText">name</span> to
		<span class="monoText">"Geronimo"</span>. How are we allowed to do this when
		there is no such instance variable in the class
		<span class="monoText">Apache</span>? Because
		<span class="monoText">Apache</span> inherits everything from its ancestors.
		The class <span class="monoText">SouthwestNative</span> is an ancestor of
		<span class="monoText">Apache</span>, and as such, all instances of
		<span class="monoText">Apache</span> have an instance variable called
		<span class="monoText">name</span> that can be initialized.
	</p>
	<p>
		The same goes for the <span class="monoText">toString()</span> method. When
		we called that method with the instance
		<span class="monoText">geronimo</span>, Java went and checked if the
		<span class="monoText">Apache</span> class contained such a method and
		verified that it is <span class="monoText">public</span>. If no such method
		existed, then Java would check the parent,
		<span class="monoText">SouthwestNative</span>; otherwise
		<span class="monoText">NativeAmerican</span>; otherwise
		<span class="monoText">Object</span>.
	</p>
	<p>
		What this means then is that if we included another
		<span class="monoText">toString()</span> method definition in a parent class
		(while keeping the <span class="monoText">toString()</span> method inside
		the subclass, Java will not go any further to execute the
		<span class="monoText">toString()</span> method in the parent class. Java
		stops and runs either (a) the method's definition in the instance's class
		itself, or (b) the nearest ancestor defining the method. In other words, it
		stops the moment it encounters a
		<span class="monoText">toString()</span> method it can use.
	</p>
	<p>
		On the other hand, this also means that a parent class cannot access
		variables in its child classes. Suppose for example we had the following:
	</p>
	<pre class="language-java"><code>
		public class bar {
			public static void main(String[] args) {
				NativeAmerican geronimo = new NativeAmerican();
				geronimo.name = "Geronimo";
				System.out.println(geronimo.bisonHunting);
			}
		}
		class NativeAmerican {}
		class SouthwestNative extends NativeAmerican {
			public String name;
		}
		class Apache extends SouthwestNative {
			public boolean bisonHunting = true;
			public String toString() {
				return name + " is an Apache.";
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		bar.java:4: error: cannot find symbol
							geronimo.name = "Geronimo";
										^
		symbol:   variable name
		location: variable geronimo of type NativeAmerican
		bar.java:5: error: cannot find symbol
							System.out.println(geronimo.bisonHunting);
																^
		symbol:   variable bisonHunting
		location: variable geronimo of type NativeAmerican
		2 errors
	</code></pre>
	<p>
		We see two compilation errors: (1) Java cannot find the variable
		<span class="monoText">name</span>; (2) Java cannot find the variable
		<span class="monoText">bisonHunting</span>. This is because
		<span class="monoText">geronimo</span> is an instance of
		<span class="monoText">NativeAmerican</span>, but the variables
		<span class="monoText">name</span> and
		<span class="monoText">bisonHunting</span> are part of the
		<span class="monoText">Apache</span> class. If we wanted to see these
		variables, then we must use the <span class="monoText">Apache</span> class:
	</p>
	<pre class="language-java"><code>
		public class bar {
			public static void main(String[] args) {
				Apache geronimo = new Apache();
				geronimo.name = "Geronimo";
				System.out.println(geronimo.bisonHunting);
			}
		}
		class NativeAmerican {}
		class SouthwestNative extends NativeAmerican {
			public String name;
		}
		class Apache extends SouthwestNative {
			public boolean bisonHunting = true;
			public String toString() {
				return name + " is an Apache.";
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		true
	</code></pre>
	<p>
		We learn a key less from these examples and principles: If we have more
		instance variables at the top of the inheritance tree, then we have more
		subclasses in the hierarchy. If we have more instance variables at the
		bottom of the inheritance tree, then we must provide more specific behaviors
		(methods) for the subclasses.
	</p>

	<p>
		<span class="topic">The <span class="monoText">super</span> Keyword.</span>
		Subclasses can access a constructor inside their parent class. This is done
		by using the <span class="monoText">super</span> keyword:
	</p>

	<pre class="language-java"><code>
		public class bar {
			public static void main(String[] args) {
				Gas argon = new Gas("argon");
				System.out.println(argon.name);
			}
		}
		
		class Inorganic {
			protected String type;
			Inorganic(String setType) {
				type = setType;
			}
		}
		class Gas extends Inorganic {
			public String name;
			Gas(String setName) {
				super("Gas");
				name = setName;
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		argon
	</code></pre>

	<p>
		In the code above, we called the constructor defined in
		<span class="monoText">Inorganic</span>, the superclass of
		<span class="monoText">Gas</span>. When we use the symbol
		<span class="monoText">super</span>, it
		<span class="underlineText">must</span> be the first thing we do.
	</p>

	<p>
		<span class="topic">Polymorphism.</span>
		<span class="italicsText">Polymorphism</span> is the provision of a single
		interface to entities of different types. In others, polymorphism is the
		phenomenon where a single entity of one type, such as an object, can act as
		if it were an entity of another, or multiple other, types. We see this all
		the time. A pet tiger may be loving and caring, acting truly like a
		domesticated animal in one moment, but then turning to their wild side and
		slaughtering their owner the next. Some ethnicities are the majority
		population in one area, while being a minority in another. A person is a
		student by day and a bartender by night.
	</p>
	<p>
		<span class="topic">Subtype Polymorphism.</span> Necessarily, in order to be
		a member of two different types, the entity must actually
		<span class="italicsText">be</span> a member of two different types. In
		Java, every object (except for <span class="monoText">Object</span>) is an
		instance of at least two types: (1) whatever class we have defined the
		object to be in; and (2) an object of
		<span class="monoText">Object</span> (the
		<span class="monoText">Java Object</span>). Of course, a particular object
		can be more than that if it is part of an
		<span class="italicsText">class tree</span>. For example:
	</p>

	<pre class="language-java"><code>
		class Animal {
			public void drinkWater() {
				System.out.println("gulp gulp gulp")
			}
		}
		class Reptile extends Animal {
			public void layEgg() {
				System.out.println("bloop bloop")
			}
		}

		/* 

		We can think of the above as: 
			Reptile extends Animal extends Object

		Thus:
			Reptile behaves like an Animal, and
			Reptile also behaves like an Object 

		*/
	</code></pre>

	<p>
		Every object of type <span class="monoText">reptile</span> is an instance of
		three different types: (1) the class <span class="monoText">Object</span>;
		(2) the class <span class="monoText">Animal</span>; and the class
		<span class="monoText">Reptile</span>. Given an object of type
		<span class="monoText">Reptile</span>, it has a method called
		<span class="monoText">layEgg()</span>. As an
		<span class="monoText">Animal</span>, it has a method called
		<span class="monoText">drinkWater()</span>. As an
		<span class="monoText">Object</span>, it has a method called
		<span class="monoText">toString()</span>.
	</p>

	<p>
		<span class="topic">Upcasting.</span> Because objects can be a member of
		multiple classes, Java provides the ability to
		<span class="term">upcast</span> &mdash; automatically allowing an object to
		behave like an object of an ancestor type:
	</p>
	<pre class="language-java"><code>
		class Animal {}
		class Reptile extends Animal {
			public String toString() {
				return "Reptilian";
			}
		}
		public class bar {
			public static void main(String[] args) {
				Reptile gator = new Reptile();
				Animal dragon = new Animal();
				bar.printAnything(gator);
				bar.printAnything(dragon);
			}
			public static void printAnything(Object toPrint) {
				System.out.println(toPrint.toString());
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		Reptilian
		Animal@6b95977
	</code></pre>

	<p>
		Pay close attention to the output. Those are the outputs from the statements
		<span class="monoText">bar.printAnything(gator)</span> and
		<span class="monoText">bar.printAnythng(dragon)</span>. We passed as
		arguments into those methods the objects
		<span class="monoText">gator</span> and
		<span class="monoText">dragon</span>. What is the method
		<span class="monoText">printAnything()</span>? It is the method defined
		inside the class <span class="monoText">bar</span>. And in that definition,
		we pass it one argument: an object <span class="monoText">toPrint</span> of
		type <span class="monoText">Object</span>. Let's focus first on
		<span class="monoText">gator</span>.
	</p>
	<p>
		The object <span class="monoText">gator</span> is an instance of
		<span class="monoText">Reptile</span>, but here it is being used as an
		object of type <span class="monoText">Object</span>. Nevertheless, it is
		also an object of type <span class="monoText">Reptile</span>. Inside the
		class definition for <span class="monoText">Reptile</span>, we overrode the
		<span class="monoText">toString()</span> method: Rather than follow
		<span class="monoText">Object</span>'s default definition, return the string
		<span class="monoText">"Reptilian"</span>. So, when we pass in
		<span class="monoText">gator</span> into the
		<span class="monoText">printAnything()</span> method, we really wrote
		<span class="monoText">gator.toString()</span>. This is why we see the
		output <span class="monoText">Reptilian</span>.
	</p>

	<p>
		Now, let's look at <span class="monoText">dragon</span>. When we pass in
		<span class="monoText">dragon</span> as an argument, we really wrote
		<span class="monoText">dragon.toString()</span>. The object
		<span class="monoText">dragon</span> is an object of type
		<span class="monoText">Object</span>. But, it is also an object of type
		<span class="monoText">Animal</span>. The class
		<span class="monoText">Animal</span> provides no override of the
		<span class="monoText">toString()</span> method. So, Java moves up the class
		tree, and goes to <span class="monoText">Object</span>. There, it applies
		the <span class="monoText">toString()</span> method as defined there, and we
		get back <span class="monoText">Animal@6b95977</span>. This is the default
		definition of <span class="monoText">toString()</span> &mdash; it tells us
		that there is an instance of <span class="monoText">Animal</span> at the
		memory reference <span class="monoText">6b95977</span>.
	</p>

	<p>
		Notice that we wrote <span class="monoText">bar.printAnything()</span> to
		call the method <span class="monoText">printAnything()</span>. Why? Because
		<span class="monoText">printAnything()</span> is a method defined in the
		class <span class="monoText">bar</span>. This is all evidence of
		<span class="italicsText">polymorhpism</span>.
	</p>
	<p>
		As an aside, we might ask, how is the
		<span class="monoText">printAnything()</span> method called when it is below
		the <span class="monoText">main()</span> method? This is a perfectly fair
		question, particularly for those coming from a Python background. In Python,
		a program structured in this manner is almost certain to return an error.
		This is because Python's evaluation model interprets then executes code
		line-by-line, top to bottom. In languages like Java, however, the code is
		first compiled then executed. Thus, the positioning of methods and classes
		alone will not prohibit execution. (Note that compiling is not necessarily
		what allows Java to avoid relative positioning; C, for example, requires the
		use of prototypes for <span class="monoText">struct</span>s defined at the
		bottom of a source code file).
	</p>

	<p>
		<span class="topic">Downcasting.</span> Where
		<span class="italicsText">upcasting</span> allows an object to behave as if
		it were an object of an ancestor type,
		<span class="term">downcasting</span> allows an object to behave as if it
		were an object of a descendent type.
		<span class="underlineText">But</span> only if the instance is actually the
		appropriate subtype. If the instance is not an appropriate subtype, then
		Java will return a runtime error.
	</p>
	<pre class="language-java"><code>
		class Animal {}
		class Reptile extends Animal {
			public String toString() {
				return "Reptilian";
			}
		}
		public class bar {
			public static void main(String[] args) {
				Object gator = new Reptile();
				bar.printAnything(gator);
				Animal gatorAsAnimal = (Animal) gator;
				bar.printAnything(gatorAsAnimal);
			}
			public static void printAnything(Object toPrint) {
				System.out.println(toPrint.toString());
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		Reptilian
		Reptilian
	</code></pre>
	<p>
		Here, we created an object named <span class="monoText">gator</span> of type
		<span class="monoText">Reptile</span> (whenever we are unsure of what type
		an object is, we always look to the right of the symbol
		<span class="monoText">new</span>). Notice, however, that we declared the
		variable <span class="monoText">gator</span> to be of type
		<span class="monoText">Object</span>. What is going on here?
	</p>
	<p>
		This is an example of performing an immediate upcast. We create an instance
		of <span class="monoText">Reptile()</span>, but we save it in a variable of
		type <span class="monoText">Object</span>. This is perfectly valid because
		it is an upcast &mdash; every instance
		<span class="monoText">Reptile</span> is an instance of
		<span class="monoText">Object</span>.
	</p>
	<p>
		The more interesting point is our creation of
		<span class="monoText">gatorAsAnimal</span>. That variable is of type
		<span class="monoText">Animal</span>. We assign to that variable the object
		<span class="monoText">gator</span>, but we prepend it with
		<span class="monoText">(Animal)</span>. This is a downcast. Why are we
		allowed to do this? Because <span class="monoText">gator</span> is an
		instance of <span class="monoText">Object</span>. And since it is an
		instance of <span class="monoText">Object</span>, an ancestor of
		<span class="monoText">Animal</span>, we can cast
		<span class="monoText">gator</span> downwards as an instance of
		<span class="monoText">Animal</span>.
	</p>
	<p>
		The tool: If we upcast an object, we can always downcast the object back to
		where we started. But, we can only cast an object that the casted object is
		related to. We cannot cast a <span class="monoText">String</span> object
		into an <span class="monoText">Animal</span> or
		<span class="monoText">Reptile</span> object, because
		<span class="monoText">Animal</span> and
		<span class="monoText">Reptile</span> are unrelated to
		<span class="monoText">String</span>.
	</p>
	<p>
		<span class="topic">Verifying an Instance's Class.</span> A useful operator
		provided by Java is the <span class="monoText">instanceOf</span> operator,
		which returns a Boolean value to the question: Is this particular instance
		an instance of this particular class? Thus:
	</p>
	<pre class="language-java"><code>
		class Animal {}
		class Reptile extends Animal {
			public String toString() {
				return "Reptilian";
			}
		}
		public class bar {
			public static void main(String[] args) {
				Reptile gator = new Reptile();
				Animal dragon = new Animal(); 
				System.out.println(gator instanceof Animal);
				System.out.println(gator instanceof Reptile);
				System.out.println(dragon instanceof Reptile);
				System.out.println(dragon instanceof Animal);
			}
			public static void printAnything(Object toPrint) {
				System.out.println(toPrint.toString());
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		true
		true
		false
		true
	</code></pre>
	<p>
		<span class="topic">Inheritance and Methods.</span> Consider the following:
	</p>
	<pre class="language-java"><code>
		class Animal {}
		class Lion extends Animal {
			public void roar() {
				System.out.println("roar");
			}
		}
		class Cobra extends Animal {
			public void hiss() {
				System.out.println("hiss");
			}
		}

		public class bar {
			public static void main(String[] args) {
				Animal bubu = new Animal();
				Lion lulu = new Lion();
				Cobra momo = new Cobra();
			}
		}
	</code></pre>
	<p>
		In the code above, we have two methods called
		<span class="monoText">roar()</span> and
		<span class="monoText">hiss()</span>. The
		<span class="monoText">roar()</span> method is defined in the subclass
		<span class="monoText">Lion</span>, and the
		<span class="monoText">hiss()</span> method is defined in the subclass
		<span class="monoText">Cobra</span>. Both
		<span class="monoText">Cobra</span> and
		<span class="monoText">Lion</span> are subclasses of
		<span class="monoText">Animal</span>. Of the instances we created,
		<span class="monoText">bubu</span> cannot call these methods. Why? Because
		<span class="monoText">bubu</span> is of class
		<span class="monoText">Animal</span>, and
		<span class="monoText">Animal</span> has no methods
		<span class="monoText">roar()</span> and
		<span class="monoText">hiss()</span>. But what if we want
		<span class="monoText">momo</span> to be an instace of
		<span class="monoText">Lion</span>, but at the same time, we want to keep
		the variable containing <span class="monoText">momo</span> to remain
		<span class="monoText">Animal</span>? Well, we can use a conditional:
	</p>
	<pre class="language-java"><code>
		class Animal {
			public void speak() {
				if (this instanceof Lion) {
					Lion me = (Lion) this;
					me.roar();
				} else if (this instanceof Cobra) {
					Cobra me = (Cobra) this;
					me.hiss();
				}
			}
		}
		class Lion extends Animal {
			public void roar() {
				System.out.println("roar");
			}
		}
		class Cobra extends Animal {
			public void hiss() {
				System.out.println("hiss");
			}
		}
		
		public class bar {
			public static void main(String[] args) {
				Animal bubu = new Lion();
				bubu.speak();
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		roar
	</code></pre>
	<p>
		In the code above, we created a new method called
		<span class="monoText">speak()</span>. That method behaves differently
		depending on what object is passed into it as an argument. That object,
		however, is an instance of <span class="monoText">Animal</span>. This means
		that the symbol <span class="monoText">this</span> refers to an instance of
		<span class="monoText">Animal</span>, so to call the
		<span class="monoText">roar()</span> and
		<span class="monoText">hiss()</span> methods, we must
		<span class="italicsText">downcast</span> the object argument. This is why
		we create a new variable (and by convention, naming the variable
		<span class="monoText">me</span>).
	</p>
</section>

<section id="object_references">
	<h2>Object References</h2>
	<p>
		The idea of a <span class="italicsText">reference</span> is not unique to
		Java. It occurs across many programming languages. References are also a
		useful way to clarify any vagueness in polymorphism.
	</p>
	<p>Consider the following code and its output:</p>
	<pre class="language-java"><code>
		class PhysConst {
			public String name;
			public double val;
			PhysConst(String setName, double setValue) {
				name = setName;
				val = setValue;
			}
			public String toString() {
				return name;
			}
		}
		
		public class bar {
			public static void main(String[] args) {
				// block (a)
				int first = 0;
				int second = first;
				second = 8;
				System.out.println(first + " " + second);
		
				// block (b)
				PhysConst otherConst = new PhysConst("Gas Constant", 8.31);
				PhysConst gasConst = otherConst;
				gasConst.name = "Molar Gas Constant";
				System.out.println(otherConst + " " + gasConst);
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		0 8
		Molar Gas Constant Molar Gas Constant
	</code></pre>
	<p>
		How does this code work? In <span class="monoText">block (a)</span>, we
		declare a variable called <span class="monoText">first</span>, of type
		<span class="monoText">int</span>. Then, we assign to that variable the
		integer value <span class="monoText">0</span>. Next, we declare a variable
		called <span class="monoText">second</span>, also of type
		<span class="monoText">int</span>, and we initialize it to the value
		<span class="monoText">first</span>, which is itself initialized to
		<span class="monoText">0</span>. Then, we changed the value bound to
		<span class="monoText">second</span> now it is
		<span class="monoText">8</span>. As expected, when we print the values, we
		see <span class="monoText">0</span> and <span class="monoText">8</span>.
		This is in line with what we know about assignment.
	</p>
	<p>
		But it seems that <span class="monoText">block (b)</span> works differently,
		even though it looks similar. We declared a variable of type
		<span class="monoText">PhysConst</span>, then assigned to it the object
		created by calling the
		<span class="monoText">PhysConst()</span> constructor. Then, on the next
		line, we declared a variable called <span class="monoText">gasConst</span>,
		of type <span class="monoText">PhysConst</span>, and assigned to
		<span class="monoText">otherConst</span>. Then, we initializd the
		<span class="monoText">name</span> instance variable of
		<span class="monoText">gasConst</span> to
		<span class="monoText">"Molar Gas Constant"</span>. After all of this, when
		print <span class="monoText">otherConst</span> and
		<span class="monoText">gasConst</span>, it looks like they have the same
		name &mdash; <span class="monoText">Molar Gas Const</span>. Why? It seems
		that in <span class="monoText">block (b)</span>, the change made to
		<span class="monoText">gasConst</span>, which was assigned
		<span class="monoText">otherConst</span>, had an effect on
		<span class="monoText">otherConst</span>. This is evidence of a
		<span class="italicsText">reference</span> at work.
	</p>
	<p>
		<span class="topic">About Variables.</span> When we discussed variables, we
		repeatedly said that a variable &#8220;stores&#8221; a value. This is
		incorrect when it comes to <span class="italicsText">objects</span> in Java.
		When we assign an object to a variable, the variable does not actually
		&#8220;store&#8221; the object. Instead, that variable stores a
		<span class="term">reference</span> to that object. We call such a variable
		a <span class="italicsText">reference variable</span>.
	</p>
	<p>
		A reference is a value representing a particular piece of data's location in
		the computer's memory. That reference
		<span class="italicsText">refers</span> to the data, and accessing the data
		is called <span class="italicsText">dereferencing</span> the reference.
		References are what allow a program to
		<span class="underlineText">indirectly</span> access a particular piece of
		data (e.g., an object). We emphasize &#8220;indirectly&#8221; because
		references are <span class="underlineText">not</span>
		<span class="italicsText">pointers</span>. Pointers provide direct access to
		the referenced data; a reference does not.
	</p>
	<p>
		There is a difference between a
		<span class="italicsText">reference</span> and the actual object the
		reference refers to. For example, a social security number. That number
		<span class="italicsText">refers</span> to a particular person, but the
		number itself is different from the object. Another example: A street
		address. The address is a reference to a physical location, say, an unlocked
		building filled with gold. If one person gains access to that address, they
		can go to that address and steal the boot. If another person knows that
		address, they can go and watch the looting or participate themselves. The
		thieves all make changes to the physical location, but the address
		nevertheless remains the same.
	</p>
	<p>
		This same phenomenon occurs with reference variables: Make an object
		<span class="monoText">x</span>. Assign <span class="monoText">x</span> to a
		reference variable called <span class="monoText">y</span>. We can make
		changes to <span class="monoText">x</span> by using the reference
		<span class="monoText">y</span>. If we make changes to
		<span class="monoText">y</span>, then those changes are reflected in
		<span class="monoText">x</span>, and are visible to every entity that has
		access to <span class="monoText">y</span> or
		<span class="monoText">x</span>.
	</p>
	<pre class="language-java"><code>
		class Fish { }

		// bass refers to an object of type Fish
		// but, bass currently refers to nothing
		
		Fish bass;

		// initializing an instance to null tells Java: 
			// this instance refers to nothing

		Fish trout = null;

		// now bass refers to a new Fish object

		Fish bass = new Fish();

		// now bass and trout refer to same Fish object

		trout = bass;             

		// returns true; bass and trout refer to the same Fish object 

		trout == bass;

		// now trout refers to new Fish object

		trout = new Fish(); 

		// false; bass and trout store refer to different Fish objects

		trout == bass;                 
	</code></pre>
	<p>
		When you assign an object to a reference variable in Java, you do not copy
		the object. You are copying the reference. If you do not see
		<span class="monoText">new</span>, you are not creating a new object. If we
		deleted everything after <span class="monoText">trout = bass</span>, we can
		make changes to the object <span class="monoText">bass</span> refers to by
		using <span class="monoText">trout</span>.
	</p>
	<p>
		The first <span class="monoText">trout == bass</span> returns
		<span class="monoText">true</span> because the two objects
		<span class="monoText">trout</span> and
		<span class="monoText">bass</span> refer to the same object. This is why we
		cannot use the <span class="monoText">==</span> operator to test whether two
		variables, both storing a string with the same exact characters, are
		equivalent. We cannot do so because the the two variables are
		<span class="italicsText">reference variables</span> &mdash; they refer to
		different objects, even if they appear the same.
	</p>
	<p>Another example:</p>
	<pre class="language-java"><code>
		class Seafood {
			public int quantity;
		}
		public class bar {
			public static void main(String[] args) {
				Seafood prawn;
				prawn = new Seafood();
				Seafood shrimp = prawn; 
				prawn.quantity = 100;
				System.out.println(shrimp.quantity);
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		100
	</code></pre>
	<p>
		Both <span class="monoText">prawn</span> and
		<span class="monoText">shrimp</span> are referring to the same object, so
		when we made a change with <span class="monoText">prawn</span>, we can see
		the changes with <span class="monoText">shrimp</span>.
	</p>

	<p>
		<span class="topic">Swapping References.</span> Suppose the following code:
	</p>
	<pre class="language-java"><code>
		class Chemical {
			public String name;
			Chemical(String setName) {
				name = setName;
			}
		}
		public class bar {
			public static void main(String[] args) {
				Chemical Na = new Chemical("iron");
				Chemical Fe = new Chemical("sodium");
			}
		}
	</code></pre>
	<p>
		We want to switch the objects the reference variables are referring to in
		the code above. In making this switch, we
		<span class="underlineText">must</span> be careful. This is because the
		moment we lose a reference, the moment that object is lost. And once it is
		lost, it effectively no longer exists (Java's garbage collector spares no
		one).
	</p>
	<p>
		To ensure the reference is never lost, we need a temporary reference
		variable, in this case a variable named <span class="monoText">tmp</span>:
	</p>
	<pre class="language-java"><code>
		class Chemical {
			public String name;
			Chemical(String setName) {
				name = setName;
			}
		}
		public class bar {
			public static void main(String[] args) {
				Chemical Na = new Chemical("iron");
				Chemical Fe = new Chemical("sodium");
				Chemical tmp = Na;
				Na = Fe;
				Fe = tmp;
			}
		}
	</code></pre>

	<p>
		<span class="topic">Pass By Reference.</span> Why do we use references in
		the first place? Why don't we just store the objects themselves in the
		variables? One of the reasons is because of the way methods work in Java.
		When we pass an object into a method, the method receives a
		<span class="italicsText">copy of the reference</span> to the object
		argument. This in turn allows the method to modify the referenced object.
	</p>
	<pre class="language-java"><code>
		class Grain {
			public String name;
			public int amount;
			Grain(String setName, int setAmount) {
				name = setName;
				amount = setAmount;
			}
		}
		
		public class bar {
			public static void main(String[], args) {
				Grain wheat = new Grain("wheat", 10);
				System.out.println("amount before: " + wheat.amount);
				newShipment(wheat);
				System.out.println("amount after: " + wheat.amount);
			}
			public static int newShipment(Grain toIncrease) {
				toIncrease.amount++;
				return toIncrease.amount;
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		amount before: 10
		amount after: 11
	</code></pre>
	<p>
		In the code above, the function
		<span class="monoText">newShipment()</span> receives a copy of the reference
		to the object created in the line
		<span class="monoText">Grain wheat = new Grain("wheat", 10)</span>. Thus,
		that reference is used by <span class="monoText">newShipment()</span> to
		modify the object.
	</p>

	<p>
		<span class="topic">Another Look: Arrays.</span> Arrays in Java store object
		references. Thus, when we copy an array, we are only copying th object
		references, not the objects themselves.
	</p>
	<pre class="language-java"><code>
		class Weapon {
			public int amount;
			Weapon(int setAmount) {
				amount = setAmount;
			}
		}
		public class bar {
			public static void main(String[] unused) {

				// array can hold 4 references
				Weapon[] guns = new Weapon[4];
				for (int i=0; i < guns.length; i++) {
					guns[i] = new Weapon(10+i);
				}
		
				// another array holding 4 references to the same objects
				Weapon[] sameGuns = new Weapon[4];
				for (int i=0; i < guns.length; i++) {
					sameGuns[i] = guns[i]; 
				}

				// increment each referenced object in first array
				for (int i = 0; i < guns.length; i++) {
					guns[i].amount++;
				}
		
				// print each referenced object in second array
				for (int i = 0; i < sameGuns.length; i++) {
					System.out.println(sameGuns[i].amount);
				}
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		11
		12
		13
		14
	</code></pre>
</section>

<section id="references_and_polymorphism">
	<p>
		<span class="topic">References and Polymorphism</span>
		Recall that every object in Java is a part of the
		<span class="italicsText">Java inheritance tree</span> &mdash; every object
		has a parent class, all the way up to the only object without a class, the
		<span class="monoText">Object</span>. Thus, every object in Java inherits
		the methods defined by <span class="monoText">Object</span>. These methods,
		however, are rarely useful, so we often override them.
	</p>
	<p>
		Additionally, recall that when we use a particular method or variable
		associated with a class, Java first looks at the object's class, and if it
		is not there, then it looks at the object's parent class. Java will continue
		until it reaches <span class="monoText">Object</span>, and if it isn't
		there, then it returns an error.
	</p>
	<p>
		<span class="italicsText">Subtype polymorphism</span> tells us that every
		object can be referred to as at least two types: the class defining it, and
		the type <span class="monoText">Object</span>. The object, of course, can
		morph into its ancestors, if any. Consider the following:
	</p>
	<pre class="language-java"><code>
		class Fruit { }
		class Berry extends Fruit {
			public String toString() {
				return "this is a berry!";
			}
		}

		public class bar {
			public static void main(String[] args) {
				Fruit banana = new Fruit();
				Berry blueberry = new Berry();
				bar.printIsType(banana);
				bar.printIsType(blueberry);
			}
			public static void printIsType(Object target) {
				System.out.println(target.toString());
			}  
		}
	</code></pre>
	<pre class="language-bash"><code>
		Fruit@6b95977
		this is a berry!
	</code></pre>
	<p>
		The first output line is the name of the class followed by a hashcode. This
		is the default definition for the
		<span class="monoText">toString()</span> method provided by
		<span class="monoText">Java.lang.Object</span>. Why do we see this output?
		Because we created an instance of <span class="monoText">Fruit</span>, and
		<span class="monoText">banana</span> stores a reference to that instance.
		The class <span class="monoText">Fruit</span>, however, does not define
		<span class="monoText">toString()</span>, so Java looks to
		<span class="monoText">Java.lang.Object</span>,
		<span class="monoText">Fruit</span>'s parent class, for a definition. Java
		found that definition, so it applied it accordingly.
	</p>
	<p>
		In contrast, with <span class="monoText">blueberry</span>, we created an
		instance of <span class="monoText">Berry</span>, and stored the reference to
		that instance in <span class="monoText">blueberry</span>. We overrode
		<span class="monoText">Java.lang.Object</span>'s definition of
		<span class="monoText">toString()</span> inside the class
		<span class="monoText">Berry</span>, so when we called that method, Java
		went and looked for a definition in <span class="monoText">Berry</span>. It
		found such a definition and applied it accordingly.
	</p>
	<p>Now, consider the following alteration:</p>
	<pre class="language-java"><code>
		class Fruit { }
		class Berry extends Fruit {
			public String toString() {
				return "this is a berry!";
			}
		}

		public class bar {
			public static void main(String[] args) {
				Fruit banana = new Berry();
				Berry blueberry = new Berry();
				bar.printIsType(banana);
				bar.printIsType(blueberry);
			}
			public static void printIsType(Object target) {
				System.out.println(target.toString());
			}  
		}
	</code></pre>
	<pre class="language-bash"><code>
		this is a berry!
		this is a berry!
	</code></pre>
	<p>
		Notice the change made: The reference variable
		<span class="monoText">banana</span> remains as a variable of type
		<span class="monoText">Fruit</span>, but it now holds a reference to an
		instance of <span class="monoText">Berry</span>. Thus, when we passed
		<span class="monoText">banana</span> to the
		<span class="monoText">printIsType()</span> method, Java went and looked at
		the class <span class="monoText">Berry</span>, rather than
		<span class="monoText">Fruit</span> (after all, the referrent is an instance
		of type <span class="monoText">Berry</span>). Java found a definition for
		<span class="monoText">toString()</span>, and evaluated accordingly. This
		example evidences the relationship between polymorphism &mdash; an object
		morphing, or behaving, as if it were a member of another class &mdash; and
		references. We can store a reference to an instance of
		<span class="monoText">Berry</span> to a reference variable of type
		<span class="monoText">Fruit</span>. Why? Because
		<span class="monoText">Berry</span> extends
		<span class="monoText">Fruit</span>. Any
		<span class="monoText">Berry</span> can behave like a
		<span class="monoText">Fruit</span> &mdash; but, not all
		<span class="monoText">Fruit</span> can behave like a
		<span class="monoText">Berry</span>. The general rule for polymorphism: An
		object can morph into an object of its superclasses, but it cannot morph
		into an object of its subclasses. If we want to
		<span class="italicsText">downcast</span>, we must do so explicitly:
	</p>
	<pre class="language-java"><code>
		class Fruit { }
		class Berry extends Fruit {
			public String toString() {
				return "this is a berry!";
			}
		}

		public class bar {
			public static void main(String[] args) {
				Object acai = new Berry();

				System.out.println(acai);

				Fruit acaiFruit = (Fruit) acai;

				System.out.println(acaiFruit);

				Berry acaiBerry = (Berry) acai;

				System.out.println(acaiBerry);

			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		this is a berry!
		this is a berry!
		this is a berry!
	</code></pre>
	<p>
		<span class="topic">How to Copy an Object.</span> Suppose we want to create
		a copy of an object, <span class="italicsText">not</span> a copy of the
		reference to that object. We have several options to accomplish this. The
		<span class="monoText">Java.lang.Object</span> class provides a method
		called <span class="monoText">clone</span>. But, we should not use this
		method to create copies of an object. It does not exactly work in the way we
		expect (more on this later).
	</p>
	<p>
		A better way is to implement a
		<span class="italicsText">copy constructor</span>:
	</p>
	<pre class="language-java"><code>
		class Employee {
			public int age;
			Employee(int setAge) {
				age = setAge;
			}
			Employee(Employee other) {
				age = other.age;
			}
		}
	</code></pre>
	<p>
		Here, we have class called <span class="monoText">Employee</span> with a
		single field called <span class="monoText">age</span>. Then, we have two
		constructors. The first constructor allows us to create a new instance of
		<span class="monoText">Employee</span> and set their
		<span class="monoText">age</span>. Then we have a second constructor: It
		takes as an argument a reference to another instance of
		<span class="monoText">Employee</span>, referred to with the dummy variable
		<span class="monoText">other</span>. In doing so, we copy all of the fields
		of <span class="monoText">other</span> (we can limit the copy) into the new
		instance of <span class="monoText">Employee</span>. Thus, what we get back
		is a copy.
	</p>
	<p>
		<span class="topic">Instance v. Reference Types.</span> When we create an
		object and assign its reference to a variable, there are effectively two
		types: (1) the instance type, and (2) the reference type. The instance type
		is what is to the right of the symbol <span class="monoText">new</span>. The
		reference type is to the right of the reference variable name. It will store
		a reference to any instance that can behave like the reference variable's
		type.
	</p>
	<pre class="language-java"><code>
		class Court { }
		class FederalCourt extends Court { }
		class AppellateCourt extends FederalCourt { }
		class CircuitCourt extends FederalCourt { }

		public class bar {
			public static void main(String[] unused) {
				Court NDCal = new Court();
				Object NDIll = new FederalCourt();
				FederalCourt NinthCir = new AppellateCourt();
			}
		}
	</code></pre>
	<p>
		In the example above, the reference variable
		<span class="monoText">NDCal</span> can store a reference to any object that
		behaves like a <span class="monoText">Court</span>. Thus, it can store a
		reference to <span class="monoText">new FederalCourt()</span>,
		<span class="monoText">new AppellateCourt()</span>, or
		<span class="monoText">new CircuitCourt()</span>. Similarly,
		<span class="monoText">NDIll</span> can store a reference to any object that
		behaves like a <span class="monoText">Java.lang.Object</span>.
	</p>
	<p>
		In Java, the reference type is what determines whether an instance can
		access particular methods or variables.
	</p>
	<pre class="language-java"><code>
		class GovEntity {}
		class Executive extends GovEntity {
			public void act() {
				System.out.println('I refused a law');
			}
		} 
		class Legislative extends GovEntity {} 
		class Judicial extends GovEntity {} 

		public class bar {
			public static void main(String[] args) {
				Executive potus = new Executive();
				potus.act(); // works
				Object potusAsObj = potus;
				potus.act(); // doesn't work
				Object stringObj = new String("I am a string");
				stringObject.act(); // doesn't work
				System.out.println(stringObject.toString()); // works
			}
		} 

	</code></pre>
	<p>
		This is an absolutely critical point to understand. It is not the class of
		the instance that determines what methods or variables that instance may
		access, it is the reference variable's class that determines what methods or
		variables that instance may access.
	</p>
	<pre class="language-java"><code>
		class GovEntity {}
		class Executive extends GovEntity {
			public void act() {
				System.out.println("I refused a law");
			}
		} 
		class Legislative extends GovEntity {
			public void legislate() {
				System.out.println("I made a law");
			}
		} 
		class Judicial extends GovEntity {
			public void judge() {
				System.out.println("I struck down a law");
			}
		} 

		public class bar {
			public static void main(String[] args) {
				Executive potus = new Executive();
				potus.act(); // works
				Legislative congress = new Legislative();
				congress.legislate(); // works
				Judicial scotus = new Judicial();
				scotus.judge(); // works
				GovEntity scotusGov = scotus;
				scotusGov.judge(); // doesn't work
				GovEntity potusGov = potus;
				potusGov.act(); // doesn't work
				GovEntity congressGov = congress;
				congressGov.legislate(); // doesn't work

				GovEntity whiteHouse = new Executive();
				whiteHouse.act(); // doesn't work -- reference type controls
			}
		} 
	</code></pre>
	<p>
		Why doesn't the last line work? Didn't we create an instance of
		<span class="monoText">Executive</span>? It doesn't work because the
		reference type is <span class="monoText">GovEntity</span>, and
		<span class="monoText">GovEntity</span> can store any one of three types:
		<span class="monoText">Executive</span>,
		<span class="monoText">Legislative</span>, and
		<span class="monoText">Judicial</span>.
	</p>

	<p>
		This is a characteristic of Java that separates it from other
		object-oriented languages. Java enforces this rule because not every
		<span class="monoText">GovEntity</span> has a method called
		<span class="monoText">act()</span>. In languages like Python, the rule is
		<span class="italicsText">duck typing</span> &mdash; if it walks like an
		<span class="monoText">Executive</span>, quacks like an
		<span class="monoText">Executive</span>, then it is an
		<span class="monoText">Executive</span>.
	</p>

	<p>
		<span class="topic">Why Polymorphism?</span> A fair question regarding all
		this complexity is <span class="italicsText">why</span>? Why organize things
		in a hierarchy? Why create so many rules implicating inheritance? These
		questions directly strike the heart of Java's type system. Java's
		motivations are reasonable: First, by focusing on class extension
		(inheritance), descendant classes can implement or override ancestor
		behavior while keeping desirable ancestor properties. This is a natural
		result of implementing hierarchy in the first place &mdash; if we follow
		strict hierarchy, there is no possibility of refusing methods and variables
		inherited from an ancestor. Indeed, Java does not allow such actions; if an
		object does not want <span class="monoText">toString()</span>, we must
		override.
	</p>

	<p>
		Second, by focusing on hierarchy relationships (polymorphism), we can write
		method that work for <span class="italicsText">any</span> descendant class
		&mdash; even those that we may not have explicitly defined within the
		particular descendant class. This is a powerful way to
		<span class="italicsText">generalize</span> &mdash; we can create elaborate
		methods without actually knowing anything about the objects they might
		operate on. This provides fertile ground for large, complex data structures
		as well as extensive libraries.
	</p>

	<p>
		<span class="topic"><span class="monoText">final</span> and Classes.</span>
		As a brief aside, appending the symbol
		<span class="monoText">final</span> to a class tells Java that the class
		<span class="underlineText">cannot</span> be extended.
	</p>
	<pre class="language-java"><code>
		public class Crustacean { }
		public final class Crab { }
		public class MangroveCrab extends Crab { } // this shall not pass
	</code></pre>
	<p>
		<span class="topic"
			><span class="monoText">abstract</span> and Classes.</span
		>
		When we append the symbol <span class="monoText">abstract</span> to a class,
		we tell Java the class can only be extended
		<span class="underlineText">but not instantiated</span> (make an instance
		of).
	</p>
	<pre class="language-java"><code>
		public abstract Bird { }
		public class Penguin extends Bird { } 
		Bird winglet = new Bird(); // this doesn't work
		Penguin penguini = new Penguin(); // this works
	</code></pre>
	<p>
		<span class="topic"
			><span class="monoText">private</span> and Classes.</span
		>
		We cannot use the symbol <span class="monoText">private</span> with classes.
		If a class were <span class="monoText">private</span>, we would not be able
		to use it at all. But, there are situations where we might want to limit a
		class. To do so, we use <span class="italicsText">inner classes</span>:
	</p>
	<pre class="language-java"><code>
		public class Organ {
			class Heart {
				public String toString() {
					return "This is part of the heart"
				}
				private Heart foo;
				Organ() {
					foo = new Heart();
				}
			}
		}
	</code></pre>
	<p>
		Inside the <span class="monoText">Organ</span> class, we have a definition
		for the <span class="monoText">Heart</span> class. Inside the
		<span class="monoText">Organ</span> class, we can use the
		<span class="monoText">Heart</span> class.
	</p>
	<p>
		<span class="topic">Generality v. Capability.</span> But, polymorphism has
		its tradeoffs. The higher a class is on the object hierarchy, the more
		general, and the more general, the fewer its capabilities. On the other
		hand, the lower a class is on the object hierarchy, the more specific it is,
		and the more specific, the more capabilities. The problem: The more specific
		a class is, the narrower its use cases. Narrow use cases are prone to abuse.
		Polymorphism, as we have seen, can easily become enormously complex, and any
		good programmer will tell you that large, deeply nested classes can lead to
		<span class="italicsText">inheritance hell</span> &mdash; adding further
		classes only makes the program look more like
		<span class="italicsText">Dante's Inferno</span>.
	</p>
</section>

{% endblock %}
