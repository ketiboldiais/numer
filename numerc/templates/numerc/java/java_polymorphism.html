{% extends '../layout.html' %} {% load static %} {% block content %}
<section id="polymorphism">
	<h3>Polymorphism</h3>
	<p>
		In the previous sections, we saw how objects provide us a way to package
		state and behavior, and organize it into a hierarchy. A fair question to
		ask: Why organize objects into hierarchy? Because humans generally prefer
		viewing and understanding things in terms of sets and subsets. Humans are in
		the category of mammals, some humans are in the category of doctors, others
		mechanics, carpenters, stay-at-home parents, students, teachers, etc. Within
		doctors there are cardiologists, pathologists, neurosurgeons, and more.
		Within students there are those that study physics and those that study
		theology. Organizing objects hierarchically is an attempt to mimic this
		preference.
	</p>
	<p>
		In the real world, when a set contains multiple subsets, there is usually
		something members of the subsets have in common that warrants their
		membership in the superset other than being a subset. For example, an LLC
		and a C Corporation are all subsets of business entities, but both entities
		are citizens of a particular jurisdiction (e.g., a C Corporation
		incorporated in Delaware is a Delaware citizen, while an LLC formed in New
		York is a New York citizen). Similarly, an LLC and a general partnership are
		business entities, and while they differ in how they are formed, they are
		generally taxed in a similar manner (passthrough entities).
	</p>
	<p>
		Because of these shared characteristics, we often want a member of one
		subset to be able to act as if they were members of another subset. A
		California-born student at the University of Washington at Tacoma should be
		able to vote in California once they become a resident of the state. That
		particular student is a member of many subclasses &mdash; University of
		Washington at Tacoma students; California-born persons; American citizens;
		Washington citizens, etc.
	</p>
	<p>
		However, recall that in Java, classes are parthenogenetic &mdash; a subclass
		can only extend one parent class; no subclass can ever have more than one
		parent. How then do we accomplish the preceding phenomenon, where objects of
		one class might <span class="italicsText">behave</span> like the objects of
		another class? Through <span class="italicsText">polymorphism</span>.
	</p>
	<p>
		<span class="topic">The Java Object.</span> To understand polymorphism, we
		need to clarify a common point of confusion. As we've stated before,
		everything in Java must be wrapped in a class. Now, because classes can only
		extend one parent class, there necessarily must be something at the very
		root of it all. It cannot be turtles all the way down. Indeed, there is a
		root &mdash; the Java Object. Every class in Java inherits from the Java
		Object. We will discuss in more detail what this Object is in later
		sections, but for now, the key point is: When we use the term Object with a
		capital "O," we are referring to the Java Object, rather than object we have
		created.
	</p>
	<pre class="language-java"><code>
		public class Chemicals { }

		// The class declaration above is equivalent to:
		
		public class Chemicals extends Object { }

		// We do not have to write this^ line
		// Java assumes this is the case when we do not include an extends symbol
	</code></pre>
	<p>
		This means that every state and method of a newly declared class inherits
		from Object. Does it inherit all of Object's states and methods? No. The
		class inherits a small number of the states and methods. Some of the most
		important methods inherited from Object are the following:
	</p>
	<figure class="table">
		<table class="loop_table">
			<thead>
				<th>Object Method</th>
				<th>Description</th>
			</thead>
			<tbody>
				<tr>
					<td><span class="monoText">String toString()</span></td>
					<td>
						Return a <span class="monoText">String</span> representing the
						instance. This is used primarily for debugging.
					</td>
				</tr>
				<tr>
					<td>
						<span class="monoText">boolean equals(object_1 object_2)</span>
					</td>
					<td>
						Return a <span class="monoText">boolean</span> indicating whether
						<span class="monoText">object_1</span> is the same as
						<span class="monoText">object_2</span>.
					</td>
				</tr>
				<tr>
					<td><span class="monoText">int hashCode()</span></td>
					<td>
						Return an <span class="monoText">int</span> uniquely representing an
						object's contents (more on this later).
					</td>
				</tr>
			</tbody>
		</table>
	</figure>
	<p>
		The methods inherited from <span class="monoText">Object</span> are very
		rarely used. This is because classes can
		<span class="italicsText">override</span> methods inherited from their
		ancestors, using their own instead.
	</p>
	<pre class="language-java"><code>
		public class bar {
			public static void main(String[] args) {
				Apache geronimo = new Apache();
				geronimo.name = "Geronimo";
				System.out.println(geronimo.toString());
			}
		}

		class NativeAmerican {}

		class SouthwestNative extends NativeAmerican {
			public String name;
		}

		class Apache extends SouthwestNative {
			public String toString() {
				return name + " is an Apache.";
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		Geronimo is an Apache.
	</code></pre>
	<p>
		Notice that we created an instance of the class
		<span class="monoText">Apache</span>, and initialized its instance variable
		<span class="monoText">name</span> to
		<span class="monoText">"Geronimo"</span>. How are we allowed to do this when
		there is no such instance variable in the class
		<span class="monoText">Apache</span>? Because
		<span class="monoText">Apache</span> inherits everything from its ancestors.
		The class <span class="monoText">SouthwestNative</span> is an ancestor of
		<span class="monoText">Apache</span>, and as such, all instances of
		<span class="monoText">Apache</span> have an instance variable called
		<span class="monoText">name</span> that can be initialized.
	</p>
	<p>
		The same goes for the <span class="monoText">toString()</span> method. When
		we called that method with the instance
		<span class="monoText">geronimo</span>, Java went and checked if the
		<span class="monoText">Apache</span> class contained such a method and
		verified that it is <span class="monoText">public</span>. If no such method
		existed, then Java would check the parent,
		<span class="monoText">SouthwestNative</span>; otherwise
		<span class="monoText">NativeAmerican</span>; otherwise
		<span class="monoText">Object</span>.
	</p>
	<p>
		What this means then is that if we included another
		<span class="monoText">toString()</span> method definition in a parent class
		(while keeping the <span class="monoText">toString()</span> method inside
		the subclass, Java will not go any further to execute the
		<span class="monoText">toString()</span> method in the parent class. Java
		stops and runs either (a) the method's definition in the instance's class
		itself, or (b) the nearest ancestor defining the method. In other words, it
		stops the moment it encounters a
		<span class="monoText">toString()</span> method it can use.
	</p>
	<p>
		On the other hand, this also means that a parent class cannot access
		variables in its child classes. Suppose for example we had the following:
	</p>
	<pre class="language-java"><code>
		public class bar {
			public static void main(String[] args) {
				NativeAmerican geronimo = new NativeAmerican();
				geronimo.name = "Geronimo";
				System.out.println(geronimo.bisonHunting);
			}
		}
		class NativeAmerican {}
		class SouthwestNative extends NativeAmerican {
			public String name;
		}
		class Apache extends SouthwestNative {
			public boolean bisonHunting = true;
			public String toString() {
				return name + " is an Apache.";
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		bar.java:4: error: cannot find symbol
							geronimo.name = "Geronimo";
										^
		symbol:   variable name
		location: variable geronimo of type NativeAmerican
		bar.java:5: error: cannot find symbol
							System.out.println(geronimo.bisonHunting);
																^
		symbol:   variable bisonHunting
		location: variable geronimo of type NativeAmerican
		2 errors
	</code></pre>
	<p>
		We see two compilation errors: (1) Java cannot find the variable
		<span class="monoText">name</span>; (2) Java cannot find the variable
		<span class="monoText">bisonHunting</span>. This is because
		<span class="monoText">geronimo</span> is an instance of
		<span class="monoText">NativeAmerican</span>, but the variables
		<span class="monoText">name</span> and
		<span class="monoText">bisonHunting</span> are part of the
		<span class="monoText">Apache</span> class. If we wanted to see these
		variables, then we must use the <span class="monoText">Apache</span> class:
	</p>
	<pre class="language-java"><code>
		public class bar {
			public static void main(String[] args) {
				Apache geronimo = new Apache();
				geronimo.name = "Geronimo";
				System.out.println(geronimo.bisonHunting);
			}
		}
		class NativeAmerican {}
		class SouthwestNative extends NativeAmerican {
			public String name;
		}
		class Apache extends SouthwestNative {
			public boolean bisonHunting = true;
			public String toString() {
				return name + " is an Apache.";
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		true
	</code></pre>
	<p>
		We learn a key less from these examples and principles: If we have more
		instance variables at the top of the inheritance tree, then we have more
		subclasses in the hierarchy. If we have more instance variables at the
		bottom of the inheritance tree, then we must provide more specific behaviors
		(methods) for the subclasses.
	</p>

	<p>
		<span class="topic">The <span class="monoText">super</span> Keyword.</span>
		Subclasses can access a constructor inside their parent class. This is done
		by using the <span class="monoText">super</span> keyword:
	</p>

	<pre class="language-java"><code>
		public class bar {
			public static void main(String[] args) {
				Gas argon = new Gas("argon");
				System.out.println(argon.name);
			}
		}
		
		class Inorganic {
			protected String type;
			Inorganic(String setType) {
				type = setType;
			}
		}
		class Gas extends Inorganic {
			public String name;
			Gas(String setName) {
				super("Gas");
				name = setName;
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		argon
	</code></pre>

	<p>
		In the code above, we called the constructor defined in
		<span class="monoText">Inorganic</span>, the superclass of
		<span class="monoText">Gas</span>. When we use the symbol
		<span class="monoText">super</span>, it
		<span class="underlineText">must</span> be the first thing we do.
	</p>

	<p>
		<span class="topic">Polymorphism.</span>
		<span class="italicsText">Polymorphism</span> is the provision of a single
		interface to entities of different types. In others, polymorphism is the
		phenomenon where a single entity of one type, such as an object, can act as
		if it were an entity of another, or multiple other, types. We see this all
		the time. A pet tiger may be loving and caring, acting truly like a
		domesticated animal in one moment, but then turning to their wild side and
		slaughtering their owner the next. Some ethnicities are the majority
		population in one area, while being a minority in another. A person is a
		student by day and a bartender by night.
	</p>
	<p>
		<span class="topic">Subtype Polymorphism.</span> Necessarily, in order to be
		a member of two different types, the entity must actually
		<span class="italicsText">be</span> a member of two different types. In
		Java, every object (except for <span class="monoText">Object</span>) is an
		instance of at least two types: (1) whatever class we have defined the
		object to be in; and (2) an object of
		<span class="monoText">Object</span> (the
		<span class="monoText">Java Object</span>). Of course, a particular object
		can be more than that if it is part of an
		<span class="italicsText">class tree</span>. For example:
	</p>

	<pre class="language-java"><code>
		class Animal {
			public void drinkWater() {
				System.out.println("gulp gulp gulp")
			}
		}
		class Reptile extends Animal {
			public void layEgg() {
				System.out.println("bloop bloop")
			}
		}

		/* 

		We can think of the above as: 
			Reptile extends Animal extends Object

		Thus:
			Reptile behaves like an Animal, and
			Reptile also behaves like an Object 

		*/
	</code></pre>

	<p>
		Every object of type <span class="monoText">reptile</span> is an instance of
		three different types: (1) the class <span class="monoText">Object</span>;
		(2) the class <span class="monoText">Animal</span>; and the class
		<span class="monoText">Reptile</span>. Given an object of type
		<span class="monoText">Reptile</span>, it has a method called
		<span class="monoText">layEgg()</span>. As an
		<span class="monoText">Animal</span>, it has a method called
		<span class="monoText">drinkWater()</span>. As an
		<span class="monoText">Object</span>, it has a method called
		<span class="monoText">toString()</span>.
	</p>

	<p>
		<span class="topic">Upcasting.</span> Because objects can be a member of
		multiple classes, Java provides the ability to
		<span class="term">upcast</span> &mdash; automatically allowing an object to
		behave like an object of an ancestor type:
	</p>
	<pre class="language-java"><code>
		class Animal {}
		class Reptile extends Animal {
			public String toString() {
				return "Reptilian";
			}
		}
		public class bar {
			public static void main(String[] args) {
				Reptile gator = new Reptile();
				Animal dragon = new Animal();
				bar.printAnything(gator);
				bar.printAnything(dragon);
			}
			public static void printAnything(Object toPrint) {
				System.out.println(toPrint.toString());
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		Reptilian
		Animal@6b95977
	</code></pre>

	<p>
		Pay close attention to the output. Those are the outputs from the statements
		<span class="monoText">bar.printAnything(gator)</span> and
		<span class="monoText">bar.printAnythng(dragon)</span>. We passed as
		arguments into those methods the objects
		<span class="monoText">gator</span> and
		<span class="monoText">dragon</span>. What is the method
		<span class="monoText">printAnything()</span>? It is the method defined
		inside the class <span class="monoText">bar</span>. And in that definition,
		we pass it one argument: an object <span class="monoText">toPrint</span> of
		type <span class="monoText">Object</span>. Let's focus first on
		<span class="monoText">gator</span>.
	</p>
	<p>
		The object <span class="monoText">gator</span> is an instance of
		<span class="monoText">Reptile</span>, but here it is being used as an
		object of type <span class="monoText">Object</span>. Nevertheless, it is
		also an object of type <span class="monoText">Reptile</span>. Inside the
		class definition for <span class="monoText">Reptile</span>, we overrode the
		<span class="monoText">toString()</span> method: Rather than follow
		<span class="monoText">Object</span>'s default definition, return the string
		<span class="monoText">"Reptilian"</span>. So, when we pass in
		<span class="monoText">gator</span> into the
		<span class="monoText">printAnything()</span> method, we really wrote
		<span class="monoText">gator.toString()</span>. This is why we see the
		output <span class="monoText">Reptilian</span>.
	</p>

	<p>
		Now, let's look at <span class="monoText">dragon</span>. When we pass in
		<span class="monoText">dragon</span> as an argument, we really wrote
		<span class="monoText">dragon.toString()</span>. The object
		<span class="monoText">dragon</span> is an object of type
		<span class="monoText">Object</span>. But, it is also an object of type
		<span class="monoText">Animal</span>. The class
		<span class="monoText">Animal</span> provides no override of the
		<span class="monoText">toString()</span> method. So, Java moves up the class
		tree, and goes to <span class="monoText">Object</span>. There, it applies
		the <span class="monoText">toString()</span> method as defined there, and we
		get back <span class="monoText">Animal@6b95977</span>. This is the default
		definition of <span class="monoText">toString()</span> &mdash; it tells us
		that there is an instance of <span class="monoText">Animal</span> at the
		memory reference <span class="monoText">6b95977</span>.
	</p>

	<p>
		Notice that we wrote <span class="monoText">bar.printAnything()</span> to
		call the method <span class="monoText">printAnything()</span>. Why? Because
		<span class="monoText">printAnything()</span> is a method defined in the
		class <span class="monoText">bar</span>. This is all evidence of
		<span class="italicsText">polymorhpism</span>.
	</p>
	<p>
		As an aside, we might ask, how is the
		<span class="monoText">printAnything()</span> method called when it is below
		the <span class="monoText">main()</span> method? This is a perfectly fair
		question, particularly for those coming from a Python background. In Python,
		a program structured in this manner is almost certain to return an error.
		This is because Python's evaluation model interprets then executes code
		line-by-line, top to bottom. In languages like Java, however, the code is
		first compiled then executed. Thus, the positioning of methods and classes
		alone will not prohibit execution. (Note that compiling is not necessarily
		what allows Java to avoid relative positioning; C, for example, requires the
		use of prototypes for <span class="monoText">struct</span>s defined at the
		bottom of a source code file).
	</p>

	<p>
		<span class="topic">Downcasting.</span> Where
		<span class="italicsText">upcasting</span> allows an object to behave as if
		it were an object of an ancestor type,
		<span class="term">downcasting</span> allows an object to behave as if it
		were an object of a descendent type.
		<span class="underlineText">But</span> only if the instance is actually the
		appropriate subtype. If the instance is not an appropriate subtype, then
		Java will return a runtime error.
	</p>
	<pre class="language-java"><code>
		class Animal {}
		class Reptile extends Animal {
			public String toString() {
				return "Reptilian";
			}
		}
		public class bar {
			public static void main(String[] args) {
				Object gator = new Reptile();
				bar.printAnything(gator);
				Animal gatorAsAnimal = (Animal) gator;
				bar.printAnything(gatorAsAnimal);
			}
			public static void printAnything(Object toPrint) {
				System.out.println(toPrint.toString());
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		Reptilian
		Reptilian
	</code></pre>
	<p>
		Here, we created an object named <span class="monoText">gator</span> of type
		<span class="monoText">Reptile</span> (whenever we are unsure of what type
		an object is, we always look to the right of the symbol
		<span class="monoText">new</span>). Notice, however, that we declared the
		variable <span class="monoText">gator</span> to be of type
		<span class="monoText">Object</span>. What is going on here?
	</p>
	<p>
		This is an example of performing an immediate upcast. We create an instance
		of <span class="monoText">Reptile()</span>, but we save it in a variable of
		type <span class="monoText">Object</span>. This is perfectly valid because
		it is an upcast &mdash; every instance
		<span class="monoText">Reptile</span> is an instance of
		<span class="monoText">Object</span>.
	</p>
	<p>
		The more interesting point is our creation of
		<span class="monoText">gatorAsAnimal</span>. That variable is of type
		<span class="monoText">Animal</span>. We assign to that variable the object
		<span class="monoText">gator</span>, but we prepend it with
		<span class="monoText">(Animal)</span>. This is a downcast. Why are we
		allowed to do this? Because <span class="monoText">gator</span> is an
		instance of <span class="monoText">Object</span>. And since it is an
		instance of <span class="monoText">Object</span>, an ancestor of
		<span class="monoText">Animal</span>, we can cast
		<span class="monoText">gator</span> downwards as an instance of
		<span class="monoText">Animal</span>.
	</p>
	<p>
		The tool: If we upcast an object, we can always downcast the object back to
		where we started. But, we can only cast an object that the casted object is
		related to. We cannot cast a <span class="monoText">String</span> object
		into an <span class="monoText">Animal</span> or
		<span class="monoText">Reptile</span> object, because
		<span class="monoText">Animal</span> and
		<span class="monoText">Reptile</span> are unrelated to
		<span class="monoText">String</span>.
	</p>
	<p>
		<span class="topic">Verifying an Instance's Class.</span> A useful operator
		provided by Java is the <span class="monoText">instanceOf</span> operator,
		which returns a Boolean value to the question: Is this particular instance
		an instance of this particular class? Thus:
	</p>
	<pre class="language-java"><code>
		class Animal {}
		class Reptile extends Animal {
			public String toString() {
				return "Reptilian";
			}
		}
		public class bar {
			public static void main(String[] args) {
				Reptile gator = new Reptile();
				Animal dragon = new Animal(); 
				System.out.println(gator instanceof Animal);
				System.out.println(gator instanceof Reptile);
				System.out.println(dragon instanceof Reptile);
				System.out.println(dragon instanceof Animal);
			}
			public static void printAnything(Object toPrint) {
				System.out.println(toPrint.toString());
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		true
		true
		false
		true
	</code></pre>
	<p>
		<span class="topic">Inheritance and Methods.</span> Consider the following:
	</p>
	<pre class="language-java"><code>
		class Animal {}
		class Lion extends Animal {
			public void roar() {
				System.out.println("roar");
			}
		}
		class Cobra extends Animal {
			public void hiss() {
				System.out.println("hiss");
			}
		}

		public class bar {
			public static void main(String[] args) {
				Animal bubu = new Animal();
				Lion lulu = new Lion();
				Cobra momo = new Cobra();
			}
		}
	</code></pre>
	<p>
		In the code above, we have two methods called
		<span class="monoText">roar()</span> and
		<span class="monoText">hiss()</span>. The
		<span class="monoText">roar()</span> method is defined in the subclass
		<span class="monoText">Lion</span>, and the
		<span class="monoText">hiss()</span> method is defined in the subclass
		<span class="monoText">Cobra</span>. Both
		<span class="monoText">Cobra</span> and
		<span class="monoText">Lion</span> are subclasses of
		<span class="monoText">Animal</span>. Of the instances we created,
		<span class="monoText">bubu</span> cannot call these methods. Why? Because
		<span class="monoText">bubu</span> is of class
		<span class="monoText">Animal</span>, and
		<span class="monoText">Animal</span> has no methods
		<span class="monoText">roar()</span> and
		<span class="monoText">hiss()</span>. But what if we want
		<span class="monoText">momo</span> to be an instace of
		<span class="monoText">Lion</span>, but at the same time, we want to keep
		the variable containing <span class="monoText">momo</span> to remain
		<span class="monoText">Animal</span>? Well, we can use a conditional:
	</p>
	<pre class="language-java"><code>
		class Animal {
			public void speak() {
				if (this instanceof Lion) {
					Lion me = (Lion) this;
					me.roar();
				} else if (this instanceof Cobra) {
					Cobra me = (Cobra) this;
					me.hiss();
				}
			}
		}
		class Lion extends Animal {
			public void roar() {
				System.out.println("roar");
			}
		}
		class Cobra extends Animal {
			public void hiss() {
				System.out.println("hiss");
			}
		}
		
		public class bar {
			public static void main(String[] args) {
				Animal bubu = new Lion();
				bubu.speak();
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		roar
	</code></pre>
	<p>
		In the code above, we created a new method called
		<span class="monoText">speak()</span>. That method behaves differently
		depending on what object is passed into it as an argument. That object,
		however, is an instance of <span class="monoText">Animal</span>. This means
		that the symbol <span class="monoText">this</span> refers to an instance of
		<span class="monoText">Animal</span>, so to call the
		<span class="monoText">roar()</span> and
		<span class="monoText">hiss()</span> methods, we must
		<span class="italicsText">downcast</span> the object argument. This is why
		we create a new variable (and by convention, naming the variable
		<span class="monoText">me</span>).
	</p>
</section>
{% endblock %}
