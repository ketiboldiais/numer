{% extends '../layout.html' %} {% load static %} {% block content %}
<section id="inheritance_in_java">
	<h3>Inheritance</h3>
	<p>
		In this section, we study the concept of
		<span class="italicsText">inheritance</span>. Inheritance provides a means
		of accomplishing two useful outcomes: (1) avoiding duplicated code, and (2)
		expressing real world relationships between data.
	</p>
	<p>Consider the following code:</p>
	<pre class="language-java"><code>
		class MythChar { };

		public class foo {
			public static void main(String[] unused) {
				MythChar hera = new MythChar(); 
				System.out.println(hera.toString());
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		MythChar@7344699f
	</code></pre>
	<p>
		There was no error &mdash; it compiled and ran correctly, even if we
		neglected to explicitly define the body of the class
		<span class="monoText">MythChar</span>. No error is returned because of
		Java's principle of <span class="term">inheritance</span> &mdash; every
		object, or instance, inherits both
		<span class="italicsText">state</span> and
		<span class="italicsText">behavior</span> from another class. Inheritance
		exists because in the real world, data follows hierarchy &mdash; Every koala
		is a marsupial, every marsupial is a mammal, every mammal is an animal, etc.
	</p>
	<p>So, for example:</p>
	<pre class="language-java"><code>
		class MythChar {
			protected String name;
			protected String type;
		
			public void printMetadata() {
				System.out.println("This is an object of type " + type + " named " + name);
			}
		}
		
		class GreekMythChar extends MythChar {
			GreekMythChar(String setName) {
				name = setName;
				type = "GreekMythChar";
			}
		}
		
		
		public class foo {
			public static void main(String[] unused) {
				GreekMythChar hera = new GreekMythChar("Hera"); 
				hera.printMetadata();
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		This is an object of type GreekMythChar named Hera
	</code></pre>
	<p>
		There are some new symbols in the code above, and we will address them in a
		moment. For now, observe that (1) every new instance of
		<span class="monoText">MythChar</span> has an instance variable called
		<span class="monoText">name</span> and another instance variable called
		<span class="monoText">type</span>; (2) every new instance of
		<span class="monoText">MythChar</span> has an instance method called
		<span class="monoText">printMetadata()</span>, which prints a string
		communicating the instance's <span class="monoText">name</span> and
		<span class="monoText">type</span>.
	</p>
	<p>
		Then, we have another class definition. This class is called
		<span class="monoText">GreekMythChar</span>, followed by
		<span class="monoText">extends MythChar</span>. Then, we have a constructor.
		But, there is something unusual about this constructor: We do not have any
		instance variables before the constructor, but we are initializing variables
		inside the constructor. How is this possible? Again, inheritance.
	</p>
	<p>
		By including <span class="monoText">extends</span> to the class definition
		for <span class="monoText">GreekMythChar</span>, we are effectively telling
		Java that <span class="monoText">GreekMythChar</span> is a subclass of
		<span class="monoText">MythChar</span>. Because
		<span class="monoText">GreekMythChar</span> is a subclass of
		<span class="monoText">MythChar</span>, all the instance and class variables
		and methods contained in <span class="monoText">MythChar</span> are
		available for <span class="monoText">GreekMythChar</span>. They are
		<span class="italicsText">inherited</span> from
		<span class="monoText">MythChar</span>.
	</p>
	<p>
		Notice that <span class="monoText">GreekMythChar</span> has a special
		relationship to <span class="monoText">MythChar</span> &mdash; it is a
		subset of mythological figures. We might have another subclass called
		<span class="monoText">NorseMythChar</span> and another one called
		<span class="monoText">CelticMythChar</span>. These two classes are
		collectively referred to as the <span class="italicsText">children</span> of
		<span class="monoText">MythChar</span>, and
		<span class="monoText">MythChar</span> is said to be the
		<span class="italicsText">parent</span> of the subclasses. The keyword we
		use for establishing these relationships is
		<span class="monoText">extends</span>.
	</p>
	<p>
		Java allows multiple inheritance. All of the classes shifted towards the
		left inherit all of the instance and class variables and methods of the
		classes to the right. All of the classes that a subclass inherits from are
		collectively called the subclass's
		<span class="italicsText">ancestors</span>, and all of the classes that a
		parent class provides behaviors to as the parent class's
		<span class="italicsText">descendants</span>:
	</p>
	<pre class="language-java"><code>
		public class MythChar {}
			public class GreekMythChar extends MythChar {}
				public class Olympian extends GreekMythChar {}
				public class Titan extends GreekMythChar {}
					public class Titanide extends Titan {}
					public class Titaness extends Titan {}
				public class Gigantes extends GreekMythChar {}
	</code></pre>
	<p>
		In Java, a class can only extend
		<span class="underlineText">one</span> parent class. In other words, we
		cannot have a subclass with two parent classes. We will revisit this concept
		and limitation again in later sections.
	</p>
	<p>
		A word of warning: If we ever find ourselves writing deeply nested classes
		like the above, we must ask ourselves whether inheritance is the proper
		approach to the problem, or whether the distinctions between parent and
		child are meaningful. Particularly tall inheritance trees can very easily
		open the gates to <span class="italicsText">inheritance hell</span> &mdash;
		the point where so many subclasses are created that the programmer loses
		track of an object's behavior and the states it stores.
	</p>
	<p>
		<span class="topic"
			>What Does <span class="monoText">protected</span> Mean?</span
		>
		One new access modifier we saw from the example above is
		<span class="monoText">protected</span>. Recall that a public variable can
		be read or written by anyone, and a private variable can only be read or
		written using methods defined by the private variable's class. A
		<span class="italicsText">protected variable</span> is a variable that can
		only be read or written using methods that are (a) defined by the protected
		variable's class, or (b) defined by a descendent of the protected variable's
		class.
	</p>
</section>
{% endblock %}
