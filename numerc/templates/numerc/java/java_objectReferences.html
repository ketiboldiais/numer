{% extends '../layout.html' %} {% load static %} {% block content %}
<section id="object_references">
	<h3>Object References</h3>
	<p>
		The idea of a <span class="italicsText">reference</span> is not unique to
		Java. It occurs across many programming languages. References are also a
		useful way to clarify any vagueness in polymorphism.
	</p>
	<p>Consider the following code and its output:</p>
	<pre class="language-java"><code>
		class PhysConst {
			public String name;
			public double val;
			PhysConst(String setName, double setValue) {
				name = setName;
				val = setValue;
			}
			public String toString() {
				return name;
			}
		}
		
		public class bar {
			public static void main(String[] args) {
				// block (a)
				int first = 0;
				int second = first;
				second = 8;
				System.out.println(first + " " + second);
		
				// block (b)
				PhysConst otherConst = new PhysConst("Gas Constant", 8.31);
				PhysConst gasConst = otherConst;
				gasConst.name = "Molar Gas Constant";
				System.out.println(otherConst + " " + gasConst);
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		0 8
		Molar Gas Constant Molar Gas Constant
	</code></pre>
	<p>
		How does this code work? In <span class="monoText">block (a)</span>, we
		declare a variable called <span class="monoText">first</span>, of type
		<span class="monoText">int</span>. Then, we assign to that variable the
		integer value <span class="monoText">0</span>. Next, we declare a variable
		called <span class="monoText">second</span>, also of type
		<span class="monoText">int</span>, and we initialize it to the value
		<span class="monoText">first</span>, which is itself initialized to
		<span class="monoText">0</span>. Then, we changed the value bound to
		<span class="monoText">second</span> now it is
		<span class="monoText">8</span>. As expected, when we print the values, we
		see <span class="monoText">0</span> and <span class="monoText">8</span>.
		This is in line with what we know about assignment.
	</p>
	<p>
		But it seems that <span class="monoText">block (b)</span> works differently,
		even though it looks similar. We declared a variable of type
		<span class="monoText">PhysConst</span>, then assigned to it the object
		created by calling the
		<span class="monoText">PhysConst()</span> constructor. Then, on the next
		line, we declared a variable called <span class="monoText">gasConst</span>,
		of type <span class="monoText">PhysConst</span>, and assigned to
		<span class="monoText">otherConst</span>. Then, we initializd the
		<span class="monoText">name</span> instance variable of
		<span class="monoText">gasConst</span> to
		<span class="monoText">"Molar Gas Constant"</span>. After all of this, when
		print <span class="monoText">otherConst</span> and
		<span class="monoText">gasConst</span>, it looks like they have the same
		name &mdash; <span class="monoText">Molar Gas Const</span>. Why? It seems
		that in <span class="monoText">block (b)</span>, the change made to
		<span class="monoText">gasConst</span>, which was assigned
		<span class="monoText">otherConst</span>, had an effect on
		<span class="monoText">otherConst</span>. This is evidence of a
		<span class="italicsText">reference</span> at work.
	</p>
	<p>
		<span class="topic">About Variables.</span> When we discussed variables, we
		repeatedly said that a variable &#8220;stores&#8221; a value. This is
		incorrect when it comes to <span class="italicsText">objects</span> in Java.
		When we assign an object to a variable, the variable does not actually
		&#8220;store&#8221; the object. Instead, that variable stores a
		<span class="term">reference</span> to that object. We call such a variable
		a <span class="italicsText">reference variable</span>.
	</p>
	<p>
		A reference is a value representing a particular piece of data's location in
		the computer's memory. That reference
		<span class="italicsText">refers</span> to the data, and accessing the data
		is called <span class="italicsText">dereferencing</span> the reference.
		References are what allow a program to
		<span class="underlineText">indirectly</span> access a particular piece of
		data (e.g., an object). We emphasize &#8220;indirectly&#8221; because
		references are <span class="underlineText">not</span>
		<span class="italicsText">pointers</span>. Pointers provide direct access to
		the referenced data; a reference does not.
	</p>
	<p>
		There is a difference between a
		<span class="italicsText">reference</span> and the actual object the
		reference refers to. For example, a social security number. That number
		<span class="italicsText">refers</span> to a particular person, but the
		number itself is different from the object. Another example: A street
		address. The address is a reference to a physical location, say, an unlocked
		building filled with gold. If one person gains access to that address, they
		can go to that address and steal the boot. If another person knows that
		address, they can go and watch the looting or participate themselves. The
		thieves all make changes to the physical location, but the address
		nevertheless remains the same.
	</p>
	<p>
		This same phenomenon occurs with reference variables: Make an object
		<span class="monoText">x</span>. Assign <span class="monoText">x</span> to a
		reference variable called <span class="monoText">y</span>. We can make
		changes to <span class="monoText">x</span> by using the reference
		<span class="monoText">y</span>. If we make changes to
		<span class="monoText">y</span>, then those changes are reflected in
		<span class="monoText">x</span>, and are visible to every entity that has
		access to <span class="monoText">y</span> or
		<span class="monoText">x</span>.
	</p>
	<pre class="language-java"><code>
		class Fish { }

		// bass refers to an object of type Fish
		// but, bass currently refers to nothing
		
		Fish bass;

		// initializing an instance to null tells Java: 
			// this instance refers to nothing

		Fish trout = null;

		// now bass refers to a new Fish object

		Fish bass = new Fish();

		// now bass and trout refer to same Fish object

		trout = bass;             

		// returns true; bass and trout refer to the same Fish object 

		trout == bass;

		// now trout refers to new Fish object

		trout = new Fish(); 

		// false; bass and trout store refer to different Fish objects

		trout == bass;                 
	</code></pre>
	<p>
		When you assign an object to a reference variable in Java, you do not copy
		the object. You are copying the reference. If you do not see
		<span class="monoText">new</span>, you are not creating a new object. If we
		deleted everything after <span class="monoText">trout = bass</span>, we can
		make changes to the object <span class="monoText">bass</span> refers to by
		using <span class="monoText">trout</span>.
	</p>
	<p>
		The first <span class="monoText">trout == bass</span> returns
		<span class="monoText">true</span> because the two objects
		<span class="monoText">trout</span> and
		<span class="monoText">bass</span> refer to the same object. This is why we
		cannot use the <span class="monoText">==</span> operator to test whether two
		variables, both storing a string with the same exact characters, are
		equivalent. We cannot do so because the the two variables are
		<span class="italicsText">reference variables</span> &mdash; they refer to
		different objects, even if they appear the same.
	</p>
	<p>Another example:</p>
	<pre class="language-java"><code>
		class Seafood {
			public int quantity;
		}
		public class bar {
			public static void main(String[] args) {
				Seafood prawn;
				prawn = new Seafood();
				Seafood shrimp = prawn; 
				prawn.quantity = 100;
				System.out.println(shrimp.quantity);
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		100
	</code></pre>
	<p>
		Both <span class="monoText">prawn</span> and
		<span class="monoText">shrimp</span> are referring to the same object, so
		when we made a change with <span class="monoText">prawn</span>, we can see
		the changes with <span class="monoText">shrimp</span>.
	</p>

	<p>
		<span class="topic">Swapping References.</span> Suppose the following code:
	</p>
	<pre class="language-java"><code>
		class Chemical {
			public String name;
			Chemical(String setName) {
				name = setName;
			}
		}
		public class bar {
			public static void main(String[] args) {
				Chemical Na = new Chemical("iron");
				Chemical Fe = new Chemical("sodium");
			}
		}
	</code></pre>
	<p>
		We want to switch the objects the reference variables are referring to in
		the code above. In making this switch, we
		<span class="underlineText">must</span> be careful. This is because the
		moment we lose a reference, the moment that object is lost. And once it is
		lost, it effectively no longer exists (Java's garbage collector spares no
		one).
	</p>
	<p>
		To ensure the reference is never lost, we need a temporary reference
		variable, in this case a variable named <span class="monoText">tmp</span>:
	</p>
	<pre class="language-java"><code>
		class Chemical {
			public String name;
			Chemical(String setName) {
				name = setName;
			}
		}
		public class bar {
			public static void main(String[] args) {
				Chemical Na = new Chemical("iron");
				Chemical Fe = new Chemical("sodium");
				Chemical tmp = Na;
				Na = Fe;
				Fe = tmp;
			}
		}
	</code></pre>

	<p>
		<span class="topic">Pass By Reference.</span> Why do we use references in
		the first place? Why don't we just store the objects themselves in the
		variables? One of the reasons is because of the way methods work in Java.
		When we pass an object into a method, the method receives a
		<span class="italicsText">copy of the reference</span> to the object
		argument. This in turn allows the method to modify the referenced object.
	</p>
	<pre class="language-java"><code>
		class Grain {
			public String name;
			public int amount;
			Grain(String setName, int setAmount) {
				name = setName;
				amount = setAmount;
			}
		}
		
		public class bar {
			public static void main(String[], args) {
				Grain wheat = new Grain("wheat", 10);
				System.out.println("amount before: " + wheat.amount);
				newShipment(wheat);
				System.out.println("amount after: " + wheat.amount);
			}
			public static int newShipment(Grain toIncrease) {
				toIncrease.amount++;
				return toIncrease.amount;
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		amount before: 10
		amount after: 11
	</code></pre>
	<p>
		In the code above, the function
		<span class="monoText">newShipment()</span> receives a copy of the reference
		to the object created in the line
		<span class="monoText">Grain wheat = new Grain("wheat", 10)</span>. Thus,
		that reference is used by <span class="monoText">newShipment()</span> to
		modify the object.
	</p>

	<p>
		<span class="topic">Another Look: Arrays.</span> Arrays in Java store object
		references. Thus, when we copy an array, we are only copying th object
		references, not the objects themselves.
	</p>
	<pre class="language-java"><code>
		class Weapon {
			public int amount;
			Weapon(int setAmount) {
				amount = setAmount;
			}
		}
		public class bar {
			public static void main(String[] unused) {

				// array can hold 4 references
				Weapon[] guns = new Weapon[4];
				for (int i=0; i < guns.length; i++) {
					guns[i] = new Weapon(10+i);
				}
		
				// another array holding 4 references to the same objects
				Weapon[] sameGuns = new Weapon[4];
				for (int i=0; i < guns.length; i++) {
					sameGuns[i] = guns[i]; 
				}

				// increment each referenced object in first array
				for (int i = 0; i < guns.length; i++) {
					guns[i].amount++;
				}
		
				// print each referenced object in second array
				for (int i = 0; i < sameGuns.length; i++) {
					System.out.println(sameGuns[i].amount);
				}
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		11
		12
		13
		14
	</code></pre>
</section>

<section id="references_and_polymorphism">
	<h3>References and Polymorphism</h3>
	<p>
		Recall that every object in Java is a part of the
		<span class="italicsText">Java inheritance tree</span> &mdash; every object
		has a parent class, all the way up to the only object without a class, the
		<span class="monoText">Object</span>. Thus, every object in Java inherits
		the methods defined by <span class="monoText">Object</span>. These methods,
		however, are rarely useful, so we often override them.
	</p>
	<p>
		Additionally, recall that when we use a particular method or variable
		associated with a class, Java first looks at the object's class, and if it
		is not there, then it looks at the object's parent class. Java will continue
		until it reaches <span class="monoText">Object</span>, and if it isn't
		there, then it returns an error.
	</p>
	<p>
		<span class="italicsText">Subtype polymorphism</span> tells us that every
		object can be referred to as at least two types: the class defining it, and
		the type <span class="monoText">Object</span>. The object, of course, can
		morph into its ancestors, if any. Consider the following:
	</p>
	<pre class="language-java"><code>
		class Fruit { }
		class Berry extends Fruit {
			public String toString() {
				return "this is a berry!";
			}
		}

		public class bar {
			public static void main(String[] args) {
				Fruit banana = new Fruit();
				Berry blueberry = new Berry();
				bar.printIsType(banana);
				bar.printIsType(blueberry);
			}
			public static void printIsType(Object target) {
				System.out.println(target.toString());
			}  
		}
	</code></pre>
	<pre class="language-bash"><code>
		Fruit@6b95977
		this is a berry!
	</code></pre>
	<p>
		The first output line is the name of the class followed by a hashcode. This
		is the default definition for the
		<span class="monoText">toString()</span> method provided by
		<span class="monoText">Java.lang.Object</span>. Why do we see this output?
		Because we created an instance of <span class="monoText">Fruit</span>, and
		<span class="monoText">banana</span> stores a reference to that instance.
		The class <span class="monoText">Fruit</span>, however, does not define
		<span class="monoText">toString()</span>, so Java looks to
		<span class="monoText">Java.lang.Object</span>,
		<span class="monoText">Fruit</span>'s parent class, for a definition. Java
		found that definition, so it applied it accordingly.
	</p>
	<p>
		In contrast, with <span class="monoText">blueberry</span>, we created an
		instance of <span class="monoText">Berry</span>, and stored the reference to
		that instance in <span class="monoText">blueberry</span>. We overrode
		<span class="monoText">Java.lang.Object</span>'s definition of
		<span class="monoText">toString()</span> inside the class
		<span class="monoText">Berry</span>, so when we called that method, Java
		went and looked for a definition in <span class="monoText">Berry</span>. It
		found such a definition and applied it accordingly.
	</p>
	<p>Now, consider the following alteration:</p>
	<pre class="language-java"><code>
		class Fruit { }
		class Berry extends Fruit {
			public String toString() {
				return "this is a berry!";
			}
		}

		public class bar {
			public static void main(String[] args) {
				Fruit banana = new Berry();
				Berry blueberry = new Berry();
				bar.printIsType(banana);
				bar.printIsType(blueberry);
			}
			public static void printIsType(Object target) {
				System.out.println(target.toString());
			}  
		}
	</code></pre>
	<pre class="language-bash"><code>
		this is a berry!
		this is a berry!
	</code></pre>
	<p>
		Notice the change made: The reference variable
		<span class="monoText">banana</span> remains as a variable of type
		<span class="monoText">Fruit</span>, but it now holds a reference to an
		instance of <span class="monoText">Berry</span>. Thus, when we passed
		<span class="monoText">banana</span> to the
		<span class="monoText">printIsType()</span> method, Java went and looked at
		the class <span class="monoText">Berry</span>, rather than
		<span class="monoText">Fruit</span> (after all, the referrent is an instance
		of type <span class="monoText">Berry</span>). Java found a definition for
		<span class="monoText">toString()</span>, and evaluated accordingly. This
		example evidences the relationship between polymorphism &mdash; an object
		morphing, or behaving, as if it were a member of another class &mdash; and
		references. We can store a reference to an instance of
		<span class="monoText">Berry</span> to a reference variable of type
		<span class="monoText">Fruit</span>. Why? Because
		<span class="monoText">Berry</span> extends
		<span class="monoText">Fruit</span>. Any
		<span class="monoText">Berry</span> can behave like a
		<span class="monoText">Fruit</span> &mdash; but, not all
		<span class="monoText">Fruit</span> can behave like a
		<span class="monoText">Berry</span>. The general rule for polymorphism: An
		object can morph into an object of its superclasses, but it cannot morph
		into an object of its subclasses. If we want to
		<span class="italicsText">downcast</span>, we must do so explicitly:
	</p>
	<pre class="language-java"><code>
		class Fruit { }
		class Berry extends Fruit {
			public String toString() {
				return "this is a berry!";
			}
		}

		public class bar {
			public static void main(String[] args) {
				Object acai = new Berry();

				System.out.println(acai);

				Fruit acaiFruit = (Fruit) acai;

				System.out.println(acaiFruit);

				Berry acaiBerry = (Berry) acai;

				System.out.println(acaiBerry);

			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		this is a berry!
		this is a berry!
		this is a berry!
	</code></pre>
	<p>
		<span class="topic">How to Copy an Object.</span> Suppose we want to create
		a copy of an object, <span class="italicsText">not</span> a copy of the
		reference to that object. We have several options to accomplish this. The
		<span class="monoText">Java.lang.Object</span> class provides a method
		called <span class="monoText">clone</span>. But, we should not use this
		method to create copies of an object. It does not exactly work in the way we
		expect (more on this later).
	</p>
	<p>
		A better way is to implement a
		<span class="italicsText">copy constructor</span>:
	</p>
	<pre class="language-java"><code>
		class Employee {
			public int age;
			Employee(int setAge) {
				age = setAge;
			}
			Employee(Employee other) {
				age = other.age;
			}
		}
	</code></pre>
	<p>
		Here, we have class called <span class="monoText">Employee</span> with a
		single field called <span class="monoText">age</span>. Then, we have two
		constructors. The first constructor allows us to create a new instance of
		<span class="monoText">Employee</span> and set their
		<span class="monoText">age</span>. Then we have a second constructor: It
		takes as an argument a reference to another instance of
		<span class="monoText">Employee</span>, referred to with the dummy variable
		<span class="monoText">other</span>. In doing so, we copy all of the fields
		of <span class="monoText">other</span> (we can limit the copy) into the new
		instance of <span class="monoText">Employee</span>. Thus, what we get back
		is a copy.
	</p>
	<p>
		<span class="topic">Instance v. Reference Types.</span> When we create an
		object and assign its reference to a variable, there are effectively two
		types: (1) the instance type, and (2) the reference type. The instance type
		is what is to the right of the symbol <span class="monoText">new</span>. The
		reference type is to the right of the reference variable name. It will store
		a reference to any instance that can behave like the reference variable's
		type.
	</p>
	<pre class="language-java"><code>
		class Court { }
		class FederalCourt extends Court { }
		class AppellateCourt extends FederalCourt { }
		class CircuitCourt extends FederalCourt { }

		public class bar {
			public static void main(String[] unused) {
				Court NDCal = new Court();
				Object NDIll = new FederalCourt();
				FederalCourt NinthCir = new AppellateCourt();
			}
		}
	</code></pre>
	<p>
		In the example above, the reference variable
		<span class="monoText">NDCal</span> can store a reference to any object that
		behaves like a <span class="monoText">Court</span>. Thus, it can store a
		reference to <span class="monoText">new FederalCourt()</span>,
		<span class="monoText">new AppellateCourt()</span>, or
		<span class="monoText">new CircuitCourt()</span>. Similarly,
		<span class="monoText">NDIll</span> can store a reference to any object that
		behaves like a <span class="monoText">Java.lang.Object</span>.
	</p>
	<p>
		In Java, the reference type is what determines whether an instance can
		access particular methods or variables.
	</p>
	<pre class="language-java"><code>
		class GovEntity {}
		class Executive extends GovEntity {
			public void act() {
				System.out.println('I refused a law');
			}
		} 
		class Legislative extends GovEntity {} 
		class Judicial extends GovEntity {} 

		public class bar {
			public static void main(String[] args) {
				Executive potus = new Executive();
				potus.act(); // works
				Object potusAsObj = potus;
				potus.act(); // doesn't work
				Object stringObj = new String("I am a string");
				stringObject.act(); // doesn't work
				System.out.println(stringObject.toString()); // works
			}
		} 

	</code></pre>
	<p>
		This is an absolutely critical point to understand. It is not the class of
		the instance that determines what methods or variables that instance may
		access, it is the reference variable's class that determines what methods or
		variables that instance may access.
	</p>
	<pre class="language-java"><code>
		class GovEntity {}
		class Executive extends GovEntity {
			public void act() {
				System.out.println("I refused a law");
			}
		} 
		class Legislative extends GovEntity {
			public void legislate() {
				System.out.println("I made a law");
			}
		} 
		class Judicial extends GovEntity {
			public void judge() {
				System.out.println("I struck down a law");
			}
		} 

		public class bar {
			public static void main(String[] args) {
				Executive potus = new Executive();
				potus.act(); // works
				Legislative congress = new Legislative();
				congress.legislate(); // works
				Judicial scotus = new Judicial();
				scotus.judge(); // works
				GovEntity scotusGov = scotus;
				scotusGov.judge(); // doesn't work
				GovEntity potusGov = potus;
				potusGov.act(); // doesn't work
				GovEntity congressGov = congress;
				congressGov.legislate(); // doesn't work

				GovEntity whiteHouse = new Executive();
				whiteHouse.act(); // doesn't work -- reference type controls
			}
		} 
	</code></pre>
	<p>
		Why doesn't the last line work? Didn't we create an instance of
		<span class="monoText">Executive</span>? It doesn't work because the
		reference type is <span class="monoText">GovEntity</span>, and
		<span class="monoText">GovEntity</span> can store any one of three types:
		<span class="monoText">Executive</span>,
		<span class="monoText">Legislative</span>, and
		<span class="monoText">Judicial</span>.
	</p>

	<p>
		This is a characteristic of Java that separates it from other
		object-oriented languages. Java enforces this rule because not every
		<span class="monoText">GovEntity</span> has a method called
		<span class="monoText">act()</span>. In languages like Python, the rule is
		<span class="italicsText">duck typing</span> &mdash; if it walks like an
		<span class="monoText">Executive</span>, quacks like an
		<span class="monoText">Executive</span>, then it is an
		<span class="monoText">Executive</span>.
	</p>

	<p>
		<span class="topic">Why Polymorphism?</span> A fair question regarding all
		this complexity is <span class="italicsText">why</span>? Why organize things
		in a hierarchy? Why create so many rules implicating inheritance? These
		questions directly strike the heart of Java's type system. Java's
		motivations are reasonable: First, by focusing on class extension
		(inheritance), descendant classes can implement or override ancestor
		behavior while keeping desirable ancestor properties. This is a natural
		result of implementing hierarchy in the first place &mdash; if we follow
		strict hierarchy, there is no possibility of refusing methods and variables
		inherited from an ancestor. Indeed, Java does not allow such actions; if an
		object does not want <span class="monoText">toString()</span>, we must
		override.
	</p>

	<p>
		Second, by focusing on hierarchy relationships (polymorphism), we can write
		method that work for <span class="italicsText">any</span> descendant class
		&mdash; even those that we may not have explicitly defined within the
		particular descendant class. This is a powerful way to
		<span class="italicsText">generalize</span> &mdash; we can create elaborate
		methods without actually knowing anything about the objects they might
		operate on. This provides fertile ground for large, complex data structures
		as well as extensive libraries.
	</p>

	<p>
		<span class="topic"><span class="monoText">final</span> and Classes.</span>
		As a brief aside, appending the symbol
		<span class="monoText">final</span> to a class tells Java that the class
		<span class="underlineText">cannot</span> be extended.
	</p>
	<pre class="language-java"><code>
		public class Crustacean { }
		public final class Crab { }
		public class MangroveCrab extends Crab { } // this shall not pass
	</code></pre>
	<p>
		<span class="topic"
			><span class="monoText">abstract</span> and Classes.</span
		>
		When we append the symbol <span class="monoText">abstract</span> to a class,
		we tell Java the class can only be extended
		<span class="underlineText">but not instantiated</span> (make an instance
		of).
	</p>
	<pre class="language-java"><code>
		public abstract Bird { }
		public class Penguin extends Bird { } 
		Bird winglet = new Bird(); // this doesn't work
		Penguin penguini = new Penguin(); // this works
	</code></pre>
	<p>
		<span class="topic"
			><span class="monoText">private</span> and Classes.</span
		>
		We cannot use the symbol <span class="monoText">private</span> with classes.
		If a class were <span class="monoText">private</span>, we would not be able
		to use it at all. But, there are situations where we might want to limit a
		class. To do so, we use <span class="italicsText">inner classes</span>:
	</p>
	<pre class="language-java"><code>
		public class Organ {
			class Heart {
				public String toString() {
					return "This is part of the heart"
				}
				private Heart foo;
				Organ() {
					foo = new Heart();
				}
			}
		}
	</code></pre>
	<p>
		Inside the <span class="monoText">Organ</span> class, we have a definition
		for the <span class="monoText">Heart</span> class. Inside the
		<span class="monoText">Organ</span> class, we can use the
		<span class="monoText">Heart</span> class.
	</p>
	<p>
		<span class="topic">Generality v. Capability.</span> But, polymorphism has
		its tradeoffs. The higher a class is on the object hierarchy, the more
		general, and the more general, the fewer its capabilities. On the other
		hand, the lower a class is on the object hierarchy, the more specific it is,
		and the more specific, the more capabilities. The problem: The more specific
		a class is, the narrower its use cases. Narrow use cases are prone to abuse.
		Polymorphism, as we have seen, can easily become enormously complex, and any
		good programmer will tell you that large, deeply nested classes can lead to
		<span class="italicsText">inheritance hell</span> &mdash; adding further
		classes only makes the program look more like
		<span class="italicsText">Dante's Inferno</span>.
	</p>
</section>
{% endblock %}
