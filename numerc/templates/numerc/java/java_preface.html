{% extends '../layout.html' %} {% load static %} {% block content %}
<h1>Foundations I: Java</h1>

<section id="java_preface">
	<p>
		A <span class="term">program</span> is a set of instructions to be carried
		out by a computer. When the computer carries out the instructions, the
		program is said to have <span class="italicsText">executed</span>. Like
		humans, computers can only carry out those instructions if it actually
		understands the them. However, unlike humans, computers can only understand
		0s and 1s. To ensure our instructions are translated to 0s and 1s, we write
		our instructions in a <span class="term">programming language</span> &mdash;
		a systematic set of rules used to describe computations in a format that we,
		as humans, can edit.
	</p>
	<p>
		Java is just one example of a programming language. It's a general-purpose,
		object-oriented, platform-independent, and concurrent programming language.
		That's a lot to unpack, so let's go over each term slowly.
	</p>
	<p>
		A general-purpose language is a language that's not constrained to one
		particular problem domain. By problem domain, we mean &#8220;kinds of
		problems.&#8221;
	</p>
	<p>
		There are many kinds of problems &mdash; finance problems, medical problems,
		legal problems, math problems, physics problems, language problems, etc.
		Now, some languages are better than others for certain problems. For legal
		problems, there is &#8220;legalese.&#8221; For physics, there is mathematics
		and statistics. For mathematics, there is symbolic manipulation and rigorous
		proof. And for any given problem, we want to use the appropriate language.
		When the President of the United States hopes to defend his new economic
		reform plan, he doesn't go up to the podium and explain economic theory or
		cite mathematical lemmas. He references history, appeals to emotion and
		logic, and attacks the other side &mdash; in essence, rhetoric.
	</p>
	<p>
		The same goes for programming languages. Some languages were designed to
		tackle specific problems. Matlab is a powerful programming language for
		physics-related problems, but we wouldn't use it to build websites. C++ is a
		great programming language for making operating systems, but it would be
		overkill for small things like auto-responding to emails. Java is a
		general-purpose language. We can use it for virtually any problem (granted,
		there are problems where another language might be a better fit).
	</p>
	<p>
		Next, Java is object-oriented. This is a
		<span class="term">computer paradigm.</span> A computer paradigm is an
		overloaded term (i.e., lots of people argue over what it means), but we can
		think of it as a philosophy of doing things, or a philosophy of solving
		problems. In object-oriented programming (&#8220;OOP&#8221;), the philosophy
		is roughly this: Real-world entities can be thought of as objects, and all
		objects have a type. We will elaborate further on this idea in later
		sections.
	</p>
	<p>
		Java is platform-independent. When the language was first released, its
		motto was &#8220;Write once, run anywhere.&#8221; At the time Java was
		released, most programs were machine-dependent. I.e., if we wrote a program
		on a Dell, there was no guarantee it would run on a Mac. Java was designed
		to avoid this problem: We can write programs on Macs, Dells, Acers, or
		Toshibas, and the same program could be run on a different computer. We will
		see how Java gets around this problem shortly.
	</p>
	<p>
		Finally, Java is a concurrent language. Historically, programming languages
		were <span class="term">single-threaded</span>: Programs written in the
		programming language could only do one thing at a time. With concurrency, we
		now have <span class="term">multi-threaded</span> languages; languages that
		allow their programs to perform more than one thing at a time. One way to
		think about single-threaded and multi-threaded: John gets off of work,
		arrives home, and realizes he needs to do laundry and cook dinner. Under
		single-threaded languages, John would have to either do the laundry first or
		cook dinner; he can't do both. Under multi-threaded languages, John could do
		his laundry while he cooks dinner. This isn't the best analogy, but we will
		elaborate further on the idea of concurrency in later sections.
	</p>
	<p>
		The instructions we write in a program are broadly referred to as
		<span class="term">source code</span>. When we're ready to execute, we
		<span class="italicsText">compile</span> the program, whereupon the
		<span class="italicsText">Java compiler</span> translates our source code
		into <span class="term">byte code</span> &mdash; code that the computer
		understands.
	</p>
	<p>
		There are numerous programming languages, many of which are designed with a
		particular &#8220;philosophy&#8221; or &#8220;principle.&#8221;
		<span class="italicsText">Procedural languages</span> are those whose
		programs are a series of commands. These languages include Pascal and C.
		<span class="italicsText">Functional programming languages</span> are
		premised on the idea that programs are composed of functions, mapping inputs
		to outputs. Examples of such languages include Lisp, ML, and Haskell. Then
		there are <span class="italicsText">object-oriented languages</span> &mdash;
		programs are composed of interacting &#8220;objects.&#8221; This family
		includes Smalltalk, C++, and Java. Finally, there are
		<span class="italicsText">logic programming languages</span>, where programs
		consist of sentences in logical form, expressing facts and rules about
		problems. This group includes languages like Prolog and Datalog.
	</p>
	<p>
		Most languages result from programmers attempting to solve a problem where
		either (a) there was no language available, or (b) an existing language was
		insufficient. For example, C is used primarily for low-level operating
		systems and devices, and C++ was the result of C not providing a means for
		object-oriented design. JavaScript was borne out of frustrations with static
		web pages.
	</p>
	<p>
		Java, the language explored in these next sections, was originally intended
		for use by embedded systems &mdash; devices like digital timers, MP3
		players, recording devices, etc. Over time, however, it began to be used for
		web applications. If we use a very old web browser and visit very old
		webpages, we might see this historical fact in the form of Java applets (if
		you don't know what those are, that's a good thing; Java applets have been
		outdated for many, many years). Today, JavaScript has taken that mantle, but
		Java is now the language of choice for the most popular mobile operating
		system, Android OS. Moreover, along with Python, Java is a common language
		for introductory computer scince courses.
	</p>
	<p>Here is a basic program in Java:</p>
	<pre class="language-java"><code>
		public class Intro {
			public static void main(String[] args) {
				System.out.println("Hello, world!");
			}
		}
	</code></pre>
	<pre class="language-bash"><code>
		Hello, world!
	</code></pre>
	<p>All of the code that follows is placed inside the space here:</p>
	<pre class="language-java"><code>
		public class Intro {
			public static void main(String[] args) {

			/* 
			* For now, assume all of the 
			* example code 
			* is placed here
			*/

			}
		}
	</code></pre>
	<p>
		We will be explaining in more detail what the other words and symbols mean
		shortly. But for now, just pretend all of the sample code is inside a file
		called <span class="monoText">Intro.java</span>, and all of the relevant
		source code is enclosed by the curly braces following
		<span class="monoText">public static void main(String[] args)</span>.
	</p>
	<p>Having made that assumption, consider the following code:</p>
	<pre class="language-java"><code>
		int x = 5;
		int y = 6;
		System.out.println(x + y);
		int z = x + y + 1;
		System.out.println(z);
	</code></pre>
	<pre class="language-bash"><code>
		11
		12
	</code></pre>
	<p>
		This is a simple arithmetic computation in Java. As we've seen, computers
		can do simple math. Another example:
	</p>
	<pre class="language-java"><code>
		int temperature = 
		if (temperature < 0) {
			System.out.println("Ok this is cold")
		} else {
			System.out.println("Meh, typical winter")
		}
	</code></pre>
	<pre class="language-bash"><code>
		Line 3: error: extraneous input 'if' expecting {'boolean', 'byte', 'char', 'double', 'float', 'int', 'long', 'new', 'record', 'short', 'super', 'switch', 'this', 'void', DECIMAL_LITERAL, HEX_LITERAL, OCT_LITERAL, BINARY_LITERAL, FLOAT_LITERAL, HEX_FLOAT_LITERAL, BOOL_LITERAL, CHAR_LITERAL, STRING_LITERAL, TEXT_BLOCK_LITERAL, 'null', '(', '{', '<', '!', '~', '++', '--', '+', '-', '@', IDENTIFIER}
		if (temperature < 0) {
		^
		Line 3: error: missing ';' at '{'
		if (temperature < 0) {
								^
		Line 5: error: extraneous input 'else' expecting {'abstract', 'assert', 'boolean', 'break', 'byte', 'char', 'class', 'continue', 'do', 'double', 'final', 'float', 'for', 'if', 'import', 'int', 'interface', 'long', 'native', 'new', 'private', 'protected', 'public', 'record', 'return', 'short', 'static', 'strictfp', 'super', 'switch', 'synchronized', 'this', 'throw', 'transient', 'try', 'void', 'volatile', 'yield', 'while', DECIMAL_LITERAL, HEX_LITERAL, OCT_LITERAL, BINARY_LITERAL, FLOAT_LITERAL, HEX_FLOAT_LITERAL, BOOL_LITERAL, CHAR_LITERAL, STRING_LITERAL, TEXT_BLOCK_LITERAL, 'null', '(', '{', '}', ';', '<', '!', '~', '++', '--', '+', '-', '@', IDENTIFIER}
		} else {
		^
		3 errors
	</code></pre>
	<p>
		The code above was supposed to compute a simple conditional. But, the output
		is a large error message. This is a typical error message in Java. In this
		case, the error message is telling us we neglected to assign a value to the
		variable <span class="monoText">temperature</span>. If we actually assign a
		value to <span class="monoText">temperature</span>:
	</p>
	<pre class="language-java"><code>
		int temperature = 10
		if (temperature < 0) {
			System.out.println("Ok this is cold")
		} else {
			System.out.println("Meh, typical winter")
		}
	</code></pre>
	<pre class="language-bash"><code>
		Meh, typical winter
	</code></pre>
	<p>
		Now the code works. Computers are good at making simple decisions. Here is
		another example:
	</p>
	<pre class="language-java"><code>
		long i = 0;
		while (i < 1000000L) {
			i++;
		}
		System.out.println("Finished");
	</code></pre>
	<pre class="language-bash"><code>
		Finished
	</code></pre>
	<p>
		The code above incremented the value <span class="monoText">0</span> by 1 a
		million times before it outputs the string
		<span class="monoText">"Finished"</span>. Executing this code, it takes less
		than a second to output the string. Compare that to how long it would take a
		human. If you held then dropped a tennis ball, a typical modern computer
		could easily have executed over a billion instructions before the ball even
		hit the floor. Computers can perform repetitive tasks very very quickly.
	</p>
	<p>Computers can also communicate:</p>
	<pre class="language-java"><code>
		System.out.println("Hello, world!");
	</code></pre>
	<pre class="language-bash"><code>
		Hello, world!
	</code></pre>
	<p>Putting it all together, computers are good at four things:</p>
	<ol>
		<li>Basic arithmetic</li>
		<li>Simple decision making</li>
		<li>Repeating tasks over and over again, very fast</li>
		<li>Communicating</li>
	</ol>
	<p>
		These are all things we generally aren't very good at. We might be good at
		the fourth point, but really, when it comes to communicating
		<span class="italicsText">efficiently</span> and
		<span class="italicsText">clearly</span>, most of us fall short.
	</p>
	<p>
		These four points evidence an implicit value of studying computer science
		&mdash; it teaches us more about what separates humans from everything else.
		The conjecture: If a computer can do $x$, where $x$ is some activity, then
		$x$ is <span class="underlineText">not</span> a uniquely human activity.
	</p>
</section>

<section id="classes_and_objects">
	<h2>Object-Orientation</h2>
	<p>
		As its name suggests, object-oriented programming is all about objects. OOP
		was borne out of the need to implement large, complex solutions in a simple
		ways. The OOP approach is to model real-world entities and ideas in the most
		natural way possible. This is accomplished by adopting the following axiom:
		Everything in the world has (1)
		<span class="italicsText">properties</span> and (2)
		<span class="italicsText">behavior</span>. For example, a person is a
		real-world entity. It has properties like a name, an age, likes, dislikes,
		they might be single or with a partner, they might have a job, a political
		subscription, etc. These are all properties. But the person also has
		behavior: They can eat, drink, for some, talk, walk, run, and many more.
	</p>
	<p>
		Now, there are different <span class="italicsText">kinds</span> of persons.
		We might think of them as <span class="italicsText">subsets</span> of
		persons. A person might be a student, in which case they have additional
		properties: The school they attend, their student ID number, the courses
		they're registered for. They also have additional behavior: Studying, going
		to the gym, socializing, emailing their instructors, and many more. Another
		person might be a voter: Where they are registered and the act of voting.
	</p>
	<p>
		Where OOP shines is through the notion of
		<span class="italicsText">classes</span>. We can think of a class as a
		mathematical set, containing two things: properties and behavior. The set
		<span class="italicsText">person</span> might also consist of subsets like
		<span class="italicsText">student</span>,
		<span class="italicsText">teacher</span>,
		<span class="italicsText">engineer</span>,
		<span class="italicsText">doctor</span>,
		<span class="italicsText">plumber</span>, and many more. OOP allows us to be
		model more complex entities: The student who is a voter and a bartender by
		night. In such a situation, we might have a class called person, in which
		there is a subclass called voter, in which there is a subclass called
		student, in which there is a subclass called bartender. Arranging it in this
		way, if the object is a student, then it is also a voter, and also a person.
	</p>
	<p>
		Historically, if we wanted to model something like the
		person-voter-student-bartender, we'd have to create a structure that
		contained all of the different properties for voter, student, and bartender.
		With OOP, we just need to write these classes separately, and rely on
		<span class="italicsText">inheritance</span>. By creating a particular
		object ${x}$ as a member of the set bartender, and that set is a member of
		student, and that set is a member of voter, and that set is a member of
		person, it logically follows that ${x}$ is a person-voter-student-bartender.
		Even better, ${x}$ has all the properties of its parent classes, and all of
		its behaviors: ${x}$ sometimes studies, sometimes mixes tequila sunrises,
		and sometimes waits at the polling places.
	</p>
</section>
{% endblock %}
